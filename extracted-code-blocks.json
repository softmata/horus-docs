{
  "version": 1,
  "extracted": "2026-01-15T06:24:33.264Z",
  "source": "content/docs/",
  "totalBlocks": 3281,
  "statistics": {
    "total": 3281,
    "byLanguage": {
      "rust": 1858,
      "text": 255,
      "bash": 641,
      "yaml": 185,
      "toml": 78,
      "python": 249,
      "powershell": 6,
      "gitignore": 1,
      "json": 1,
      "dockerfile": 1,
      "groovy": 1,
      "markdown": 2,
      "ini": 1,
      "xml": 2
    },
    "verifiable": 1992,
    "withFlags": 1671
  },
  "blocks": [
    {
      "id": "content/docs/advanced/blackbox:22:rust",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 22,
      "lineEnd": 32,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::path::PathBuf;\n\n// Create with 10MB buffer\nlet mut blackbox = BlackBox::new(10);\n\n// Enable disk persistence with WAL\nlet blackbox = BlackBox::new(10)\n    .with_persistence(PathBuf::from(\"/var/log/horus/blackbox.json\"));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/blackbox:55:rust",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 55,
      "lineEnd": 95,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut blackbox = BlackBox::new(10);\n\n// Record scheduler start\nblackbox.record(BlackBoxEvent::SchedulerStart {\n    name: \"main_scheduler\".to_string(),\n    node_count: 15,\n    config: \"default\".to_string(),\n});\n\n// Advance tick counter (call each scheduler tick)\nblackbox.tick();\n\n// Record node execution\nblackbox.record(BlackBoxEvent::NodeTick {\n    name: \"sensor_node\".to_string(),\n    duration_us: 150,\n    success: true,\n});\n\n// Record errors\nblackbox.record(BlackBoxEvent::NodeError {\n    name: \"motor_controller\".to_string(),\n    error: \"I2C timeout\".to_string(),\n});\n\n// Record deadline misses\nblackbox.record(BlackBoxEvent::DeadlineMiss {\n    name: \"critical_node\".to_string(),\n    deadline_us: 1000,\n    actual_us: 1500,\n});\n\n// Record custom events\nblackbox.record(BlackBoxEvent::Custom {\n    category: \"sensor\".to_string(),\n    message: \"IMU calibration started\".to_string(),\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/blackbox:104:text",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 104,
      "lineEnd": 111,
      "language": "text",
      "code": "\n### Get Recent Events\n\n```rust,ignore\n// Get events from last 100 ticks\nlet recent = blackbox.get_recent(100);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/blackbox:124:text",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 124,
      "lineEnd": 135,
      "language": "text",
      "code": "\n### Get Anomalies\n\nGet all error-related events (errors, deadline misses, WCET violations, emergency stops):\n\n```rust,ignore\nlet anomalies = blackbox.get_anomalies();\nfor record in anomalies {\n    println!(\"[tick {}] {:?}\", record.tick, record.event);\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/blackbox:143:rust",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 143,
      "lineEnd": 152,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::path::PathBuf;\n\nlet blackbox = BlackBox::new(10)\n    .with_persistence(PathBuf::from(\"/var/log/horus/blackbox.json\"));\n\n// Events are automatically written to blackbox.wal as JSON lines\n// blackbox.json contains the full buffer on explicit save",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/blackbox:162:text",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 162,
      "lineEnd": 171,
      "language": "text",
      "code": "\n## Crash Reports\n\nGenerate a comprehensive crash report for incident analysis:\n\n```rust,ignore\nlet report = blackbox.generate_crash_report();\nprintln!(\"{}\", report);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/blackbox:175:text",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 175,
      "lineEnd": 191,
      "language": "text",
      "code": "=== HORUS BLACK BOX CRASH REPORT ===\n\nTotal events: 1523\nLast tick: 45678\n\n=== ANOMALIES (12) ===\n[tick 45670] DeadlineMiss { name: \"vision_node\", deadline_us: 5000, actual_us: 7200 }\n[tick 45672] WCETViolation { name: \"planner\", budget_us: 1000, actual_us: 1850 }\n[tick 45675] CircuitBreakerChange { name: \"motor_ctrl\", new_state: \"Open\", failure_count: 5 }\n[tick 45678] EmergencyStop { reason: \"Too many deadline misses: 10\" }\n\n=== LAST 100 EVENTS ===\n[tick 45678] EmergencyStop { reason: \"Too many deadline misses: 10\" }\n[tick 45678] NodeTick { name: \"safety_monitor\", duration_us: 50, success: true }\n...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/advanced/blackbox:197:rust",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 197,
      "lineEnd": 213,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::sync::Arc;\n\n// Create thread-safe blackbox\nlet blackbox: SharedBlackBox = create_shared_blackbox(10);\n\n// Use from multiple threads\nlet bb_clone = Arc::clone(&blackbox);\nstd::thread::spawn(move || {\n    let mut bb = bb_clone.lock().unwrap();\n    bb.record(BlackBoxEvent::Custom {\n        category: \"thread\".to_string(),\n        message: \"Worker started\".to_string(),\n    });\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/blackbox:228:text",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 228,
      "lineEnd": 249,
      "language": "text",
      "code": "\n## Configuration\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `max_size_mb` | 0 (disabled) | Maximum buffer size in MB |\n| Buffer capacity | ~5000/MB | Estimated records per MB |\n| WAL flush | Immediate | Events flushed to WAL immediately |\n\n## Best Practices\n\n### 1. Enable in Production\n\n```rust\nuse horus::prelude::*;\nuse std::path::PathBuf;\n\n// Production: Enable with persistence\nlet blackbox = BlackBox::new(50)\n    .with_persistence(PathBuf::from(\"/var/log/horus/blackbox.json\"));",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/blackbox:259:text",
      "file": "content/docs/advanced/blackbox.mdx",
      "lineStart": 259,
      "lineEnd": 275,
      "language": "text",
      "code": "\n### 3. Size Appropriately\n\n- Development: 1-5 MB\n- Production: 10-50 MB\n- Long-running systems: 50-100 MB\n\n### 4. Monitor Anomalies\n\n```rust,ignore\n// Check for anomalies periodically\nlet anomalies = blackbox.get_anomalies();\nif anomalies.len() > previous_count {\n    alert_operator(&anomalies[previous_count..]);\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:35:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 35,
      "lineEnd": 44,
      "language": "text",
      "code": "\n### Checking When to Checkpoint\n\n```rust,ignore\n// In main loop\nif manager.should_checkpoint() {\n    // Time to create a checkpoint\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:78:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 78,
      "lineEnd": 105,
      "language": "text",
      "code": "\n## Checkpoint Structure\n\n```rust,ignore\npub struct Checkpoint {\n    pub id: u64,           // Unique checkpoint ID\n    pub timestamp: u64,    // Unix timestamp\n    pub node_states: HashMap<String, NodeCheckpoint>,\n    pub metadata: CheckpointMetadata,\n}\n\npub struct NodeCheckpoint {\n    pub name: String,\n    pub tick_count: u64,\n    pub last_tick_us: u64,\n    pub error_count: u64,\n    pub custom_state: Option<Vec<u8>>,  // Serialized state\n}\n\npub struct CheckpointMetadata {\n    pub scheduler_name: String,\n    pub total_ticks: u64,\n    pub learning_complete: bool,\n    pub node_count: usize,\n    pub uptime_secs: f64,\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:125:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 125,
      "lineEnd": 134,
      "language": "text",
      "code": "\n### Load Specific Checkpoint\n\n```rust,ignore\nlet path = PathBuf::from(\"/var/lib/horus/checkpoints/checkpoint_00000005.bin\");\nif let Some(checkpoint) = manager.load_checkpoint(&path)? {\n    // Use checkpoint\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:143:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 143,
      "lineEnd": 177,
      "language": "text",
      "code": "\n## Custom Node State\n\nNodes can save custom state in checkpoints:\n\n```rust,ignore\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct SensorNodeState {\n    calibration_offset: f64,\n    sample_count: u64,\n    last_readings: Vec<f64>,\n}\n\nimpl Node for SensorNode {\n    fn checkpoint_state(&self) -> Option<Vec<u8>> {\n        let state = SensorNodeState {\n            calibration_offset: self.calibration_offset,\n            sample_count: self.sample_count,\n            last_readings: self.last_readings.clone(),\n        };\n        bincode::serialize(&state).ok()\n    }\n\n    fn restore_state(&mut self, data: &[u8]) -> Result<()> {\n        let state: SensorNodeState = bincode::deserialize(data)?;\n        self.calibration_offset = state.calibration_offset;\n        self.sample_count = state.sample_count;\n        self.last_readings = state.last_readings;\n        Ok(())\n    }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:190:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 190,
      "lineEnd": 207,
      "language": "text",
      "code": "\n## Integration with Scheduler\n\n```rust,ignore\nuse horus::prelude::*;\n\n// Note: Configure checkpoints through the scheduler config\nlet mut config = SchedulerConfig::default();\n// Checkpoint settings are handled through the monitoring config\n\nlet scheduler = Scheduler::with_config(config);\n\n// Scheduler can be configured to:\n// - Create checkpoints at interval\n// - Save node states\n// - Clean up old checkpoints",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:238:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 238,
      "lineEnd": 250,
      "language": "text",
      "code": "\n## Best Practices\n\n### 1. Choose Appropriate Intervals\n\n```rust,ignore\n// Real-time critical: More frequent\nlet manager = CheckpointManager::new(dir, 10000);  // 10s\n\n// Long-running batch: Less frequent\nlet manager = CheckpointManager::new(dir, 300000);  // 5min",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:265:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 265,
      "lineEnd": 287,
      "language": "text",
      "code": "\n### 3. Validate Checkpoints\n\n```rust,ignore\nfn validate_checkpoint(checkpoint: &Checkpoint) -> bool {\n    // Check basic validity\n    if checkpoint.node_states.is_empty() {\n        return false;\n    }\n\n    // Check timestamp is reasonable\n    let now = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap()\n        .as_secs();\n    if checkpoint.timestamp > now {\n        return false;\n    }\n\n    true\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/checkpoint:306:text",
      "file": "content/docs/advanced/checkpoint.mdx",
      "lineStart": 306,
      "lineEnd": 312,
      "language": "text",
      "code": "\n## File Format\n\nCheckpoints are stored as bincode-serialized files:\n",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:26:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 26,
      "lineEnd": 36,
      "language": "text",
      "code": "    [Closed] ──failure threshold──> [Open]\n        ↑                              │\n        │                         timeout\n        │                              ↓\n        └──success threshold── [Half-Open]\n                                       │\n                                  failure\n                                       ↓\n                                   [Open]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:59:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 59,
      "lineEnd": 85,
      "language": "text",
      "code": "\n## Configuration\n\n```rust\nuse horus::prelude::*;\n\n// Conservative settings (for critical nodes)\nlet critical = CircuitBreaker::new(\n    3,     // Open after 3 failures\n    5,     // Need 5 successes to close\n    10000, // 10 second timeout\n);\n\n// Aggressive settings (for non-critical nodes)\nlet non_critical = CircuitBreaker::new(\n    10,    // Open after 10 failures\n    2,     // Need 2 successes to close\n    2000,  // 2 second timeout\n);\n\n// Default settings\nlet default = CircuitBreaker::default();\n// failure_threshold: 5\n// success_threshold: 3\n// timeout: 5000ms",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:102:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 102,
      "lineEnd": 120,
      "language": "text",
      "code": "\n### Open → Half-Open\n\nAfter timeout elapses:\n\n```rust,ignore\n// Circuit is open\nassert_eq!(circuit.get_state(), CircuitState::Open);\n\n// Wait for timeout\nstd::thread::sleep(Duration::from_millis(5000));\n\n// Next call triggers half-open\nif circuit.should_allow() {\n    // State is now Half-Open\n    assert_eq!(circuit.get_state(), CircuitState::HalfOpen);\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:132:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 132,
      "lineEnd": 143,
      "language": "text",
      "code": "\n### Half-Open → Open\n\nOn any failure:\n\n```rust,ignore\n// In Half-Open state\ncircuit.record_failure(); // Immediately reopens\n\nassert_eq!(circuit.get_state(), CircuitState::Open);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:155:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 155,
      "lineEnd": 173,
      "language": "text",
      "code": "\n### State Checking\n\n```rust,ignore\nuse horus::prelude::*;\n\nmatch circuit.get_state() {\n    CircuitState::Closed => {\n        println!(\"Normal operation\");\n    }\n    CircuitState::Open => {\n        println!(\"Circuit open - failures detected\");\n    }\n    CircuitState::HalfOpen => {\n        println!(\"Testing recovery\");\n    }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:194:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 194,
      "lineEnd": 214,
      "language": "text",
      "code": "\n## Per-Node Configuration\n\nConfigure circuit breakers per node for different reliability requirements:\n\n```rust,ignore\nuse horus::prelude::*;\n\n// Critical control node - conservative settings\nlet control_config = NodeConfig {\n    circuit_breaker: Some(CircuitBreaker::new(2, 5, 10000)),\n    ..Default::default()\n};\n\n// Logging node - aggressive settings\nlet log_config = NodeConfig {\n    circuit_breaker: Some(CircuitBreaker::new(20, 1, 1000)),\n    ..Default::default()\n};",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:241:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 241,
      "lineEnd": 256,
      "language": "text",
      "code": "\n## Best Practices\n\n### 1. Tune Thresholds Per Node Type\n\n```rust,ignore\n// Safety-critical: fail fast\nlet safety_cb = CircuitBreaker::new(2, 5, 15000);\n\n// Sensor: tolerate intermittent failures\nlet sensor_cb = CircuitBreaker::new(10, 2, 3000);\n\n// Logging: very tolerant\nlet log_cb = CircuitBreaker::new(50, 1, 1000);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/circuit-breaker:269:text",
      "file": "content/docs/advanced/circuit-breaker.mdx",
      "lineStart": 269,
      "lineEnd": 290,
      "language": "text",
      "code": "\n### 3. Handle Open Circuit Gracefully\n\n```rust,ignore\nif circuit.should_allow() {\n    let result = execute_node();\n    match result {\n        Ok(v) => {\n            circuit.record_success();\n            Ok(v)\n        }\n        Err(e) => {\n            circuit.record_failure();\n            Err(e)\n        }\n    }\n} else {\n    // Return cached value or default\n    Ok(cached_value.clone())\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:66:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 66,
      "lineEnd": 90,
      "language": "text",
      "code": "\n**Guarantees:**\n- Sequential execution (same order every tick)\n- No learning phase (no ~100-tick profiling)\n- Reproducible runs with same inputs\n\n**Does NOT include:** Performance optimization, safety monitoring, topology validation.\n\n### Level 2: Determinism + Performance\n\nUse `add_with_tier()` to get deterministic execution with explicit performance tiers:\n\n```rust,ignore\nuse horus::prelude::*;\n\nlet mut scheduler = Scheduler::new();\n\nscheduler\n    .add_with_tier(Box::new(pid_controller), 0, NodeTier::Jit)      // JIT compiled\n    .add_with_tier(Box::new(sensor_reader), 1, NodeTier::Fast)      // Inline\n    .add_with_tier(Box::new(data_logger), 5, NodeTier::Background); // Low priority\n\nscheduler.run()?;",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:103:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 103,
      "lineEnd": 140,
      "language": "text",
      "code": "\n**Adds:**\n- Watchdog timers (100ms timeout)\n- WCET enforcement\n- Deadline monitoring (panic on miss)\n- Memory locking (mlockall)\n- Real-time scheduling class (SCHED_FIFO)\n\n### Level 4: Determinism + Topology Validation\n\nUse `SchedulerConfig::deterministic()` for formal verification and deterministic guarantees:\n\n```rust,ignore\nuse horus::prelude::*;\n\nlet mut scheduler = Scheduler::new()\n    .with_config(SchedulerConfig::deterministic());\n\n// Add nodes - topology auto-collected from node.get_publishers() / get_subscribers()\nscheduler.add(Box::new(ImuNode::new()), 0, None);\nscheduler.add(Box::new(ControllerNode::new()), 1, None);\nscheduler.add(Box::new(MotorNode::new()), 2, None);\n\n// Validate all connections before running\nlet errors = scheduler.validate_topology();\nif !errors.is_empty() {\n    for err in &errors {\n        eprintln!(\"Topology error: {}\", err);\n    }\n    panic!(\"Topology validation failed\");\n}\n\n// Lock topology - no more nodes can be added after this\nscheduler.lock_topology();\n\nscheduler.run();",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:177:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 177,
      "lineEnd": 187,
      "language": "text",
      "code": "\n### Presets\n\n```rust,ignore\n// Full determinism\nDeterministicConfig::strict()\n\n// Just static execution order, no topology validation\nDeterministicConfig::execution_only()",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:204:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 204,
      "lineEnd": 231,
      "language": "text",
      "code": "\n### What Topology Validation Checks\n\n| Check | Description |\n|-------|-------------|\n| **Orphaned publishers** | Topics with publishers but no subscribers |\n| **Orphaned subscribers** | Topics with subscribers but no publishers |\n| **Type mismatches** | Publisher sends `TypeA`, subscriber expects `TypeB` |\n\n### Auto-Collection from Nodes\n\nWhen you use the `node!` macro, topology is automatically declared:\n\n```rust,ignore\nnode! {\n    ImuNode {\n        pub {\n            imu_data: ImuData -> \"sensors.imu\",\n        }\n\n        tick { /* ... */ }\n    }\n}\n\n// When added to scheduler, get_publishers() returns:\n// [TopicMetadata { topic_name: \"sensors.imu\", type_name: \"ImuData\" }]",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/advanced/deterministic-execution:268:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 268,
      "lineEnd": 275,
      "language": "text",
      "code": "\n## Deterministic vs Non-Deterministic\n\n### Execution Comparison\n\n**Default (Deterministic):**",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:279:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 279,
      "lineEnd": 282,
      "language": "text",
      "code": "\n**With `enable_learning()` (Non-Deterministic):**",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:286:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 286,
      "lineEnd": 318,
      "language": "text",
      "code": "\n### Performance Trade-off\n\n| Metric | Default (Deterministic) | With `enable_learning()` |\n|--------|------------------------|-------------------------|\n| Consistency | Perfect | Variable |\n| Average Latency | 87-313ns | &lt;50ns (after learning) |\n| Peak Performance | Consistent | Higher (variable) |\n| Multi-core | Via config | Auto-detected |\n| Certification Ready | **Yes** | No |\n| Startup | Immediate | ~100 ticks warmup |\n\n## Best Practices\n\n### Use Deterministic Seeds\n\nFor any randomness in your nodes:\n\n```rust,ignore\nimpl Node for RandomNode {\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Use deterministic seed from tick\n        self.rng = StdRng::seed_from_u64(42);\n        Ok(())\n    }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Generates same sequence every run\n        let value = self.rng.gen::<f64>();\n    }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:333:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 333,
      "lineEnd": 346,
      "language": "text",
      "code": "\n### Control External Inputs\n\n```rust,ignore\n// For testing, mock external sensors\n#[cfg(test)]\nimpl Node for SensorNode {\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Return predetermined values in tests\n        self.output = self.test_data[self.tick_count % self.test_data.len()];\n    }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:409:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 409,
      "lineEnd": 425,
      "language": "text",
      "code": "\n## Verification\n\n### Comparing Runs\n\n```bash\n# Run 1\nhorus run my_robot.rs 2>&1 | tee run1.log\n\n# Run 2\nhorus run my_robot.rs 2>&1 | tee run2.log\n\n# Compare (should be identical in deterministic mode)\ndiff run1.log run2.log\n# No output = identical runs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/deterministic-execution:438:text",
      "file": "content/docs/advanced/deterministic-execution.mdx",
      "lineStart": 438,
      "lineEnd": 453,
      "language": "text",
      "code": "\n## When to Enable Learning\n\nThe default deterministic mode is best for most use cases. Consider enabling learning only when:\n\n- **Maximum performance needed**: Learning identifies JIT candidates automatically\n- **Variable workloads**: Runtime adaptation can optimize dynamically\n- **Long-running systems**: Learning cost amortizes over time\n- **Non-safety-critical**: Where determinism isn't required\n\n```rust,ignore\n// Only if you need adaptive optimization and don't care about determinism\nlet scheduler = Scheduler::new()\n    .enable_learning();  // WARNING: Non-deterministic!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:21:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 21,
      "lineEnd": 32,
      "language": "text",
      "code": "\n## Sequential Mode\n\n**The deterministic choice for safety-critical systems.**\n\n```rust,ignore\nuse horus::prelude::*;\n\nlet config = SchedulerConfig::standard()\n    .with_execution_mode(ExecutionMode::Sequential);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:66:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 66,
      "lineEnd": 75,
      "language": "text",
      "code": "\n## JITOptimized Mode\n\n**Maximum performance through Just-In-Time compilation.**\n\n```rust,ignore\nlet config = SchedulerConfig::standard()\n    .with_execution_mode(ExecutionMode::JITOptimized);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:113:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 113,
      "lineEnd": 129,
      "language": "text",
      "code": "\n### When to Use\n\n- Racing/competition robots\n- High-frequency control loops (&gt;1kHz)\n- Performance-critical applications\n- When determinism is not required\n\n## Parallel Mode\n\n**Multi-core execution with dependency resolution.**\n\n```rust,ignore\nlet config = SchedulerConfig::standard()\n    .with_execution_mode(ExecutionMode::Parallel);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:157:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 157,
      "lineEnd": 173,
      "language": "text",
      "code": "\n### When to Use\n\n- Multi-sensor robots\n- Compute-heavy pipelines\n- Systems with many independent nodes\n- When you have multiple CPU cores available\n\n## AsyncIO Mode\n\n**Optimized for I/O-bound operations.**\n\n```rust,ignore\nlet config = SchedulerConfig::standard()\n    .with_execution_mode(ExecutionMode::AsyncIO);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:207:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 207,
      "lineEnd": 220,
      "language": "text",
      "code": "\n## AutoAdaptive Mode (Opt-In)\n\n**Learns and optimizes at runtime - must be explicitly enabled.**\n\n```rust,ignore\n// Default scheduler is deterministic (no learning)\nlet scheduler = Scheduler::new();\n\n// Opt-in to adaptive learning (non-deterministic!)\nlet scheduler = Scheduler::new()\n    .enable_learning();  // WARNING: Non-deterministic",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:258:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 258,
      "lineEnd": 281,
      "language": "text",
      "code": "\n### When to Use\n\n- Long-running production systems where learning cost amortizes\n- Non-safety-critical applications\n- When optimal performance is worth the warmup time\n- When determinism is not required\n\n## Mode Comparison\n\n| Feature | Sequential | JIT | Parallel | AsyncIO | AutoAdaptive |\n|---------|------------|-----|----------|---------|--------------|\n| Deterministic | **Yes** | Via profile | Via profile | Via profile | **No** |\n| Multi-core | No | No | Yes | Partial | Auto |\n| JIT Compile | Via tier | Yes | No | No | Auto |\n| Async I/O | No | No | No | Yes | Auto |\n| Learning Phase | No | No | No | No | **Yes** |\n| Best Latency | 87-313ns | &lt;50ns | Variable | Variable | Variable |\n| Certification Ready | **Yes** | With profile | No | No | No |\n\n## Choosing the Right Mode\n",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:310:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 310,
      "lineEnd": 328,
      "language": "text",
      "code": "\n**Key Insight**: The default `Scheduler::new()` is deterministic and suitable for most robotics applications. Only add complexity if you need specific optimizations.\n\n## Examples\n\n### Safety-Critical System\n\n```rust,ignore\n// Surgical robot - must be deterministic\nlet config = SchedulerConfig::safety_critical();\n// Uses Sequential mode automatically\n\nlet mut scheduler = Scheduler::with_config(config);\nscheduler.add(Box::new(safety_monitor), 0, Some(true));\nscheduler.add(Box::new(force_feedback), 1, Some(true));\nscheduler.add(Box::new(motion_controller), 1, Some(true));\nscheduler.run()?;",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/execution-modes:341:text",
      "file": "content/docs/advanced/execution-modes.mdx",
      "lineStart": 341,
      "lineEnd": 359,
      "language": "text",
      "code": "\n### Multi-Sensor Robot\n\n```rust,ignore\n// Research robot with many sensors\nlet config = SchedulerConfig::standard()\n    .with_execution_mode(ExecutionMode::Parallel);\n\nlet mut scheduler = Scheduler::with_config(config);\n// These run in parallel\nscheduler.add(Box::new(lidar), 2, Some(true));\nscheduler.add(Box::new(camera), 2, Some(true));\nscheduler.add(Box::new(radar), 2, Some(true));\nscheduler.add(Box::new(imu), 2, Some(true));\n// This waits for all sensors\nscheduler.add(Box::new(fusion), 1, Some(true));\nscheduler.run()?;",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:28:text",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 28,
      "lineEnd": 36,
      "language": "text",
      "code": "Process A (Perception)     Process B (Planning)\n┌─────────────────┐       ┌─────────────────┐\n│ GPU: Run YOLO   │       │ GPU: Path Plan  │\n│       ↓         │       │       ↑         │\n│ GPU → CPU copy  │──────→│ CPU → GPU copy  │\n└─────────────────┘ IPC   └─────────────────┘\n        ~2ms                      ~2ms",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:44:text",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 44,
      "lineEnd": 52,
      "language": "text",
      "code": "Process A (Perception)     Process B (Planning)\n┌─────────────────┐       ┌─────────────────┐\n│ GPU: Run YOLO   │       │ GPU: Path Plan  │\n│       ↓         │       │       ↑         │\n│ IPC Handle (64B)│──────→│ Open IPC Handle │\n└─────────────────┘       └─────────────────┘\n        ~1μs                      ~1μs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:64:bash",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 64,
      "lineEnd": 66,
      "language": "bash",
      "code": "horus run --enable cuda",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:70:yaml",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 70,
      "lineEnd": 73,
      "language": "yaml",
      "code": "enable:\n  - cuda",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:76:bash",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 76,
      "lineEnd": 78,
      "language": "bash",
      "code": "horus run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:84:toml",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 84,
      "lineEnd": 87,
      "language": "toml",
      "code": "[dependencies]\nhorus_core = { version = \"0.1\", features = [\"cuda\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:97:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 97,
      "lineEnd": 103,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nif cuda_available() {\n    println!(\"CUDA available with {} devices\", cuda_device_count());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:109:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 109,
      "lineEnd": 127,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Process A: Create pool and allocate tensor\nlet pool = CudaTensorPool::new(1, 0, CudaTensorPoolConfig::default())?;\nlet tensor = pool.alloc(&[1080, 1920, 3], TensorDtype::F32)?;\n\n// Get IPC handle to share (64 bytes)\nlet ipc_handle = tensor.ipc_handle_bytes();\n\n// Send ipc_handle through Hub/Link/socket to Process B...\n\n// Process B: Open shared GPU memory\nlet pool = CudaTensorPool::open(1, 0)?;\nlet (gpu_ptr, tensor) = pool.import_ipc(ipc_handle, &[1080, 1920, 3], TensorDtype::F32)?;\n\n// gpu_ptr points to the SAME GPU memory as Process A\n// No data was copied!",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:131:python",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 131,
      "lineEnd": 151,
      "language": "python",
      "code": "import horus\n\n# Check CUDA availability\nif horus.cuda_is_available():\n    print(f\"CUDA devices: {horus.cuda_device_count()}\")\n\n# Create tensor pool\npool = horus.TensorPool(pool_id=1, size_mb=1024)\n\n# Allocate CPU tensor and transfer to GPU\ncpu_tensor = pool.alloc(shape=(1080, 1920, 3), dtype=\"float32\")\ngpu_tensor = cpu_tensor.cuda(\"cuda:0\")\n\n# Get IPC handle for sharing\nipc_handle = gpu_tensor.get_cuda_ipc_handle()\n\n# Zero-copy PyTorch integration\nimport torch\ntorch_tensor = torch.as_tensor(gpu_tensor)  # Uses __cuda_array_interface__",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:159:text",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 159,
      "lineEnd": 176,
      "language": "text",
      "code": "┌─────────────────────────────────────────────────────────────┐\n│                    CudaTensorPool Design                     │\n├─────────────────────────────────────────────────────────────┤\n│  Process A (Owner)              Process B (Consumer)         │\n│  ┌─────────────────┐            ┌─────────────────┐         │\n│  │ cudaMalloc      │            │                 │         │\n│  │    ↓            │            │                 │         │\n│  │ GPU Memory      │════════════│ GPU Memory      │         │\n│  │ (same physical) │ IPC Handle │ (same physical) │         │\n│  │    ↓            │  64 bytes  │    ↓            │         │\n│  │ IpcGetHandle    │───────────→│ IpcOpenHandle   │         │\n│  └─────────────────┘            └─────────────────┘         │\n│                                                              │\n│  Shared Memory (CPU): Stores metadata + IPC handles          │\n│  /dev/shm/horus/cuda_pool_{id}_{device}                     │\n└─────────────────────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:192:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 192,
      "lineEnd": 203,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Allocate GPU tensor\nlet handle = TensorHandle::alloc(pool, &[640, 480, 3], TensorDtype::F32, TensorDevice::Cuda0)?;\n\n// Fill with data (e.g., from camera)\n// ...\n\n// Send through Hub - only 64-byte handle is copied!\nhub.send(handle.tensor().clone())?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:207:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 207,
      "lineEnd": 216,
      "language": "rust",
      "code": "// Receiver gets tensor descriptor\nlet tensor = hub.recv()?;\n\n// Wrap in handle - this opens the IPC handle if from another process\nlet handle = TensorHandle::from_ipc(tensor, pool)?;\n\n// Access GPU memory directly\nlet gpu_ptr = handle.data_ptr();  // Points to shared GPU memory",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:264:bash",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 264,
      "lineEnd": 273,
      "language": "bash",
      "code": "# Check NVIDIA driver\nnvidia-smi\n\n# Check CUDA toolkit\nnvcc --version\n\n# Ensure libcudart is installed\nls /usr/lib/x86_64-linux-gnu/libcudart*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:285:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 285,
      "lineEnd": 288,
      "language": "rust",
      "code": "// When done with imported tensor\npool.close_ipc(gpu_ptr)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:294:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 294,
      "lineEnd": 315,
      "language": "rust",
      "code": "// perception_node.rs\nuse horus::prelude::*;\n\nstruct PerceptionNode {\n    pool: CudaTensorPool,\n    output: Hub<HorusTensor>,\n}\n\nimpl Node for PerceptionNode {\n    fn tick(&mut self, _ctx: &mut NodeInfo) {\n        // Allocate GPU tensor for inference output\n        let tensor = self.pool.alloc(&[100, 7], TensorDtype::F32).unwrap();\n\n        // Run YOLO inference (fills tensor on GPU)\n        self.run_inference(&tensor);\n\n        // Send IPC handle - receiver gets same GPU memory!\n        self.output.send(tensor).unwrap();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:317:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 317,
      "lineEnd": 339,
      "language": "rust",
      "code": "// planning_node.rs\nstruct PlanningNode {\n    pool: CudaTensorPool,\n    input: Hub<HorusTensor>,\n}\n\nimpl Node for PlanningNode {\n    fn tick(&mut self, _ctx: &mut NodeInfo) {\n        if let Some(tensor) = self.input.recv() {\n            // Import GPU tensor - zero copy!\n            let (gpu_ptr, _) = self.pool.import_ipc(\n                &tensor.ipc_handle,\n                &[100, 7],\n                TensorDtype::F32\n            ).unwrap();\n\n            // Use GPU pointer directly for planning\n            self.plan_path(gpu_ptr);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:349:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 349,
      "lineEnd": 361,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet pool = CudaTensorPool::new(1, 0, Default::default())?;\nlet tensor = pool.alloc(&[12, 8], TensorDtype::F32)?;  // 96 elements\n\n// Reshape to different dimensions (same total elements)\nlet view_3d = tensor.view(&[4, 3, 8]).unwrap();  // 96 elements\nlet view_1d = tensor.view(&[96]).unwrap();       // Flatten\n\n// Views share the same GPU memory - no copy!\nassert_eq!(tensor.numel, view_3d.numel);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:367:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 367,
      "lineEnd": 378,
      "language": "rust",
      "code": "// Slice along first dimension\nlet tensor = pool.alloc(&[100, 64, 64], TensorDtype::F32)?;  // Batch of 100\n\n// Get items 10-20 (zero-copy slice)\nlet batch_slice = tensor.slice_first_dim(10, 20).unwrap();\nassert_eq!(batch_slice.shape[0], 10);  // 10 items\n\n// Slice along any dimension\nlet spatial_crop = tensor.slice_dim(1, 16, 48).unwrap();  // Crop dim 1\nassert_eq!(spatial_crop.shape[1], 32);  // 48 - 16 = 32",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:382:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 382,
      "lineEnd": 397,
      "language": "rust",
      "code": "// Transpose dimensions (swaps strides, no copy)\nlet tensor = pool.alloc(&[3, 224, 224], TensorDtype::F32)?;  // CHW\nlet transposed = tensor.transpose(0, 2).unwrap();  // WHC\nassert_eq!(transposed.shape, [224, 224, 3]);\n\n// Squeeze: remove size-1 dimensions\nlet batched = pool.alloc(&[1, 64, 64], TensorDtype::F32)?;\nlet squeezed = batched.squeeze(0).unwrap();\nassert_eq!(squeezed.shape[0], 64);  // Now [64, 64]\n\n// Unsqueeze: add size-1 dimension\nlet unbatched = pool.alloc(&[64, 64], TensorDtype::F32)?;\nlet batched = unbatched.unsqueeze(0).unwrap();\nassert_eq!(batched.shape[0], 1);  // Now [1, 64, 64]",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:403:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 403,
      "lineEnd": 419,
      "language": "rust",
      "code": "let tensor = pool.alloc(&[10, 20, 30], TensorDtype::F32)?;\n\n// Original is always contiguous\nassert!(tensor.is_contiguous());\n\n// Slices along first dim are contiguous\nlet slice = tensor.slice_first_dim(0, 5).unwrap();\nassert!(slice.is_contiguous());\n\n// Transpose makes it non-contiguous\nlet transposed = tensor.transpose(0, 1).unwrap();\nassert!(!transposed.is_contiguous());\n\n// Views require contiguous input\nassert!(transposed.view(&[6000]).is_none());  // Fails",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:427:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 427,
      "lineEnd": 443,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Check if GPU 0 can access GPU 1 directly\nif P2PManager::can_access_peer(0, 1)? {\n    println!(\"P2P supported between GPU 0 and GPU 1\");\n}\n\n// Get full P2P topology\nlet topology = P2PManager::get_p2p_topology()?;\nfor info in topology {\n    println!(\"GPU {} → GPU {}: {}\",\n        info.device, info.peer_device,\n        if info.can_access { \"P2P\" } else { \"via CPU\" }\n    );\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:447:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 447,
      "lineEnd": 455,
      "language": "rust",
      "code": "let p2p = P2PManager::new();\n\n// Enable bidirectional P2P access between two GPUs\np2p.enable_bidirectional(0, 1)?;\n\n// Or enable one-way access\np2p.enable_peer_access(0, 1)?;  // GPU 0 can access GPU 1",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:459:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 459,
      "lineEnd": 480,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet p2p = P2PManager::new();\np2p.enable_bidirectional(0, 1)?;\n\n// Create pools on different GPUs\nlet pool_gpu0 = CudaTensorPool::new(1, 0, Default::default())?;\nlet pool_gpu1 = CudaTensorPool::new(2, 1, Default::default())?;\n\n// Allocate tensor on GPU 0\nlet src_tensor = pool_gpu0.alloc(&[1024, 1024], TensorDtype::F32)?;\n\n// Direct P2P copy to GPU 1 (synchronous)\nlet dst_tensor = p2p.copy_p2p(&pool_gpu0, &src_tensor, &pool_gpu1)?;\n\n// Async P2P copy with CUDA stream\nlet stream = cuda_ffi::stream_create()?;\nlet dst_tensor = pool_gpu1.alloc(&[1024, 1024], TensorDtype::F32)?;\np2p.copy_p2p_async(&pool_gpu0, &src_tensor, &pool_gpu1, &dst_tensor, stream)?;\ncuda_ffi::stream_synchronize(stream)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:496:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 496,
      "lineEnd": 506,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a non-blocking stream\nlet stream = cuda_ffi::stream_create_with_flags(\n    cuda_ffi::CudaStreamFlags::NonBlocking\n)?;\n\n// Use default stream\nlet default_stream = std::ptr::null_mut();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:510:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 510,
      "lineEnd": 525,
      "language": "rust",
      "code": "// Async device-to-host copy\nlet host_buffer: Vec<f32> = vec![0.0; tensor.numel as usize];\ncuda_ffi::memcpy_async(\n    host_buffer.as_ptr() as *mut _,\n    pool.device_ptr(&tensor),\n    tensor.size as usize,\n    cuda_ffi::CudaMemcpyKind::DeviceToHost,\n    stream,\n)?;\n\n// Continue other work while copy happens...\n\n// Wait for completion when needed\ncuda_ffi::stream_synchronize(stream)?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:529:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 529,
      "lineEnd": 543,
      "language": "rust",
      "code": "// Create event\nlet event = cuda_ffi::event_create()?;\n\n// Record event on stream\ncuda_ffi::event_record(event, stream)?;\n\n// Wait for event from another stream\ncuda_ffi::stream_wait_event(other_stream, event)?;\n\n// Query if event completed (non-blocking)\nif cuda_ffi::event_query(event).is_ok() {\n    println!(\"Event completed\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/gpu-tensor-sharing:549:rust",
      "file": "content/docs/advanced/gpu-tensor-sharing.mdx",
      "lineStart": 549,
      "lineEnd": 566,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Allocate pinned host memory\nlet size = 1024 * 1024 * 4;  // 4MB\nlet pinned_ptr = cuda_ffi::host_malloc(size)?;\n\n// Register existing memory as pinned\nlet buffer: Vec<f32> = vec![0.0; 1_000_000];\ncuda_ffi::host_register(\n    buffer.as_ptr() as *mut _,\n    buffer.len() * 4,\n    cuda_ffi::CudaHostRegisterFlags::Portable,\n)?;\n\n// Unregister when done\ncuda_ffi::host_unregister(buffer.as_ptr() as *mut _)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:37:toml",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 37,
      "lineEnd": 40,
      "language": "toml",
      "code": "[dependencies]\nhorus_core = { version = \"0.1\", features = [\"jit\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/jit-compilation:46:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 46,
      "lineEnd": 51,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a new JIT compiler\nlet mut compiler = JITCompiler::new()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:57:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 57,
      "lineEnd": 70,
      "language": "rust",
      "code": "// Compile: output = input * 2 + 10\nlet func_ptr = compiler.compile_arithmetic_node(\n    \"scale_sensor\",  // Node name\n    2,               // Multiply factor\n    10,              // Offset\n)?;\n\n// Execute the compiled function\nlet result = unsafe {\n    compiler.execute_arithmetic(func_ptr, 100)\n};\nassert_eq!(result, 210);  // 100 * 2 + 10",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:76:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 76,
      "lineEnd": 84,
      "language": "rust",
      "code": "let func_ptr = compiler.compile_dataflow_combiner(\"combine_sensors\")?;\n\n// Execute with 4 inputs\nlet result = unsafe {\n    compiler.execute_combiner(func_ptr, 10, 5, 20, 3)\n};\nassert_eq!(result, 255);  // (10 + 5) * (20 - 3) = 15 * 17",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:90:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 90,
      "lineEnd": 107,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SchedulerConfig, Scheduler, ExecutionTier}\n\nlet config = SchedulerConfig {\n    jit_enabled: true,\n    ..Default::default()\n};\n\nlet mut scheduler = Scheduler::with_config(config);\n\n// After learning phase, ultra-fast nodes are JIT-compiled\n// Node tier can be checked:\nif let Some(tier) = scheduler.get_node_tier(\"sensor_scale\") {\n    if tier == ExecutionTier::UltraFast {\n        println!(\"Node is JIT-compiled\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:123:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 123,
      "lineEnd": 130,
      "language": "rust",
      "code": "// UltraFast tier requirements:\n// - Average execution < 5µs\n// - Deterministic (low variance, CV < 10%)\n// - No I/O operations\n\n// Classification happens automatically during learning phase",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:143:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 143,
      "lineEnd": 182,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn setup_sensor_pipeline() -> Result<(), String> {\n    let mut compiler = JITCompiler::new()?;\n\n    // Temperature sensor: raw ADC to Celsius\n    // celsius = (raw * 0.01) - 40\n    // Using integers: (raw * 1 + -4000) / 100\n    let temp_convert = compiler.compile_arithmetic_node(\n        \"temp_convert\",\n        1,\n        -4000,\n    )?;\n\n    // Pressure sensor: raw to kPa\n    // kPa = raw * 0.1\n    let pressure_convert = compiler.compile_arithmetic_node(\n        \"pressure_convert\",\n        1,  // Scale factor\n        0,  // No offset\n    )?;\n\n    // Process sensor readings\n    loop {\n        let raw_temp = read_adc(0);\n        let raw_pressure = read_adc(1);\n\n        let celsius = unsafe {\n            compiler.execute_arithmetic(temp_convert, raw_temp)\n        } / 100;  // Final division for decimal\n\n        let pressure = unsafe {\n            compiler.execute_arithmetic(pressure_convert, raw_pressure)\n        };\n\n        // Ultra-fast processing!\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:188:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 188,
      "lineEnd": 211,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Define dataflow: (sensor1 + sensor2) * gain + offset\nlet dataflow = CompiledDataflow::builder()\n    .input(\"sensor1\")\n    .input(\"sensor2\")\n    .add(\"sensor1\", \"sensor2\", \"sum\")\n    .multiply(\"sum\", \"gain\", \"scaled\")\n    .add(\"scaled\", \"offset\", \"output\")\n    .build()?;\n\n// Compile to native code\nlet compiled = dataflow.compile()?;\n\n// Execute\nlet result = compiled.execute(&[\n    (\"sensor1\", 100),\n    (\"sensor2\", 50),\n    (\"gain\", 2),\n    (\"offset\", 10),\n])?;\n// result = (100 + 50) * 2 + 10 = 310",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:232:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 232,
      "lineEnd": 241,
      "language": "rust",
      "code": "// Instead of floating point:\n// celsius = raw * 0.0125 - 40\n\n// Use scaled integers:\n// celsius_x1000 = raw * 125 / 10 - 40000\nlet func = compiler.compile_arithmetic_node(\"temp\", 125, -400000)?;\nlet result_x1000 = unsafe { compiler.execute_arithmetic(func, raw) };\nlet celsius = result_x1000 as f64 / 10000.0;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:247:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 247,
      "lineEnd": 257,
      "language": "rust",
      "code": "// The function pointer must be valid JIT-compiled code\nlet result = unsafe {\n    compiler.execute_arithmetic(func_ptr, input)\n};\n\n// Safety requirements:\n// - func_ptr from this compiler instance\n// - Correct signature (compile_arithmetic -> execute_arithmetic)\n// - Compiler not dropped while function in use",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:263:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 263,
      "lineEnd": 268,
      "language": "rust",
      "code": "match compiler.compile_arithmetic_node(\"test\", 2, 0) {\n    Ok(ptr) => println!(\"Compiled at {:p}\", ptr),\n    Err(e) => eprintln!(\"Compilation failed: {}\", e),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/jit-compilation:272:rust",
      "file": "content/docs/advanced/jit-compilation.mdx",
      "lineStart": 272,
      "lineEnd": 281,
      "language": "rust",
      "code": "// Test against reference implementation\nfn reference_impl(input: i64, factor: i64, offset: i64) -> i64 {\n    input * factor + offset\n}\n\nlet jit_result = unsafe { compiler.execute_arithmetic(func, 100) };\nlet ref_result = reference_impl(100, 2, 10);\nassert_eq!(jit_result, ref_result);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:23:yaml",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 23,
      "lineEnd": 47,
      "language": "yaml",
      "code": "models:\n  yolov8n:\n    versions:\n      - name: yolov8n\n        version: \"1.0.0\"\n        format: onnx\n        path: models/yolov8n.onnx\n        hash: \"sha256:abc123...\"\n        size_bytes: 6000000\n        status: latest\n        metrics:\n          mAP: 0.372\n          latency_ms: 5.2\n        trained_date: \"2024-01-15\"\n        dataset: \"COCO\"\n\n      - name: yolov8n\n        version: \"0.9.0\"\n        format: onnx\n        path: models/yolov8n_v0.9.onnx\n        status: stable\n        metrics:\n          mAP: 0.358",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:53:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 53,
      "lineEnd": 64,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ModelRegistry\nuse std::path::PathBuf;\n\n// Create from file\nlet registry = ModelRegistry::new(\n    PathBuf::from(\"/path/to/models.yaml\")\n)?;\n\n// Or use default location (~/.horus/models.yaml)\nlet registry = ModelRegistry::default();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:68:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 68,
      "lineEnd": 78,
      "language": "rust",
      "code": "// Get latest version\nlet model = registry.get_model(\"yolov8n\", None)?;\nprintln!(\"Using {} v{}\", model.name, model.version);\n\n// Get specific version\nlet model = registry.get_model(\"yolov8n\", Some(\"1.0.0\"))?;\n\n// Get model path\nprintln!(\"Model path: {}\", model.path);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:82:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 82,
      "lineEnd": 94,
      "language": "rust",
      "code": "// List all model names\nlet models = registry.list_models();\nfor name in models {\n    println!(\"Model: {}\", name);\n}\n\n// List versions of a model\nlet versions = registry.list_versions(\"yolov8n\");\nfor version in versions {\n    println!(\"  v{}\", version);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:100:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 100,
      "lineEnd": 114,
      "language": "rust",
      "code": "pub struct ModelEntry {\n    pub name: String,           // Model name\n    pub version: String,        // Semantic version\n    pub format: String,         // onnx, tflite, pytorch, etc.\n    pub path: String,           // File path or URL\n    pub hash: Option<String>,   // SHA256 hash\n    pub size_bytes: Option<u64>,\n    pub metrics: HashMap<String, f64>,  // mAP, accuracy, etc.\n    pub status: String,         // latest, stable, deprecated\n    pub trained_date: Option<String>,\n    pub dataset: Option<String>,\n    pub metadata: HashMap<String, String>,  // Custom fields\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:120:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 120,
      "lineEnd": 145,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {ModelRegistry, ModelEntry}\nuse std::collections::HashMap;\n\nlet mut registry = ModelRegistry::default();\n\nlet entry = ModelEntry {\n    name: \"yolov8n\".to_string(),\n    version: \"1.1.0\".to_string(),\n    format: \"onnx\".to_string(),\n    path: \"models/yolov8n_v1.1.onnx\".to_string(),\n    hash: Some(\"sha256:def456...\".to_string()),\n    size_bytes: Some(6_200_000),\n    metrics: [\n        (\"mAP\".to_string(), 0.385),\n        (\"latency_ms\".to_string(), 4.8),\n    ].iter().cloned().collect(),\n    status: \"latest\".to_string(),\n    trained_date: Some(\"2024-03-01\".to_string()),\n    dataset: Some(\"COCO\".to_string()),\n    metadata: HashMap::new(),\n};\n\nregistry.register_model(entry)?;\nregistry.save()?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:149:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 149,
      "lineEnd": 157,
      "language": "rust",
      "code": "// Mark version as deprecated\nregistry.deprecate_model(\"yolov8n\", \"0.9.0\")?;\n\n// Set new latest version\nregistry.set_latest(\"yolov8n\", \"1.1.0\")?;\n\nregistry.save()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:175:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 175,
      "lineEnd": 192,
      "language": "rust",
      "code": "let model = registry.get_model(\"yolov8n\", None)?;\n\n// Common metrics\nif let Some(map) = model.metrics.get(\"mAP\") {\n    println!(\"mAP: {:.3}\", map);\n}\n\nif let Some(latency) = model.metrics.get(\"latency_ms\") {\n    println!(\"Inference latency: {:.1}ms\", latency);\n}\n\n// Custom metrics\nprintln!(\"All metrics:\");\nfor (key, value) in &model.metrics {\n    println!(\"  {}: {}\", key, value);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:198:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 198,
      "lineEnd": 230,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ModelRegistry\n\nstruct ObjectDetectionNode {\n    model_path: String,\n    model_version: String,\n}\n\nimpl ObjectDetectionNode {\n    pub fn new(registry: &ModelRegistry) -> Result<Self> {\n        // Get latest model\n        let model = registry.get_model(\"yolov8n\", None)?;\n\n        // Verify model exists\n        if !std::path::Path::new(&model.path).exists() {\n            return Err(Error::not_found(\n                format!(\"Model file: {}\", model.path)\n            ));\n        }\n\n        // Log model info\n        println!(\"Loading {} v{}\", model.name, model.version);\n        if let Some(map) = model.metrics.get(\"mAP\") {\n            println!(\"  mAP: {:.3}\", map);\n        }\n\n        Ok(Self {\n            model_path: model.path,\n            model_version: model.version,\n        })\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:236:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 236,
      "lineEnd": 272,
      "language": "rust",
      "code": "use sha2::{Sha256, Digest};\n\nfn validate_model(registry: &ModelRegistry, name: &str) -> Result<bool> {\n    let model = registry.get_model(name, None)?;\n\n    // Check file exists\n    let path = std::path::Path::new(&model.path);\n    if !path.exists() {\n        return Err(Error::not_found(\"Model file\"));\n    }\n\n    // Check size\n    if let Some(expected_size) = model.size_bytes {\n        let actual_size = std::fs::metadata(path)?.len();\n        if actual_size != expected_size {\n            return Err(Error::invalid_input(\n                format!(\"Size mismatch: {} vs {}\", actual_size, expected_size)\n            ));\n        }\n    }\n\n    // Check hash\n    if let Some(expected_hash) = &model.hash {\n        let data = std::fs::read(path)?;\n        let mut hasher = Sha256::new();\n        hasher.update(&data);\n        let actual_hash = format!(\"sha256:{:x}\", hasher.finalize());\n\n        if &actual_hash != expected_hash {\n            return Err(Error::invalid_input(\"Hash mismatch\"));\n        }\n    }\n\n    Ok(true)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:278:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 278,
      "lineEnd": 303,
      "language": "rust",
      "code": "fn select_model(\n    registry: &ModelRegistry,\n    max_latency_ms: f64,\n    min_accuracy: f64,\n) -> Result<ModelEntry> {\n    let versions = registry.list_versions(\"yolov8n\");\n\n    for version in versions {\n        let model = registry.get_model(\"yolov8n\", Some(&version))?;\n\n        if model.status == \"deprecated\" {\n            continue;\n        }\n\n        let latency = model.metrics.get(\"latency_ms\").copied().unwrap_or(f64::MAX);\n        let accuracy = model.metrics.get(\"mAP\").copied().unwrap_or(0.0);\n\n        if latency <= max_latency_ms && accuracy >= min_accuracy {\n            return Ok(model);\n        }\n    }\n\n    Err(Error::not_found(\"No suitable model found\"))\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:309:yaml",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 309,
      "lineEnd": 316,
      "language": "yaml",
      "code": "# Good\nversion: \"1.2.3\"  # major.minor.patch\n\n# Bad\nversion: \"new\"\nversion: \"final_v2\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/model-registry:320:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 320,
      "lineEnd": 325,
      "language": "rust",
      "code": "let entry = ModelEntry {\n    hash: Some(compute_sha256(&model_path)?),\n    ..\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:329:yaml",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 329,
      "lineEnd": 336,
      "language": "yaml",
      "code": "trained_date: \"2024-03-01\"\ndataset: \"COCO\"\nmetadata:\n  epochs: \"300\"\n  batch_size: \"16\"\n  learning_rate: \"0.001\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/model-registry:340:rust",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 340,
      "lineEnd": 351,
      "language": "rust",
      "code": "// Don't delete - deprecate first\nregistry.deprecate_model(\"yolov8n\", \"0.9.0\")?;\n\n// Clean up deprecated versions later\nfor version in registry.list_versions(\"yolov8n\") {\n    let model = registry.get_model(\"yolov8n\", Some(&version))?;\n    if model.status == \"deprecated\" {\n        // Remove after grace period\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/model-registry:357:text",
      "file": "content/docs/advanced/model-registry.mdx",
      "lineStart": 357,
      "lineEnd": 367,
      "language": "text",
      "code": "project/\n├── models/\n│   ├── yolov8n.onnx\n│   ├── yolov8n_v0.9.onnx\n│   └── mobilenet.tflite\n├── config/\n│   └── models.yaml\n└── src/\n    └── ...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:34:toml",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 34,
      "lineEnd": 37,
      "language": "toml",
      "code": "[dependencies]\nhorus_core = { version = \"0.1\", features = [\"quic\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/network-backends:41:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 41,
      "lineEnd": 52,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {QuicConfig, QuicTransport}\n\n// Default configuration\nlet config = QuicConfig::default();\n\n// Low latency configuration\nlet config = QuicConfig::low_latency();\n\n// High throughput configuration\nlet config = QuicConfig::high_throughput();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:67:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 67,
      "lineEnd": 90,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {QuicConfig, QuicTransport}\nuse std::net::SocketAddr;\n\n#[tokio::main]\nasync fn main() -> std::io::Result<()> {\n    let bind_addr: SocketAddr = \"0.0.0.0:0\".parse().unwrap();\n\n    // Create client\n    let transport = QuicTransport::new_client(\n        bind_addr,\n        QuicConfig::low_latency()\n    ).await?;\n\n    // Send data (unidirectional)\n    let server_addr: SocketAddr = \"192.168.1.100:9000\".parse().unwrap();\n    transport.send(server_addr, b\"sensor data\").await?;\n\n    // Send and receive response (bidirectional)\n    let response = transport.send_recv(server_addr, b\"request\").await?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/network-backends:94:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 94,
      "lineEnd": 122,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {QuicConfig, QuicTransport, generate_self_signed_cert}\n\n#[tokio::main]\nasync fn main() -> std::io::Result<()> {\n    // Generate self-signed certificate for development\n    let (certs, key) = generate_self_signed_cert()?;\n\n    let bind_addr: SocketAddr = \"0.0.0.0:9000\".parse().unwrap();\n\n    // Create server\n    let transport = QuicTransport::new_server(\n        bind_addr,\n        certs,\n        key,\n        QuicConfig::default()\n    ).await?;\n\n    // Accept connections\n    loop {\n        let (conn, addr) = transport.accept().await?;\n        println!(\"Connection from {}\", addr);\n\n        // Handle incoming data\n        let (data, _) = transport.accept_uni(&conn).await?;\n        println!(\"Received: {:?}\", data);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/network-backends:126:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 126,
      "lineEnd": 133,
      "language": "rust",
      "code": "let stats = transport.stats();\n\nprintln!(\"Connections established: {}\", stats.connections_established.load(Ordering::Relaxed));\nprintln!(\"Streams opened: {}\", stats.streams_opened.load(Ordering::Relaxed));\nprintln!(\"Bytes sent: {}\", stats.bytes_sent.load(Ordering::Relaxed));\nprintln!(\"0-RTT accepted: {}\", stats.zero_rtt_accepted.load(Ordering::Relaxed));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:154:toml",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 154,
      "lineEnd": 157,
      "language": "toml",
      "code": "[dependencies]\nhorus_core = { version = \"0.1\", features = [\"io-uring-net\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/network-backends:161:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 161,
      "lineEnd": 172,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {RealIoUringConfig, RealIoUringBackend}\n\n// Default configuration\nlet config = RealIoUringConfig::default();\n\n// High performance (requires root/CAP_SYS_NICE)\nlet config = RealIoUringConfig::high_performance();\n\n// Low latency\nlet config = RealIoUringConfig::low_latency();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:188:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 188,
      "lineEnd": 212,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {RealIoUringBackend, RealIoUringConfig, is_real_io_uring_available}\n\n// Check availability\nif !is_real_io_uring_available() {\n    eprintln!(\"io_uring not available on this system\");\n    return;\n}\n\nlet bind_addr: SocketAddr = \"0.0.0.0:9000\".parse().unwrap();\nlet remote_addr: SocketAddr = \"192.168.1.100:9000\".parse().unwrap();\n\n// Create backend\nlet mut backend = RealIoUringBackend::new(\n    bind_addr,\n    Some(remote_addr),  // Connected mode\n    RealIoUringConfig::default()\n)?;\n\n// Synchronous send\nlet bytes_sent = backend.send_sync(b\"sensor data\")?;\n\n// Synchronous receive\nlet data = backend.recv_sync()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:216:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 216,
      "lineEnd": 243,
      "language": "rust",
      "code": "// Submit send (returns immediately)\nlet user_data = backend.submit_send(b\"data\")?;\n\n// Submit receive\nlet recv_ud = backend.submit_recv()?;\n\n// Submit to kernel (required for non-SQPOLL)\nbackend.submit()?;\n\n// Wait for completions\nbackend.submit_and_wait(1)?;\n\n// Process completions\nfor completion in backend.process_completions() {\n    match completion {\n        CompletionResult::SendComplete { bytes_sent, .. } => {\n            println!(\"Sent {} bytes\", bytes_sent);\n        }\n        CompletionResult::RecvComplete { data, .. } => {\n            println!(\"Received {} bytes\", data.len());\n        }\n        CompletionResult::Error { error, .. } => {\n            eprintln!(\"Error: {}\", error);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:249:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 249,
      "lineEnd": 259,
      "language": "rust",
      "code": "// Check if SQPOLL is available\nif is_sqpoll_available() {\n    let config = RealIoUringConfig::high_performance();\n    let backend = RealIoUringBackend::new(bind_addr, None, config)?;\n\n    // No submit() calls needed - kernel polls automatically\n    backend.submit_send(b\"data\")?;\n    // Kernel will send without syscall\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:275:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 275,
      "lineEnd": 297,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {CompressionConfig, CompressionAlgo, Compressor}\n\n// LZ4 for real-time\nlet config = CompressionConfig::lz4();\n\n// Zstd for better ratio\nlet config = CompressionConfig::zstd();\n\n// Zstd with custom level (1-19)\nlet config = CompressionConfig::zstd_level(6);\n\n// Auto-select based on size\nlet config = CompressionConfig::auto();\n\n// Custom configuration\nlet config = CompressionConfig {\n    algorithm: CompressionAlgo::Zstd,\n    min_size: 1024,      // Don't compress < 1KB\n    level: 3,            // Compression level\n    min_ratio: 0.8,      // Need 20% savings\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:301:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 301,
      "lineEnd": 320,
      "language": "rust",
      "code": "let compressor = Compressor::new(CompressionConfig::lz4());\n\n// Compress data\nlet compressed = compressor.compress(&large_data);\n\nif compressed.is_compressed {\n    println!(\"Compressed {} -> {} bytes\",\n        compressed.original_size,\n        compressed.data.len()\n    );\n}\n\n// Decompress\nlet decompressed = compressor.decompress(\n    &compressed.data,\n    compressed.algorithm,\n    compressed.original_size\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:324:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 324,
      "lineEnd": 337,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides CompressedPacket\n\n// Create packet from compressed data\nlet packet = CompressedPacket::from_compressed(compressed);\n\n// Send over network (serialize packet)\nlet bytes = bincode::serialize(&packet)?;\nsend_udp(&bytes)?;\n\n// Receive and decompress\nlet packet: CompressedPacket = bincode::deserialize(&received)?;\nlet data = packet.decompress(&compressor)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:343:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 343,
      "lineEnd": 354,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SmartTransport\n\n// Auto-selects based on:\n// - Local network → BatchUDP or io_uring\n// - WAN → QUIC\n// - Reliability needed → QUIC\n// - Low latency needed → io_uring\n\nlet transport = SmartTransport::new()?;\ntransport.send(addr, data).await?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:360:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 360,
      "lineEnd": 377,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides MessageBatcher\n\nlet mut batcher = MessageBatcher::new(\n    1024,  // Max batch size bytes\n    10,    // Max messages per batch\n    Duration::from_millis(5),  // Max wait time\n);\n\n// Add messages\nbatcher.add(message1)?;\nbatcher.add(message2)?;\n\n// Get batch when ready\nif let Some(batch) = batcher.get_batch() {\n    send_batch(&batch)?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:383:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 383,
      "lineEnd": 399,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {CongestionController, DropPolicy}\n\nlet controller = CongestionController::new(DropPolicy::DropOldest);\n\n// Check if we can send\nif controller.can_send() {\n    send(data)?;\n    controller.record_send(data.len());\n}\n\n// Record acknowledgment\ncontroller.record_ack();\n\n// Record timeout (congestion signal)\ncontroller.record_timeout();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:405:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 405,
      "lineEnd": 418,
      "language": "rust",
      "code": "// Local high-frequency sensors → io_uring\nif is_real_io_uring_available() && is_local {\n    use_io_uring();\n}\n\n// WAN or reliability needed → QUIC\nif is_wan || needs_reliability {\n    use_quic();\n}\n\n// General purpose → SmartTransport\nuse_smart_transport();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:422:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 422,
      "lineEnd": 430,
      "language": "rust",
      "code": "// Only compress if beneficial\nlet config = CompressionConfig {\n    min_size: 512,      // Skip small messages\n    min_ratio: 0.9,     // Need 10% savings\n    algorithm: CompressionAlgo::Auto,\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:434:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 434,
      "lineEnd": 441,
      "language": "rust",
      "code": "// For high-frequency small messages\nlet batcher = MessageBatcher::new(\n    MTU_SIZE - HEADERS,  // Fill MTU\n    100,                 // Up to 100 messages\n    Duration::from_millis(1),  // 1ms max latency\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:458:toml",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 458,
      "lineEnd": 461,
      "language": "toml",
      "code": "[dependencies]\nhorus_core = { version = \"0.1\", features = [\"zenoh-transport\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/network-backends:465:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 465,
      "lineEnd": 482,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {ZenohConfig, ZenohMode}\n\n// HORUS mode (default)\nlet config = ZenohConfig::new()\n    .with_namespace(\"robot1\");\n\n// ROS2 compatible mode\nlet config = ZenohConfig::ros2(0);  // Domain ID 0\n\n// Connect to cloud\nlet config = ZenohConfig::cloud(\"tcp/cloud.example.com:7447\");\n\n// Multi-robot mesh\nlet config = ZenohConfig::mesh(\"fleet1\")\n    .connect_to(\"tcp/192.168.1.10:7447\")\n    .connect_to(\"tcp/192.168.1.11:7447\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:486:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 486,
      "lineEnd": 508,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {ZenohQos, Reliability, HistoryPolicy, Durability}\n\n// Sensor data: best-effort, small history, deadline/lifespan constraints\nlet sensor_qos = ZenohQos::sensor_data();\n\n// Parameters: reliable, transient-local durability\nlet param_qos = ZenohQos::parameters();\n\n// Services: reliable, keep all messages\nlet service_qos = ZenohQos::services();\n\n// Actions: reliable, bounded history\nlet action_qos = ZenohQos::actions();\n\n// Custom QoS\nlet custom_qos = ZenohQos::default()\n    .with_reliability(Reliability::Reliable)\n    .with_history(HistoryPolicy::KeepLast(10))\n    .with_durability(Durability::TransientLocal)\n    .with_deadline(Duration::from_millis(100))\n    .with_lifespan(Duration::from_secs(5));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:514:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 514,
      "lineEnd": 529,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Ros2ServiceConfig, ServiceRegistry, TriggerRequest, TriggerResponse}\n\n// Create service client\nlet config = Ros2ServiceConfig::new(\"/robot\", \"trigger_action\");\nlet client = Ros2ServiceClient::new(zenoh_session, config)?;\n\n// Call service\nlet request = TriggerRequest::default();\nlet response = client.call(request, Duration::from_secs(5)).await?;\n\n// Create service server\nlet server = Ros2ServiceServer::new(zenoh_session, config, |req| {\n    TriggerResponse { success: true, message: \"Done\".into() }\n})?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:535:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 535,
      "lineEnd": 564,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Ros2ActionClient, Ros2ActionServer, Ros2ActionConfig, GoalStatus, SendGoalRequest}\n\n// Create action client\nlet config = Ros2ActionConfig::new(\"/robot\", \"navigate_to_pose\");\nlet client = Ros2ActionClient::new(zenoh_session, config)?;\n\n// Send goal\nlet goal = NavigateGoal { x: 1.0, y: 2.0, theta: 0.0 };\nlet handle = client.send_goal(goal).await?;\n\n// Monitor feedback\nwhile let Some(feedback) = handle.get_feedback().await {\n    println!(\"Progress: {:.1}%\", feedback.percent_complete);\n}\n\n// Get result\nlet result = handle.get_result().await?;\nprintln!(\"Navigation complete: {:?}\", result);\n\n// Create action server\nlet server = Ros2ActionServer::new(zenoh_session, config,\n    |goal| async { Ok(GoalStatus::Accepted) },  // Goal callback\n    |_| async { Ok(true) },                      // Cancel callback\n    |goal| async {                               // Execute callback\n        // Do navigation...\n        NavigateResult { success: true }\n    }\n)?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/network-backends:570:rust",
      "file": "content/docs/advanced/network-backends.mdx",
      "lineStart": 570,
      "lineEnd": 602,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {LocalParameterStore, Parameter, ParameterValue, ParameterDescriptor, ParameterType}\n\n// Create local parameter store\nlet store = LocalParameterStore::new(\"/robot_controller\");\n\n// Declare parameters with descriptors\nstore.declare_parameter(\n    \"max_velocity\",\n    ParameterValue::from_double(1.5),\n    Some(ParameterDescriptor::new(\"max_velocity\", ParameterType::Double)\n        .with_description(\"Maximum velocity in m/s\")\n        .with_float_range(0.0, 10.0, 0.1))\n)?;\n\n// Set parameter with validation\nlet result = store.set_parameter(Parameter::double(\"max_velocity\", 2.0))?;\nif !result.successful {\n    println!(\"Failed: {}\", result.reason);\n}\n\n// Register change callback\nstore.add_change_callback(|param, event_type| {\n    println!(\"Parameter {} changed: {:?}\", param.name, event_type);\n});\n\n// Create parameter client for ROS2 interop\nlet client = Ros2ParameterClient::new(zenoh_session, \"/remote_node\")?;\nlet params = client.get_parameters(&[\"max_velocity\", \"use_sim_time\"]).await?;\n\n// Create parameter server for ROS2 nodes to query\nlet server = Ros2ParameterServer::new(zenoh_session, store)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:26:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 26,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Default configuration\nlet config = RecordingConfig::default();\n// Stores in: ~/.horus/recordings/<session_name>/\n\n// Custom configuration\nlet config = RecordingConfig {\n    session_name: \"sensor_test_001\".to_string(),\n    base_dir: PathBuf::from(\"/data/recordings\"),\n    max_size: 50 * 1024 * 1024,  // 50MB per node\n    compress: true,               // Use gzip compression\n    interval: 1,                  // Record every tick\n    include_nodes: vec![],        // Empty = all nodes\n    exclude_nodes: vec![\"DebugNode\".to_string()],\n};\n\n// Named session (shorthand)\nlet config = RecordingConfig::with_name(\"lidar_calibration\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:64:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 64,
      "lineEnd": 97,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a recorder for a specific node\nlet config = RecordingConfig::with_name(\"motor_debug\");\nlet mut recorder = NodeRecorder::new(\"MotorController\", \"motor_001\", config);\n\n// In node's tick function:\nfn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n    // Start recording this tick\n    self.recorder.begin_tick(self.tick_count);\n\n    // Record inputs as they arrive\n    if let Some(cmd) = self.velocity_sub.try_recv(&mut ctx) {\n        self.recorder.record_input(\"velocity_cmd\", serialize(&cmd));\n        self.process_command(cmd);\n    }\n\n    // Record outputs as they're sent\n    let motor_state = self.get_motor_state();\n    self.recorder.record_output(\"motor_state\", serialize(&motor_state));\n    self.state_pub.send(motor_state, &mut ctx).ok();\n\n    // Optionally record internal state\n    self.recorder.record_state(serialize(&self.internal_state));\n\n    // Finish recording with execution duration\n    self.recorder.end_tick(duration_ns);\n}\n\n// Save recording when done\nlet path = recorder.finish()?;\nprintln!(\"Recording saved to: {:?}\", path);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:103:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 103,
      "lineEnd": 109,
      "language": "rust",
      "code": "let snapshot = NodeTickSnapshot::new(tick)\n    .with_input(\"sensor\", sensor_data.to_bytes())\n    .with_output(\"motor\", motor_cmd.to_bytes())\n    .with_state(node_state.to_bytes())\n    .with_duration(1500); // nanoseconds",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:126:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 126,
      "lineEnd": 151,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Load and replay a recording\nlet mut replayer = NodeReplayer::load(&PathBuf::from(\n    \"~/.horus/recordings/sensor_test/MotorController@motor_001.horus\"\n))?;\n\n// Iterate through recorded ticks\nwhile !replayer.is_finished() {\n    if let Some(snapshot) = replayer.current_snapshot() {\n        println!(\"Tick {}: {} inputs, {} outputs\",\n            snapshot.tick,\n            snapshot.inputs.len(),\n            snapshot.outputs.len());\n\n        // Get specific output\n        if let Some(motor_data) = replayer.get_output(\"motor_state\") {\n            let state: MotorState = deserialize(motor_data)?;\n            println!(\"  Motor position: {}\", state.position);\n        }\n    }\n\n    replayer.advance();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:155:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 155,
      "lineEnd": 177,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Full replay - replay entire system from a scheduler recording\nlet mode = ReplayMode::Full {\n    scheduler_path: PathBuf::from(\"~/.horus/recordings/mission/scheduler.horus\"),\n};\n\n// Mixed replay - some nodes from recording, others live\nlet mode = ReplayMode::Mixed {\n    replay_nodes: HashMap::from([\n        (\"Lidar\".to_string(), PathBuf::from(\"recordings/Lidar@001.horus\")),\n        (\"Camera\".to_string(), PathBuf::from(\"recordings/Camera@002.horus\")),\n    ]),\n};\n\n// Time travel - replay a specific tick range\nlet mode = ReplayMode::TimeTravel {\n    scheduler_path: PathBuf::from(\"recordings/scheduler.horus\"),\n    start_tick: 1000,\n    end_tick: Some(2000),  // None = replay to end\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:181:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 181,
      "lineEnd": 192,
      "language": "rust",
      "code": "// Jump to specific tick\nreplayer.seek(1500);\n\n// Reset to beginning\nreplayer.reset();\n\n// Get position information\nprintln!(\"Current tick: {}\", replayer.current_tick());\nprintln!(\"Total ticks: {}\", replayer.total_ticks());\nprintln!(\"Finished: {}\", replayer.is_finished());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:198:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 198,
      "lineEnd": 232,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Load a recording with debugger\nlet mut debugger = ReplayDebugger::load(&recording_path)?;\n\n// Add breakpoints\nlet bp1 = debugger.add_breakpoint_at_tick(500);\nlet bp2 = debugger.add_breakpoint(BreakpointCondition::TopicHasData(\"error\".to_string()));\nlet bp3 = debugger.add_named_breakpoint(\"slow_tick\",\n    BreakpointCondition::OnSlowExecution { threshold_ns: 10_000_000 });\n\n// Add watch expressions\ndebugger.add_watch(WatchExpression::output(\"motor_pos\", \"Motor Position\", \"motor_state\"));\ndebugger.add_watch(WatchExpression::input(\"cmd_vel\", \"Command Velocity\", \"velocity_cmd\")\n    .with_range(0, 8));  // Watch specific byte range\n\n// Run until breakpoint\ndebugger.continue_execution();\n\n// Check state at breakpoint\nif debugger.state() == DebuggerState::Paused {\n    let values = debugger.evaluate_watches();\n    for val in values {\n        println!(\"{}: {}\", val.expression_id, val.display_value);\n    }\n}\n\n// Step controls\ndebugger.step_forward();\ndebugger.step_backward();  // Time travel!\ndebugger.seek(1234);\ndebugger.reset();\ndebugger.stop();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:236:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 236,
      "lineEnd": 257,
      "language": "rust",
      "code": "// Break at specific tick\nBreakpointCondition::AtTick(500)\n\n// Break when topic has data\nBreakpointCondition::TopicHasData(\"error_report\".to_string())\n\n// Break when output matches pattern\nBreakpointCondition::OutputMatches {\n    topic: \"status\".to_string(),\n    pattern: vec![0xFF, 0x00],  // Error code\n}\n\n// Break on any error\nBreakpointCondition::OnError\n\n// Break after N ticks from current position\nBreakpointCondition::AfterTicks(100)\n\n// Break on custom expression\nBreakpointCondition::Expression(WatchExpression::output(\"id\", \"name\", \"topic\"))",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:261:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 261,
      "lineEnd": 277,
      "language": "rust",
      "code": "// Watch output topic\nlet watch = WatchExpression::output(\"motor_pos\", \"Motor Position\", \"motor_state\");\n\n// Watch input topic\nlet watch = WatchExpression::input(\"cmd\", \"Command\", \"velocity_cmd\");\n\n// Watch specific bytes (e.g., first 4 bytes as f32)\nlet watch = WatchExpression::output(\"temp\", \"Temperature\", \"sensors\")\n    .with_range(8, 4);  // Offset 8, length 4\n\n// Evaluate watch\nif let Some(value) = watch.evaluate(&snapshot) {\n    println!(\"Value: {}\", value.display_value);\n    println!(\"Raw bytes: {:02x?}\", value.raw_bytes);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:283:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 283,
      "lineEnd": 304,
      "language": "rust",
      "code": "for event in debugger.recent_events(10) {\n    match event {\n        DebugEvent::BreakpointHit { breakpoint_id, tick } => {\n            println!(\"Hit breakpoint {} at tick {}\", breakpoint_id, tick);\n        }\n        DebugEvent::WatchValueChanged { watch_id, old_value, new_value } => {\n            println!(\"Watch {} changed: {} -> {}\",\n                watch_id,\n                old_value.map(|v| v.display_value).unwrap_or_default(),\n                new_value.display_value);\n        }\n        DebugEvent::PositionChanged { tick, .. } => {\n            println!(\"Now at tick {}\", tick);\n        }\n        DebugEvent::Finished { total_ticks } => {\n            println!(\"Replay finished after {} ticks\", total_ticks);\n        }\n        _ => {}\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:310:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 310,
      "lineEnd": 340,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Auto-record on errors\nlet config = AutoRecordConfig::on_error();\n\n// Auto-record on slow execution (>10ms)\nlet config = AutoRecordConfig::on_slow_execution(10);\n\n// Auto-record when specific topic is active\nlet config = AutoRecordConfig::on_topic(\"collision_alert\")\n    .with_pre_trigger(100)   // Keep 100 ticks before trigger\n    .with_post_trigger(50);  // Record 50 ticks after\n\n// Create auto-recorder\nlet mut auto_recorder = AutoRecorder::new(\"MotorController\", \"motor_001\", config);\n\n// In tick function\nfn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n    // ... normal processing ...\n\n    // Create snapshot\n    let snapshot = NodeTickSnapshot::new(self.tick_count)\n        .with_output(\"motor_state\", serialize(&state));\n\n    // Process tick (may trigger recording)\n    if let Some(path) = self.auto_recorder.process_tick(snapshot) {\n        log::info!(\"Auto-recording saved: {:?}\", path);\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:344:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 344,
      "lineEnd": 365,
      "language": "rust",
      "code": "// Trigger on error patterns in topic names\nAutoRecordTrigger::OnError {\n    patterns: vec![\"error\".to_string(), \"fault\".to_string()],\n}\n\n// Trigger on specific condition\nAutoRecordTrigger::OnCondition {\n    topic: \"sensor_status\".to_string(),\n    condition: TriggerCondition::DataEquals(vec![0xFF]),  // Error code\n}\n\n// Trigger on topic activity\nAutoRecordTrigger::OnTopicActivity {\n    topic: \"emergency_stop\".to_string(),\n}\n\n// Trigger on slow execution\nAutoRecordTrigger::OnSlowExecution {\n    threshold_ns: 10_000_000,  // 10ms\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:371:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 371,
      "lineEnd": 392,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet manager = RecordingManager::new();\n\n// List all sessions\nfor session in manager.list_sessions()? {\n    println!(\"Session: {}\", session);\n\n    // List recordings in session\n    for path in manager.get_session_recordings(&session)? {\n        println!(\"  Recording: {:?}\", path);\n    }\n}\n\n// Get total storage used\nlet total_bytes = manager.total_size()?;\nprintln!(\"Total recording storage: {} MB\", total_bytes / 1024 / 1024);\n\n// Delete old session\nmanager.delete_session(\"old_session_name\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:398:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 398,
      "lineEnd": 420,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet recording1 = NodeRecording::load(&path1)?;\nlet recording2 = NodeRecording::load(&path2)?;\n\nlet diffs = diff_recordings(&recording1, &recording2);\n\nfor diff in diffs {\n    match diff {\n        RecordingDiff::OutputDifference { tick, topic, .. } => {\n            println!(\"Tick {}: Output '{}' differs\", tick, topic);\n        }\n        RecordingDiff::MissingOutput { tick, topic, in_recording } => {\n            println!(\"Tick {}: Output '{}' missing in recording {}\",\n                tick, topic, in_recording);\n        }\n        RecordingDiff::MissingTick { tick, in_recording } => {\n            println!(\"Tick {} missing in recording {}\", tick, in_recording);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:426:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 426,
      "lineEnd": 438,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Save with compression\nsave_recording_compressed(&recording, &path, true)?;\n\n// Load (auto-detects compression)\nlet recording = load_recording_compressed(&path)?;\n\n// Manual compression utilities\nlet compressed = compress_data(&data, 6)?;  // Level 0-9\nlet decompressed = decompress_data(&compressed)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:444:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 444,
      "lineEnd": 456,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Save session state\nlet mut session = DebugSessionState::new(recording_path, \"debug_session_1\");\nsession.update_from_debugger(&debugger);\nsession.save(&PathBuf::from(\"~/.horus/sessions/my_debug.json\"))?;\n\n// Later, restore session\nlet session = DebugSessionState::load(&path)?;\nlet mut debugger = session.create_debugger()?;\n// Breakpoints, watches, and position are restored",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:460:rust",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 460,
      "lineEnd": 495,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n/// Test that motor controller produces same outputs as recorded baseline\nfn test_motor_regression() {\n    // Load baseline recording\n    let baseline = NodeRecording::load(&PathBuf::from(\n        \"testdata/motor_baseline.horus\"\n    )).unwrap();\n\n    // Run the same inputs through current implementation\n    let mut motor = MotorController::new();\n    let mut current = NodeRecording::new(\"MotorController\", \"test\", \"regression_test\");\n\n    for snapshot in baseline.snapshots.iter() {\n        // Feed recorded inputs\n        for (topic, data) in &snapshot.inputs {\n            motor.inject_input(topic, data.clone());\n        }\n\n        // Run tick\n        motor.tick(None);\n\n        // Capture outputs\n        let mut new_snapshot = NodeTickSnapshot::new(snapshot.tick);\n        for (topic, data) in motor.get_outputs() {\n            new_snapshot.outputs.insert(topic.clone(), data.clone());\n        }\n        current.add_snapshot(new_snapshot);\n    }\n\n    // Compare\n    let diffs = diff_recordings(&baseline, &current);\n    assert!(diffs.is_empty(), \"Found {} differences from baseline\", diffs.len());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/record-replay:501:bash",
      "file": "content/docs/advanced/record-replay.mdx",
      "lineStart": 501,
      "lineEnd": 519,
      "language": "bash",
      "code": "# Start recording\nhorus record --session motor_test --nodes MotorController,Lidar\n\n# List recordings\nhorus record --list\n\n# Replay a recording\nhorus replay ~/.horus/recordings/motor_test/\n\n# Replay with time travel to specific tick\nhorus replay --seek 1000 ~/.horus/recordings/motor_test/\n\n# Compare two recordings\nhorus diff recording1.horus recording2.horus\n\n# Clean old recordings\nhorus record --clean --older-than 30d",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/redundancy:26:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 26,
      "lineEnd": 71,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create checkpoint manager with 5-second interval\nlet mut checkpoint_mgr = CheckpointManager::new(\n    PathBuf::from(\"/var/lib/horus/checkpoints\"),\n    5000  // 5000ms interval\n);\n\n// Configure retention\ncheckpoint_mgr.set_max_checkpoints(10);\n\n// In scheduler loop\nif checkpoint_mgr.should_checkpoint() {\n    let metadata = CheckpointMetadata {\n        scheduler_name: \"robot_controller\".to_string(),\n        total_ticks: 100000,\n        learning_complete: true,\n        node_count: 12,\n        uptime_secs: 3600.0,\n    };\n\n    if let Some(checkpoint) = checkpoint_mgr.create_checkpoint(metadata) {\n        // Add node states to checkpoint\n        let mut checkpoint = checkpoint;\n        for (name, state) in &node_states {\n            checkpoint.node_states.insert(\n                name.clone(),\n                NodeCheckpoint {\n                    name: name.clone(),\n                    tick_count: state.ticks,\n                    last_tick_us: state.last_duration_us,\n                    error_count: state.errors,\n                    custom_state: state.serialize(),\n                },\n            );\n        }\n\n        // Save to disk\n        match checkpoint_mgr.save_checkpoint(&checkpoint) {\n            Ok(path) => log::info!(\"Checkpoint saved: {:?}\", path),\n            Err(e) => log::error!(\"Checkpoint failed: {}\", e),\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:75:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 75,
      "lineEnd": 101,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Recover from latest checkpoint on startup\nlet checkpoint_mgr = CheckpointManager::new(\n    PathBuf::from(\"/var/lib/horus/checkpoints\"),\n    5000\n);\n\nif let Ok(Some(checkpoint)) = checkpoint_mgr.load_latest_checkpoint() {\n    log::info!(\"Recovering from checkpoint {}\", checkpoint.id);\n    log::info!(\"  Timestamp: {}\", checkpoint.timestamp);\n    log::info!(\"  Ticks: {}\", checkpoint.metadata.total_ticks);\n    log::info!(\"  Nodes: {}\", checkpoint.metadata.node_count);\n\n    // Restore node states\n    for (name, node_state) in &checkpoint.node_states {\n        log::info!(\"  Restoring node: {} (ticks: {})\",\n            node_state.name, node_state.tick_count);\n\n        if let Some(state_data) = &node_state.custom_state {\n            // Deserialize and apply custom state\n            restore_node_state(name, state_data);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:105:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 105,
      "lineEnd": 123,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet checkpoint_mgr = CheckpointManager::default();\n\n// List all available checkpoints\nfor (id, path) in checkpoint_mgr.list_checkpoints() {\n    println!(\"Checkpoint {}: {:?}\", id, path);\n\n    // Load specific checkpoint\n    if let Ok(Some(cp)) = checkpoint_mgr.load_checkpoint(&path) {\n        println!(\"  Created: {} seconds ago\",\n            std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs() - cp.timestamp);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:162:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 162,
      "lineEnd": 173,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create TMR manager (3 replicas, majority voting)\nlet mut rm = RedundancyManager::tmr();\n\n// Or dual redundancy (2 replicas, unanimous)\nlet rm_dual = RedundancyManager::dual();\n\n// Or custom configuration\nlet rm_custom = RedundancyManager::new(5, VotingStrategy::Majority);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:177:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 177,
      "lineEnd": 213,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut rm = RedundancyManager::tmr();\n\n// Execute a safety-critical computation redundantly\nlet result = rm.execute_redundant(|replica_id| {\n    // Each replica computes the same result\n    // Slight differences indicate hardware faults\n    let sensor_reading = read_sensor_with_replica(replica_id);\n\n    Some(sensor_reading.round() as i32)\n});\n\nmatch result {\n    VoteResult::Consensus(value) => {\n        // All replicas agreed (or majority voted)\n        log::info!(\"Consensus reached: {}\", value);\n        apply_value(value);\n    }\n    VoteResult::Disagreement { values, reason } => {\n        // Replicas produced different results\n        log::error!(\"Voting disagreement: {} - values: {:?}\", reason, values);\n        enter_safe_mode();\n    }\n    VoteResult::PartialFailure { successful, failed_count } => {\n        // Some replicas failed but consensus possible\n        log::warn!(\"{} replicas failed, using survivors: {:?}\",\n            failed_count, successful);\n    }\n    VoteResult::TotalFailure => {\n        // All replicas failed\n        log::error!(\"Total failure - all replicas failed!\");\n        emergency_stop();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:217:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 217,
      "lineEnd": 234,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Majority voting (2 of 3 must agree) - for TMR\nlet rm_majority = RedundancyManager::new(3, VotingStrategy::Majority);\n\n// Unanimous voting (all must agree) - strictest\nlet rm_unanimous = RedundancyManager::new(3, VotingStrategy::Unanimous);\n\n// Any (first successful result) - for availability, not correctness\nlet rm_any = RedundancyManager::new(3, VotingStrategy::Any);\n\n// First success (use first result that doesn't fail)\nlet rm_first = RedundancyManager::new(3, VotingStrategy::FirstSuccess);\n\n// Median (for numeric values) - tolerates outliers\nlet rm_median = RedundancyManager::new(5, VotingStrategy::Median);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:248:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 248,
      "lineEnd": 269,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create custom voter\nlet voter: Voter<i32> = Voter::majority(2);  // Need at least 2 successful\n\nlet mut redundant = RedundantValue::new(3);\n\n// Record results from replicas\nredundant.record(0, 42, Duration::from_micros(100));\nredundant.record(1, 42, Duration::from_micros(110));\nredundant.record(2, 99, Duration::from_micros(105));  // Faulty replica!\n\n// Vote on results\nlet result = voter.vote(&redundant);\nmatch result {\n    VoteResult::Consensus(v) => {\n        assert_eq!(v, 42);  // Majority wins\n    }\n    _ => panic!(\"Expected consensus\"),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:275:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 275,
      "lineEnd": 295,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet voter: Voter<f64> = Voter::majority(3);\nlet mut redundant = RedundantValue::new(5);\n\n// Record sensor readings with potential outliers\nredundant.record(0, 25.0, Duration::from_micros(100));\nredundant.record(1, 25.1, Duration::from_micros(110));\nredundant.record(2, 99999.0, Duration::from_micros(105));  // Outlier!\nredundant.record(3, 25.2, Duration::from_micros(108));\nredundant.record(4, 24.9, Duration::from_micros(112));\n\n// Median vote ignores outliers\nmatch voter.median_vote(&redundant) {\n    VoteResult::Consensus(v) => {\n        println!(\"Median value: {}\", v);  // 25.1 (ignores outlier)\n    }\n    _ => {}\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:299:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 299,
      "lineEnd": 322,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut rm = RedundancyManager::tmr();\n\n// Execute many redundant operations...\nfor _ in 0..1000 {\n    rm.execute_redundant(|_| Some(compute_value()));\n}\n\n// Check fault statistics\nlet stats = rm.stats();\nprintln!(\"Redundancy Statistics:\");\nprintln!(\"  Total votes: {}\", stats.total_votes);\nprintln!(\"  Consensus: {} ({:.1}%)\",\n    stats.consensus_count,\n    100.0 * stats.consensus_count as f64 / stats.total_votes as f64);\nprintln!(\"  Disagreements: {}\", stats.disagreement_count);\nprintln!(\"  Partial failures: {}\", stats.partial_failure_count);\nprintln!(\"  Total failures: {}\", stats.total_failure_count);\n\n// Reset statistics\nrm.reset_stats();",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:338:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 338,
      "lineEnd": 353,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet config = SchedulerConfig {\n    fault: FaultConfig {\n        circuit_breaker_enabled: true,\n        max_failures: 5,\n        recovery_threshold: 3,\n        circuit_timeout_ms: 30000,\n        auto_restart: true,\n        redundancy_factor: 3,  // TMR\n        checkpoint_interval_ms: 5000,  // Every 5 seconds\n    },\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:371:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 371,
      "lineEnd": 386,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nimpl RtNode for SafetyController {\n    fn name(&self) -> &'static str { \"SafetyController\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Primary implementation\n    }\n\n    fn fallback_node(&self) -> Option<Box<dyn RtNode>> {\n        // Provide fallback implementation for redundancy\n        Some(Box::new(SafetyControllerBackup::new()))\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:390:rust",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 390,
      "lineEnd": 514,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::path::PathBuf;\n\nstruct FaultTolerantController {\n    checkpoint_mgr: CheckpointManager,\n    redundancy_mgr: RedundancyManager,\n    sensor_sub: Hub<f64>,\n    motor_pub: Hub<MotorCommand>,\n    tick_count: u64,\n    last_safe_command: MotorCommand,\n}\n\nimpl Node for FaultTolerantController {\n    fn name(&self) -> &'static str { \"FaultTolerantController\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.tick_count += 1;\n\n        // Read sensor with TMR\n        let sensor_result = self.redundancy_mgr.execute_redundant(|replica| {\n            if let Some(val) = self.sensor_sub.try_recv(&mut ctx) {\n                Some((val * 1000.0).round() as i64)  // Convert to int for voting\n            } else {\n                None\n            }\n        });\n\n        let command = match sensor_result {\n            VoteResult::Consensus(value) => {\n                // Compute motor command from consensus sensor value\n                let sensor_value = value as f64 / 1000.0;\n                let cmd = self.compute_command(sensor_value);\n                self.last_safe_command = cmd.clone();\n                cmd\n            }\n            VoteResult::Disagreement { .. } => {\n                log::warn!(\"Sensor disagreement, using last safe command\");\n                self.last_safe_command.clone()\n            }\n            VoteResult::PartialFailure { .. } |\n            VoteResult::TotalFailure => {\n                log::error!(\"Sensor failure, emergency safe state\");\n                MotorCommand::safe_stop()\n            }\n        };\n\n        self.motor_pub.send(command, &mut ctx).ok();\n\n        // Periodic checkpointing\n        if self.checkpoint_mgr.should_checkpoint() {\n            self.save_checkpoint();\n        }\n    }\n\n    fn init(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Attempt recovery from checkpoint\n        if let Ok(Some(checkpoint)) = self.checkpoint_mgr.load_latest_checkpoint() {\n            log::info!(\"Recovering from checkpoint {}\", checkpoint.id);\n            self.tick_count = checkpoint.metadata.total_ticks;\n\n            if let Some(state) = checkpoint.node_states.get(\"FaultTolerantController\") {\n                if let Some(data) = &state.custom_state {\n                    self.restore_state(data);\n                }\n            }\n        }\n    }\n}\n\nimpl FaultTolerantController {\n    fn new() -> Self {\n        Self {\n            checkpoint_mgr: CheckpointManager::new(\n                PathBuf::from(\"/var/lib/horus/motor_checkpoints\"),\n                5000,  // 5 second interval\n            ),\n            redundancy_mgr: RedundancyManager::tmr(),\n            sensor_sub: Hub::new(),\n            motor_pub: Hub::new(),\n            tick_count: 0,\n            last_safe_command: MotorCommand::safe_stop(),\n        }\n    }\n\n    fn compute_command(&self, sensor_value: f64) -> MotorCommand {\n        // PID control logic...\n        MotorCommand { velocity: sensor_value * 0.5, torque: 0.0 }\n    }\n\n    fn save_checkpoint(&mut self) {\n        let metadata = CheckpointMetadata {\n            scheduler_name: \"motor_controller\".to_string(),\n            total_ticks: self.tick_count,\n            learning_complete: true,\n            node_count: 1,\n            uptime_secs: self.tick_count as f64 * 0.01,\n        };\n\n        if let Some(mut checkpoint) = self.checkpoint_mgr.create_checkpoint(metadata) {\n            checkpoint.node_states.insert(\n                \"FaultTolerantController\".to_string(),\n                NodeCheckpoint {\n                    name: \"FaultTolerantController\".to_string(),\n                    tick_count: self.tick_count,\n                    last_tick_us: 0,\n                    error_count: self.redundancy_mgr.stats().total_failure_count,\n                    custom_state: Some(self.serialize_state()),\n                },\n            );\n\n            self.checkpoint_mgr.save_checkpoint(&checkpoint).ok();\n        }\n    }\n\n    fn serialize_state(&self) -> Vec<u8> {\n        // Serialize internal state...\n        vec![]\n    }\n\n    fn restore_state(&mut self, _data: &[u8]) {\n        // Restore internal state...\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/advanced/redundancy:520:bash",
      "file": "content/docs/advanced/redundancy.mdx",
      "lineStart": 520,
      "lineEnd": 532,
      "language": "bash",
      "code": "# Enable checkpointing (5 second interval)\nhorus run robot.yaml --checkpoint-interval 5000\n\n# List available checkpoints\nhorus checkpoint --list\n\n# Restore from specific checkpoint\nhorus run robot.yaml --restore-checkpoint /path/to/checkpoint.bin\n\n# Clean old checkpoints\nhorus checkpoint --clean --older-than 7d",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:24:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 24,
      "lineEnd": 34,
      "language": "rust",
      "code": "let config = RtConfig::hard_realtime(Some(&[2, 3]));\nmatch config.apply() {\n    Ok(RtApplyResult::FullSuccess) => println!(\"Full RT enabled (Linux)\"),\n    Ok(RtApplyResult::Degraded(reasons)) => {\n        // On macOS/Windows: continues running without RT\n        println!(\"Running in degraded mode: {:?}\", reasons);\n    }\n    Err(e) => eprintln!(\"Error: {}\", e),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:50:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 50,
      "lineEnd": 59,
      "language": "rust",
      "code": "use horus::prelude::*;  // Provides RtConfig, RtScheduler\n\n// Apply hard real-time configuration\nlet config = RtConfig::hard_realtime(Some(&[2, 3]));  // Pin to cores 2, 3\nconfig.apply()?;\n\n// Now all HORUS operations run with RT guarantees\nlet link: Link<CmdVel> = Link::producer(\"cmd_vel\")?;  // <100ns latency",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:67:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 67,
      "lineEnd": 71,
      "language": "rust",
      "code": "// Highest priority, locked memory, pinned to isolated cores\nlet config = RtConfig::hard_realtime(Some(&[2, 3]));\nconfig.apply()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:83:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 83,
      "lineEnd": 86,
      "language": "rust",
      "code": "let config = RtConfig::soft_realtime();\nconfig.apply()?;  // Works without CAP_SYS_NICE",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:97:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 97,
      "lineEnd": 100,
      "language": "rust",
      "code": "let config = RtConfig::normal();\nconfig.apply()?;  // No RT modifications",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:106:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 106,
      "lineEnd": 118,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet config = RtConfig::new()\n    .memory_locked(true)           // mlockall()\n    .prefault_stack(1024 * 1024)   // 1MB stack prefault\n    .scheduler(RtScheduler::Fifo)  // SCHED_FIFO\n    .priority(90)                  // High priority (1-99)\n    .cpu_affinity(&[4, 5, 6, 7])   // Pin to cores 4-7\n    .build();\n\nconfig.apply()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:132:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 132,
      "lineEnd": 138,
      "language": "rust",
      "code": "pub enum RtScheduler {\n    Normal,  // Default Linux scheduler (SCHED_OTHER)\n    Fifo,    // SCHED_FIFO - First-in-first-out RT\n    RR,      // SCHED_RR - Round-robin RT\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:159:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 159,
      "lineEnd": 165,
      "language": "bash",
      "code": "# For development - grant capabilities to your binary\nsudo setcap 'cap_sys_nice=ep cap_ipc_lock=ep' ./target/release/my_robot\n\n# For production - run as RT user\nsudo usermod -a -G realtime $USER",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:169:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 169,
      "lineEnd": 173,
      "language": "bash",
      "code": "# In /etc/security/limits.conf\nyour_user  soft  memlock  unlimited\nyour_user  hard  memlock  unlimited",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:181:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 181,
      "lineEnd": 187,
      "language": "bash",
      "code": "# Install RT kernel\nsudo apt install linux-image-rt-amd64\n\n# Reboot and select RT kernel in GRUB\nsudo reboot",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:191:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 191,
      "lineEnd": 194,
      "language": "bash",
      "code": "uname -a | grep -i rt\n# Should show: PREEMPT_RT",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:198:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 198,
      "lineEnd": 204,
      "language": "bash",
      "code": "# Isolate CPU cores for RT (add to kernel cmdline)\nisolcpus=2,3 nohz_full=2,3 rcu_nocbs=2,3\n\n# Disable CPU frequency scaling\necho performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:210:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 210,
      "lineEnd": 239,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::time::Duration;\n\n// 1. Configure system for RT\nRtConfig::hard_realtime(Some(&[2, 3])).apply()?;\n\n// 2. Create scheduler with safety-critical config\nlet mut scheduler = Scheduler::new();\nscheduler.set_config(SchedulerConfig::safety_critical());\n\n// 3. Add RT nodes with timing constraints\nstruct MotorControl { /* ... */ }\n\nimpl RtNode for MotorControl {\n    fn wcet_budget(&self) -> Duration { Duration::from_micros(50) }\n    fn deadline(&self) -> Duration { Duration::from_micros(500) }\n    fn rt_priority(&self) -> RtPriority { RtPriority::Critical }\n    fn rt_class(&self) -> RtClass { RtClass::Hard }\n}\n\nscheduler.add_rt(\n    Box::new(MotorControl::new()),\n    0,  // Priority 0 (highest)\n    Duration::from_micros(50),   // WCET budget\n    Duration::from_micros(500),  // Deadline (2kHz)\n);\n\nscheduler.run();",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:256:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 256,
      "lineEnd": 273,
      "language": "rust",
      "code": "let config = RtConfig::hard_realtime(Some(&[2, 3]));\nmatch config.apply() {\n    Ok(report) => {\n        if report.memory_locked {\n            println!(\"Memory locked successfully\");\n        } else {\n            println!(\"Memory locking unavailable (needs CAP_IPC_LOCK)\");\n        }\n        if report.scheduler_set {\n            println!(\"RT scheduler enabled\");\n        } else {\n            println!(\"RT scheduler unavailable (needs CAP_SYS_NICE)\");\n        }\n    }\n    Err(e) => eprintln!(\"Critical failure: {}\", e),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:281:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 281,
      "lineEnd": 287,
      "language": "rust",
      "code": "let status = RtConfig::current()?;\nprintln!(\"Memory locked: {}\", status.memory_locked);\nprintln!(\"Scheduler: {:?}\", status.scheduler);\nprintln!(\"Priority: {}\", status.priority);\nprintln!(\"CPU affinity: {:?}\", status.cpu_affinity);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:291:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 291,
      "lineEnd": 298,
      "language": "rust",
      "code": "// In your node's tick()\nif let Some(ctx) = &ctx {\n    if ctx.metrics.max_tick_duration_ms > 1.0 {\n        ctx.log_warning(\"RT constraint violated!\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/rt-config:304:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 304,
      "lineEnd": 309,
      "language": "bash",
      "code": "# Check memlock limit\nulimit -l\n# If not unlimited, increase in /etc/security/limits.conf\n# Or grant CAP_IPC_LOCK capability",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:313:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 313,
      "lineEnd": 316,
      "language": "bash",
      "code": "# Grant CAP_SYS_NICE\nsudo setcap 'cap_sys_nice=ep' ./target/release/my_robot",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:327:bash",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 327,
      "lineEnd": 331,
      "language": "bash",
      "code": "# Verify isolated cores\ncat /sys/devices/system/cpu/isolated\n# Should show your isolated cores: 2-3",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/rt-config:344:rust",
      "file": "content/docs/advanced/rt-config.mdx",
      "lineStart": 344,
      "lineEnd": 375,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    // Configure system for hard real-time\n    let rt_config = RtConfig::new()\n        .memory_locked(true)\n        .prefault_stack(512 * 1024)  // 512KB\n        .scheduler(RtScheduler::Fifo)\n        .priority(80)\n        .cpu_affinity(&[2, 3])  // Isolated cores\n        .build();\n\n    let report = rt_config.apply()?;\n    println!(\"RT Config applied: memory_locked={}, scheduler_set={}\",\n             report.memory_locked, report.scheduler_set);\n\n    // Create RT communication channel\n    let producer: Link<CmdVel> = Link::producer(\"motor_cmd\")?;\n    let consumer: Link<CmdVel> = Link::consumer(\"motor_cmd\")?;\n\n    // Now IPC runs with <100ns latency and minimal jitter\n    loop {\n        let cmd = CmdVel::new(1.0, 0.5);\n        producer.send(cmd, &mut None)?;\n\n        if let Some(received) = consumer.recv(&mut None) {\n            // Process at 10kHz+ with deterministic timing\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:29:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 29,
      "lineEnd": 36,
      "language": "text",
      "code": "    [Normal] ──non-critical failure──> [Degraded]\n        │                                   │\n    critical                           critical\n    failure                            failure\n        ↓                                   ↓\n  [EmergencyStop] <───────────── [SafeMode]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:60:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 60,
      "lineEnd": 76,
      "language": "text",
      "code": "\n## Watchdogs\n\nWatchdogs monitor node liveness by requiring periodic \"feeding\":\n\n### Feeding Watchdogs\n\n```rust,ignore\n// During normal node execution\nfn tick_node(monitor: &SafetyMonitor) {\n    // Do node work...\n\n    // Feed the watchdog to signal node is alive\n    monitor.feed_watchdog(\"motor_controller\");\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/advanced/safety-monitor:90:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 90,
      "lineEnd": 105,
      "language": "text",
      "code": "\n### Watchdog Configuration\n\n```rust,ignore\n// Different timeouts for different node types\nmonitor.add_critical_node(\n    \"safety_controller\".to_string(),\n    Duration::from_millis(10)   // Very tight timeout\n);\n\nmonitor.add_critical_node(\n    \"sensor_fusion\".to_string(),\n    Duration::from_millis(100)  // More relaxed\n);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:126:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 126,
      "lineEnd": 152,
      "language": "text",
      "code": "\n### Checking Execution Time\n\n```rust,ignore\nuse std::time::Instant;\n\nlet start = Instant::now();\nnode.tick();\nlet execution_time = start.elapsed();\n\n// Check against budget\nmatch monitor.check_wcet(\"motor_controller\", execution_time) {\n    Ok(()) => {\n        // Within budget\n    }\n    Err(violation) => {\n        log::warn!(\n            \"WCET violation: {} took {:?} (budget: {:?})\",\n            violation.node_name,\n            violation.actual,\n            violation.budget\n        );\n        // Note: Critical node WCET violation triggers emergency stop\n    }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:163:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 163,
      "lineEnd": 179,
      "language": "text",
      "code": "\n## Deadline Monitoring\n\nTrack deadline misses across the system:\n\n```rust,ignore\n// Record a deadline miss\nmonitor.record_deadline_miss(\"slow_node\");\n\n// Check statistics\nlet stats = monitor.get_stats();\nprintln!(\"Total deadline misses: {}\", stats.deadline_misses);\n\n// Note: Critical node deadline miss or exceeding max_deadline_misses\n// triggers emergency stop",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:197:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 197,
      "lineEnd": 222,
      "language": "text",
      "code": "\n### Automatic Triggers\n\nEmergency stop is automatically triggered by:\n- Critical node watchdog expiration\n- Critical node WCET violation\n- Critical node deadline miss\n- Exceeding `max_deadline_misses` threshold\n\n## Safety States Management\n\n### Entering Degraded Mode\n\n```rust,ignore\n// Enter degraded mode for non-critical issues\nmonitor.enter_degraded_mode(\"Sensor calibration drift detected\".to_string());\n\n// Check current state\nmatch monitor.get_state() {\n    SafetyState::Normal => { /* Full operation */ }\n    SafetyState::Degraded => { /* Reduce speed, disable features */ }\n    SafetyState::SafeMode => { /* Minimal operation */ }\n    SafetyState::EmergencyStop => { /* All motion stopped */ }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:231:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 231,
      "lineEnd": 244,
      "language": "text",
      "code": "\n## Statistics\n\nGet comprehensive safety statistics:\n\n```rust,ignore\nlet stats = monitor.get_stats();\n\nprintln!(\"Safety State: {:?}\", stats.state);\nprintln!(\"WCET Overruns: {}\", stats.wcet_overruns);\nprintln!(\"Deadline Misses: {}\", stats.deadline_misses);\nprintln!(\"Watchdog Expirations: {}\", stats.watchdog_expirations);",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:270:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 270,
      "lineEnd": 347,
      "language": "text",
      "code": "\n## Complete Example\n\n```rust,ignore\nuse horus::prelude::*;\nuse std::time::{Duration, Instant};\n\nfn main() {\n    // Create safety monitor\n    let mut monitor = SafetyMonitor::new(10);\n\n    // Configure critical nodes\n    monitor.add_critical_node(\n        \"motor_controller\".to_string(),\n        Duration::from_millis(50)\n    );\n    monitor.set_wcet_budget(\n        \"motor_controller\".to_string(),\n        Duration::from_micros(200)\n    );\n\n    // Main loop\n    loop {\n        // Check for emergency stop\n        if monitor.is_emergency_stop() {\n            println!(\"EMERGENCY STOP - Halting all operations\");\n            break;\n        }\n\n        // Execute node\n        let start = Instant::now();\n        // motor_controller.tick();\n        let duration = start.elapsed();\n\n        // Feed watchdog\n        monitor.feed_watchdog(\"motor_controller\");\n\n        // Check WCET\n        if let Err(violation) = monitor.check_wcet(\"motor_controller\", duration) {\n            println!(\"WCET violation: {:?}\", violation);\n        }\n\n        // Periodic watchdog check\n        let expired = monitor.check_watchdogs();\n        if !expired.is_empty() {\n            println!(\"Expired watchdogs: {:?}\", expired);\n        }\n\n        // Handle safety state\n        match monitor.get_state() {\n            SafetyState::Normal => {\n                // Full operation\n            }\n            SafetyState::Degraded => {\n                // Reduce speed\n                println!(\"Operating in degraded mode\");\n            }\n            SafetyState::SafeMode => {\n                // Minimal operation\n                println!(\"Operating in safe mode\");\n            }\n            SafetyState::EmergencyStop => {\n                break;\n            }\n        }\n\n        std::thread::sleep(Duration::from_millis(10));\n    }\n\n    // Print final statistics\n    let stats = monitor.get_stats();\n    println!(\"\\nFinal Statistics:\");\n    println!(\"  State: {:?}\", stats.state);\n    println!(\"  WCET Overruns: {}\", stats.wcet_overruns);\n    println!(\"  Deadline Misses: {}\", stats.deadline_misses);\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:360:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 360,
      "lineEnd": 372,
      "language": "text",
      "code": "\n### 2. Use Appropriate Watchdog Timeouts\n\n```rust,ignore\n// Watchdog timeout should be:\n// - Longer than expected execution time\n// - Shorter than safety-critical response time\n\nlet expected_period = Duration::from_millis(10);\nlet safety_deadline = Duration::from_millis(100);\nlet watchdog_timeout = expected_period * 5;  // Allow some misses",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/safety-monitor:381:text",
      "file": "content/docs/advanced/safety-monitor.mdx",
      "lineStart": 381,
      "lineEnd": 397,
      "language": "text",
      "code": "\n### 4. Log Safety Events\n\n```rust,ignore\n// Log all state changes\nif prev_state != monitor.get_state() {\n    log::warn!(\"Safety state changed: {:?} -> {:?}\",\n        prev_state, monitor.get_state());\n}\n\n// Log all violations\nif let Err(v) = monitor.check_wcet(node, duration) {\n    log::error!(\"WCET violation: {} overran by {:?}\",\n        v.node_name, v.overrun);\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:23:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 23,
      "lineEnd": 48,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    // Simple case: deterministic scheduler (no config needed)\n    let scheduler = Scheduler::new();\n\n    // With explicit tier annotations (deterministic + optimized)\n    let mut scheduler = Scheduler::new();\n    scheduler.add_with_tier(Box::new(my_node), 0, NodeTier::Jit);\n\n    // With full configuration preset\n    let config = SchedulerConfig::safety_critical();\n    let scheduler = Scheduler::new().with_config(config);\n\n    // Or customize from standard\n    let config = SchedulerConfig::standard()\n        .with_execution_mode(ExecutionMode::Sequential)\n        .with_tick_rate(1000.0);  // 1kHz\n\n    let mut scheduler = Scheduler::new().with_config(config);\n    scheduler.add(Box::new(my_node), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:56:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 56,
      "lineEnd": 69,
      "language": "rust",
      "code": "pub enum ExecutionMode {\n    /// JIT compilation for ultra-fast control loops\n    JITOptimized,\n    /// Parallel execution with dependency resolution\n    Parallel,\n    /// Async I/O for network and file operations\n    AsyncIO,\n    /// Traditional sequential execution (deterministic)\n    Sequential,\n    /// Mixed mode with automatic classification\n    AutoAdaptive,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:81:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 81,
      "lineEnd": 94,
      "language": "rust",
      "code": "pub struct TimingConfig {\n    /// Global tick rate in Hz (default: 60)\n    pub global_rate_hz: f64,\n    /// Enable per-node rate control\n    pub per_node_rates: bool,\n    /// Maximum allowed jitter in microseconds\n    pub max_jitter_us: u64,\n    /// Deadline miss policy\n    pub deadline_miss_policy: DeadlineMissPolicy,\n    /// Time synchronization source\n    pub time_sync_source: TimeSyncSource,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:98:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 98,
      "lineEnd": 105,
      "language": "rust",
      "code": "pub enum DeadlineMissPolicy {\n    Warn,      // Log warning and continue\n    Skip,      // Skip the node for this tick\n    Panic,     // Terminate the scheduler (safety-critical)\n    Degrade,   // Downgrade priority and continue\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:109:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 109,
      "lineEnd": 117,
      "language": "rust",
      "code": "pub enum TimeSyncSource {\n    Monotonic,  // System monotonic clock (default, currently only supported)\n    NTP,        // Reserved for future use\n    GPS,        // Reserved for future use\n    PTP,        // Reserved for future use\n    External,   // Reserved for future use\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:123:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 123,
      "lineEnd": 140,
      "language": "rust",
      "code": "pub struct FaultConfig {\n    /// Enable circuit breaker pattern\n    pub circuit_breaker_enabled: bool,\n    /// Max failures before circuit opens\n    pub max_failures: u32,\n    /// Success count to close circuit\n    pub recovery_threshold: u32,\n    /// Circuit timeout in milliseconds\n    pub circuit_timeout_ms: u64,\n    /// Enable automatic node restart\n    pub auto_restart: bool,\n    /// Redundancy factor - reserved for future use\n    pub redundancy_factor: u32,\n    /// Checkpointing frequency (0 = disabled)\n    pub checkpoint_interval_ms: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:146:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 146,
      "lineEnd": 169,
      "language": "rust",
      "code": "pub struct RealTimeConfig {\n    /// Enable WCET enforcement\n    pub wcet_enforcement: bool,\n    /// Enable deadline monitoring\n    pub deadline_monitoring: bool,\n    /// Enable watchdog timers\n    pub watchdog_enabled: bool,\n    /// Default watchdog timeout in milliseconds\n    pub watchdog_timeout_ms: u64,\n    /// Enable safety monitor\n    pub safety_monitor: bool,\n    /// Maximum deadline misses before emergency stop\n    pub max_deadline_misses: u64,\n    /// Enable priority inheritance protocol\n    pub priority_inheritance: bool,\n    /// Enable formal verification checks (debug builds only)\n    pub formal_verification: bool,\n    /// Memory locking (mlockall)\n    pub memory_locking: bool,\n    /// Use real-time scheduling class (SCHED_FIFO/RR)\n    pub rt_scheduling_class: bool,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:173:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 173,
      "lineEnd": 190,
      "language": "rust",
      "code": "pub struct ResourceConfig {\n    /// CPU cores to use (None = all cores) - Linux only\n    pub cpu_cores: Option<Vec<usize>>,\n    /// Memory limit in MB (0 = unlimited) - reserved\n    pub memory_limit_mb: usize,\n    /// I/O priority (0-7, 0 = highest) - reserved\n    pub io_priority: u8,\n    /// Enable NUMA awareness - Linux only\n    pub numa_aware: bool,\n    /// GPU device IDs - reserved for future use\n    pub gpu_devices: Vec<usize>,\n    /// Power management - reserved for future use\n    pub power_management: bool,\n    /// Power budget in watts - reserved for future use\n    pub power_budget_watts: u32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:200:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 200,
      "lineEnd": 203,
      "language": "rust",
      "code": "// Simple: deterministic by default\nlet scheduler = Scheduler::new();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:214:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 214,
      "lineEnd": 217,
      "language": "rust",
      "code": "let config = SchedulerConfig::standard();\nlet scheduler = Scheduler::new().with_config(config);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:229:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 229,
      "lineEnd": 231,
      "language": "rust",
      "code": "let config = SchedulerConfig::safety_critical();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:244:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 244,
      "lineEnd": 246,
      "language": "rust",
      "code": "let config = SchedulerConfig::high_performance();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:258:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 258,
      "lineEnd": 260,
      "language": "rust",
      "code": "let config = SchedulerConfig::hard_realtime();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:272:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 272,
      "lineEnd": 274,
      "language": "rust",
      "code": "let config = SchedulerConfig::space();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:282:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 282,
      "lineEnd": 284,
      "language": "rust",
      "code": "let config = SchedulerConfig::swarm();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduler-configuration:295:rust",
      "file": "content/docs/advanced/scheduler-configuration.mdx",
      "lineStart": 295,
      "lineEnd": 348,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet config = SchedulerConfig {\n    execution: ExecutionMode::Sequential,\n    timing: TimingConfig {\n        global_rate_hz: 500.0,\n        per_node_rates: true,\n        max_jitter_us: 50,\n        deadline_miss_policy: DeadlineMissPolicy::Warn,\n        time_sync_source: TimeSyncSource::PTP,\n    },\n    fault: FaultConfig {\n        circuit_breaker_enabled: true,\n        max_failures: 3,\n        recovery_threshold: 2,\n        circuit_timeout_ms: 1000,\n        auto_restart: false,\n        redundancy_factor: 2,\n        checkpoint_interval_ms: 1000,\n    },\n    realtime: RealTimeConfig {\n        wcet_enforcement: true,\n        deadline_monitoring: true,\n        watchdog_enabled: true,\n        watchdog_timeout_ms: 50,\n        safety_monitor: true,\n        max_deadline_misses: 5,\n        priority_inheritance: true,\n        formal_verification: false,\n        memory_locking: true,\n        rt_scheduling_class: true,\n    },\n    resources: ResourceConfig {\n        cpu_cores: Some(vec![2, 3]),  // Isolate to cores 2-3\n        memory_limit_mb: 512,\n        io_priority: 0,\n        numa_aware: true,\n        gpu_devices: vec![0],\n        power_management: false,\n        power_budget_watts: 0,\n    },\n    monitoring: MonitoringConfig {\n        profiling_enabled: false,\n        tracing_enabled: true,\n        metrics_interval_ms: 100,\n        telemetry_endpoint: None,\n        black_box_enabled: true,\n        black_box_size_mb: 256,\n    },\n    preset: RobotPreset::Custom,\n    custom: HashMap::new(),\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:26:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 26,
      "lineEnd": 34,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with 100-tick learning phase\nlet mut profiler = RuntimeProfiler::new(100);\n\n// Or use default (100 ticks)\nlet mut profiler = RuntimeProfiler::new_default();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:38:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 38,
      "lineEnd": 51,
      "language": "rust",
      "code": "use std::time::{Duration, Instant};\n\n// During node execution\nlet start = Instant::now();\nnode.tick();\nlet duration = start.elapsed();\n\n// Record the execution time\nprofiler.record(\"sensor_node\", duration);\n\n// Advance tick counter\nprofiler.tick();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:55:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 55,
      "lineEnd": 58,
      "language": "rust",
      "code": "// Record node failures (for Isolated tier classification)\nprofiler.record_node_failure(\"motor_controller\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:62:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 62,
      "lineEnd": 71,
      "language": "rust",
      "code": "// Check if learning is complete\nif profiler.is_learning_complete() {\n    println!(\"Learning phase finished!\");\n}\n\n// Get progress (0.0 to 1.0)\nlet progress = profiler.learning_progress();\nprintln!(\"Learning: {:.0}%\", progress * 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:77:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 77,
      "lineEnd": 95,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nif let Some(stats) = profiler.get_stats(\"sensor_node\") {\n    println!(\"Average: {:.2}µs\", stats.avg_us);\n    println!(\"Std Dev: {:.2}µs\", stats.stddev_us);\n    println!(\"Min: {:.2}µs\", stats.min_us);\n    println!(\"Max: {:.2}µs\", stats.max_us);\n    println!(\"Samples: {}\", stats.count);\n\n    // Characteristics\n    println!(\"Deterministic: {}\", stats.is_deterministic);\n    println!(\"I/O Heavy: {}\", stats.is_io_heavy);\n    println!(\"CPU Bound: {}\", stats.is_cpu_bound);\n\n    // Failure tracking\n    println!(\"Failure rate: {:.1}%\", stats.failure_rate * 100.0);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:110:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 110,
      "lineEnd": 125,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create classifier from profiler data\nlet classifier = TierClassifier::from_profiler(&profiler);\n\n// Get tier for a specific node\nif let Some(tier) = classifier.get_tier(\"sensor_node\") {\n    println!(\"Tier: {}\", tier.name());\n    println!(\"Expected latency: {}\", tier.latency_range());\n}\n\n// Get all nodes in a tier\nlet ultra_fast = classifier.get_nodes_in_tier(ExecutionTier::UltraFast);\nprintln!(\"JIT-eligible nodes: {:?}\", ultra_fast);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:139:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 139,
      "lineEnd": 146,
      "language": "rust",
      "code": "// Classification priority (highest to lowest):\n// 1. High failure rate → Isolated (process isolation for safety)\n// 2. Ultra-fast + deterministic → UltraFast (JIT compilation)\n// 3. I/O heavy → AsyncIO (async executor)\n// 4. Fast (<1ms) → Fast (inline execution)\n// 5. Default → Background (thread pool)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:150:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 150,
      "lineEnd": 161,
      "language": "rust",
      "code": "let stats = classifier.tier_stats();\n\nprintln!(\"Total nodes: {}\", stats.total_nodes);\nprintln!(\"UltraFast: {} ({:.1}%)\",\n    stats.ultra_fast,\n    stats.ultra_fast_percent()\n);\nprintln!(\"Parallel capable: {:.1}%\",\n    stats.parallel_capable_percent()\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:167:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 167,
      "lineEnd": 179,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Define nodes with their pub/sub topics\nlet nodes = vec![\n    (\"sensor\", vec![\"raw_data\".to_string()], vec![]),\n    (\"filter\", vec![\"filtered\".to_string()], vec![\"raw_data\".to_string()]),\n    (\"detector\", vec![\"objects\".to_string()], vec![\"filtered\".to_string()]),\n    (\"logger\", vec![], vec![\"raw_data\".to_string()]),\n];\n\nlet graph = DependencyGraph::from_nodes(&nodes);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:185:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 185,
      "lineEnd": 195,
      "language": "rust",
      "code": "println!(\"Execution levels:\");\nfor (i, level) in graph.levels.iter().enumerate() {\n    println!(\"  Level {}: {:?}\", i, level);\n}\n\n// Output:\n// Level 0: [\"sensor\"]           <- No dependencies\n// Level 1: [\"filter\", \"logger\"] <- Depend on sensor\n// Level 2: [\"detector\"]         <- Depends on filter",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:201:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 201,
      "lineEnd": 208,
      "language": "rust",
      "code": "println!(\"Parallel groups:\");\nfor group in &graph.parallel_groups {\n    println!(\"  {:?}\", group);\n}\n\n// Nodes in the same group have no dependencies",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:212:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 212,
      "lineEnd": 225,
      "language": "rust",
      "code": "let stats = graph.stats();\n\nprintln!(\"Total nodes: {}\", stats.total_nodes);\nprintln!(\"Total edges: {}\", stats.total_edges);\nprintln!(\"Levels: {}\", stats.num_levels);\nprintln!(\"Parallel groups: {}\", stats.num_parallel_groups);\nprintln!(\"Max parallel: {}\", stats.max_parallel_nodes);\n\n// Check for cycles (invalid in pub/sub)\nif graph.has_cycles() {\n    eprintln!(\"Warning: Dependency cycle detected!\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:231:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 231,
      "lineEnd": 246,
      "language": "rust",
      "code": "let summary = profiler.summary();\n\nprintln!(\"=== Profiler Summary ===\");\nprintln!(\"Total nodes: {}\", summary.total_nodes);\nprintln!(\"Ultra-fast nodes: {}\", summary.ultra_fast_nodes);\nprintln!(\"I/O heavy nodes: {}\", summary.io_heavy_nodes);\nprintln!(\"CPU bound nodes: {}\", summary.cpu_bound_nodes);\nprintln!(\"Avg execution: {:.2}µs\", summary.avg_execution_us);\nprintln!(\"Learning: {}\",\n    if summary.learning_complete { \"Complete\" } else { \"In progress\" }\n);\n\n// Detailed statistics\nprofiler.print_stats();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:252:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 252,
      "lineEnd": 284,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet config = SchedulerConfig {\n    // Enable profiling\n    profiling_enabled: true,\n    learning_ticks: 100,\n\n    // Enable tier-based execution\n    tier_execution_enabled: true,\n\n    // Enable JIT for ultra-fast nodes\n    jit_enabled: true,\n\n    ..Default::default()\n};\n\nlet mut scheduler = Scheduler::with_config(config);\n\n// Add nodes\nscheduler.add_node(sensor_node)?;\nscheduler.add_node(filter_node)?;\n\n// Run - profiling happens automatically\nfor _ in 0..1000 {\n    scheduler.tick();\n\n    // After learning phase, tiers are assigned\n    if scheduler.is_learning_complete() {\n        // Nodes now execute in optimized tiers\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:290:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 290,
      "lineEnd": 296,
      "language": "rust",
      "code": "// Force all nodes to be classified as ultra-fast\nprofiler.force_ultra_fast_classification = true;\n\n// Force all nodes to be classified as async I/O\nprofiler.force_async_io_classification = true;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:302:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 302,
      "lineEnd": 308,
      "language": "rust",
      "code": "// Short for real-time critical (faster startup)\nlet profiler = RuntimeProfiler::new(50);\n\n// Long for complex systems (better accuracy)\nlet profiler = RuntimeProfiler::new(500);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:312:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 312,
      "lineEnd": 322,
      "language": "rust",
      "code": "// After learning phase\nlet classifier = TierClassifier::from_profiler(&profiler);\nclassifier.print_classification();\n\n// Check for unexpected results\nlet isolated = classifier.get_nodes_in_tier(ExecutionTier::Isolated);\nif !isolated.is_empty() {\n    log::warn!(\"Nodes with high failure rates: {:?}\", isolated);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/scheduling-intelligence:326:rust",
      "file": "content/docs/advanced/scheduling-intelligence.mdx",
      "lineStart": 326,
      "lineEnd": 336,
      "language": "rust",
      "code": "let graph = DependencyGraph::from_nodes(&nodes);\n\nif graph.has_cycles() {\n    panic!(\"Invalid pub/sub configuration: cycle detected\");\n}\n\nif graph.stats().num_levels == graph.stats().total_nodes {\n    log::warn!(\"No parallelism possible - fully sequential graph\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:24:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 24,
      "lineEnd": 54,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create telemetry manager with 1-second export interval\nlet mut telemetry = TelemetryManager::new(\n    TelemetryEndpoint::from_string(\"udp://192.168.1.100:9999\"),\n    1000  // 1000ms interval\n);\n\ntelemetry.set_scheduler_name(\"robot_controller\");\n\n// Record metrics during operation\ntelemetry.counter(\"scheduler_ticks\", 1000);\ntelemetry.gauge(\"cpu_usage\", 45.5);\ntelemetry.gauge(\"motor_temperature\", 38.2);\n\n// Record metrics with labels\ntelemetry.counter_with_labels(\n    \"messages_sent\",\n    500,\n    HashMap::from([\n        (\"topic\".to_string(), \"motor.cmd\".to_string()),\n        (\"node\".to_string(), \"MotorController\".to_string()),\n    ])\n);\n\n// Export when ready\nif telemetry.should_export() {\n    telemetry.export()?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:60:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 60,
      "lineEnd": 80,
      "language": "rust",
      "code": "// Local JSON file\nlet endpoint = TelemetryEndpoint::LocalFile(PathBuf::from(\"/tmp/metrics.json\"));\n\n// UDP broadcast (for Prometheus, Grafana, etc.)\nlet endpoint = TelemetryEndpoint::Udp(\"127.0.0.1:9999\".to_string());\n\n// HTTP POST endpoint\nlet endpoint = TelemetryEndpoint::Http(\"http://metrics.example.com/api/v1/push\".to_string());\n\n// Stdout (debugging)\nlet endpoint = TelemetryEndpoint::Stdout;\n\n// Disabled\nlet endpoint = TelemetryEndpoint::Disabled;\n\n// Parse from string (configuration files)\nlet endpoint = TelemetryEndpoint::from_string(\"udp://192.168.1.100:9999\");\nlet endpoint = TelemetryEndpoint::from_string(\"file:///var/log/horus/metrics.json\");\nlet endpoint = TelemetryEndpoint::from_string(\"stdout\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:86:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 86,
      "lineEnd": 100,
      "language": "rust",
      "code": "/// Counter - monotonically increasing value\ntelemetry.counter(\"total_messages\", 12345);\n\n/// Gauge - value that can go up or down\ntelemetry.gauge(\"queue_depth\", 42.0);\ntelemetry.gauge(\"temperature\", 65.5);\n\n/// Histogram - distribution of values\nlet latencies = vec![1.2, 1.5, 1.3, 2.1, 1.4];\ntelemetry.record(\"tick_latency_ms\", MetricValue::Histogram(latencies), labels);\n\n/// Text - string value for status/state\ntelemetry.record(\"current_state\", MetricValue::Text(\"Running\".to_string()), labels);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:106:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 106,
      "lineEnd": 130,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create shared telemetry\nlet telemetry = create_shared_telemetry(\n    TelemetryEndpoint::from_string(\"udp://localhost:9999\"),\n    1000\n);\n\n// Clone for use in different threads\nlet tm_clone = telemetry.clone();\n\nstd::thread::spawn(move || {\n    let mut tm = tm_clone.lock().unwrap();\n    tm.counter(\"thread_events\", 1);\n});\n\n// Export from main thread\n{\n    let mut tm = telemetry.lock().unwrap();\n    if tm.should_export() {\n        tm.export().ok();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:136:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 136,
      "lineEnd": 146,
      "language": "rust",
      "code": "let snapshot = telemetry.get_snapshot();\n\nprintln!(\"Scheduler: {}\", snapshot.scheduler_name);\nprintln!(\"Uptime: {:.1}s\", snapshot.uptime_secs);\nprintln!(\"Timestamp: {}\", snapshot.timestamp);\n\nfor metric in &snapshot.metrics {\n    println!(\"  {} = {:?}\", metric.name, metric.value);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:156:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 156,
      "lineEnd": 170,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create heartbeat\nlet mut heartbeat = Heartbeat::new(\"MotorController\", 1);\n\n// Update on each tick\nheartbeat.update(elapsed_secs);\n\n// Check status\nprintln!(\"Node: {}\", heartbeat.name());\nprintln!(\"Sequence: {}\", heartbeat.sequence);\nprintln!(\"Uptime: {:.1}s\", heartbeat.uptime);\nprintln!(\"Alive: {}\", heartbeat.alive);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:187:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 187,
      "lineEnd": 205,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create status messages\nlet ok = Status::ok(\"System initialized\");\nlet warn = Status::warn(101, \"Battery below 30%\");\nlet error = Status::error(500, \"Sensor timeout\");\nlet fatal = Status::fatal(999, \"Safety system failure\");\n\n// With component name\nlet status = Status::error(404, \"Camera not found\")\n    .with_component(\"VisionSystem\");\n\n// Access fields\nprintln!(\"Level: {:?}\", status.level);\nprintln!(\"Code: {}\", status.code);\nprintln!(\"Message: {}\", status.message_str());\nprintln!(\"Component: {}\", status.component_str());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:220:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 220,
      "lineEnd": 233,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Engage emergency stop\nlet estop = EmergencyStop::engage(\"Obstacle detected within safety zone\")\n    .with_source(\"LidarSafetyMonitor\");\n\nif estop.engaged {\n    log::error!(\"E-STOP: {}\", estop.reason_str());\n}\n\n// Release emergency stop\nlet release = EmergencyStop::release();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:239:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 239,
      "lineEnd": 264,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut resources = ResourceUsage::new();\n\nresources.cpu_percent = 45.5;\nresources.memory_bytes = 1024 * 1024 * 512;  // 512 MB\nresources.memory_percent = 25.0;\nresources.disk_bytes = 1024 * 1024 * 1024 * 10;  // 10 GB\nresources.disk_percent = 15.0;\nresources.temperature = 55.0;\nresources.thread_count = 24;\n\n// Check thresholds\nif resources.is_cpu_high(80.0) {\n    log::warn!(\"High CPU usage: {:.1}%\", resources.cpu_percent);\n}\n\nif resources.is_memory_high(90.0) {\n    log::warn!(\"High memory usage: {:.1}%\", resources.memory_percent);\n}\n\nif resources.is_temperature_high(85.0) {\n    log::error!(\"Critical temperature: {:.1}°C\", resources.temperature);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:285:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 285,
      "lineEnd": 298,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut report = DiagnosticReport::new(\"MotorController\");\n\n// Add diagnostic values (max 16)\nreport.add_string(\"firmware_version\", \"2.3.1\")?;\nreport.add_int(\"error_count\", 0)?;\nreport.add_float(\"motor_temp\", 42.5)?;\nreport.add_bool(\"homing_complete\", true)?;\n\n// Set overall status\nreport.set_level(StatusLevel::Ok);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:315:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 315,
      "lineEnd": 330,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet state = NodeState::Running;\n\nmatch state {\n    NodeState::Idle => println!(\"Node created but not started\"),\n    NodeState::Initializing => println!(\"Running initialization\"),\n    NodeState::Running => println!(\"Active and executing\"),\n    NodeState::Paused => println!(\"Temporarily suspended\"),\n    NodeState::Stopped => println!(\"Cleanly shut down\"),\n    NodeState::Error => println!(\"Error or crashed\"),\n}\n\nprintln!(\"State: {}\", state.as_str());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:336:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 336,
      "lineEnd": 351,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet health = HealthStatus::Warning;\n\n// Use for UI display\nprintln!(\"Status: {} ({})\", health.as_str(), health.color());\n\nmatch health {\n    HealthStatus::Healthy => println!(\"Operating normally\"),\n    HealthStatus::Warning => println!(\"Degraded performance\"),\n    HealthStatus::Error => println!(\"Errors but still running\"),\n    HealthStatus::Critical => println!(\"Fatal - about to crash\"),\n    HealthStatus::Unknown => println!(\"No heartbeat received\"),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:367:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 367,
      "lineEnd": 388,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut heartbeat = NodeHeartbeat::new(NodeState::Running, HealthStatus::Healthy);\n\nheartbeat.tick_count = 10000;\nheartbeat.target_rate_hz = 100;\nheartbeat.actual_rate_hz = 98;\nheartbeat.error_count = 0;\n\n// Update timestamp\nheartbeat.update_timestamp();\n\n// Check freshness (within last 5 seconds)\nif !heartbeat.is_fresh(5) {\n    println!(\"Stale heartbeat - node may be unresponsive\");\n}\n\n// Serialize for file storage\nlet bytes = heartbeat.to_bytes();\nlet restored = NodeHeartbeat::from_bytes(&bytes);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:407:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 407,
      "lineEnd": 428,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut safety = SafetyStatus::new();\n\n// Check if safe to operate\nif safety.is_safe() {\n    println!(\"System safe for operation\");\n}\n\n// Update safety indicators\nsafety.watchdog_ok = true;\nsafety.limits_ok = true;\nsafety.comms_ok = true;\nsafety.estop_engaged = false;\n\n// Set fault\nsafety.set_fault(101);  // Auto-enters SAFE_STOP mode\n\n// Clear faults\nsafety.clear_faults();  // Returns to NORMAL mode",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:442:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 442,
      "lineEnd": 456,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet config = SchedulerConfig {\n    monitoring: MonitoringConfig {\n        profiling_enabled: true,\n        tracing_enabled: false,\n        metrics_interval_ms: 1000,\n        telemetry_endpoint: Some(\"udp://localhost:9999\".to_string()),\n        black_box_enabled: true,\n        black_box_size_mb: 100,\n    },\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/advanced/telemetry:471:rust",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 471,
      "lineEnd": 544,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::collections::HashMap;\n\nstruct MonitoredNode {\n    telemetry: SharedTelemetry,\n    heartbeat_pub: Hub<NodeHeartbeat>,\n    status_pub: Hub<Status>,\n    resources_pub: Hub<ResourceUsage>,\n    start_time: std::time::Instant,\n    tick_count: u64,\n}\n\nimpl Node for MonitoredNode {\n    fn name(&self) -> &'static str { \"MonitoredNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.tick_count += 1;\n\n        // Record telemetry metrics\n        {\n            let mut tm = self.telemetry.lock().unwrap();\n            tm.counter(\"node_ticks\", self.tick_count);\n            tm.gauge(\"uptime_secs\", self.start_time.elapsed().as_secs_f64());\n\n            // Export periodically\n            if tm.should_export() {\n                if let Err(e) = tm.export() {\n                    log::warn!(\"Telemetry export failed: {}\", e);\n                }\n            }\n        }\n\n        // Publish heartbeat\n        let mut heartbeat = NodeHeartbeat::new(NodeState::Running, HealthStatus::Healthy);\n        heartbeat.tick_count = self.tick_count;\n        heartbeat.target_rate_hz = 100;\n        heartbeat.actual_rate_hz = self.calculate_rate();\n        self.heartbeat_pub.send(heartbeat, &mut ctx).ok();\n\n        // Publish resource usage\n        let resources = self.get_resource_usage();\n        self.resources_pub.send(resources, &mut ctx).ok();\n\n        // Publish status on significant events\n        if self.tick_count % 1000 == 0 {\n            let status = Status::ok(&format!(\"Completed {} ticks\", self.tick_count))\n                .with_component(\"MonitoredNode\");\n            self.status_pub.send(status, &mut ctx).ok();\n        }\n    }\n}\n\nimpl MonitoredNode {\n    fn calculate_rate(&self) -> u32 {\n        // Calculate actual tick rate\n        let elapsed = self.start_time.elapsed().as_secs_f64();\n        if elapsed > 0.0 {\n            (self.tick_count as f64 / elapsed) as u32\n        } else {\n            0\n        }\n    }\n\n    fn get_resource_usage(&self) -> ResourceUsage {\n        let mut resources = ResourceUsage::new();\n        // Populate with actual system metrics\n        resources.cpu_percent = 25.0;\n        resources.memory_percent = 40.0;\n        resources.temperature = 45.0;\n        resources\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced/telemetry:550:bash",
      "file": "content/docs/advanced/telemetry.mdx",
      "lineStart": 550,
      "lineEnd": 565,
      "language": "bash",
      "code": "# Start with telemetry endpoint\nhorus run robot.yaml --telemetry udp://localhost:9999\n\n# Monitor node health\nhorus monitor --health\n\n# View diagnostics\nhorus diag --node MotorController\n\n# Export current metrics\nhorus metrics --export /tmp/snapshot.json\n\n# Watch real-time metrics\nhorus metrics --watch",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:21:rust",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 21,
      "lineEnd": 133,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum RobotState {\n    Idle,\n    Moving,\n    ObstacleDetected,\n    Rotating,\n    Escaped,\n}\n\nstruct StateMachineNode {\n    state: RobotState,\n    obstacle_sub: Hub<bool>,\n    cmd_pub: Hub<CmdVel>,\n    rotation_counter: u32,\n}\n\nimpl StateMachineNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            state: RobotState::Idle,\n            obstacle_sub: Hub::new(\"obstacle_detected\")?,\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            rotation_counter: 0,\n        })\n    }\n}\n\nimpl Node for StateMachineNode {\n    fn name(&self) -> &'static str { \"StateMachineNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"State machine initialized - starting in IDLE state\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check for obstacles\n        let obstacle = self.obstacle_sub.recv(&mut ctx).unwrap_or(false);\n\n        // Store previous state for logging\n        let prev_state = self.state;\n\n        // State machine logic\n        self.state = match self.state {\n            RobotState::Idle => {\n                if !obstacle {\n                    RobotState::Moving\n                } else {\n                    RobotState::Idle\n                }\n            }\n\n            RobotState::Moving => {\n                if obstacle {\n                    self.cmd_pub.send(CmdVel::zero(), &mut ctx).ok();  // Stop\n                    RobotState::ObstacleDetected\n                } else {\n                    self.cmd_pub.send(CmdVel::new(1.0, 0.0), &mut ctx).ok();  // Forward\n                    RobotState::Moving\n                }\n            }\n\n            RobotState::ObstacleDetected => {\n                self.rotation_counter = 0;\n                RobotState::Rotating\n            }\n\n            RobotState::Rotating => {\n                self.cmd_pub.send(CmdVel::new(0.0, 0.5), &mut ctx).ok();  // Rotate\n                self.rotation_counter += 1;\n\n                if self.rotation_counter > 50 {\n                    RobotState::Escaped\n                } else {\n                    RobotState::Rotating\n                }\n            }\n\n            RobotState::Escaped => {\n                RobotState::Moving  // Resume moving\n            }\n        };\n\n        // Log state transitions\n        if self.state != prev_state {\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\n                    \"State transition: {:?} -> {:?}\",\n                    prev_state, self.state\n                ));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Ensure robot is stopped\n        self.cmd_pub.send(CmdVel::zero(), &mut None).ok();\n        ctx.log_info(\"State machine shutdown\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(StateMachineNode::new()?), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:136:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 136,
      "lineEnd": 138,
      "language": "bash",
      "code": "horus run state_machine.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:154:rust",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 154,
      "lineEnd": 366,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides {CmdVel, BatteryState};\n\n// CRITICAL PRIORITY: Emergency stop\nstruct EmergencyStopNode {\n    battery_sub: Hub<BatteryState>,\n    lidar_sub: Hub<f32>,  // Min obstacle distance\n    estop_pub: Hub<bool>,\n    estop_active: bool,\n}\n\nimpl EmergencyStopNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            battery_sub: Hub::new(\"battery_state\")?,\n            lidar_sub: Hub::new(\"min_distance\")?,\n            estop_pub: Hub::new(\"emergency_stop\")?,\n            estop_active: false,\n        })\n    }\n}\n\nimpl Node for EmergencyStopNode {\n    fn name(&self) -> &'static str { \"EmergencyStop\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\" Emergency stop system online - CRITICAL priority\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let mut should_stop = false;\n\n        // Check battery\n        if let Some(battery) = self.battery_sub.recv(&mut ctx) {\n            if battery.is_critical() {  // Below 10%\n                should_stop = true;\n                if let Some(ref mut c) = ctx {\n                    c.log_error(&format!(\n                        \" CRITICAL: Battery at {:.0}% - EMERGENCY STOP!\",\n                        battery.percentage\n                    ));\n                }\n            }\n        }\n\n        // Check obstacle distance\n        if let Some(min_dist) = self.lidar_sub.recv(&mut ctx) {\n            if min_dist < 0.2 {  // 20cm\n                should_stop = true;\n                if let Some(ref mut c) = ctx {\n                    c.log_error(&format!(\n                        \" CRITICAL: Obstacle at {:.2}m - EMERGENCY STOP!\",\n                        min_dist\n                    ));\n                }\n            }\n        }\n\n        // Publish estop state\n        if should_stop != self.estop_active {\n            self.estop_pub.send(should_stop, &mut ctx).ok();\n            self.estop_active = should_stop;\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Always activate estop on shutdown\n        self.estop_pub.send(true, &mut None).ok();\n        ctx.log_warning(\"Emergency stop system offline\");\n        Ok(())\n    }\n}\n\n// HIGH PRIORITY: Motor controller\nstruct MotorController {\n    estop_sub: Hub<bool>,\n    cmd_sub: Hub<CmdVel>,\n    motor_pub: Hub<CmdVel>,\n    estop_active: bool,\n}\n\nimpl MotorController {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            estop_sub: Hub::new(\"emergency_stop\")?,\n            cmd_sub: Hub::new(\"cmd_vel_request\")?,\n            motor_pub: Hub::new(\"cmd_vel_actual\")?,\n            estop_active: false,\n        })\n    }\n}\n\nimpl Node for MotorController {\n    fn name(&self) -> &'static str { \"MotorController\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Motor controller online - HIGH priority\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check emergency stop FIRST\n        if let Some(estop) = self.estop_sub.recv(&mut ctx) {\n            if estop != self.estop_active {\n                self.estop_active = estop;\n                if let Some(ctx) = ctx {\n                    if estop {\n                        ctx.log_warning(\"Motors DISABLED - emergency stop active\");\n                    } else {\n                        ctx.log_info(\"Motors ENABLED - emergency stop cleared\");\n                    }\n                }\n            }\n        }\n\n        // Don't move if estop active\n        if self.estop_active {\n            self.motor_pub.send(CmdVel::zero(), &mut ctx).ok();\n            return;\n        }\n\n        // Process normal commands\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            self.motor_pub.send(cmd, &mut ctx).ok();\n\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"Motors: linear={:.2}, angular={:.2}\",\n                    cmd.linear, cmd.angular\n                ));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Stop motors\n        self.motor_pub.send(CmdVel::zero(), &mut None).ok();\n        ctx.log_info(\"Motor controller stopped\");\n        Ok(())\n    }\n}\n\n// BACKGROUND PRIORITY: Data logging\nstruct LoggerNode {\n    cmd_sub: Hub<CmdVel>,\n    battery_sub: Hub<BatteryState>,\n}\n\nimpl LoggerNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_sub: Hub::new(\"cmd_vel_actual\")?,\n            battery_sub: Hub::new(\"battery_state\")?,\n        })\n    }\n}\n\nimpl Node for LoggerNode {\n    fn name(&self) -> &'static str { \"Logger\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\" Logger online - BACKGROUND priority\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Log velocity commands\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"LOG: cmd_vel({:.2}, {:.2})\",\n                    cmd.linear, cmd.angular\n                ));\n            }\n        }\n\n        // Log battery state\n        if let Some(battery) = self.battery_sub.recv(&mut ctx) {\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"LOG: battery({:.1}V, {:.0}%)\",\n                    battery.voltage, battery.percentage\n                ));\n            }\n        }\n\n        // In production: write to file, database, etc.\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Logger stopped\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // PRIORITY 0 (Critical): Safety runs FIRST\n    scheduler.add(Box::new(EmergencyStopNode::new()?), 0, Some(true));\n\n    // PRIORITY 1 (High): Control runs SECOND\n    scheduler.add(Box::new(MotorController::new()?), 1, Some(true));\n\n    // PRIORITY 4 (Background): Logging runs LAST\n    scheduler.add(Box::new(LoggerNode::new()?), 4, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:369:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 369,
      "lineEnd": 371,
      "language": "bash",
      "code": "horus run safety_system.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:388:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 388,
      "lineEnd": 392,
      "language": "bash",
      "code": "mkdir multi_node_system\ncd multi_node_system\nmkdir nodes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:397:python",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 397,
      "lineEnd": 420,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport time\nimport random\n\ndef sensor_tick(node):\n    \"\"\"Simulate temperature sensor readings\"\"\"\n    # Generate realistic temperature with noise\n    temperature = 20.0 + random.random() * 10.0\n\n    node.send(\"temperature\", temperature)\n    print(f\"Sensor: {temperature:.1f}°C\")\n\nnode = horus.Node(\n    name=\"SensorNode\",\n    pubs={\"temperature\": float},\n    tick=sensor_tick,\n    rate=2  # 2 Hz\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:425:python",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 425,
      "lineEnd": 454,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\n\ndef controller_tick(node):\n    \"\"\"Control cooling fan based on temperature\"\"\"\n    temp = node.recv(\"temperature\")\n\n    if temp is not None:\n        if temp > 25.0:\n            # Temperature too high - activate fan\n            fan_speed = min(100, int((temp - 20) * 10))\n            node.send(\"fan_control\", fan_speed)\n            print(f\"Controller: Fan at {fan_speed}%\")\n        else:\n            # Temperature OK - fan off\n            node.send(\"fan_control\", 0)\n            print(f\"Controller: Temperature normal, fan off\")\n\nnode = horus.Node(\n    name=\"ControllerNode\",\n    subs={\"temperature\": float},\n    pubs={\"fan_control\": int},\n    tick=controller_tick,\n    rate=2\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:459:python",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 459,
      "lineEnd": 483,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport datetime\n\ndef logger_tick(node):\n    \"\"\"Log system status\"\"\"\n    temp = node.recv(\"temperature\")\n    fan = node.recv(\"fan_control\")\n\n    if temp is not None and fan is not None:\n        timestamp = datetime.datetime.now().strftime(\"%H:%M:%S\")\n        status = \"COOLING\" if fan > 0 else \"NORMAL\"\n        print(f\"Logger [{timestamp}]: {temp:.1f}°C | Fan {fan}% | {status}\")\n\nnode = horus.Node(\n    name=\"LoggerNode\",\n    subs={\"temperature\": float, \"fan_control\": int},\n    tick=logger_tick,\n    rate=1  # 1 Hz\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:487:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 487,
      "lineEnd": 493,
      "language": "bash",
      "code": "# Make scripts executable\nchmod +x nodes/*.py\n\n# Run all nodes as separate processes\nhorus run \"nodes/*.py\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:496:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 496,
      "lineEnd": 517,
      "language": "bash",
      "code": "Executing 3 files concurrently:\n  1. nodes/controller.py (python)\n  2. nodes/logger.py (python)\n  3. nodes/sensor.py (python)\n\nPhase 1: Building all files...\nPhase 2: Starting all processes...\n  Started [controller]\n  Started [logger]\n  Started [sensor]\n\nAll processes running. Press Ctrl+C to stop.\n\n[sensor] Sensor: 23.4°C\n[controller] Controller: Fan at 34%\n[logger] Logger [15:30:45]: 23.4°C | Fan 34% | COOLING\n[sensor] Sensor: 26.8°C\n[controller] Controller: Fan at 68%\n[sensor] Sensor: 21.2°C\n[logger] Logger [15:30:46]: 21.2°C | Fan 12% | COOLING",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/advanced-examples:535:rust",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 535,
      "lineEnd": 583,
      "language": "rust",
      "code": "use horus::prelude::*;\n\npub struct TempSensor {\n    temp_pub: Hub<f32>,\n    counter: f32,\n}\n\nimpl TempSensor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            temp_pub: Hub::new(\"temperature\")?,\n            counter: 0.0,\n        })\n    }\n}\n\nimpl Node for TempSensor {\n    fn name(&self) -> &'static str { \"RustTempSensor\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Rust sensor online - high performance mode\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Fast sensor simulation\n        let temp = 20.0 + (self.counter.sin() * 5.0);\n        self.temp_pub.send(temp, &mut ctx).ok();\n\n        if let Some(ref mut c) = ctx {\n            c.log_debug(&format!(\"Rust: {:.2}°C\", temp));\n        }\n\n        self.counter += 0.1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Rust sensor offline\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(TempSensor::new()?), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:588:python",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 588,
      "lineEnd": 614,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\n\ndef controller_tick(node):\n    \"\"\"Python controller receives from Rust sensor\"\"\"\n    temp = node.recv(\"temperature\")\n\n    if temp is not None:\n        status = \"HOT\" if temp > 22.0 else \"NORMAL\"\n        print(f\"Python controller: {temp:.2f}°C - {status}\")\n\n        # Send command back to Rust actuator\n        command = 1.0 if temp > 22.0 else 0.0\n        node.send(\"actuator_cmd\", command)\n\nnode = horus.Node(\n    name=\"PyController\",\n    subs={\"temperature\": float},\n    pubs={\"actuator_cmd\": float},\n    tick=controller_tick,\n    rate=10\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:619:rust",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 619,
      "lineEnd": 651,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct Actuator {\n    cmd_sub: Hub<f32>,\n}\n\nimpl Node for Actuator {\n    fn name(&self) -> &'static str { \"RustActuator\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            if let Some(ctx) = ctx {\n                let action = if cmd > 0.5 { \"COOLING\" } else { \"IDLE\" };\n                ctx.log_info(&format!(\"Actuator: {}\", action));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Actuator stopped\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(Actuator {\n        cmd_sub: Hub::new(\"actuator_cmd\")?,\n    }), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:655:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 655,
      "lineEnd": 657,
      "language": "bash",
      "code": "horus run \"nodes/*\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:676:python",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 676,
      "lineEnd": 754,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport time\n\ndef high_freq_sensor(node):\n    \"\"\"100Hz IMU sensor\"\"\"\n    imu = {\n        \"accel_x\": 1.0,\n        \"accel_y\": 0.0,\n        \"accel_z\": 9.8,\n        \"timestamp\": time.time()\n    }\n    node.send(\"imu_data\", imu)\n\ndef control_loop(node):\n    \"\"\"50Hz controller with staleness detection\"\"\"\n    if node.has_msg(\"imu_data\"):\n        # Check message age\n        imu, timestamp = node.get_with_timestamp(\"imu_data\")\n\n        # Skip stale data (older than 100ms)\n        age = time.time() - timestamp\n        if age > 0.1:\n            node.log_warning(f\"Skipping stale IMU data (age: {age*1000:.1f}ms)\")\n            return\n\n        # Process fresh data\n        accel_magnitude = (\n            imu[\"accel_x\"]**2 +\n            imu[\"accel_y\"]**2 +\n            imu[\"accel_z\"]**2\n        ) ** 0.5\n\n        print(f\"Control: IMU magnitude = {accel_magnitude:.2f} m/s²\")\n\n        # Send command\n        cmd = {\"linear\": 1.0, \"angular\": 0.5}\n        node.send(\"cmd_vel\", cmd)\n\ndef logger(node):\n    \"\"\"10Hz logger with latency measurement\"\"\"\n    if node.has_msg(\"cmd_vel\"):\n        msg, timestamp = node.get_with_timestamp(\"cmd_vel\")\n        latency = (time.time() - timestamp) * 1000  # ms\n\n        print(f\"Logger: Command latency = {latency:.1f}ms\")\n\n        # Log to file in production\n        # with open(\"log.txt\", \"a\") as f:\n        #     f.write(f\"{timestamp},{msg},{latency}\\n\")\n\n# Create nodes with different rates\nsensor_node = horus.Node(\n    name=\"HighFreqSensor\",\n    pubs={\"imu_data\": dict},\n    tick=high_freq_sensor,\n    rate=100.0  # 100 Hz\n)\n\ncontrol_node = horus.Node(\n    name=\"Controller\",\n    subs={\"imu_data\": dict},\n    pubs={\"cmd_vel\": dict},\n    tick=control_loop,\n    rate=50.0  # 50 Hz\n)\n\nlogger_node = horus.Node(\n    name=\"Logger\",\n    subs={\"cmd_vel\": dict},\n    tick=logger,\n    rate=10.0  # 10 Hz\n)\n\n# Run all nodes\nif __name__ == \"__main__\":\n    horus.run(sensor_node, control_node, logger_node, duration=5.0)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:757:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 757,
      "lineEnd": 759,
      "language": "bash",
      "code": "horus run advanced_python.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:782:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 782,
      "lineEnd": 786,
      "language": "bash",
      "code": "horus run \"nodes/*.rs\"\nhorus run \"nodes/*.py\"\nhorus run \"nodes/*\"  # Mix Rust and Python!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:798:bash",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 798,
      "lineEnd": 800,
      "language": "bash",
      "code": "horus run main.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/advanced-examples:824:python",
      "file": "content/docs/advanced-examples.mdx",
      "lineStart": 824,
      "lineEnd": 863,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport time\n\ndef test_sensor_controller_integration():\n    \"\"\"Integration test for sensor + controller\"\"\"\n\n    # Mock sensor\n    def mock_sensor(node):\n        node.send(\"temperature\", 30.0)  # Hot!\n\n    # Test controller\n    fan_commands = []\n\n    def test_controller(node):\n        temp = node.recv(\"temperature\")\n        if temp is not None and temp > 25.0:\n            fan_speed = min(100, int((temp - 20) * 10))\n            fan_commands.append(fan_speed)\n            node.send(\"fan_control\", fan_speed)\n\n    # Run test\n    sensor = horus.Node(\"sensor\", pubs={\"temperature\": float}, tick=mock_sensor)\n    controller = horus.Node(\"controller\",\n                           subs={\"temperature\": float},\n                           pubs={\"fan_control\": int},\n                           tick=test_controller)\n\n    horus.run(sensor, controller, duration=0.1)\n\n    # Verify\n    assert len(fan_commands) > 0, \"Controller should have sent fan commands\"\n    assert fan_commands[0] == 100, f\"Expected fan at 100%, got {fan_commands[0]}%\"\n\n    print(\" Test passed!\")\n\nif __name__ == \"__main__\":\n    test_sensor_controller_integration()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/architecture:78:rust",
      "file": "content/docs/concepts/architecture.mdx",
      "lineStart": 78,
      "lineEnd": 89,
      "language": "rust",
      "code": "fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n    // Read inputs\n    let sensor_data = self.sensor_hub.recv(ctx);\n\n    // Process\n    let command = self.compute_response(sensor_data);\n\n    // Write outputs\n    self.command_hub.send(command, ctx);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/architecture:133:rust",
      "file": "content/docs/concepts/architecture.mdx",
      "lineStart": 133,
      "lineEnd": 143,
      "language": "rust",
      "code": "// Camera node publishes images\nlet image_pub: Hub<Image> = Hub::new(\"camera.image\")?;\nimage_pub.send(frame, ctx)?;\n\n// Multiple subscribers receive the same image\nlet image_sub: Hub<Image> = Hub::new(\"camera.image\")?;\nif let Some(frame) = image_sub.recv(ctx) {\n    // Process frame\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/architecture:155:rust",
      "file": "content/docs/concepts/architecture.mdx",
      "lineStart": 155,
      "lineEnd": 165,
      "language": "rust",
      "code": "// Producer side\nlet link = Link::<SensorData>::producer(\"sensor_pipeline\")?;\nlink.send(&data)?;\n\n// Consumer side\nlet link = Link::<SensorData>::consumer(\"sensor_pipeline\")?;\nif let Some(data) = link.recv() {\n    // Process in order\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/architecture:302:rust",
      "file": "content/docs/concepts/architecture.mdx",
      "lineStart": 302,
      "lineEnd": 313,
      "language": "rust",
      "code": "// Allocate space for a 1080p RGB image\nlet pool = TensorPool::new(1, TensorPoolConfig::default())?;\nlet tensor = pool.alloc(&[1080, 1920, 3], TensorDtype::U8)?;\n\n// Write data (only done once)\nlet data = pool.data_slice_mut(&tensor);\ncamera.capture_into(data);\n\n// Send through Hub - only the descriptor is copied, not the image\nimage_pub.send(tensor, ctx)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/architecture:326:python",
      "file": "content/docs/concepts/architecture.mdx",
      "lineStart": 326,
      "lineEnd": 338,
      "language": "python",
      "code": "import horus\nimport numpy as np\n\n# Receive tensor from Rust node\ntensor = hub.recv()\n\n# Zero-copy numpy view - no data copied!\narray = np.array(tensor, copy=False)\n\n# Process with numpy/PyTorch\nresult = model.predict(array)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:14:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 14,
      "lineEnd": 21,
      "language": "rust",
      "code": "// Development machine\nlet hub: Hub<Status> = Hub::new(\"status\")?;  // Local\n\n// Production robot\nlet hub: Hub<Status> = Hub::new(\"status@192.168.1.100\")?;  // Network\n// Need to change code for different environments!",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:24:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 24,
      "lineEnd": 28,
      "language": "rust",
      "code": "// Same code for dev and production!\nlet hub: Hub<Status> = Hub::from_config(\"status\")?;\n// Endpoint loaded from config file",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:37:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 37,
      "lineEnd": 49,
      "language": "toml",
      "code": "[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@192.168.1.100:8000\"\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera@192.168.1.50:9000\"\n\n[hubs.motors]\nname = \"motors\"\nendpoint = \"motors\"  # Local shared memory",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:54:yaml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 54,
      "lineEnd": 67,
      "language": "yaml",
      "code": "hubs:\n  telemetry:\n    name: telemetry\n    endpoint: telemetry@192.168.1.100:8000\n\n  camera:\n    name: camera\n    endpoint: camera@192.168.1.50:9000\n\n  motors:\n    name: motors\n    endpoint: motors  # Local shared memory",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:83:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 83,
      "lineEnd": 91,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Load from default search path\nlet telemetry: Hub<Status> = Hub::from_config(\"telemetry\")?;\n\n// Load from specific file\nlet camera: Hub<Image> = Hub::from_config_file(\"my_config.toml\", \"camera\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:95:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 95,
      "lineEnd": 109,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Producer\nlet output: Link<SensorData> = Link::producer_from_config(\"sensors\")?;\n\n// Consumer\nlet input: Link<SensorData> = Link::consumer_from_config(\"sensors\")?;\n\n// From specific file\nlet motors: Link<MotorCmd> = Link::producer_from_config_file(\n    \"/etc/robot/config.toml\",\n    \"motors\"\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:116:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 116,
      "lineEnd": 129,
      "language": "toml",
      "code": "# Local shared memory for development\n[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry\"  # Local\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera\"  # Local\n\n[hubs.motors]\nname = \"motors\"\nendpoint = \"motors\"  # Local",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:134:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 134,
      "lineEnd": 147,
      "language": "toml",
      "code": "# Network endpoints for production\n[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@ground-station:8000\"\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera@edge-device.local:9000\"\n\n[hubs.motors]\nname = \"motors\"\nendpoint = \"motors\"  # Still local (critical path)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:152:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 152,
      "lineEnd": 158,
      "language": "bash",
      "code": "# Development\nln -sf horus_dev.toml horus.toml\n\n# Production\nln -sf horus_prod.toml horus.toml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:161:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 161,
      "lineEnd": 168,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet config_file = std::env::var(\"HORUS_CONFIG\")\n    .unwrap_or_else(|_| \"horus.toml\".to_string());\n\nlet telemetry: Hub<Status> = Hub::from_config_file(&config_file, \"telemetry\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:170:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 170,
      "lineEnd": 178,
      "language": "bash",
      "code": "# Development\nexport HORUS_CONFIG=horus_dev.toml\nhorus run robot.rs\n\n# Production\nexport HORUS_CONFIG=horus_prod.toml\nhorus run --release robot.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:185:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 185,
      "lineEnd": 212,
      "language": "toml",
      "code": "# ======= ROBOT CONFIGURATION =======\n\n# Network telemetry to ground station\n[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@192.168.1.100:8000\"\n\n# Network camera to processing server\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera@192.168.1.200:9000\"\n\n# Local motor control (critical path - must be local!)\n[hubs.motors]\nname = \"motors\"\nendpoint = \"motors\"\n\n# Local IMU (critical path)\n[hubs.imu]\nname = \"imu\"\nendpoint = \"imu\"\n\n# Network fleet coordination\n[hubs.fleet]\nname = \"fleet\"\nendpoint = \"fleet@router:7000\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:216:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 216,
      "lineEnd": 246,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct Robot {\n    // Network: telemetry to ground station\n    telemetry: Hub<Status>,\n\n    // Network: camera to processing server\n    camera: Hub<Image>,\n\n    // Local: critical control loop\n    imu: Link<ImuData>,\n    motors: Link<MotorCmd>,\n\n    // Network: fleet coordination\n    fleet: Hub<FleetMsg>,\n}\n\nimpl Robot {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            // All loaded from config - no hardcoded endpoints!\n            telemetry: Hub::from_config(\"telemetry\")?,\n            camera: Hub::from_config(\"camera\")?,\n            imu: Link::consumer_from_config(\"imu\")?,\n            motors: Link::producer_from_config(\"motors\")?,\n            fleet: Hub::from_config(\"fleet\")?,\n        })\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:253:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 253,
      "lineEnd": 257,
      "language": "toml",
      "code": "[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@ground-station:8000\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:260:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 260,
      "lineEnd": 264,
      "language": "toml",
      "code": "[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry\"  # Override to local for testing",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:266:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 266,
      "lineEnd": 275,
      "language": "rust",
      "code": "// Load with fallback\nlet config_file = if cfg!(debug_assertions) {\n    \"horus_local.toml\"\n} else {\n    \"horus.toml\"\n};\n\nlet telemetry: Hub<Status> = Hub::from_config_file(config_file, \"telemetry\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-configuration:280:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 280,
      "lineEnd": 289,
      "language": "toml",
      "code": "[hubs.fleet]\nname = \"fleet\"\nendpoint = \"fleet@router:7000\"\n\n[robot]\nid = 1\nname = \"scout-01\"\nposition = [0.0, 0.0, 0.0]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:292:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 292,
      "lineEnd": 301,
      "language": "toml",
      "code": "[hubs.fleet]\nname = \"fleet\"\nendpoint = \"fleet@router:7000\"\n\n[robot]\nid = 2\nname = \"scout-02\"\nposition = [10.0, 10.0, 0.0]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:303:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 303,
      "lineEnd": 311,
      "language": "bash",
      "code": "# Deploy robot 1\nscp robot1_config.toml robot1:/etc/horus/horus.toml\nssh robot1 'horus run --release robot.rs'\n\n# Deploy robot 2\nscp robot2_config.toml robot2:/etc/horus/horus.toml\nssh robot2 'horus run --release robot.rs'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:316:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 316,
      "lineEnd": 325,
      "language": "toml",
      "code": "# Simulate network delays locally for testing\n[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@localhost:8000\"\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera@localhost:9000\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:327:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 327,
      "lineEnd": 331,
      "language": "bash",
      "code": "# Run with test config\nexport HORUS_CONFIG=horus_test.toml\nhorus run robot.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:337:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 337,
      "lineEnd": 344,
      "language": "bash",
      "code": "# Track all config files\ngit add horus*.toml\ngit commit -m \"Add robot configuration files\"\n\n# .gitignore sensitive production configs\necho \"horus_prod_secrets.toml\" >> .gitignore",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:349:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 349,
      "lineEnd": 359,
      "language": "toml",
      "code": "# Template configuration - copy and customize\n\n[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@GROUND_STATION_IP:8000\"\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera@EDGE_DEVICE_IP:9000\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:361:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 361,
      "lineEnd": 365,
      "language": "bash",
      "code": "# Setup new deployment\ncp horus.template.toml horus.toml\n# Edit horus.toml with actual IPs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:370:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 370,
      "lineEnd": 389,
      "language": "bash",
      "code": "#!/bin/bash\n# Deploy robot configuration\n\nROBOT_IP=$1\nCONFIG_ENV=$2\n\nif [ -z \"$ROBOT_IP\" ] || [ -z \"$CONFIG_ENV\" ]; then\n    echo \"Usage: ./deploy.sh <robot_ip> <dev|staging|prod>\"\n    exit 1\nfi\n\n# Copy environment-specific config\nscp \"horus_${CONFIG_ENV}.toml\" \"robot@${ROBOT_IP}:/etc/horus/horus.toml\"\n\n# Deploy and run\nssh \"robot@${ROBOT_IP}\" 'systemctl restart horus-robot'\n\necho \"Deployed $CONFIG_ENV config to $ROBOT_IP\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:391:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 391,
      "lineEnd": 397,
      "language": "bash",
      "code": "# Deploy to staging\n./deploy.sh 192.168.1.50 staging\n\n# Deploy to production\n./deploy.sh 192.168.1.50 prod",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:401:rust",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 401,
      "lineEnd": 422,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn validate_config() -> Result<()> {\n    // Try loading all configured hubs\n    let _telemetry: Hub<Status> = Hub::from_config(\"telemetry\")?;\n    let _camera: Hub<Image> = Hub::from_config(\"camera\")?;\n    let _motors: Link<MotorCmd> = Link::producer_from_config(\"motors\")?;\n\n    println!(\"[OK] Configuration valid\");\n    Ok(())\n}\n\nfn main() {\n    if let Err(e) = validate_config() {\n        eprintln!(\"[ERROR] Configuration error: {}\", e);\n        std::process::exit(1);\n    }\n\n    // Run application\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:429:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 429,
      "lineEnd": 438,
      "language": "toml",
      "code": "[hubs.telemetry]\nendpoint = \"telemetry\"\n\n[hubs.camera]\nendpoint = \"camera\"\n\n[hubs.motors]\nendpoint = \"motors\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:443:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 443,
      "lineEnd": 452,
      "language": "toml",
      "code": "[hubs.telemetry]\nendpoint = \"telemetry@192.168.1.100:8000\"\n\n[hubs.camera]\nendpoint = \"camera@192.168.1.50:9000\"\n\n[hubs.motors]\nendpoint = \"motors\"  # Keep critical path local",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:457:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 457,
      "lineEnd": 466,
      "language": "toml",
      "code": "[hubs.telemetry]\nendpoint = \"telemetry@ground-station.local:8000\"\n\n[hubs.camera]\nendpoint = \"camera@edge.local:9000\"\n\n[hubs.motors]\nendpoint = \"motors\"  # Always local for safety",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:471:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 471,
      "lineEnd": 485,
      "language": "toml",
      "code": "# Central router for fleet coordination\n[hubs.fleet_positions]\nendpoint = \"positions@router.local:7000\"\n\n[hubs.fleet_commands]\nendpoint = \"commands@router.local:7001\"\n\n# Local control for each robot\n[hubs.motors]\nendpoint = \"motors\"\n\n[hubs.imu]\nendpoint = \"imu\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:494:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 494,
      "lineEnd": 506,
      "language": "bash",
      "code": "# Check current directory\nls -la horus.toml\n\n# Check user config\nls -la ~/.horus/config.toml\n\n# Check system config\nls -la /etc/horus/config.toml\n\n# Create config\ncp horus.template.toml horus.toml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:513:bash",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 513,
      "lineEnd": 519,
      "language": "bash",
      "code": "# Verify hub name matches config\ngrep -A2 \"\\[hubs.telemetry\\]\" horus.toml\n\n# Check TOML syntax\ntoml-validator horus.toml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-configuration:526:toml",
      "file": "content/docs/concepts/communication-configuration.mdx",
      "lineStart": 526,
      "lineEnd": 532,
      "language": "toml",
      "code": "# Correct endpoint formats\nendpoint = \"topic\"                      # Local\nendpoint = \"topic@192.168.1.100\"       # Network (default port)\nendpoint = \"topic@192.168.1.100:8000\"  # Network (custom port)\nendpoint = \"topic@hostname.local:9000\"  # Hostname",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-overview:19:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 19,
      "lineEnd": 28,
      "language": "rust",
      "code": "// One publisher\nlet pub_hub: Hub<SensorData> = Hub::new(\"sensors\")?;\npub_hub.send(data, &mut ctx)?;\n\n// Many subscribers receive the same data\nlet sub1: Hub<SensorData> = Hub::new(\"sensors\")?;\nlet sub2: Hub<SensorData> = Hub::new(\"sensors\")?;\nlet sub3: Hub<SensorData> = Hub::new(\"sensors\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:36:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 36,
      "lineEnd": 46,
      "language": "rust",
      "code": "// Producer\nlet output: Link<ImuData> = Link::producer(\"imu_raw\")?;\noutput.send(data, &mut ctx)?;\n\n// Consumer (exactly one)\nlet input: Link<ImuData> = Link::consumer(\"imu_raw\")?;\nif let Some(data) = input.recv(&mut ctx) {\n    process(data);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:91:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 91,
      "lineEnd": 97,
      "language": "rust",
      "code": "// Can add/remove subscribers dynamically\nlet logger: Hub<Event> = Hub::new(\"events\")?;\nlet monitor: Hub<Event> = Hub::new(\"events\")?;\nlet analyzer: Hub<Event> = Hub::new(\"events\")?;\n// All receive the same events",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:100:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 100,
      "lineEnd": 105,
      "language": "rust",
      "code": "// Fixed 1P1C topology\nlet producer: Link<Data> = Link::producer(\"data\")?;\nlet consumer: Link<Data> = Link::consumer(\"data\")?;\n// Exactly one of each - adding another consumer won't work",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:110:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 110,
      "lineEnd": 116,
      "language": "rust",
      "code": "// One camera feeds multiple processors\nlet camera_pub: Hub<Image> = Hub::new(\"camera\")?;\n// subscriber 1: face detection\n// subscriber 2: object tracking\n// subscriber 3: recording/logging",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:119:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 119,
      "lineEnd": 123,
      "language": "rust",
      "code": "// Many nodes publish diagnostics, one logger subscribes\nlet diag_pub: Hub<DiagMsg> = Hub::new(\"diagnostics\")?;\nlet logger: Hub<DiagMsg> = Hub::new(\"diagnostics\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:126:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 126,
      "lineEnd": 130,
      "language": "rust",
      "code": "// Events trigger actions in multiple subsystems\nlet event_pub: Hub<EmergencyStop> = Hub::new(\"estop\")?;\n// All motor controllers subscribe and react",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:140:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 140,
      "lineEnd": 147,
      "language": "rust",
      "code": "// IMU → State Estimator → Controller → Motors\n// Each stage connected by a Link (248ns latency)\nstruct FlightController {\n    imu_input: Link<ImuData>,\n    motor_output: Link<MotorCommands>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:150:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 150,
      "lineEnd": 156,
      "language": "rust",
      "code": "// Sensor → Filter → Processor\nlet raw_output: Link<RawData> = Link::producer(\"raw\")?;\nlet raw_input: Link<RawData> = Link::consumer(\"raw\")?;\n\nlet filtered_output: Link<FilteredData> = Link::producer(\"filtered\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:159:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 159,
      "lineEnd": 163,
      "language": "rust",
      "code": "// Always want the newest sensor reading\nlet lidar: Link<LidarScan> = Link::consumer(\"lidar\")?;\n// Old scans are irrelevant - only latest matters",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:174:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 174,
      "lineEnd": 185,
      "language": "rust",
      "code": "struct RobotSystem {\n    // Link for critical control loop (248ns)\n    imu_link: Link<ImuData>,\n    motor_link: Link<MotorCommands>,\n\n    // Hub for broadcasting and monitoring (481ns)\n    status_hub: Hub<RobotStatus>,\n    diagnostics_hub: Hub<DiagMsg>,\n    camera_hub: Hub<Image>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:193:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 193,
      "lineEnd": 208,
      "language": "rust",
      "code": "// Multiple sensors → One fusion node (Hub)\nlet imu_pub: Hub<ImuData> = Hub::new(\"sensors.imu\")?;\nlet gps_pub: Hub<GpsData> = Hub::new(\"sensors.gps\")?;\nlet lidar_pub: Hub<LidarScan> = Hub::new(\"sensors.lidar\")?;\n\n// Fusion node subscribes to all\nstruct FusionNode {\n    imu_sub: Hub<ImuData>,\n    gps_sub: Hub<GpsData>,\n    lidar_sub: Hub<LidarScan>,\n\n    // Fused output via Link (high performance)\n    state_output: Link<StateEstimate>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:212:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 212,
      "lineEnd": 221,
      "language": "rust",
      "code": "// One joystick → Multiple motors (Hub)\nlet joystick_pub: Hub<JoystickCmd> = Hub::new(\"joystick\")?;\n\n// Each motor controller subscribes\nstruct MotorController {\n    cmd_sub: Hub<JoystickCmd>,\n    motor_output: Link<MotorPWM>,  // Link to actual motor driver\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:225:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 225,
      "lineEnd": 233,
      "language": "rust",
      "code": "// Sequential processing (all Link)\nlet raw: Link<RawImage> = Link::producer(\"raw\")?;\nlet filtered: Link<FilteredImage> = Link::producer(\"filtered\")?;\nlet detected: Link<Detections> = Link::producer(\"detected\")?;\n\n// raw → filter → detector → tracker\n// Each stage: Link input → process → Link output",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-overview:239:rust",
      "file": "content/docs/concepts/communication-overview.mdx",
      "lineStart": 239,
      "lineEnd": 247,
      "language": "rust",
      "code": "// Local shared memory (default)\nlet hub: Hub<Data> = Hub::new(\"topic\")?;           // 481ns\nlet link: Link<Data> = Link::producer(\"topic\")?;   // 248ns\n\n// Network (just change the endpoint)\nlet hub: Hub<Data> = Hub::new(\"topic@192.168.1.5\")?;        // &lt;50µs\nlet link: Link<Data> = Link::producer(\"topic@192.168.1.5:9000\")?;  // 5-15µs",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:32:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 32,
      "lineEnd": 36,
      "language": "rust",
      "code": "// Automatically uses shared memory\nlet hub: Hub<SensorData> = Hub::new(\"sensors\")?;\nlet link: Link<ImuData> = Link::producer(\"imu\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:50:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 50,
      "lineEnd": 54,
      "language": "rust",
      "code": "// Automatically uses network backend\nlet hub: Hub<SensorData> = Hub::new(\"sensors@192.168.1.5\")?;\nlet link: Link<ImuData> = Link::producer(\"imu@192.168.1.5:9000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:98:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 98,
      "lineEnd": 102,
      "language": "rust",
      "code": "// Raspberry Pi robot with multiple processes\nlet camera: Hub<Image> = Hub::new(\"camera\")?;\nlet motors: Link<MotorCmd> = Link::producer(\"motors\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:105:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 105,
      "lineEnd": 110,
      "language": "rust",
      "code": "// All nodes on your laptop\nhorus run sensors.rs &\nhorus run controller.rs &\nhorus run motors.rs &",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:113:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 113,
      "lineEnd": 117,
      "language": "rust",
      "code": "// 1kHz control loop (1ms period)\n// 248ns Link latency leaves plenty of headroom\nlet state: Link<State> = Link::consumer(\"state\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:120:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 120,
      "lineEnd": 124,
      "language": "rust",
      "code": "// Streaming 30 FPS camera at 1920x1080\n// ~60MB/sec throughput\nlet camera: Hub<Image> = Hub::new(\"camera\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:143:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 143,
      "lineEnd": 150,
      "language": "rust",
      "code": "// Robot fleet coordination\n// Robot 1 (192.168.1.10)\nlet position_pub: Hub<Position> = Hub::new(\"fleet.positions@router\")?;\n\n// Robot 2 (192.168.1.20) subscribes\nlet positions: Hub<Position> = Hub::new(\"fleet.positions@router\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:153:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 153,
      "lineEnd": 160,
      "language": "rust",
      "code": "// Camera on edge device, processing on server\n// Edge device (192.168.1.50)\nlet camera: Link<Image> = Link::producer(\"camera@192.168.1.100:9000\")?;\n\n// Server (192.168.1.100) processes images\nlet images: Link<Image> = Link::consumer(\"camera@0.0.0.0:9000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:163:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 163,
      "lineEnd": 171,
      "language": "rust",
      "code": "// Multiple sensors across warehouse\n// Sensor nodes at different locations\nlet sensor1: Hub<Temperature> = Hub::new(\"sensors@192.168.1.5\")?;\nlet sensor2: Hub<Temperature> = Hub::new(\"sensors@192.168.1.6\")?;\n\n// Central aggregator\nlet temps: Hub<Temperature> = Hub::new(\"sensors@router\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:174:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 174,
      "lineEnd": 181,
      "language": "rust",
      "code": "// Robot in field, monitoring monitor on laptop\n// Robot publishes status\nlet status: Hub<RobotStatus> = Hub::new(\"status@192.168.1.100\")?;\n\n// Monitor on laptop subscribes\nlet monitor: Hub<RobotStatus> = Hub::new(\"status@0.0.0.0:8080\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:203:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 203,
      "lineEnd": 216,
      "language": "rust",
      "code": "struct RobotSystem {\n    // Local: Critical control loop on same machine\n    imu: Link<ImuData>,           // 248ns latency\n    motors: Link<MotorCmd>,       // 248ns latency\n\n    // Network: Communication with other robots\n    fleet_position: Hub<Position>, // &lt;50µs latency (acceptable)\n    camera_stream: Hub<Image>,     // Network to processing server\n}\n\n// Critical loop stays local (fast)\n// Fleet coordination uses network (still fast enough)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:220:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 220,
      "lineEnd": 235,
      "language": "rust",
      "code": "// === ON DRONE (192.168.1.50) ===\n// Local: Flight control loop (ultra-fast)\nlet imu_local: Link<ImuData> = Link::producer(\"imu\")?;              // 248ns\nlet motors_local: Link<MotorCmd> = Link::consumer(\"motors\")?;      // 248ns\n\n// Network: Telemetry to ground station\nlet telemetry: Hub<Telemetry> = Hub::new(\"telem@192.168.1.100\")?;  // &lt;50µs\n\n// === ON GROUND STATION (192.168.1.100) ===\n// Network: Receive telemetry from drone\nlet telem_sub: Hub<Telemetry> = Hub::new(\"telem@0.0.0.0:8000\")?;\n\n// Network: Send commands to drone\nlet cmd_pub: Hub<Command> = Hub::new(\"cmd@192.168.1.50\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:241:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 241,
      "lineEnd": 250,
      "language": "rust",
      "code": "// Local (no '@' in topic name)\nHub::new(\"sensors\")?                          // → Shared memory\n\n// Network (contains '@')\nHub::new(\"sensors@192.168.1.5\")?              // → UDP to 192.168.1.5\nHub::new(\"sensors@192.168.1.5:9000\")?         // → UDP with custom port\nLink::producer(\"imu@192.168.1.5:9000\")?       // → TCP to 192.168.1.5:9000\nLink::consumer(\"imu@0.0.0.0:9000\")?           // → TCP listen on port 9000",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:320:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 320,
      "lineEnd": 330,
      "language": "rust",
      "code": "// Critical: Local (never fails)\nlet motors: Link<MotorCmd> = Link::consumer(\"motors\")?;\n\n// Non-critical: Network (can tolerate failures)\nlet telemetry: Hub<Status> = Hub::new(\"status@gcs\")?;\nif let Err(_) = telemetry.send(status, &mut ctx) {\n    // Telemetry failed, but motors still work\n    ctx.log_warning(\"Telemetry unavailable\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/communication-transport:336:toml",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 336,
      "lineEnd": 345,
      "language": "toml",
      "code": "# horus.toml\n[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@192.168.1.100\"  # Network\n\n[hubs.motors]\nname = \"motors\"\nendpoint = \"motors\"  # Local (no @)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/communication-transport:347:rust",
      "file": "content/docs/concepts/communication-transport.mdx",
      "lineStart": 347,
      "lineEnd": 351,
      "language": "rust",
      "code": "// Load from config\nlet telemetry: Hub<Status> = Hub::from_config(\"telemetry\")?;\nlet motors: Link<MotorCmd> = Link::consumer_from_config(\"motors\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:42:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 42,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a Hub for f32 values on topic \"velocity\"\nlet hub: Hub<f32> = Hub::new(\"velocity\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:56:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 56,
      "lineEnd": 90,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct Publisher {\n    velocity_pub: Hub<f32>,\n}\n\nimpl Publisher {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            velocity_pub: Hub::new(\"velocity\")?,\n        })\n    }\n}\n\nimpl Node for Publisher {\n    fn name(&self) -> &'static str {\n        \"Publisher\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let velocity = 1.5;\n\n        // Send message\n        match self.velocity_pub.send(velocity, &mut ctx) {\n            Ok(()) => {\n                // Message sent successfully\n            }\n            Err(msg) => {\n                // Failed to send, msg contains the original value\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:94:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 94,
      "lineEnd": 124,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct Subscriber {\n    velocity_sub: Hub<f32>,\n}\n\nimpl Subscriber {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            velocity_sub: Hub::new(\"velocity\")?,\n        })\n    }\n}\n\nimpl Node for Subscriber {\n    fn name(&self) -> &'static str {\n        \"Subscriber\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Receive message\n        if let Some(velocity) = self.velocity_sub.recv(&mut ctx) {\n            // Process the received message\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\"Received velocity: {}\", velocity));\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:132:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 132,
      "lineEnd": 135,
      "language": "rust",
      "code": "// Automatically uses local shared memory\nlet hub: Hub<SensorData> = Hub::new(\"sensors\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:143:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 143,
      "lineEnd": 147,
      "language": "rust",
      "code": "// Automatically uses network backend\nlet hub: Hub<SensorData> = Hub::new(\"sensors@192.168.1.5\")?;\nlet hub: Hub<SensorData> = Hub::new(\"sensors@192.168.1.5:8000\")?;  // Custom port",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:161:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 161,
      "lineEnd": 163,
      "language": "rust",
      "code": "pub fn send(&self, msg: T, ctx: &mut Option<&mut NodeInfo>) -> Result<(), T>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:181:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 181,
      "lineEnd": 183,
      "language": "rust",
      "code": "pub fn recv(&self, ctx: &mut Option<&mut NodeInfo>) -> Option<T>",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:203:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 203,
      "lineEnd": 211,
      "language": "rust",
      "code": "pub enum ConnectionState {\n    Disconnected,\n    Connecting,\n    Connected,\n    Reconnecting,\n    Failed,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:215:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 215,
      "lineEnd": 219,
      "language": "rust",
      "code": "pub fn get_connection_state(&self) -> ConnectionState {\n    // Returns current connection state\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:223:text",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 223,
      "lineEnd": 229,
      "language": "text",
      "code": "Disconnected  Connecting  Connected\n                               ->\n                          Reconnecting  Connected\n                               ->\n                            Failed",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:235:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 235,
      "lineEnd": 250,
      "language": "rust",
      "code": "pub struct AtomicHubMetrics {\n    pub messages_sent: AtomicU64,\n    pub messages_received: AtomicU64,\n    pub send_failures: AtomicU64,\n    pub recv_failures: AtomicU64,\n}\n\npub struct HubMetrics {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub send_failures: u64,\n    pub recv_failures: u64,\n    pub last_activity: Option<Instant>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:254:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 254,
      "lineEnd": 266,
      "language": "rust",
      "code": "let hub: Hub<f32> = Hub::new(\"velocity\")?;\n\n// Send some messages (requires mutable ctx)\nlet mut ctx: Option<&mut NodeInfo> = None;\nhub.send(1.0, &mut ctx).ok();\nhub.send(2.0, &mut ctx).ok();\n\n// Get metrics\nlet metrics = hub.get_metrics();\neprintln!(\"Total sent: {}\", metrics.messages_sent);\neprintln!(\"Send failures: {}\", metrics.send_failures);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:274:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 274,
      "lineEnd": 302,
      "language": "rust",
      "code": "// Publisher\nstruct PubNode {\n    data_pub: Hub<f32>,\n}\n\nimpl Node for PubNode {\n    fn name(&self) -> &'static str { \"PubNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.data_pub.send(42.0, &mut ctx).ok();\n    }\n}\n\n// Subscriber\nstruct SubNode {\n    data_sub: Hub<f32>,\n}\n\nimpl Node for SubNode {\n    fn name(&self) -> &'static str { \"SubNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_sub.recv(&mut ctx) {\n            ctx.log_info(&format!(\"Got: {}\", data));\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:308:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 308,
      "lineEnd": 328,
      "language": "rust",
      "code": "// One publisher\nstruct Broadcaster {\n    broadcast_pub: Hub<String>,\n}\n\n// Multiple subscribers\nstruct Listener1 {\n    broadcast_sub: Hub<String>,\n}\n\nstruct Listener2 {\n    broadcast_sub: Hub<String>,\n}\n\nstruct Listener3 {\n    broadcast_sub: Hub<String>,\n}\n\n// All subscribers receive the same message",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:334:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 334,
      "lineEnd": 359,
      "language": "rust",
      "code": "// Multiple publishers\nstruct Sensor1 {\n    reading_pub: Hub<f32>,\n}\n\nstruct Sensor2 {\n    reading_pub: Hub<f32>,\n}\n\n// Single aggregator\nstruct Aggregator {\n    reading_sub: Hub<f32>,\n}\n\nimpl Node for Aggregator {\n    fn name(&self) -> &'static str { \"Aggregator\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Receives from any publisher on this topic\n        if let Some(reading) = self.reading_sub.recv(&mut ctx) {\n            self.process(reading);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:365:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 365,
      "lineEnd": 378,
      "language": "rust",
      "code": "// All nodes can publish and subscribe to the same topic\nstruct Agent1 {\n    state_pub: Hub<RobotState>,\n    state_sub: Hub<RobotState>,\n}\n\nstruct Agent2 {\n    state_pub: Hub<RobotState>,\n    state_sub: Hub<RobotState>,\n}\n\n// Agents share state with each other",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:386:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 386,
      "lineEnd": 394,
      "language": "rust",
      "code": "// CORRECT - Use dots\nlet hub = Hub::new(\"sensors.lidar\");\nlet hub = Hub::new(\"robot.cmd_vel\");\n\n// WRONG - Do NOT use slashes\nlet hub = Hub::new(\"sensors.lidar\");   // Will cause errors!\nlet hub = Hub::new(\"robot.cmd_vel\");   // Will cause errors!",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:400:text",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 400,
      "lineEnd": 403,
      "language": "text",
      "code": "Topic: \"sensors.lidar\"  →  /dev/shm/horus_default_sensors.lidar\nTopic: \"sensors.lidar\"  →  /dev/shm/horus_default_sensors/lidar  (ERROR!)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:419:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 419,
      "lineEnd": 422,
      "language": "rust",
      "code": "let hub = Hub::new(\"cmd_vel\");           // Good\nlet hub = Hub::new(\"data\");              // Too vague",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:425:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 425,
      "lineEnd": 429,
      "language": "rust",
      "code": "let hub = Hub::new(\"sensor.lidar\");      // Hierarchical\nlet hub = Hub::new(\"robot1.cmd_vel\");    // Namespaced\nlet hub = Hub::new(\"diagnostics.cpu\");   // Categorized",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:432:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 432,
      "lineEnd": 437,
      "language": "rust",
      "code": "// Pick one style and stick to it\n\"cmd_vel\"       // Snake case\n\"cmdVel\"        // Camel case\n\"CmdVel\"        // Pascal case",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:451:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 451,
      "lineEnd": 462,
      "language": "rust",
      "code": "match hub.send(data, &mut ctx) {\n    Ok(()) => {\n        // Success\n    }\n    Err(original_data) => {\n        // Failed to send - shared memory full or not available\n        // original_data contains the message that couldn't be sent\n        ctx.log_warning(\"Failed to publish message\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:471:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 471,
      "lineEnd": 481,
      "language": "rust",
      "code": "match hub.recv(&mut ctx) {\n    Some(data) => {\n        // Process data\n    }\n    None => {\n        // No data available - this is normal\n        // Don't treat this as an error\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:489:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 489,
      "lineEnd": 509,
      "language": "rust",
      "code": "// Simple types work out of the box\nHub::<f32>::new(\"float_topic\");\nHub::<bool>::new(\"bool_topic\");\nHub::<u32>::new(\"int_topic\");\n\n// Structs need derives\n#[derive(Clone, Debug)]\nstruct MyMessage {\n    x: f32,\n    y: f32,\n}\n\nHub::<MyMessage>::new(\"my_topic\");\n\n// Arrays work\nHub::<[f32; 100]>::new(\"array_topic\");\n\n// Strings work\nHub::<String>::new(\"string_topic\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:513:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 513,
      "lineEnd": 525,
      "language": "rust",
      "code": "// Missing Clone\nstruct NoClone {\n    data: f32,\n}\n// Hub::<NoClone>::new(\"topic\"); // Won't compile\n\n// Missing Send\nstruct NoSend {\n    ptr: *const u8,  // Raw pointers are !Send\n}\n// Hub::<NoSend>::new(\"topic\"); // Won't compile",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:533:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 533,
      "lineEnd": 544,
      "language": "rust",
      "code": "impl Node for ConditionalPublisher {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let data = self.read_sensor();\n\n        // Only publish if above threshold\n        if data > self.threshold {\n            self.alert_pub.send(data, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:550:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 550,
      "lineEnd": 569,
      "language": "rust",
      "code": "struct BufferedSubscriber {\n    data_sub: Hub<f32>,\n    last_value: Option<f32>,\n}\n\nimpl Node for BufferedSubscriber {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update cached value if new message available\n        if let Some(value) = self.data_sub.recv(&mut ctx) {\n            self.last_value = Some(value);\n        }\n\n        // Always have access to last value\n        if let Some(value) = self.last_value {\n            self.process(value);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:575:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 575,
      "lineEnd": 592,
      "language": "rust",
      "code": "struct RateLimitedPublisher {\n    data_pub: Hub<f32>,\n    tick_count: u32,\n    publish_every_n_ticks: u32,\n}\n\nimpl Node for RateLimitedPublisher {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.tick_count += 1;\n\n        // Publish every 10 ticks (~6 Hz at 60 FPS)\n        if self.tick_count % self.publish_every_n_ticks == 0 {\n            self.data_pub.send(42.0, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:598:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 598,
      "lineEnd": 609,
      "language": "rust",
      "code": "impl Node for FilteringSubscriber {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_sub.recv(&mut ctx) {\n            // Only process valid data\n            if data.is_valid() && data.quality > 0.8 {\n                self.process(data);\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:617:bash",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 617,
      "lineEnd": 620,
      "language": "bash",
      "code": "# View HORUS shared memory segments\nls -lh /dev/shm/horus_*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:626:bash",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 626,
      "lineEnd": 628,
      "language": "bash",
      "code": "df -h /dev/shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:636:bash",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 636,
      "lineEnd": 639,
      "language": "bash",
      "code": "# Remove all HORUS shared memory\nrm -f /dev/shm/horus_*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:684:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 684,
      "lineEnd": 690,
      "language": "rust",
      "code": "// Good: Fixed-size array for known dimensions\nHub::<[f32; 3]>::new(\"position\");\n\n// Bad: Vec requires heap allocation\nHub::<Vec<f32>>::new(\"position\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:696:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 696,
      "lineEnd": 707,
      "language": "rust",
      "code": "// Good: Small struct\n#[derive(Clone, Debug)]\nstruct Pose {\n    x: f32,\n    y: f32,\n    theta: f32,\n}\n\n// Consider Arc for large data\nHub::<Arc<LargeData>>::new(\"big_data\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:713:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 713,
      "lineEnd": 720,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Check EVERY tick\n    if let Some(msg) = self.sub.recv(&mut ctx) {\n        self.process(msg);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-hub:726:rust",
      "file": "content/docs/concepts/core-concepts-hub.mdx",
      "lineStart": 726,
      "lineEnd": 730,
      "language": "rust",
      "code": "if let Err(data) = self.pub.send(data, &mut ctx) {\n        ctx.log_warning(\"Publish failed\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:35:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 35,
      "lineEnd": 43,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Producer side\nlet output: Link<SensorData> = Link::producer(\"imu_raw\")?;\n\n// Consumer side (different node/process)\nlet input: Link<SensorData> = Link::consumer(\"imu_raw\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:47:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 47,
      "lineEnd": 50,
      "language": "rust",
      "code": "let data = SensorData { x: 1.0, y: 2.0, z: 3.0 };\noutput.send(data, &mut ctx)?; // ctx enables logging",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:54:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 54,
      "lineEnd": 58,
      "language": "rust",
      "code": "if let Some(data) = input.recv(&mut ctx) {\n    ctx.log_info(&format!(\"Received: {:?}\", data));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:66:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 66,
      "lineEnd": 70,
      "language": "rust",
      "code": "// Automatically uses local shared memory\nlet output: Link<SensorData> = Link::producer(\"sensors\")?;\nlet input: Link<SensorData> = Link::consumer(\"sensors\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:78:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 78,
      "lineEnd": 84,
      "language": "rust",
      "code": "// Producer connects to consumer\nlet output: Link<SensorData> = Link::producer(\"sensors@192.168.1.5:9000\")?;\n\n// Consumer listens for producer\nlet input: Link<SensorData> = Link::consumer(\"sensors@0.0.0.0:9000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:125:text",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 125,
      "lineEnd": 137,
      "language": "text",
      "code": "┌─────────────────────────────────────────────────────────┐\n│ Header (64 bytes, cache-aligned)                       │\n├─────────────────────────────────────────────────────────┤\n│  - sequence: AtomicU64 (version counter)               │\n│  - element_size: AtomicUsize (validation)              │\n│  - _padding: [u8; 48] (cache line alignment)           │\n├─────────────────────────────────────────────────────────┤\n│ Single Data Slot (sizeof(T) bytes)                     │\n├─────────────────────────────────────────────────────────┤\n│  - Value: T (always the latest message)                │\n└─────────────────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-link:188:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 188,
      "lineEnd": 205,
      "language": "rust",
      "code": "// IMU  State Estimator  Controller  Motors\n// Each stage connected by a Link\n\nstruct ImuNode {\n    output: Link<ImuData>,\n}\n\nstruct EstimatorNode {\n    input: Link<ImuData>,\n    output: Link<StateEstimate>,\n}\n\nstruct ControllerNode {\n    input: Link<StateEstimate>,\n    output: Link<MotorCommands>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:209:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 209,
      "lineEnd": 238,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct SensorNode {\n    output: Link<LidarScan>,\n}\n\nimpl SensorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            output: Link::producer(\"lidar\")?,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str { \"SensorNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let scan = self.read_lidar();\n        self.output.send(scan, &mut ctx).ok();\n        thread::sleep(Duration::from_millis(10)); // 100Hz\n    }\n}\n\n// Run with scheduler\nlet mut scheduler = Scheduler::new();\nscheduler.add(Box::new(SensorNode::new()?), 0, Some(true));\nscheduler.run()?;",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:242:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 242,
      "lineEnd": 255,
      "language": "rust",
      "code": "// Check Link health\nlet metrics = link.get_metrics();\neprintln!(\"Sent: {}, Received: {}\",\n    metrics.messages_sent,\n    metrics.messages_received\n);\n\n// Large difference = consumer not keeping up (messages being skipped)\nlet skipped = metrics.messages_sent - metrics.messages_received;\nif skipped > 100 {\n    eprintln!(\"Warning: Consumer skipped {} messages!\", skipped);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:263:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 263,
      "lineEnd": 266,
      "language": "rust",
      "code": "// Link::send() always returns Ok(()) - it overwrites the previous value\nlink.send(data, &mut ctx).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:277:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 277,
      "lineEnd": 284,
      "language": "rust",
      "code": "if let Some(data) = link.recv(&mut ctx) {\n    process(data);\n} else {\n    // No messages available - this is normal, not an error\n    // Consumer is faster than producer\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:290:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 290,
      "lineEnd": 297,
      "language": "rust",
      "code": "let metrics = link.get_metrics();\nlet skipped = metrics.messages_sent - metrics.messages_received;\nif skipped > 0 {\n    eprintln!(\"Consumer skipped {} messages - may be too slow!\",\n        skipped);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:303:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 303,
      "lineEnd": 309,
      "language": "rust",
      "code": "// Enable logging when adding node\nscheduler.add(Box::new(node), 0, Some(true));\n\n// In tick():\nlink.send(data, &mut ctx)?; // Logs: [NodeName] PUB sensor_data (234ns)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-link:351:rust",
      "file": "content/docs/concepts/core-concepts-link.mdx",
      "lineStart": 351,
      "lineEnd": 374,
      "language": "rust",
      "code": "// Real-world usage from HORUS test suite\nstruct FlightController {\n    state_input: Link<StateEstimate>,    // From estimator\n    motor_output: Link<MotorCommands>,   // To motor driver\n}\n\nimpl Node for FlightController {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read latest state (248ns)\n        if let Some(state) = self.state_input.recv(&mut ctx) {\n            let commands = self.compute_pd_control(state);\n\n            // Send motor commands (248ns)\n            if let Err(_) = self.motor_output.send(commands, &mut ctx) {\n                eprintln!(\"Motor buffer full!\"); // Safety critical!\n            }\n        }\n\n        // Total latency: ~600ns including processing\n        // Runs at 1kHz (1ms period)\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:40:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 40,
      "lineEnd": 57,
      "language": "rust",
      "code": "pub trait Node: Send {\n    // Required - identify your node\n    fn name(&self) -> &'static str;\n\n    // Required - your main logic runs here\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>);\n\n    // Optional - setup when node starts\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()>;\n\n    // Optional - cleanup when node stops\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()>;\n\n    // Optional - node's preferred tick rate (Hz)\n    fn rate_hz(&self) -> Option<f64> { None }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:65:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 65,
      "lineEnd": 69,
      "language": "rust",
      "code": "fn name(&self) -> &'static str {\n    \"MyNode\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:73:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 73,
      "lineEnd": 80,
      "language": "rust",
      "code": "node! {\n    SensorNode {\n        name: \"imu_front\",  // Explicit name instead of \"sensor_node\"\n        tick(ctx) { ... }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:86:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 86,
      "lineEnd": 90,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Your node logic here\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:96:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 96,
      "lineEnd": 102,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"Node starting up\");\n    // Initialize resources, open files, etc.\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:106:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 106,
      "lineEnd": 112,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"Node shutting down\");\n    // Clean up resources, close connections, etc.\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:116:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 116,
      "lineEnd": 120,
      "language": "rust",
      "code": "fn rate_hz(&self) -> Option<f64> {\n    Some(100.0)  // This node runs at 100Hz\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:170:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 170,
      "lineEnd": 202,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct LifecycleDemo {\n    counter: u32,\n}\n\nimpl Node for LifecycleDemo {\n    fn name(&self) -> &'static str {\n        \"LifecycleDemo\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Called ONCE when node starts\n        ctx.log_info(\"Initializing resources\");\n        self.counter = 0;\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Called REPEATEDLY in main loop (~60 FPS default)\n        self.counter += 1;\n\n        ctx.log_debug(&format!(\"Tick #{}\", self.counter));\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Called ONCE during graceful shutdown\n        ctx.log_info(&format!(\"Shutting down after {} ticks\", self.counter));\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:210:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 210,
      "lineEnd": 220,
      "language": "rust",
      "code": "pub struct NodeInfo {\n    pub name: &'static str,\n    pub state: NodeState,\n    pub priority: u32,  // Lower number = higher priority (0 = highest)\n    pub metrics: NodeMetrics,\n    pub publishers: Vec<TopicMetadata>,\n    pub subscribers: Vec<TopicMetadata>,\n    // Internal timing and logging fields\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:226:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 226,
      "lineEnd": 228,
      "language": "rust",
      "code": "ctx.log_info(\"Robot ready\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:232:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 232,
      "lineEnd": 234,
      "language": "rust",
      "code": "ctx.log_warning(\"Battery low\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:238:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 238,
      "lineEnd": 240,
      "language": "rust",
      "code": "ctx.log_error(\"Sensor disconnected\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:244:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 244,
      "lineEnd": 246,
      "language": "rust",
      "code": "ctx.log_debug(&format!(\"Position: ({}, {})\", x, y));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:252:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 252,
      "lineEnd": 264,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Automatic pub logging - just pass ctx to send()\n    self.velocity_pub.send(1.5, &mut ctx).ok();\n    // Output: [12:34:56.789] [IPC: 437ns | Tick: 12μs] MyNode --PUB--> 'cmd_vel' = 1.5\n\n    // Automatic sub logging - just pass ctx to recv()\n    if let Some(scan) = self.lidar_sub.recv(&mut ctx) {\n        // Output: [12:34:56.789] [IPC: 142ns | Tick: 8μs] MyNode <--SUB-- 'laser_scan' = LaserScan { ... }\n        self.process(scan);\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:272:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 272,
      "lineEnd": 289,
      "language": "rust",
      "code": "pub struct NodeMetrics {\n    pub total_ticks: u64,\n    pub successful_ticks: u64,\n    pub failed_ticks: u64,\n    pub avg_tick_duration_ms: f64,\n    pub max_tick_duration_ms: f64,\n    pub min_tick_duration_ms: f64,\n    pub last_tick_duration_ms: f64,\n    pub cpu_usage_percent: f64,\n    pub memory_usage_bytes: u64,\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub errors_count: u64,\n    pub warnings_count: u64,\n    pub uptime_seconds: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:293:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 293,
      "lineEnd": 302,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(ctx) = ctx {\n        let avg_duration = ctx.metrics.avg_tick_duration_ms;\n        if avg_duration > 1.0 {\n            ctx.log_warning(\"Tick duration exceeding 1ms\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:322:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 322,
      "lineEnd": 329,
      "language": "rust",
      "code": "// Recommended priority constants\nconst CRITICAL: u32    = 0;   // Highest priority\nconst HIGH: u32        = 10;\nconst NORMAL: u32      = 50;  // Default\nconst LOW: u32         = 80;\nconst BACKGROUND: u32  = 100; // Lowest priority",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:335:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 335,
      "lineEnd": 357,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut scheduler = Scheduler::new();\n\n// Safety monitor runs FIRST every tick (priority 0)\nscheduler.add(Box::new(safety_node), 0, None);\n\n// Controller runs second (priority 10)\nscheduler.add(Box::new(control_node), 10, None);\n\n// Sensors run third (priority 50)\nscheduler.add(Box::new(sensor_node), 50, None);\n\n// Logging runs LAST (priority 100)\nscheduler.add(Box::new(logger_node), 100, None);\n\n// Fine-grained priorities for complex systems\nscheduler.add(Box::new(emergency_stop), 0, None);    // Highest\nscheduler.add(Box::new(motor_control), 15, None);    // Between HIGH and NORMAL\nscheduler.add(Box::new(vision_processing), 55, None); // Slightly lower than normal\nscheduler.add(Box::new(telemetry), 90, None);        // Between LOW and BACKGROUND",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:377:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 377,
      "lineEnd": 402,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct SensorNode {\n    data_pub: Hub<f32>,\n}\n\nimpl SensorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            data_pub: Hub::new(\"sensor_data\")?,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str {\n        \"SensorNode\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let data = 42.0; // Read sensor\n        self.data_pub.send(data, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:408:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 408,
      "lineEnd": 420,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nnode! {\n    name: SensorNode,\n    publishers: [sensor_data: f32],\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let data = 42.0;\n        self.sensor_data.send(data, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:432:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 432,
      "lineEnd": 443,
      "language": "rust",
      "code": "struct Publisher {\n    data_pub: Hub<f32>,\n}\n\nimpl Node for Publisher {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let data = self.generate_data();\n        self.data_pub.send(data, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:447:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 447,
      "lineEnd": 459,
      "language": "rust",
      "code": "struct Subscriber {\n    data_sub: Hub<f32>,\n}\n\nimpl Node for Subscriber {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_sub.recv(&mut ctx) {\n            self.process(data);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:463:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 463,
      "lineEnd": 477,
      "language": "rust",
      "code": "struct Filter {\n    input_sub: Hub<f32>,\n    output_pub: Hub<f32>,\n}\n\nimpl Node for Filter {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(input) = self.input_sub.recv(&mut ctx) {\n            let output = input * 2.0;\n            self.output_pub.send(output, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:481:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 481,
      "lineEnd": 496,
      "language": "rust",
      "code": "struct Aggregator {\n    input_a: Hub<f32>,\n    input_b: Hub<f32>,\n    output_pub: Hub<f32>,\n}\n\nimpl Node for Aggregator {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let (Some(a), Some(b)) = (self.input_a.recv(&mut ctx), self.input_b.recv(&mut ctx)) {\n            let result = a + b;\n            self.output_pub.send(result, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:504:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 504,
      "lineEnd": 516,
      "language": "rust",
      "code": "// GOOD: Fast computation\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let result = self.compute_quickly();\n    self.pub.send(result, &mut ctx).ok();\n}\n\n// BAD: Blocking I/O\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = std::fs::read_to_string(\"file.txt\").unwrap(); // Blocks!\n    // ...\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:535:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 535,
      "lineEnd": 557,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"Initializing MyMotorNode\");\n\n    // 1. Open hardware connections\n    self.serial_port = serialport::new(\"/dev/ttyUSB0\", 115200)\n        .open()\n        .map_err(|e| format!(\"Failed to open serial: {}\", e))?;\n\n    // 2. Pre-allocate buffers (avoid allocation in tick)\n    self.command_buffer = vec![0u8; 256];\n\n    // 3. Initialize hardware state\n    self.send_init_sequence()?;\n\n    // 4. Set initial values\n    self.velocity = 0.0;\n    self.is_armed = false;\n\n    ctx.log_info(\"MyMotorNode initialized successfully\");\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:574:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 574,
      "lineEnd": 596,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"MyMotorNode shutting down\");\n\n    // 1. CRITICAL: Stop all actuators FIRST\n    self.velocity = 0.0;\n    self.send_stop_command();\n\n    // 2. Disable hardware (safe state)\n    self.disable_motor_driver();\n\n    // 3. Close hardware connections\n    if let Some(port) = self.serial_port.take() {\n        drop(port);  // Closes the port\n    }\n\n    // 4. Save any important state\n    self.save_position_to_file()?;\n\n    ctx.log_info(\"MyMotorNode shutdown complete\");\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:602:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 602,
      "lineEnd": 691,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct MyMotorController {\n    // Hardware\n    serial_port: Option<Box<dyn serialport::SerialPort>>,\n\n    // Communication\n    cmd_sub: Hub<MotorCommand>,\n    status_pub: Hub<MotorStatus>,\n\n    // State\n    velocity: f64,\n    position: i32,\n    is_enabled: bool,\n}\n\nimpl MyMotorController {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            serial_port: None,\n            cmd_sub: Hub::new(\"motor.cmd\")?,\n            status_pub: Hub::new(\"motor.status\")?,\n            velocity: 0.0,\n            position: 0,\n            is_enabled: false,\n        })\n    }\n\n    fn send_velocity(&mut self, vel: f64) {\n        if let Some(ref mut port) = self.serial_port {\n            let cmd = format!(\"V{}\\n\", vel);\n            let _ = port.write(cmd.as_bytes());\n        }\n    }\n}\n\nimpl Node for MyMotorController {\n    fn name(&self) -> &'static str { \"MyMotorController\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Opening serial connection to motor controller\");\n\n        // Open hardware connection\n        self.serial_port = Some(\n            serialport::new(\"/dev/ttyUSB0\", 115200)\n                .timeout(std::time::Duration::from_millis(100))\n                .open()\n                .map_err(|e| format!(\"Serial open failed: {}\", e))?\n        );\n\n        // Initialize motor to stopped state\n        self.send_velocity(0.0);\n        self.is_enabled = true;\n\n        ctx.log_info(\"Motor controller ready\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Process commands\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            self.velocity = cmd.velocity;\n            self.send_velocity(self.velocity);\n        }\n\n        // Publish status\n        let status = MotorStatus {\n            velocity: self.velocity,\n            position: self.position,\n        };\n        self.status_pub.send(status, &mut ctx).ok();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Stopping motor for safe shutdown\");\n\n        // CRITICAL: Stop motor first!\n        self.velocity = 0.0;\n        self.send_velocity(0.0);\n\n        // Close serial port\n        self.serial_port = None;\n        self.is_enabled = false;\n\n        ctx.log_info(\"Motor stopped safely\");\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:712:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 712,
      "lineEnd": 719,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    if !self.sensor.is_available() {\n        return Err(\"Sensor not found\".into());\n    }\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:725:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 725,
      "lineEnd": 729,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        ctx.log_info(\"This is safe\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:735:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 735,
      "lineEnd": 743,
      "language": "rust",
      "code": "// GOOD\nstruct MyNode {\n    counter: u32,  // Instance state\n}\n\n// BAD\nstatic mut COUNTER: u32 = 0;  // Unsafe global state",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:749:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 749,
      "lineEnd": 758,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    self.device = Device::open().map_err(|e| {\n        Error::InitializationFailed(format!(\"Failed to open device: {}\", e))\n    })?;\n\n    ctx.log_info(\"Device opened successfully\");\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:766:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 766,
      "lineEnd": 775,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    match self.data_sub.recv(&mut ctx) {\n        Some(data) => self.process(data),\n        None => {\n            // No data available - this is normal\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:779:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 779,
      "lineEnd": 787,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    if let Err(e) = self.device.close() {\n        ctx.log_warning(&format!(\"Failed to close device: {}\", e));\n        // Continue shutdown anyway\n    }\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:795:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 795,
      "lineEnd": 804,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    self.tick_count += 1;\n\n    // Execute every 10 ticks\n    if self.tick_count % 10 == 0 {\n        self.slow_operation();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:810:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 810,
      "lineEnd": 842,
      "language": "rust",
      "code": "enum RobotState {\n    Idle,\n    Moving,\n    Stopped,\n}\n\nstruct RobotController {\n    state: RobotState,\n    cmd_sub: Hub<CmdVel>,\n}\n\nimpl Node for RobotController {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        match self.state {\n            RobotState::Idle => {\n                if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n                    self.state = RobotState::Moving;\n                }\n            }\n            RobotState::Moving => {\n                // Execute movement\n                if self.is_done() {\n                    self.state = RobotState::Stopped;\n                }\n            }\n            RobotState::Stopped => {\n                self.state = RobotState::Idle;\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:848:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 848,
      "lineEnd": 872,
      "language": "rust",
      "code": "struct Synchronizer {\n    topic_a: Hub<f32>,\n    topic_b: Hub<f32>,\n    last_a: Option<f32>,\n    last_b: Option<f32>,\n}\n\nimpl Node for Synchronizer {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update cached values\n        if let Some(a) = self.topic_a.recv(&mut ctx) {\n            self.last_a = Some(a);\n        }\n        if let Some(b) = self.topic_b.recv(&mut ctx) {\n            self.last_b = Some(b);\n        }\n\n        // Process when both available\n        if let (Some(a), Some(b)) = (self.last_a, self.last_b) {\n            self.process(a, b);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:903:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 903,
      "lineEnd": 916,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"Stopping all motors for safe shutdown\");\n\n    // Send stop command to all motors\n    self.emergency_stop();\n\n    // Optionally: disable motor drivers\n    self.disable_all_drivers();\n\n    ctx.log_info(\"Motors stopped safely\");\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:952:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 952,
      "lineEnd": 977,
      "language": "rust",
      "code": "impl Node for MyMotorController {\n    fn name(&self) -> &'static str { \"MyMotorController\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Normal operation - motors running\n        self.motor_pub.send(self.velocity, &mut ctx).ok();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"MyMotorController shutting down\");\n\n        // CRITICAL: Stop all motors\n        self.velocity = 0.0;\n        self.motor_pub.send(0.0, &mut None).ok();\n\n        // Close hardware connections\n        if let Some(port) = self.serial_port.take() {\n            port.close();\n        }\n\n        ctx.log_info(\"All motors stopped safely\");\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:983:bash",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 983,
      "lineEnd": 991,
      "language": "bash",
      "code": "# Start your application\nhorus run\n\n# In another terminal, send SIGINT\nkill -SIGINT <pid>\n\n# Or simply press Ctrl+C in the application terminal",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:994:text",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 994,
      "lineEnd": 997,
      "language": "text",
      "code": "[12:34:56.789] [INFO] MyMotorController shutting down\n[12:34:56.790] [INFO] All motors stopped safely",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-nodes:1007:rust",
      "file": "content/docs/concepts/core-concepts-nodes.mdx",
      "lineStart": 1007,
      "lineEnd": 1022,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    // Always try to stop motors, even if other cleanup fails\n    if let Err(e) = self.stop_motors() {\n        ctx.log_error(&format!(\"Failed to stop motors: {}\", e));\n        // Continue with other cleanup anyway\n    }\n\n    // Close connections (non-critical)\n    if let Err(e) = self.close_connection() {\n        ctx.log_warning(&format!(\"Failed to close connection: {}\", e));\n    }\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:40:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 40,
      "lineEnd": 53,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Add nodes (priority 0 = highest, logging enabled)\n    scheduler.add(Box::new(my_node), 0, Some(true));\n\n    // Run the scheduler\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:57:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 57,
      "lineEnd": 67,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut scheduler = Scheduler::new();\n\n// Add with priority 2 (Normal - default recommended)\nscheduler.add(Box::new(sensor_node), 2, Some(true));\n\n// Add with priority 0 (Critical - highest priority)\nscheduler.add(Box::new(safety_node), 0, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:71:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 71,
      "lineEnd": 83,
      "language": "rust",
      "code": "fn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Add your nodes\n    scheduler.add(Box::new(node1), 0, Some(true));\n    scheduler.add(Box::new(node2), 1, Some(true));\n\n    // Start the main loop\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:89:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 89,
      "lineEnd": 101,
      "language": "rust",
      "code": "pub struct Scheduler {\n    nodes: Vec<RegisteredNode>,\n    running: Arc<Mutex<bool>>,\n    tick_rate_fps: u32,\n}\n\nstruct RegisteredNode {\n    node: Box<dyn Node>,\n    context: NodeInfo,\n    priority: u32,  // Lower number = higher priority\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:111:text",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 111,
      "lineEnd": 123,
      "language": "text",
      "code": "1. Initialize all nodes (call init())\n2. Sort nodes by priority\n3. Main loop:\n   a. For each node (in priority order):\n      - Start tick timing\n      - Call node.tick()\n      - Record tick metrics\n   b. Sleep to maintain target FPS\n4. On shutdown signal:\n   a. Set running = false\n   b. Call shutdown() on all nodes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:129:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 129,
      "lineEnd": 147,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Default: 60 Hz (suitable for most robotics applications)\nlet scheduler = Scheduler::new();\n\n// Custom tick rate: 1 kHz for high-frequency control\nlet config = SchedulerConfig::standard()\n    .with_tick_rate(1000.0);  // 1000 Hz\nlet scheduler = Scheduler::new().with_config(config);\n\n// High-performance preset: 10 kHz\nlet config = SchedulerConfig::high_performance();  // 10,000 Hz\nlet scheduler = Scheduler::new().with_config(config);\n\n// Safety-critical preset: 1 kHz with strict timing\nlet config = SchedulerConfig::safety_critical();  // 1,000 Hz\nlet scheduler = Scheduler::new().with_config(config);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:160:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 160,
      "lineEnd": 167,
      "language": "rust",
      "code": "// Enable per-node rates and set individual node frequencies\nlet config = SchedulerConfig::standard();\nlet mut scheduler = Scheduler::new().with_config(config);\n\n// Set specific node to run at 100 Hz\nscheduler.set_node_rate(\"FastSensor\", 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:177:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 177,
      "lineEnd": 184,
      "language": "rust",
      "code": "// Recommended priority constants\nconst CRITICAL: u32    = 0;   // Highest priority - safety systems\nconst HIGH: u32        = 10;  // Control loops, actuators\nconst NORMAL: u32      = 50;  // Default - sensors, processing\nconst LOW: u32         = 80;  // Non-critical computation\nconst BACKGROUND: u32  = 100; // Logging, monitoring",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:192:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 192,
      "lineEnd": 202,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\n\n// Execution order: Safety → Controller → Sensor → Logger\nscheduler.add(Box::new(safety_monitor), 0, Some(true));    // Runs 1st (priority 0 - highest)\nscheduler.add(Box::new(controller), 10, Some(true));        // Runs 2nd (priority 10)\nscheduler.add(Box::new(sensor), 50, Some(true));            // Runs 3rd (priority 50)\nscheduler.add(Box::new(logger), 100, Some(true));           // Runs 4th (priority 100 - lowest)\n\nscheduler.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:220:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 220,
      "lineEnd": 222,
      "language": "rust",
      "code": "scheduler.add(Box::new(emergency_stop), 0, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:226:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 226,
      "lineEnd": 228,
      "language": "rust",
      "code": "scheduler.add(Box::new(motor_controller), 1, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:232:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 232,
      "lineEnd": 234,
      "language": "rust",
      "code": "scheduler.add(Box::new(lidar_node), 2, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:238:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 238,
      "lineEnd": 240,
      "language": "rust",
      "code": "scheduler.add(Box::new(path_planner), 3, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:244:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 244,
      "lineEnd": 246,
      "language": "rust",
      "code": "scheduler.add(Box::new(data_logger), 4, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:288:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 288,
      "lineEnd": 291,
      "language": "rust",
      "code": "let scheduler = Scheduler::new();\n// Runs at ~60 FPS (16ms per tick)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:311:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 311,
      "lineEnd": 313,
      "language": "rust",
      "code": "scheduler.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:321:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 321,
      "lineEnd": 323,
      "language": "rust",
      "code": "scheduler.tick(&[\"SensorNode\", \"MotorNode\"])?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:337:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 337,
      "lineEnd": 345,
      "language": "rust",
      "code": "// Automatically set up by run()\nctrlc::set_handler(move || {\n    eprintln!(\"\\nCtrl+C received! Shutting down HORUS scheduler...\");\n    if let Ok(mut r) = running.lock() {\n        *r = false;\n    }\n}).expect(\"Error setting HORUS signal handler\");",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:348:text",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 348,
      "lineEnd": 352,
      "language": "text",
      "code": "^C\nCtrl+C received! Shutting down HORUS scheduler...\n[Nodes shutting down gracefully...]",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:372:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 372,
      "lineEnd": 376,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    return Err(\"Sensor not connected\".into());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:388:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 388,
      "lineEnd": 392,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    panic!(\"Something went wrong!\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:400:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 400,
      "lineEnd": 409,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    match self.do_something() {\n        Ok(result) => { /* process */ }\n        Err(e) => {\n            ctx.log_error(&format!(\"Error: {}\", e));\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:415:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 415,
      "lineEnd": 419,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    Err(\"Failed to close connection\".into())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:432:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 432,
      "lineEnd": 445,
      "language": "rust",
      "code": "let metrics = scheduler.get_metrics();\n\nfor m in metrics {\n    println!(\"Node: {} (priority: {})\", m.name, m.priority);\n    println!(\"  Total ticks: {} (success: {}, failed: {})\",\n             m.total_ticks, m.successful_ticks, m.failed_ticks);\n    println!(\"  Tick duration: avg={:.2}ms, min={:.2}ms, max={:.2}ms\",\n             m.avg_tick_duration_ms, m.min_tick_duration_ms, m.max_tick_duration_ms);\n    println!(\"  Messages: sent={}, received={}\", m.messages_sent, m.messages_received);\n    println!(\"  Errors: {}, Warnings: {}\", m.errors_count, m.warnings_count);\n    println!(\"  Uptime: {:.2}s\", m.uptime_seconds);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:451:text",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 451,
      "lineEnd": 453,
      "language": "text",
      "code": "[12:34:56.789] [IPC: 437ns | Tick: 12μs] PublisherNode --PUB--> 'cmd_vel' = 1.5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:465:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 465,
      "lineEnd": 473,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\n\n// Start with basic nodes\nscheduler.add(Box::new(node1), 2, Some(true));\n\n// Later, add more nodes\nscheduler.add(Box::new(node2), 2, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:481:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 481,
      "lineEnd": 492,
      "language": "rust",
      "code": "impl Node for ConditionalNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if !self.should_run {\n            return;  // Skip this tick\n        }\n\n        // Execute normally\n        self.do_work();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:498:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 498,
      "lineEnd": 516,
      "language": "rust",
      "code": "use std::thread;\n\nfn main() -> Result<()> {\n    let mut scheduler1 = Scheduler::new();\n    scheduler1.add(Box::new(critical_nodes), 0, Some(true));\n\n    let mut scheduler2 = Scheduler::new();\n    scheduler2.add(Box::new(background_nodes), 4, Some(true));\n\n    // Run schedulers in separate threads\n    let handle1 = thread::spawn(move || scheduler1.run());\n    let handle2 = thread::spawn(move || scheduler2.run());\n\n    handle1.join().unwrap()?;\n    handle2.join().unwrap()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:527:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 527,
      "lineEnd": 537,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    // Pre-allocate buffers\n    self.buffer = vec![0.0; 10000];\n\n    // Open connections\n    self.connection = connect_to_hardware()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:543:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 543,
      "lineEnd": 554,
      "language": "rust",
      "code": "// GOOD: Fast tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = self.read_sensor();\n    self.pub.send(data, &mut ctx).ok();\n}\n\n// BAD: Slow tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    std::thread::sleep(Duration::from_millis(100));  // Blocks!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:560:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 560,
      "lineEnd": 568,
      "language": "rust",
      "code": "// GOOD: Appropriate priorities\nscheduler.add(Box::new(emergency_stop), 0, Some(true));  // Critical\nscheduler.add(Box::new(controller), 1, Some(true));      // High\nscheduler.add(Box::new(sensor), 2, Some(true));          // Normal\n\n// BAD: Everything is critical\nscheduler.add(Box::new(logger), 0, Some(true));  // Wrong!",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:574:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 574,
      "lineEnd": 589,
      "language": "rust",
      "code": "// GOOD: Handle errors\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    match self.operation() {\n        Ok(_) => {},\n        Err(e) => {\n            ctx.log_error(&format!(\"Error: {}\", e));\n        }\n    }\n}\n\n// BAD: Panic on error\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    self.operation().unwrap();  // Will crash scheduler!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:595:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 595,
      "lineEnd": 603,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(ctx) = ctx {\n        if ctx.metrics.avg_tick_duration_ms > 1.0 {\n            ctx.log_warning(\"Tick duration exceeding 1ms\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:611:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 611,
      "lineEnd": 631,
      "language": "rust",
      "code": "// Layer 1: Safety (Critical = 0)\nscheduler.add(Box::new(collision_detector), 0, Some(true));\nscheduler.add(Box::new(emergency_stop), 0, Some(true));\n\n// Layer 2: Control (High = 1)\nscheduler.add(Box::new(pid_controller), 1, Some(true));\nscheduler.add(Box::new(motor_driver), 1, Some(true));\n\n// Layer 3: Sensing (Normal = 2)\nscheduler.add(Box::new(lidar_node), 2, Some(true));\nscheduler.add(Box::new(camera_node), 2, Some(true));\nscheduler.add(Box::new(imu_node), 2, Some(true));\n\n// Layer 4: Processing (Low = 3)\nscheduler.add(Box::new(path_planner), 3, Some(true));\n\n// Layer 5: Monitoring (Background = 4)\nscheduler.add(Box::new(logger), 4, Some(true));\nscheduler.add(Box::new(diagnostics), 4, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:637:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 637,
      "lineEnd": 648,
      "language": "rust",
      "code": "// Sensor (Normal priority = 2)\nscheduler.add(Box::new(encoder_sensor), 2, Some(true));  // Publishes position\n\n// Controller (High priority = 1) - runs after sensor\nscheduler.add(Box::new(position_controller), 1, Some(true));\n// Subscribes to position, publishes velocity command\n\n// Actuator (High priority = 1)\nscheduler.add(Box::new(motor_actuator), 1, Some(true));\n// Subscribes to velocity command",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:654:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 654,
      "lineEnd": 664,
      "language": "rust",
      "code": "// Raw sensor (Normal = 2)\nscheduler.add(Box::new(raw_sensor), 2, Some(true));  // Publishes raw data\n\n// Filter (Normal = 2)\nscheduler.add(Box::new(kalman_filter), 2, Some(true));  // Subscribes to raw, publishes filtered\n\n// Analyzer (Low = 3)\nscheduler.add(Box::new(data_analyzer), 3, Some(true));\n// Subscribes to filtered data",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:672:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 672,
      "lineEnd": 685,
      "language": "rust",
      "code": "// WRONG: Infinite loop in tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    loop {  // Never returns!\n        // ...\n    }\n}\n\n// RIGHT: Return from tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Do work\n    // Return naturally\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:691:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 691,
      "lineEnd": 697,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"Initializing...\");\n    // If this fails, node won't run\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:703:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 703,
      "lineEnd": 712,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(ctx) = ctx {\n        let avg_ms = ctx.metrics.avg_tick_duration_ms;\n        if avg_ms > 1.0 {\n            ctx.log_warning(&format!(\"Slow tick: {:.2}ms\", avg_ms));\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:749:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 749,
      "lineEnd": 753,
      "language": "rust",
      "code": "// Set individual node tick rates\nscheduler.set_node_rate(\"FastSensor\", 100.0);   // 100 Hz\nscheduler.set_node_rate(\"SlowLogger\", 10.0);    // 10 Hz",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:757:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 757,
      "lineEnd": 773,
      "language": "rust",
      "code": "// Enable recording for debugging/replay\nlet scheduler = Scheduler::new()\n    .enable_recording(\"my_session\");\n\n// Later: replay a recorded session\nlet mut replay_scheduler = Scheduler::replay_from(\n    \"~/.horus/recordings/my_session\".into()\n)?;\nreplay_scheduler.run()?;\n\n// List available recordings\nlet recordings = Scheduler::list_recordings()?;\n\n// Delete a recording\nScheduler::delete_recording(\"old_session\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:787:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 787,
      "lineEnd": 799,
      "language": "rust",
      "code": "// Set real-time scheduling priority (requires root/CAP_SYS_NICE)\nscheduler.set_realtime_priority(80)?;\n\n// Pin scheduler to specific CPU core\nscheduler.pin_to_cpu(2)?;\n\n// Lock memory to prevent page faults\nscheduler.lock_memory()?;\n\n// Prefault stack to avoid runtime allocation\nscheduler.prefault_stack(8192)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:803:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 803,
      "lineEnd": 820,
      "language": "rust",
      "code": "// Validate pub/sub connections before running\nlet warnings = scheduler.validate_topology();\nfor warning in warnings {\n    println!(\"Topology warning: {}\", warning);\n}\n\n// Lock topology to prevent changes during execution\nscheduler.lock_topology();\n\n// Check if topology is locked\nif scheduler.is_topology_locked() {\n    println!(\"Topology is locked\");\n}\n\n// Get current topology (publishers, subscribers)\nlet (pubs, subs) = scheduler.get_topology();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-scheduler:824:rust",
      "file": "content/docs/concepts/core-concepts-scheduler.mdx",
      "lineStart": 824,
      "lineEnd": 836,
      "language": "rust",
      "code": "// Enable deterministic mode (reproducible runs)\nlet scheduler = Scheduler::new()\n    .enable_determinism();\n\n// Load execution profile from previous run\nlet scheduler = Scheduler::new()\n    .with_profile(\"my_profile.json\")?;\n\n// Enable learning mode (classifier adapts, then save profile)\nlet scheduler = Scheduler::new()\n    .enable_learning();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:39:text",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 39,
      "lineEnd": 41,
      "language": "text",
      "code": "/dev/shm/horus/topics/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:44:text",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 44,
      "lineEnd": 46,
      "language": "text",
      "code": "/tmp/horus/topics/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:49:text",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 49,
      "lineEnd": 51,
      "language": "text",
      "code": "%TEMP%\\horus\\topics\\",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:71:text",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 71,
      "lineEnd": 77,
      "language": "text",
      "code": "# Terminal 1: Robot controller\nHub::new(\"cmd_vel\")  → /dev/shm/horus/topics/horus_cmd_vel\n\n# Terminal 2: GUI monitor (same topic!)\nHub::new(\"cmd_vel\")  → /dev/shm/horus/topics/horus_cmd_vel",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:94:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 94,
      "lineEnd": 100,
      "language": "rust",
      "code": "// Project A\nHub::new(\"robot_arm.cmd_vel\")?;\n\n// Project B\nHub::new(\"mobile_robot.cmd_vel\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:110:text",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 110,
      "lineEnd": 112,
      "language": "text",
      "code": "/dev/shm/horus/topics/horus_{topic_name}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:115:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 115,
      "lineEnd": 119,
      "language": "bash",
      "code": "/dev/shm/horus/topics/horus_cmd_vel\n/dev/shm/horus/topics/horus_laser_scan\n/dev/shm/horus/topics/horus_system_monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:134:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 134,
      "lineEnd": 143,
      "language": "rust",
      "code": "pub struct ShmRegion {\n    mmap: MmapMut,      // Memory-mapped region\n    size: usize,        // Size in bytes\n    path: PathBuf,      // Path to /dev/shm file\n    _file: File,        // Underlying file handle\n    name: String,       // Topic name\n    owner: bool,        // Created this region?\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:147:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 147,
      "lineEnd": 150,
      "language": "rust",
      "code": "// Create or open shared memory region\nlet region = ShmRegion::new(\"my_topic\", 4096)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:160:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 160,
      "lineEnd": 163,
      "language": "rust",
      "code": "// Open existing shared memory (no creation)\nlet region = ShmRegion::open(\"my_topic\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:174:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 174,
      "lineEnd": 180,
      "language": "rust",
      "code": "if region.is_owner() {\n    println!(\"I created this shared memory\");\n} else {\n    println!(\"I'm using existing shared memory\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:234:text",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 234,
      "lineEnd": 240,
      "language": "text",
      "code": "Publisher writes:    HEAD  [0] [1] [2] [3] [4]\n\nSubscriber A:        TAIL_A  [0]  (just joined)\nSubscriber B:        TAIL_B  [2]  (caught up partially)\nSubscriber C:        TAIL_C  [4]  (fully caught up)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:252:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 252,
      "lineEnd": 254,
      "language": "rust",
      "code": "let max_unread = (self.capacity * 3) / 4;  // 75% fill limit",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:274:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 274,
      "lineEnd": 286,
      "language": "rust",
      "code": "// Validate index is in bounds\nif head >= self.capacity {\n    panic!(\"Critical safety violation: head index >= capacity\");\n}\n\n// Validate byte offset is in bounds\nlet byte_offset = head * mem::size_of::<T>();\nlet data_region_size = self.capacity * mem::size_of::<T>();\nif byte_offset + mem::size_of::<T>() > data_region_size {\n    panic!(\"Critical safety violation: write would exceed bounds\");\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:292:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 292,
      "lineEnd": 297,
      "language": "rust",
      "code": "const MAX_CAPACITY: usize = 1_000_000;        // Max elements\nconst MIN_CAPACITY: usize = 1;                // Min elements\nconst MAX_ELEMENT_SIZE: usize = 1_000_000;    // Max size per element\nconst MAX_TOTAL_SIZE: usize = 100_000_000;    // Max total (100MB)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:300:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 300,
      "lineEnd": 307,
      "language": "rust",
      "code": "if capacity > MAX_CAPACITY {\n    return Err(\"Capacity too large\");\n}\nif element_size > MAX_ELEMENT_SIZE {\n    return Err(\"Element size too large\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:313:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 313,
      "lineEnd": 319,
      "language": "rust",
      "code": "let stored_element_size = header.element_size.load(Ordering::Relaxed);\nlet expected_element_size = mem::size_of::<T>();\nif stored_element_size != expected_element_size {\n    return Err(\"Element size mismatch\");\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:330:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 330,
      "lineEnd": 332,
      "language": "rust",
      "code": "#[repr(align(64))]",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:344:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 344,
      "lineEnd": 353,
      "language": "rust",
      "code": "// Relaxed for non-critical reads\nlet head = header.head.load(Ordering::Relaxed);\n\n// Acquire for critical synchronization\nlet current_head = header.head.load(Ordering::Acquire);\n\n// Release when publishing\nheader.head.compare_exchange_weak(..., Ordering::Release, ...);",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:365:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 365,
      "lineEnd": 370,
      "language": "rust",
      "code": "// No allocations - just pointer arithmetic\nlet sample = topic.loan()?;  // Returns stack-allocated sample\nsample.write(data);          // Writes directly to shared memory\n// Drop publishes (no allocation)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:380:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 380,
      "lineEnd": 390,
      "language": "bash",
      "code": "# Linux\nls -lh /dev/shm/horus/topics/\n\n# macOS\nls -lh /tmp/horus/topics/\n\n# Example output:\n# -rw-r--r-- 1 user user 4.0K Oct 5 12:34 horus_cmd_vel\n# -rw-r--r-- 1 user user 8.0K Oct 5 12:34 horus_laser_scan",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:394:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 394,
      "lineEnd": 404,
      "language": "bash",
      "code": "# Linux\ndf -h /dev/shm\n\n# macOS (check temp space)\ndf -h /tmp\n\n# Example output (Linux):\n# Filesystem      Size  Used Avail Use% Mounted on\n# tmpfs           7.8G  128M  7.7G   2% /dev/shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:410:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 410,
      "lineEnd": 417,
      "language": "bash",
      "code": "# Using HORUS CLI (recommended)\nhorus clean --shm\n\n# Or manually remove the directory\nrm -rf /dev/shm/horus/      # Linux\nrm -rf /tmp/horus/          # macOS",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:426:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 426,
      "lineEnd": 432,
      "language": "bash",
      "code": "# Watch memory usage in real-time\nwatch -n 1 'du -sh /dev/shm/horus/'\n\n# Show per-topic sizes\ndu -h /dev/shm/horus/topics/*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:452:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 452,
      "lineEnd": 461,
      "language": "bash",
      "code": "# Check current size\ndf -h /dev/shm\n\n# Increase to 4GB (requires sudo)\nsudo mount -o remount,size=4G /dev/shm\n\n# Make permanent (add to /etc/fstab):\n# tmpfs /dev/shm tmpfs defaults,size=4G 0 0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:473:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 473,
      "lineEnd": 479,
      "language": "bash",
      "code": "# Check shared memory\nls -lh /tmp/horus/\n\n# Check available space\ndf -h /tmp",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:491:powershell",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 491,
      "lineEnd": 497,
      "language": "powershell",
      "code": "# Check shared memory\ndir $env:TEMP\\horus\n\n# View temp directory location\necho $env:TEMP",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:500:powershell",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 500,
      "lineEnd": 503,
      "language": "powershell",
      "code": "wsl --install\n# Inside WSL, HORUS uses Linux's /dev/shm/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:515:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 515,
      "lineEnd": 518,
      "language": "rust",
      "code": "// Specify number of messages to buffer\nHub::new_with_capacity(\"topic\", 1000)?;  // 1000 messages",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:528:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 528,
      "lineEnd": 534,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ShmRegion\n\n// Allocate exactly 100 MB of shared memory\nlet size_bytes = 100 * 1024 * 1024;  // 100 MB\nlet region = ShmRegion::new(\"large_topic\", size_bytes)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:540:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 540,
      "lineEnd": 549,
      "language": "rust",
      "code": "use std::mem::size_of;\n\n// Example: Hub with 1000 messages of type LaserScan\nlet capacity = 1000;\nlet message_size = size_of::<LaserScan>();  // ~1536 bytes\nlet total_memory = capacity * message_size;  // ~1.5 MB\n\nHub::<LaserScan>::new_with_capacity(\"scan\", capacity)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:553:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 553,
      "lineEnd": 562,
      "language": "rust",
      "code": "// Example: Want to use 50 MB for PointCloud messages\nlet target_memory_mb = 50;\nlet target_bytes = target_memory_mb * 1024 * 1024;\nlet message_size = size_of::<PointCloud>();  // ~120 KB\n\nlet capacity = target_bytes / message_size;  // ~426 messages\n\nHub::<PointCloud>::new_with_capacity(\"points\", capacity)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:579:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 579,
      "lineEnd": 584,
      "language": "rust",
      "code": "// Maximum constraints (defined in horus_core)\nconst MAX_CAPACITY: usize = 1_000_000;        // Max messages\nconst MAX_ELEMENT_SIZE: usize = 1_000_000;    // Max 1 MB per message\nconst MAX_TOTAL_SIZE: usize = 100_000_000;    // Max 100 MB per topic",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:594:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 594,
      "lineEnd": 603,
      "language": "rust",
      "code": "// Small messages, high frequency\nHub::<CmdVel>::new_with_capacity(\"cmd_vel\", 1000)?;  // 16 KB\n\n// Medium messages, moderate frequency\nHub::<Imu>::new_with_capacity(\"imu\", 500)?;  // 152 KB\n\n// Large messages, lower frequency\nHub::<LaserScan>::new_with_capacity(\"scan\", 100)?;  // 150 KB",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:609:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 609,
      "lineEnd": 617,
      "language": "rust",
      "code": "// Budget: 10 MB for point cloud buffer\nlet budget_mb = 10;\nlet budget_bytes = budget_mb * 1024 * 1024;\nlet msg_size = size_of::<PointCloud>();  // 120 KB\n\nlet capacity = budget_bytes / msg_size;  // ~85 messages\nHub::<PointCloud>::new_with_capacity(\"points\", capacity)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:621:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 621,
      "lineEnd": 633,
      "language": "rust",
      "code": "// High-frequency control (1 kHz) - buffer 1 second\nlet capacity_1khz = 1000;  // 1 second @ 1000 Hz\n\n// Video frames (30 Hz) - buffer 5 seconds\nlet capacity_30hz = 150;   // 5 seconds @ 30 Hz\n\n// Sensor data (100 Hz) - buffer 10 seconds\nlet capacity_100hz = 1000; // 10 seconds @ 100 Hz\n\n// Match to your loop rate and desired buffer time\nlet capacity = loop_rate_hz * buffer_seconds;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:637:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 637,
      "lineEnd": 645,
      "language": "rust",
      "code": "// Small messages, high frequency\nShmTopic::<CmdVel>::new(\"cmd_vel\", 100)?;  // 100 slots\n\n// Large messages, lower frequency\nShmTopic::<PointCloud>::new(\"points\", 10)?;  // 10 slots\n\n// Balance between latency and memory usage",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:649:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 649,
      "lineEnd": 654,
      "language": "rust",
      "code": "let metrics = hub.get_metrics();\nif metrics.messages_sent > capacity * 100 {\n    println!(\"Consider increasing buffer capacity\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:658:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 658,
      "lineEnd": 670,
      "language": "rust",
      "code": "match hub.send(data, &mut ctx) {\n    Ok(()) => {},\n    Err(original_data) => {\n        // Buffer full - decide what to do\n        // Option 1: Log and drop\n        ctx.log_warning(\"Buffer full, dropping message\");\n\n        // Option 2: Retry with backoff\n        // Option 3: Use larger buffer\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:674:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 674,
      "lineEnd": 683,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// In development, clean shared memory between runs\n#[cfg(debug_assertions)]\nfn cleanup_shm() {\n    // Cross-platform cleanup using shm_base_dir from prelude\n    let _ = std::fs::remove_dir_all(shm_base_dir());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:692:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 692,
      "lineEnd": 701,
      "language": "bash",
      "code": "# Check usage\ndf -h /dev/shm\n\n# Clean up (HORUS auto-cleans sessions, but manual cleanup helps if full)\nrm -rf /dev/shm/horus/\n\n# Or increase size\nsudo mount -o remount,size=2G /dev/shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:704:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 704,
      "lineEnd": 710,
      "language": "bash",
      "code": "# Check usage\ndf -h /tmp\n\n# Clean up\nrm -rf /tmp/horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:713:powershell",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 713,
      "lineEnd": 716,
      "language": "powershell",
      "code": "# Clean up\nRemove-Item -Recurse -Force \"$env:TEMP\\horus\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:723:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 723,
      "lineEnd": 733,
      "language": "bash",
      "code": "# Check permissions (Linux)\nls -la /dev/shm/horus/\n\n# Check permissions (macOS)\nls -la /tmp/horus/\n\n# Fix permissions (if needed)\nchmod 755 /dev/shm/horus/  # Linux\nchmod 755 /tmp/horus/      # macOS",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:740:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 740,
      "lineEnd": 750,
      "language": "bash",
      "code": "# Using HORUS CLI\nhorus clean --shm\n\n# Or manually:\n# Linux\nrm -rf /dev/shm/horus/\n\n# macOS\nrm -rf /tmp/horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:752:powershell",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 752,
      "lineEnd": 755,
      "language": "powershell",
      "code": "# Windows\nRemove-Item -Recurse -Force \"$env:TEMP\\horus\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:762:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 762,
      "lineEnd": 768,
      "language": "rust",
      "code": "// Publisher\nlet pub_hub: Hub<f32> = Hub::new(\"data\");\n\n// Subscriber\nlet sub_hub: Hub<f32> = Hub::new(\"data\");  // Same type!",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:778:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 778,
      "lineEnd": 791,
      "language": "rust",
      "code": "// Backend (Terminal 1) - inside Node::tick()\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = self.read_sensor();\n    self.publisher.send(data, &mut ctx).ok();  // Hub::new(\"sensors\")\n}\n\n// GUI (Terminal 2) - inside Node::tick()\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(data) = self.subscriber.recv(&mut ctx) {  // Hub::new(\"sensors\")\n        // Receives data from backend automatically!\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:797:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 797,
      "lineEnd": 803,
      "language": "bash",
      "code": "# Terminal 1 - Backend\nhorus run backend.rs\n\n# Terminal 2 - GUI (same topic names = automatic communication)\nhorus run gui.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:809:rust",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 809,
      "lineEnd": 815,
      "language": "rust",
      "code": "// Project A\nHub::new(\"project_a.sensors\")?;\n\n// Project B\nHub::new(\"project_b.sensors\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core-concepts-shared-memory:822:bash",
      "file": "content/docs/concepts/core-concepts-shared-memory.mdx",
      "lineStart": 822,
      "lineEnd": 830,
      "language": "bash",
      "code": "# Terminal 1 - Backend\ncd ~/my_snakesim\nhorus run main.rs\n\n# Terminal 2 - GUI (same topics = automatic communication)\ncd ~/my_snakesim\nhorus run snakesim_gui/main.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/core:45:rust",
      "file": "content/docs/concepts/core.mdx",
      "lineStart": 45,
      "lineEnd": 60,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\n// Create publisher/subscriber for any message type\nlet cmd_pub: Hub<CmdVel> = Hub::new(\"motor.cmd_vel\")?;\nlet cmd_sub: Hub<CmdVel> = Hub::new(\"motor.cmd_vel\")?;\n\n// Multiple publishers can send to same topic\nlet pub1: Hub<SensorData> = Hub::new(\"sensors.imu\")?;\nlet pub2: Hub<SensorData> = Hub::new(\"sensors.imu\")?;\n\n// Multiple subscribers receive all messages\nlet sub1: Hub<SensorData> = Hub::new(\"sensors.imu\")?;\nlet sub2: Hub<SensorData> = Hub::new(\"sensors.imu\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/core:85:rust",
      "file": "content/docs/concepts/core.mdx",
      "lineStart": 85,
      "lineEnd": 100,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\n// Inside a Node's tick() method:\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Send complex message types\n    let cmd = CmdVel::new(1.5, 0.8);  // ~500ns (Hub) / 248ns (Link)\n    self.cmd_pub.send(cmd, &mut ctx).ok();\n\n    // Receive messages\n    if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n        println!(\"Linear: {}, Angular: {}\", cmd.linear, cmd.angular);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/goals:115:rust",
      "file": "content/docs/concepts/goals.mdx",
      "lineStart": 115,
      "lineEnd": 122,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, ImuNode}\n\nlet mut scheduler = Scheduler::new();\n// Create IMU node (simulation mode by default)\nlet imu = ImuNode::new()?;\nscheduler.add(Box::new(imu), 0, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/goals:125:rust",
      "file": "content/docs/concepts/goals.mdx",
      "lineStart": 125,
      "lineEnd": 132,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, PidControllerNode}\n\nlet mut scheduler = Scheduler::new();\n// Create PID controller with default topics\nlet pid = PidControllerNode::new()?;\nscheduler.add(Box::new(pid), 1, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/goals:135:rust",
      "file": "content/docs/concepts/goals.mdx",
      "lineStart": 135,
      "lineEnd": 144,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, ImuNode, LidarNode, PidControllerNode, DifferentialDriveNode}\n\nlet mut scheduler = Scheduler::new();\nscheduler.add(Box::new(ImuNode::new()?), 0, Some(true));\nscheduler.add(Box::new(LidarNode::new()?), 0, Some(true));\nscheduler.add(Box::new(PidControllerNode::new()?), 1, Some(true));\nscheduler.add(Box::new(DifferentialDriveNode::new()?), 2, Some(true));\nscheduler.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/goals:152:bash",
      "file": "content/docs/concepts/goals.mdx",
      "lineStart": 152,
      "lineEnd": 161,
      "language": "bash",
      "code": "# Publish your package to the registry\nhorus pkg publish\n\n# Others can discover it\nhorus pkg list imu-driver\n\n# And install it in one command\nhorus pkg install your-imu-driver",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/goals:173:bash",
      "file": "content/docs/concepts/goals.mdx",
      "lineStart": 173,
      "lineEnd": 188,
      "language": "bash",
      "code": "# Team A builds and publishes a SLAM node\ncd my-slam-package\nhorus pkg publish\n#  Published: slam-cartographer v1.0.0\n#  Install: horus pkg install slam-cartographer\n\n# Team B discovers and uses it weeks later\nhorus pkg list slam\n#  slam-cartographer  1.0.0  SLAM using cartographer  234  ⬇5.2k\nhorus pkg install slam-cartographer\n\n# Use it directly in their code\nuse slam_cartographer::CartographerNode;\nscheduler.add(Box::new(CartographerNode::new()?), 2, Some(true));",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/hframe:87:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 87,
      "lineEnd": 95,
      "language": "rust",
      "code": "// String API (~200ns)\nlet tf = hf.tf(\"camera_frame\", \"base_link\")?;\n\n// Integer ID API (~50ns) - for hot paths\nlet camera_id = hf.frame_id(\"camera_frame\").unwrap();\nlet base_id = hf.frame_id(\"base_link\").unwrap();\nlet tf = hf.tf_by_id(camera_id, base_id);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:108:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 108,
      "lineEnd": 117,
      "language": "rust",
      "code": "#[repr(C, align(64))]  // Cache-line aligned\npub struct FrameSlot {\n    version: AtomicU64,      // Odd = write in progress\n    sequence: AtomicU64,     // Increment on each update\n    parent: AtomicU32,       // Parent frame ID\n    frame_type: AtomicU8,    // Static or Dynamic\n    history: Vec<TransformEntry>,  // Ring buffer\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:148:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 148,
      "lineEnd": 157,
      "language": "rust",
      "code": "// Cache the ID once\nlet camera = hf.frame_id(\"camera\").unwrap();  // Do this once\n\n// Use integer ID in hot loop\nloop {\n    let tf = hf.tf_by_id(camera, world);  // ~50ns vs ~2μs\n    control_robot(tf);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:163:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 163,
      "lineEnd": 166,
      "language": "rust",
      "code": "#[repr(C, align(64))]\npub struct FrameSlot { ... }",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:176:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 176,
      "lineEnd": 183,
      "language": "rust",
      "code": "// Pre-allocate for 1024 frames at startup\nlet hf = HFrame::with_config(HFrameConfig {\n    max_frames: 1024,\n    history_len: 32,\n    ..Default::default()\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:189:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 189,
      "lineEnd": 195,
      "language": "rust",
      "code": "// First query: Compute chain camera → base → world\nlet tf = hf.tf(\"camera\", \"world\");  // ~150ns\n\n// Second query: Cache hit\nlet tf = hf.tf(\"camera\", \"world\");  // ~50ns",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:203:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 203,
      "lineEnd": 220,
      "language": "rust",
      "code": "/// 3D Transform (translation + quaternion)\npub struct Transform {\n    pub translation: [f64; 3],  // meters\n    pub rotation: [f64; 4],     // quaternion [x, y, z, w]\n}\n\n/// Frame identifier (16-bit)\npub type FrameId = u16;\n\n/// Configuration\npub struct HFrameConfig {\n    pub max_frames: usize,        // 256 - 65535\n    pub max_static_frames: usize, // Pre-allocated static frames\n    pub history_len: usize,       // Ring buffer size (1-256)\n    pub chain_cache_size: usize,  // LRU cache entries\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:245:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 245,
      "lineEnd": 266,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {HFrame, Transform}\n\n// Create with default config (256 frames)\nlet hf = HFrame::new();\n\n// Register frame hierarchy\nhf.register_frame(\"world\", None)?;\nhf.register_frame(\"base_link\", Some(\"world\"))?;\nhf.register_frame(\"camera\", Some(\"base_link\"))?;\n\n// Update transform\nlet tf = Transform::new(\n    [1.0, 0.0, 0.5],        // translation [x, y, z]\n    [0.0, 0.0, 0.0, 1.0]    // quaternion [x, y, z, w]\n);\nhf.update_transform(\"camera\", &tf, timestamp_now())?;\n\n// Query transform\nlet tf = hf.tf(\"camera\", \"world\")?;\nlet point_world = tf.transform_point([1.0, 0.0, 0.0]);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:270:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 270,
      "lineEnd": 280,
      "language": "rust",
      "code": "// Cache frame IDs at startup\nlet camera_id = hf.frame_id(\"camera\").unwrap();\nlet world_id = hf.frame_id(\"world\").unwrap();\n\n// Use IDs in control loop (50ns vs 200ns)\nloop {\n    let tf = hf.tf_by_id(camera_id, world_id);\n    // Control loop...\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:284:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 284,
      "lineEnd": 291,
      "language": "rust",
      "code": "// Query transform at past timestamp (SLERP interpolation)\nlet past = timestamp_now() - 100_000_000;  // 100ms ago\nlet tf = hf.tf_at(\"camera\", \"world\", past)?;\n\n// Query with extrapolation limit\nlet tf = hf.tf_at_with_tolerance(\"camera\", \"world\", past, 50_000_000)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:295:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 295,
      "lineEnd": 301,
      "language": "rust",
      "code": "// Static transforms (never change, optimized path)\nhf.register_static_frame(\"lidar\", Some(\"base_link\"), &lidar_tf)?;\n\n// Update static transform (rare)\nhf.set_static_transform(\"lidar\", &new_tf)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:305:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 305,
      "lineEnd": 322,
      "language": "rust",
      "code": "// Small robot (256 frames, ~550KB)\nlet hf = HFrame::small();\n\n// Medium robot (1024 frames, ~2.2MB)\nlet hf = HFrame::medium();\n\n// Large simulation (4096 frames, ~9MB)\nlet hf = HFrame::large();\n\n// Custom configuration\nlet hf = HFrame::with_config(HFrameConfig {\n    max_frames: 2048,\n    max_static_frames: 1024,\n    history_len: 64,\n    chain_cache_size: 512,\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:330:bash",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 330,
      "lineEnd": 345,
      "language": "bash",
      "code": "# List all frames\nhorus hf list\n\n# Echo transform between frames (like tf_echo)\nhorus hf echo camera base_link\n\n# Show frame tree (like view_frames)\nhorus hf tree\n\n# Check if transform is available\nhorus hf can-transform camera world\n\n# Monitor update rates\nhorus hf monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/hframe:366:bash",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 366,
      "lineEnd": 375,
      "language": "bash",
      "code": "# Run all HFrame tests\ncargo test --package horus_library hframe\n\n# Run with output\ncargo test --package horus_library hframe -- --nocapture\n\n# Run benchmarks\ncargo test --release --package horus_library hframe_benchmark -- --nocapture --ignored",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/hframe:383:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 383,
      "lineEnd": 389,
      "language": "rust",
      "code": "// Publish HFrame transforms to TF2\nuse horus::bridge::TF2Publisher;\n\nlet tf_pub = TF2Publisher::new(&hf);\ntf_pub.broadcast_all()?;  // Publish to /tf and /tf_static",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hframe:391:rust",
      "file": "content/docs/concepts/hframe.mdx",
      "lineStart": 391,
      "lineEnd": 397,
      "language": "rust",
      "code": "// Subscribe to TF2 and update HFrame\nuse horus::bridge::TF2Subscriber;\n\nlet tf_sub = TF2Subscriber::new(&hf);\ntf_sub.start();  // Listens to /tf and /tf_static",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:22:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 22,
      "lineEnd": 37,
      "language": "rust",
      "code": "pub trait Processor<I, O = I>: Send + 'static {\n    /// Process input and produce output\n    /// Return Some(output) to publish, None to skip\n    fn process(&mut self, input: I) -> Option<O>;\n\n    /// Called once when the node starts\n    fn on_start(&mut self) {}\n\n    /// Called once when the node shuts down\n    fn on_shutdown(&mut self) {}\n\n    /// Called on each tick, even if no data\n    fn on_tick(&mut self) {}\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:43:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 43,
      "lineEnd": 48,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides CameraNode\n\n// Simple driver mode - no custom processing\nlet camera = CameraNode::new()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:52:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 52,
      "lineEnd": 60,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {CameraNode, Image}\n\n// Add grayscale conversion\nlet camera = CameraNode::new()?\n    .with_processor(|frame: Image| {\n        apply_grayscale(frame)\n    });",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:64:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 64,
      "lineEnd": 74,
      "language": "rust",
      "code": "// Only publish frames meeting criteria\nlet camera = CameraNode::new()?\n    .with_filter(|frame: Image| {\n        if frame.is_valid() && !frame.is_blurry() {\n            Some(frame)\n        } else {\n            None  // Skip this frame\n        }\n    });",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:78:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 78,
      "lineEnd": 97,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Processor\n\nstruct EdgeDetector {\n    threshold: u8,\n}\n\nimpl Processor<Image> for EdgeDetector {\n    fn process(&mut self, input: Image) -> Option<Image> {\n        Some(detect_edges(input, self.threshold))\n    }\n\n    fn on_start(&mut self) {\n        println!(\"Edge detector initialized\");\n    }\n}\n\nlet camera = CameraNode::new()?\n    .with_processor(EdgeDetector { threshold: 50 });",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:103:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 103,
      "lineEnd": 113,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {CameraNode, CameraConfig}\n\nlet camera = CameraNode::builder()\n    .config(CameraConfig::default().with_resolution(1280, 720))\n    .with_closure(|frame| {\n        // Transform each frame\n        resize(frame, 640, 480)\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:119:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 119,
      "lineEnd": 133,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {processor, filter}\n\nlet camera = CameraNode::builder()\n    .pipe(processor(|img| resize(img, 640, 480)))\n    .pipe(processor(|img| apply_grayscale(img)))\n    .pipe(filter(|img| {\n        if img.brightness() > 0.1 {\n            Some(img)\n        } else {\n            None\n        }\n    }))\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:141:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 141,
      "lineEnd": 146,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides PassThrough\n\n// This is the default for all hybrid nodes\nlet pass = PassThrough::<Image>::new();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:152:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 152,
      "lineEnd": 156,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ClosureProcessor\n\nlet processor = ClosureProcessor::new(|x: i32| x * 2);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:162:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 162,
      "lineEnd": 168,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides FilterProcessor\n\nlet filter = FilterProcessor::new(|x: i32| {\n    if x > 0 { Some(x) } else { None }\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:174:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 174,
      "lineEnd": 182,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Pipeline\n\nlet pipeline = Pipeline::new(\n    ClosureProcessor::new(|x: i32| x * 2),\n    ClosureProcessor::new(|x: i32| x + 1),\n);\n// Input: 10 -> Output: 21 (10 * 2 + 1)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:188:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 188,
      "lineEnd": 195,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Tap\n\nlet tap = Tap::new(|x: &i32| {\n    println!(\"Processing: {}\", x);\n});\n// Data passes through unchanged",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:201:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 201,
      "lineEnd": 211,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {processor, ProcessorExt}\n\nlet pipeline = processor(|x: i32| x * 2)\n    .pipe(processor(|x: i32| x + 1))\n    .tap(|x| println!(\"Value: {}\", x))\n    .map(|x| x.to_string())\n    .filter_map(|s| {\n        if s.len() > 1 { Some(s) } else { None }\n    });",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:219:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 219,
      "lineEnd": 240,
      "language": "rust",
      "code": "// Camera with image processing\nlet camera = CameraNode::builder()\n    .with_closure(|img| enhance_contrast(img))\n    .build()?;\n\n// IMU with filtering\nlet imu = ImuNode::builder()\n    .with_closure(|data| apply_kalman_filter(data))\n    .build()?;\n\n// LiDAR with filtering\nlet lidar = LidarNode::builder()\n    .with_filter(|scan| {\n        if scan.ranges.len() > 100 {\n            Some(scan)\n        } else {\n            None\n        }\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:244:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 244,
      "lineEnd": 264,
      "language": "rust",
      "code": "// Visual odometry with filtering\nlet vo = VisualOdometryNode::builder()\n    .with_filter(|odom| {\n        // Only output when moving\n        if odom.twist.linear[0].abs() > 0.01 {\n            Some(odom)\n        } else {\n            None\n        }\n    })\n    .build()?;\n\n// Odometry with covariance estimation\nlet odom = OdometryNode::builder()\n    .with_closure(|mut odom| {\n        odom.pose_covariance[0] = 0.1;\n        odom\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:268:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 268,
      "lineEnd": 282,
      "language": "rust",
      "code": "// Motor with velocity ramping\nlet motor = DcMotorNode::builder()\n    .with_closure(|cmd| {\n        ramp_velocity(cmd, 0.1)\n    })\n    .build()?;\n\n// PID with output limiting\nlet pid = PidControllerNode::builder()\n    .with_closure(|output| {\n        output.clamp(-1.0, 1.0)\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:288:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 288,
      "lineEnd": 319,
      "language": "rust",
      "code": "struct StatefulProcessor {\n    buffer: Vec<f32>,\n    running_avg: f32,\n}\n\nimpl Processor<f32> for StatefulProcessor {\n    fn process(&mut self, input: f32) -> Option<f32> {\n        self.buffer.push(input);\n        if self.buffer.len() > 10 {\n            self.buffer.remove(0);\n        }\n        self.running_avg = self.buffer.iter().sum::<f32>() / self.buffer.len() as f32;\n        Some(self.running_avg)\n    }\n\n    fn on_start(&mut self) {\n        println!(\"Processor starting, clearing buffer\");\n        self.buffer.clear();\n        self.running_avg = 0.0;\n    }\n\n    fn on_shutdown(&mut self) {\n        println!(\"Final average: {}\", self.running_avg);\n    }\n\n    fn on_tick(&mut self) {\n        // Called every tick, even without data\n        // Useful for timeouts, heartbeats, etc.\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:325:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 325,
      "lineEnd": 336,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {processor, filter, tap}\n\n// Create a transformation processor\nlet double = processor(|x: i32| x * 2);\n\n// Create a filtering processor\nlet positive = filter(|x: i32| if x > 0 { Some(x) } else { None });\n\n// Create a side-effect tap\nlet logger = tap(|x: &i32| println!(\"Value: {}\", x));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:340:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 340,
      "lineEnd": 377,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, CameraNode, CameraConfig, processor, filter, tap}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Build a complete vision pipeline\n    let camera = CameraNode::builder()\n        .config(CameraConfig::default()\n            .with_resolution(1920, 1080)\n            .with_fps(30.0))\n        // Step 1: Resize for processing\n        .pipe(processor(|img| resize(img, 640, 480)))\n        // Step 2: Color correction\n        .pipe(processor(|img| white_balance(img)))\n        // Step 3: Log frame rate\n        .tap(|img| {\n            static COUNTER: AtomicU64 = AtomicU64::new(0);\n            let count = COUNTER.fetch_add(1, Ordering::Relaxed);\n            if count % 100 == 0 {\n                println!(\"Processed {} frames\", count);\n            }\n        })\n        // Step 4: Quality filter\n        .pipe(filter(|img| {\n            if img.brightness() > 0.1 && !img.is_blurry() {\n                Some(img)\n            } else {\n                None\n            }\n        }))\n        .build()?;\n\n    scheduler.add(Box::new(camera), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/hybrid-nodes:388:rust",
      "file": "content/docs/concepts/hybrid-nodes.mdx",
      "lineStart": 388,
      "lineEnd": 396,
      "language": "rust",
      "code": "// These two are equivalent in performance:\n\n// Option 1: Explicit PassThrough\nlet node = SensorNode::<PassThrough<Data>>::new()?;\n\n// Option 2: Default (PassThrough is inferred)\nlet node = SensorNode::new()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:17:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 17,
      "lineEnd": 34,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Manual definition - lots of boilerplate!\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[repr(C)]\npub struct Position {\n    pub x: f32,\n    pub y: f32,\n}\n\n// Must manually implement LogSummary\nimpl LogSummary for Position {\n    fn log_summary(&self) -> String {\n        format!(\"Position(x={:.2}, y={:.2})\", self.x, self.y)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:42:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 42,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nmessage!(Position = (f32, f32));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:57:yaml",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 57,
      "lineEnd": 62,
      "language": "yaml",
      "code": "# horus.yaml - serde required!\ndependencies:\n  - name: serde\n    features: [\"derive\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-macro:64:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 64,
      "lineEnd": 68,
      "language": "rust",
      "code": "// Requires serde as a direct dependency\n#[derive(Serialize, Deserialize)]\nstruct MyMessage { x: f32, y: f32 }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:71:yaml",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 71,
      "lineEnd": 74,
      "language": "yaml",
      "code": "# horus.yaml - no serde needed!\ndependencies: []",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-macro:76:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 76,
      "lineEnd": 79,
      "language": "rust",
      "code": "// Just works - no serde dependency needed\nmessage!(MyMessage { x: f32, y: f32 });",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:89:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 89,
      "lineEnd": 103,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// 2D position\nmessage!(Position = (f32, f32));\n\n// RGB color\nmessage!(Color = (u8, u8, u8));\n\n// Command with ID and enable flag\nmessage!(Command = (u32, bool));\n\n// Velocity in 3D\nmessage!(Velocity = (f32, f32, f32));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:109:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 109,
      "lineEnd": 130,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nmessage! {\n    RobotStatus {\n        position_x: f32,\n        position_y: f32,\n        battery_level: u8,\n        is_moving: bool,\n        error_code: u32,\n    }\n}\n\nmessage! {\n    SensorData {\n        temperature: f32,\n        humidity: f32,\n        pressure: f32,\n        timestamp: u64,\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:137:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 137,
      "lineEnd": 141,
      "language": "rust",
      "code": "#[derive(Debug, Clone, Serialize, Deserialize)]\n#[repr(C)]\npub struct YourMessage(/* fields */);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:144:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 144,
      "lineEnd": 150,
      "language": "rust",
      "code": "impl LogSummary for YourMessage {\n    fn log_summary(&self) -> String {\n        format!(\"{:?}\", self)  // Uses Debug format\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:156:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 156,
      "lineEnd": 159,
      "language": "rust",
      "code": "let hub = Hub::<YourMessage>::new(\"topic\")?;  //  Works!\nlet link = Link::<YourMessage>::producer(\"topic\")?;  //  Works!",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:165:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 165,
      "lineEnd": 242,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Define messages in one line each!\nmessage!(TempReading = (f32, u64));  // (celsius, timestamp)\nmessage!(Alert = (bool, f32));       // (is_critical, threshold)\n\n// Sensor node\nstruct TempSensor {\n    publisher: Hub<TempReading>,\n    reading: f32,\n}\n\nimpl TempSensor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            publisher: Hub::new(\"sensors.temperature\")?,\n            reading: 20.0,\n        })\n    }\n}\n\nimpl Node for TempSensor {\n    fn name(&self) -> &'static str { \"temp_sensor\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let now = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_nanos() as u64;\n\n        let reading = TempReading(self.reading, now);\n        self.publisher.send(reading, &mut ctx).ok();\n\n        self.reading += 0.1;  // Simulate change\n    }\n}\n\n// Alert node\nstruct AlertMonitor {\n    subscriber: Hub<TempReading>,\n    alert_pub: Hub<Alert>,\n    threshold: f32,\n}\n\nimpl AlertMonitor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            subscriber: Hub::new(\"sensors.temperature\")?,\n            alert_pub: Hub::new(\"alerts.temperature\")?,\n            threshold: 30.0,\n        })\n    }\n}\n\nimpl Node for AlertMonitor {\n    fn name(&self) -> &'static str { \"alert_monitor\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(TempReading(temp, _)) = self.subscriber.recv(&mut ctx) {\n            if temp > self.threshold {\n                let alert = Alert(true, temp);\n                self.alert_pub.send(alert, &mut ctx).ok();\n                println!(\"  High temperature: {:.1}°C\", temp);\n            }\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new().name(\"temp_monitor\");\n\n    scheduler.add(Box::new(TempSensor::new()?), 0, Some(true));\n    scheduler.add(Box::new(AlertMonitor::new()?), 1, Some(true));\n\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-macro:250:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 250,
      "lineEnd": 255,
      "language": "rust",
      "code": "message!(Position = (f32, f32));\n\nlet pos = Position(1.0, 2.0);\nprintln!(\"X: {}, Y: {}\", pos.0, pos.1);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:261:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 261,
      "lineEnd": 272,
      "language": "rust",
      "code": "message! {\n    RobotStatus {\n        x: f32,\n        y: f32,\n        battery: u8,\n    }\n}\n\nlet status = RobotStatus { x: 1.0, y: 2.0, battery: 85 };\nprintln!(\"Battery: {}%\", status.battery);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:278:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 278,
      "lineEnd": 284,
      "language": "rust",
      "code": "message!(Position = (f32, f32));\n\nlet pos = Position(3.5, 7.2);\nprintln!(\"{}\", pos.log_summary());\n// Output: Position(3.5, 7.2)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:295:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 295,
      "lineEnd": 299,
      "language": "rust",
      "code": "message!(RGB = (u8, u8, u8));\nmessage!(Point2D = (f32, f32));\nmessage!(Command = (u32, bool));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:306:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 306,
      "lineEnd": 316,
      "language": "rust",
      "code": "message! {\n    SensorReading {\n        temperature: f32,\n        humidity: f32,\n        pressure: f32,\n        altitude: f32,\n        timestamp: u64,\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:322:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 322,
      "lineEnd": 331,
      "language": "rust",
      "code": "// Library type - optimized LogSummary\nuse horus::prelude::*; // Provides vision::Image;\n// Logs: \"Image(1920x1080, Rgb8, 6220800 bytes)\"\n// NOT the full 6.2 MB of pixel data!\n\n// Your custom type - simple LogSummary\nmessage!(MyImage = (u32, u32, Vec<u8>));\n// Logs: Debug format (still better than cloning!)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:341:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 341,
      "lineEnd": 343,
      "language": "rust",
      "code": "use horus::prelude::*;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:349:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 349,
      "lineEnd": 358,
      "language": "rust",
      "code": "// Temperature monitoring module\nmod temperature {\n    use horus::prelude::*;\n\n    message!(TempReading = (f32, u64));\n\n    pub struct TempSensor { /* ... */ }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:364:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 364,
      "lineEnd": 372,
      "language": "rust",
      "code": "// Good\nmessage!(WheelVelocity = (f32, f32));\nmessage!(BatteryStatus = (f32, bool));\n\n// Avoid\nmessage!(Data = (f32, f32));  // Too vague\nmessage!(Msg = (f32, bool));  // Not descriptive",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:378:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 378,
      "lineEnd": 384,
      "language": "rust",
      "code": "// Good - value first, metadata second\nmessage!(SensorReading = (f32, u64));  // (value, timestamp)\n\n// Less clear\nmessage!(SensorReading = (u64, f32));  // (timestamp, value)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:390:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 390,
      "lineEnd": 400,
      "language": "rust",
      "code": "message!(TimedValue = (f32, u64));  // (value, timestamp_ns)\n\nfn create_reading(value: f32) -> TimedValue {\n    let now = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as u64;\n    TimedValue(value, now)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:404:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 404,
      "lineEnd": 413,
      "language": "rust",
      "code": "message! {\n    SystemStatus {\n        is_ok: bool,\n        error_code: u32,\n        message: String,\n        timestamp: u64,\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:417:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 417,
      "lineEnd": 419,
      "language": "rust",
      "code": "message!(MotorCommand = (u8, f32, bool));  // (motor_id, speed, enable)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:432:yaml",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 432,
      "lineEnd": 437,
      "language": "yaml",
      "code": "# Only needed for manual derives or direct serde usage\ndependencies:\n  - name: serde\n    features: [\"derive\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-macro:443:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 443,
      "lineEnd": 460,
      "language": "rust",
      "code": "// Manual definition for Pod types\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[repr(C)]\npub struct FastMessage {\n    pub x: f32,\n    pub y: f32,\n}\n\nunsafe impl bytemuck::Pod for FastMessage {}\nunsafe impl bytemuck::Zeroable for FastMessage {}\n\nimpl LogSummary for FastMessage {\n    fn log_summary(&self) -> String {\n        format!(\"FastMessage({:.2}, {:.2})\", self.x, self.y)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-macro:466:rust",
      "file": "content/docs/concepts/message-macro.mdx",
      "lineStart": 466,
      "lineEnd": 468,
      "language": "rust",
      "code": "use horus::prelude::*;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:15:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 15,
      "lineEnd": 22,
      "language": "rust",
      "code": "use serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MyMessage {\n    // Your fields here\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:45:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 45,
      "lineEnd": 51,
      "language": "rust",
      "code": "// Rust - Typed message\nuse horus::prelude::*; // Provides {Hub, Pose2D}\n\nlet hub: Hub<Pose2D> = Hub::new(\"robot.pose\")?;\nhub.send(Pose2D::new(1.0, 2.0, 0.5), &mut ctx)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:53:python",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 53,
      "lineEnd": 62,
      "language": "python",
      "code": "# Python - Typed hub\nfrom horus import Node, Pose2D\n\nnode = Node(\n    name=\"controller\",\n    pubs={\"robot.pose\": {\"type\": Pose2D}}  # Specify type\n)\nnode.send(\"robot.pose\", Pose2D(x=1.0, y=2.0, theta=0.5))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:65:text",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 65,
      "lineEnd": 67,
      "language": "text",
      "code": "[12:34:56.789] controller --PUB--> 'robot.pose' = Pose2D { x: 1.0, y: 2.0, theta: 0.5 }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:95:python",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 95,
      "lineEnd": 103,
      "language": "python",
      "code": "# Python - Generic hub (string topic)\nnode = Node(name=\"sensor\", pubs=[\"custom_data\"])  # No type specified\nnode.send(\"custom_data\", {\n    \"value\": 42,\n    \"notes\": \"testing new algorithm\",\n    \"measurements\": [1.2, 3.4, 5.6]\n})",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:105:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 105,
      "lineEnd": 112,
      "language": "rust",
      "code": "// Rust - GenericMessage\nuse horus::prelude::*; // Provides {Hub, GenericMessage}\n\nlet hub: Hub<GenericMessage> = Hub::new(\"custom_data\")?;\nlet data = GenericMessage::from_value(&my_dynamic_data)?;\nhub.send(data, &mut ctx)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:115:text",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 115,
      "lineEnd": 117,
      "language": "text",
      "code": "[12:34:56.789] sensor --PUB--> 'custom_data' = {\"value\":42,\"notes\":\"testing new algorithm\",\"measurements\":[1.2,3.4,5.6]}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:172:python",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 172,
      "lineEnd": 176,
      "language": "python",
      "code": "# Phase 1: Prototyping with generic hub\nnode = Node(name=\"sensor\", pubs=[\"pose\"])\nnode.send(\"pose\", {\"x\": 1.0, \"y\": 2.0, \"theta\": 0.5})",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:180:python",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 180,
      "lineEnd": 186,
      "language": "python",
      "code": "# Phase 2: Production with typed hub\nfrom horus import Node, Pose2D\n\nnode = Node(name=\"sensor\", pubs={\"pose\": {\"type\": Pose2D}})\nnode.send(\"pose\", Pose2D(x=1.0, y=2.0, theta=0.5))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:223:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 223,
      "lineEnd": 233,
      "language": "rust",
      "code": "// BAD: Using Debug trait on large messages\n#[derive(Debug)]\nstruct PointCloud {\n    points: Vec<[f32; 3]>,  // 100,000 points = 1.2 MB\n}\n\n// Debug output would be:\n// PointCloud { points: [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], ... 99,998 more] }\n// This kills performance and floods logs!",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:237:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 237,
      "lineEnd": 248,
      "language": "rust",
      "code": "impl LogSummary for PointCloud {\n    fn log_summary(&self) -> String {\n        format!(\"PointCloud({} points, {:.2}MB)\",\n                self.points.len(),\n                (self.points.len() * 12) as f32 / 1_000_000.0)\n    }\n}\n\n// Output: PointCloud(100000 points, 1.20MB)\n// Clean, informative, fast!",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:269:text",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 269,
      "lineEnd": 271,
      "language": "text",
      "code": "[12:34:56.789] [IPC: 437ns | Tick: 12μs] MyNode --PUB--> 'cmd_vel' = Twist(lin:1.5, ang:0.5)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:275:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 275,
      "lineEnd": 295,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RobotState {\n    pub position: [f64; 3],\n    pub velocity: f64,\n    pub battery_level: f32,\n}\n\nimpl LogSummary for RobotState {\n    fn log_summary(&self) -> String {\n        format!(\n            \"RobotState(pos:[{:.2},{:.2},{:.2}] vel:{:.2} bat:{:.0}%)\",\n            self.position[0], self.position[1], self.position[2],\n            self.velocity,\n            self.battery_level * 100.0\n        )\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:300:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 300,
      "lineEnd": 306,
      "language": "rust",
      "code": "// Good: Compact, essential info only\nformat!(\"Twist(lin:{:.2}, ang:{:.2})\", self.linear, self.angular)\n\n// Bad: Too verbose\nformat!(\"Twist {{ linear_x: {}, linear_y: {}, linear_z: {}, angular_x: {}, ... }}\", ...)",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:309:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 309,
      "lineEnd": 315,
      "language": "rust",
      "code": "// For sensor data: Include critical measurements\nformat!(\"LaserScan({} points, range:[{:.2}-{:.2}])\", self.num_points, self.min, self.max)\n\n// For commands: Include the command values\nformat!(\"CmdVel(v:{:.2} m/s, w:{:.2} rad/s)\", self.linear, self.angular)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:318:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 318,
      "lineEnd": 324,
      "language": "rust",
      "code": "// Good: Units clear\nformat!(\"Pose(x:{:.2}m, y:{:.2}m, θ:{:.2}°)\", x, y, theta_deg)\n\n// Unclear: What units?\nformat!(\"Pose({:.2}, {:.2}, {:.2})\", x, y, theta)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:329:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 329,
      "lineEnd": 338,
      "language": "rust",
      "code": "impl LogSummary for Twist {\n    fn log_summary(&self) -> String {\n        format!(\"lin:({:.2},{:.2},{:.2}) ang:({:.2},{:.2},{:.2})\",\n                self.linear.x, self.linear.y, self.linear.z,\n                self.angular.x, self.angular.y, self.angular.z)\n    }\n}\n// Output: lin:(1.50,0.00,0.00) ang:(0.00,0.00,0.50)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:341:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 341,
      "lineEnd": 353,
      "language": "rust",
      "code": "impl LogSummary for LaserScan {\n    fn log_summary(&self) -> String {\n        format!(\"LaserScan({} pts, {:.2}-{:.2}m @ {:.1}Hz)\",\n                self.ranges.len(),     // Don't log all 1000 points!\n                self.range_min,\n                self.range_max,\n                1.0 / self.time_increment)\n    }\n}\n// Output: LaserScan(1080 pts, 0.12-30.00m @ 40.0Hz)\n// Instead of: LaserScan { ranges: [0.12, 0.15, 0.18, ... 1077 more], ... }",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:356:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 356,
      "lineEnd": 366,
      "language": "rust",
      "code": "impl LogSummary for PointCloud {\n    fn log_summary(&self) -> String {\n        format!(\"PointCloud(seq:{}, points:{})\",\n                self.sequence,\n                self.point_count)  // Just count, not 1365 points!\n    }\n}\n// Output: PointCloud(seq:42, points:1365)\n// Avoids logging ~16KB of point data",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:369:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 369,
      "lineEnd": 380,
      "language": "rust",
      "code": "impl LogSummary for CameraMetadata {\n    fn log_summary(&self) -> String {\n        format!(\"CameraMeta(frame:{}, {}x{})\",\n                self.frame_id,\n                self.width,\n                self.height)\n    }\n}\n// Output: CameraMeta(frame:123, 1920x1080)\n// Avoids logging 200 bytes of padding/metadata",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:403:bash",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 403,
      "lineEnd": 410,
      "language": "bash",
      "code": "# In terminal 1: Run your application\nhorus run\n\n# In terminal 2: Start monitor\nhorus monitor\n# Opens browser to http://localhost:3000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:433:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 433,
      "lineEnd": 450,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Twist;\n\n// Create 2D twist (common for mobile robots)\nlet cmd = Twist::new_2d(1.0, 0.5);  // 1.0 m/s forward, 0.5 rad/s rotation\n\n// Create 3D twist\nlet cmd_3d = Twist::new(\n    [1.0, 0.5, 0.0],      // Linear velocity [x, y, z] m/s\n    [0.0, 0.0, 0.5]       // Angular velocity [roll, pitch, yaw] rad/s\n);\n\n// Stop command\nlet stop = Twist::stop();\n\n// Check validity\nassert!(cmd.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:461:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 461,
      "lineEnd": 476,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Pose2D;\n\n// Create pose\nlet pose = Pose2D::new(1.0, 2.0, 0.5);  // x=1m, y=2m, theta=0.5rad\n\n// Start at origin\nlet origin = Pose2D::origin();\n\n// Calculate distance between poses\nlet distance = pose.distance_to(&origin);\n\n// Normalize angle to [-π, π]\nlet mut pose = Pose2D::new(1.0, 2.0, 3.5);\npose.normalize_angle();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:488:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 488,
      "lineEnd": 507,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Transform;\n\n// Identity transform\nlet identity = Transform::identity();\n\n// From 2D pose\nlet pose2d = Pose2D::new(1.0, 2.0, 0.5);\nlet transform = Transform::from_pose_2d(&pose2d);\n\n// Custom transform\nlet tf = Transform::new(\n    [1.0, 2.0, 3.0],           // Translation [x, y, z]\n    [0.0, 0.0, 0.0, 1.0]       // Rotation quaternion [x, y, z, w]\n);\n\n// Normalize quaternion\nlet mut tf = transform;\ntf.normalize_rotation();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:518:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 518,
      "lineEnd": 533,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Point3, Vector3};\n\n// Create point\nlet point = Point3::new(1.0, 2.0, 3.0);\nlet distance = point.distance_to(&Point3::origin());\n\n// Create vector\nlet mut vec = Vector3::new(1.0, 0.0, 0.0);\nlet magnitude = vec.magnitude();\nvec.normalize();\n\n// Vector operations\nlet dot_product = vec.dot(&Vector3::new(0.0, 1.0, 0.0));\nlet cross_product = vec.cross(&Vector3::new(0.0, 1.0, 0.0));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:539:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 539,
      "lineEnd": 551,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Quaternion;\n\n// Identity quaternion (no rotation)\nlet q = Quaternion::identity();\n\n// From Euler angles\nlet q = Quaternion::from_euler(0.0, 0.0, std::f64::consts::PI / 2.0);\n\n// Normalize\nlet mut q = Quaternion::new(1.0, 0.0, 0.0, 1.0);\nq.normalize();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:561:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 561,
      "lineEnd": 592,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides LaserScan;\n\nlet mut scan = LaserScan::new();\n\n// Set range readings (360-element array)\nscan.ranges[0] = 5.2;   // Distance in meters\nscan.ranges[1] = 3.8;\n\n// Configure scan parameters\nscan.angle_min = -std::f32::consts::PI;       // -180 degrees\nscan.angle_max = std::f32::consts::PI;        // +180 degrees\nscan.range_min = 0.1;                         // Minimum valid range\nscan.range_max = 30.0;                        // Maximum valid range\nscan.angle_increment = std::f32::consts::PI / 180.0;  // 1 degree\n\n// Get angle for specific reading\nlet angle = scan.angle_at(45);  // Angle at index 45\n\n// Check if reading is valid\nif scan.is_range_valid(0) {\n    println!(\"Range at index 0: {}m\", scan.ranges[0]);\n}\n\n// Count valid readings\nlet valid_count = scan.valid_count();\n\n// Find minimum range\nif let Some(min) = scan.min_range() {\n    println!(\"Closest obstacle: {}m\", min);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:606:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 606,
      "lineEnd": 635,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Imu;\n\nlet mut imu = Imu::new();\n\n// Set orientation from Euler angles\nimu.set_orientation_from_euler(\n    0.1,  // Roll in radians\n    0.2,  // Pitch in radians\n    1.5   // Yaw in radians\n);\n\n// Set angular velocity\nimu.angular_velocity = [0.1, 0.2, 0.3];  // rad/s\n\n// Set linear acceleration\nimu.linear_acceleration = [0.0, 0.0, 9.81];  // m/s²\n\n// Check if orientation is available\nif imu.has_orientation() {\n    let quat = imu.orientation;\n}\n\n// Validate data\nassert!(imu.is_valid());\n\n// Get vectors\nlet angular_vel = imu.angular_velocity_vec();\nlet linear_accel = imu.linear_acceleration_vec();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:650:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 650,
      "lineEnd": 669,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Odometry, Pose2D, Twist};\n\nlet mut odom = Odometry::new();\n\n// Set frames\nodom.set_frames(\"odom\", \"base_link\");\n\n// Update pose and velocity\nlet pose = Pose2D::new(1.0, 2.0, 0.5);\nlet twist = Twist::new_2d(0.5, 0.2);\nodom.update(pose, twist);\n\n// Access data\nprintln!(\"Position: ({}, {})\", odom.pose.x, odom.pose.y);\nprintln!(\"Velocity: {}m/s\", odom.twist.linear[0]);\n\n// Validate\nassert!(odom.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:684:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 684,
      "lineEnd": 700,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Range;\n\n// Create ultrasonic range reading\nlet range = Range::new(Range::ULTRASONIC, 1.5);  // 1.5 meters\n\n// Configure sensor parameters\nlet mut range = Range::new(Range::INFRARED, 0.8);\nrange.min_range = 0.02;  // 2cm minimum\nrange.max_range = 4.0;   // 4m maximum\nrange.field_of_view = 0.1;  // ~6 degrees\n\n// Check validity\nif range.is_valid() {\n    println!(\"Distance: {}m\", range.range);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:714:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 714,
      "lineEnd": 739,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides BatteryState;\n\nlet mut battery = BatteryState::new(12.6, 75.0);  // 12.6V, 75% charge\n\n// Set additional parameters\nbattery.current = -2.5;  // -2.5A (discharging)\nbattery.charge = 5.0;    // 5 Ah remaining\nbattery.capacity = 10.0; // 10 Ah total\nbattery.temperature = 28.5;  // 28.5°C\nbattery.power_supply_status = BatteryState::STATUS_DISCHARGING;\n\n// Check battery level\nif battery.is_low(20.0) {\n    println!(\"Battery low!\");\n}\n\nif battery.is_critical() {  // Below 10%\n    println!(\"Battery critical!\");\n}\n\n// Estimate remaining time\nif let Some(time_left) = battery.time_remaining() {\n    println!(\"Time remaining: {}s\", time_left);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:761:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 761,
      "lineEnd": 772,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides CmdVel;\n\n// Create command\nlet cmd = CmdVel::new(1.0, 0.5);  // 1.0 m/s forward, 0.5 rad/s rotation\n\n// Stop command\nlet stop = CmdVel::zero();\n\n// With explicit timestamp\nlet cmd = CmdVel::with_timestamp(1.0, 0.5, 123456789);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:847:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 847,
      "lineEnd": 880,
      "language": "rust",
      "code": "use serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RobotStatus {\n    pub battery_level: f32,\n    pub temperature: f32,\n    pub error_code: u32,\n    pub timestamp: u64,\n}\n\nimpl RobotStatus {\n    pub fn new(battery: f32, temp: f32) -> Self {\n        Self {\n            battery_level: battery,\n            temperature: temp,\n            error_code: 0,\n            timestamp: std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_nanos() as u64,\n        }\n    }\n\n    pub fn is_healthy(&self) -> bool {\n        self.battery_level > 20.0 && self.temperature < 60.0\n    }\n}\n\n// Use with Hub\nuse horus::prelude::*;\nlet status_pub: Hub<RobotStatus> = Hub::new(\"robot_status\")?;\nstatus_pub.send(RobotStatus::new(75.0, 42.0), &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:886:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 886,
      "lineEnd": 896,
      "language": "rust",
      "code": "// GOOD: Fixed-size array\npub struct LaserData {\n    pub ranges: [f32; 360],  // Fixed size\n}\n\n// BAD: Variable-size Vec\npub struct LaserData {\n    pub ranges: Vec<f32>,  // Requires heap allocation\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:900:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 900,
      "lineEnd": 905,
      "language": "rust",
      "code": "pub struct MyMessage {\n    pub data: f32,\n    pub timestamp: u64,  // Always include timestamp\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:909:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 909,
      "lineEnd": 915,
      "language": "rust",
      "code": "impl MyMessage {\n    pub fn new() -> Self { /* ... */ }\n    pub fn is_valid(&self) -> bool { /* ... */ }\n    pub fn from_other(other: &OtherMsg) -> Self { /* ... */ }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:919:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 919,
      "lineEnd": 926,
      "language": "rust",
      "code": "#[repr(C)]  // C-compatible layout\n#[derive(Debug, Clone, Copy)]\npub struct CInteropMessage {\n    pub x: f32,\n    pub y: f32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:946:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 946,
      "lineEnd": 961,
      "language": "rust",
      "code": "// Instead of sending full image every frame\npub struct CompressedImage {\n    pub data: Vec<u8>,  // JPEG compressed\n    pub format: u8,\n}\n\n// Or send only regions of interest\npub struct ImageROI {\n    pub x: u32,\n    pub y: u32,\n    pub width: u32,\n    pub height: u32,\n    pub data: [u8; 4096],  // Fixed-size ROI\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:965:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 965,
      "lineEnd": 977,
      "language": "rust",
      "code": "// For high precision (scientific)\npub struct HighPrecisionPose {\n    pub x: f64,  // Double precision\n    pub y: f64,\n}\n\n// For most robotics (faster)\npub struct FastPose {\n    pub x: f32,  // Single precision - sufficient for most cases\n    pub y: f32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:981:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 981,
      "lineEnd": 995,
      "language": "rust",
      "code": "// GOOD: Only what you need\npub struct SimpleCmdVel {\n    pub linear: f32,\n    pub angular: f32,\n}\n\n// BAD: Extra unused fields\npub struct VerboseCmdVel {\n    pub linear: f32,\n    pub angular: f32,\n    pub metadata: [u8; 256],  // Unused\n    pub debug_info: [u8; 512],  // Unused\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:1001:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 1001,
      "lineEnd": 1017,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Hub, Node, NodeInfo, LaserScan}\n\nstruct LidarNode {\n    scan_pub: Hub<LaserScan>,\n}\n\nimpl Node for LidarNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let mut scan = LaserScan::new();\n        // Fill in scan data...\n        scan.ranges[0] = 5.2;\n\n        self.scan_pub.send(scan, &mut ctx).ok();\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/concepts/message-types:1021:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 1021,
      "lineEnd": 1040,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Hub, Node, NodeInfo, LaserScan}\n\nstruct ObstacleDetector {\n    scan_sub: Hub<LaserScan>,\n}\n\nimpl Node for ObstacleDetector {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            // Find closest obstacle\n            if let Some(min_range) = scan.min_range() {\n                if min_range < 0.5 {\n                    // Obstacle too close!\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:1056:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 1056,
      "lineEnd": 1069,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Hub, Node, NodeInfo, CmdVel}\n\nstruct Publisher {\n    cmd_pub: Hub<CmdVel>,\n}\n\nimpl Node for Publisher {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let cmd = CmdVel::new(1.0, 0.5);  // linear, angular\n        self.cmd_pub.send(cmd, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/message-types:1072:rust",
      "file": "content/docs/concepts/message-types.mdx",
      "lineStart": 1072,
      "lineEnd": 1085,
      "language": "rust",
      "code": "struct Subscriber {\n    cmd_sub: Hub<CmdVel>,\n}\n\nimpl Node for Subscriber {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            // Use the message\n            println!(\"linear={}, angular={}\", cmd.linear, cmd.angular);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/mission-planner:37:text",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 37,
      "lineEnd": 49,
      "language": "text",
      "code": "Mission: \"Deliver Package to Room 101\"\n├── Goal: \"Pick up package\"\n│   ├── Task: \"Navigate to pickup location\"\n│   ├── Task: \"Detect package\"\n│   └── Task: \"Grasp package\"\n├── Goal: \"Navigate to destination\"\n│   ├── Task: \"Plan path\"\n│   └── Task: \"Execute trajectory\"\n└── Goal: \"Deliver package\"\n    ├── Task: \"Navigate to drop zone\"\n    └── Task: \"Release package\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/mission-planner:55:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 55,
      "lineEnd": 102,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, TaskExecutor, GoalSpec, MissionSpec, MissionPlanner, MissionPlannerError}\n\nfn main() -> Result<(), MissionPlannerError> {\n    // Create tasks\n    let navigate = TaskSpec::new(\n        \"navigate\",\n        \"Navigate to Target\",\n        TaskExecutor::Noop,  // Placeholder for demo\n    );\n\n    let pickup = TaskSpec::new(\n        \"pickup\",\n        \"Pick Up Object\",\n        TaskExecutor::Noop,\n    );\n\n    // Task IDs for dependencies\n    let navigate_id = navigate.id.clone();\n\n    // Create goal with sequential tasks\n    let goal = GoalSpec::new(\"fetch\", \"Fetch Object\")\n        .add_task(navigate)\n        .add_task_after(pickup, &navigate_id);  // pickup depends on navigate\n\n    // Create mission\n    let mission = MissionSpec::new(\"delivery\")\n        .with_description(\"Deliver a package\")\n        .add_goal(goal);\n\n    // Create planner and run\n    let mut planner = MissionPlanner::new();\n    let mission_id = planner.submit(mission)?;\n    planner.start(&mission_id)?;\n\n    // Tick until complete\n    loop {\n        planner.tick()?;\n        let status = planner.get_mission_status(&mission_id)?;\n        if status.status.is_terminal() {\n            println!(\"Mission completed: {:?}\", status.status);\n            break;\n        }\n    }\n\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:108:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 108,
      "lineEnd": 128,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, GoalSpec}\n\n// Three independent sensor checks\nlet check_lidar = TaskSpec::noop(\"check_lidar\", \"Check LiDAR\");\nlet check_camera = TaskSpec::noop(\"check_camera\", \"Check Camera\");\nlet check_imu = TaskSpec::noop(\"check_imu\", \"Check IMU\");\n\n// Final task waits for all checks\nlet start_nav = TaskSpec::noop(\"start_nav\", \"Start Navigation\");\n\nlet lidar_id = check_lidar.id.clone();\nlet camera_id = check_camera.id.clone();\nlet imu_id = check_imu.id.clone();\n\nlet goal = GoalSpec::new(\"startup\", \"Startup Checks\")\n    .add_task(check_lidar)    // These three run\n    .add_task(check_camera)   // in parallel\n    .add_task(check_imu)      // automatically\n    .add_task_after_all(start_nav, &[lidar_id, camera_id, imu_id]);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:134:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 134,
      "lineEnd": 155,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {GoalSpec, TaskSpec, MissionSpec}\n\nlet pickup_goal = GoalSpec::new(\"pickup\", \"Pick Up Package\")\n    .add_task(TaskSpec::noop(\"approach\", \"Approach Object\"))\n    .add_task(TaskSpec::noop(\"grasp\", \"Grasp Object\"));\n\nlet navigate_goal = GoalSpec::new(\"navigate\", \"Navigate to Destination\")\n    .add_task(TaskSpec::noop(\"plan\", \"Plan Path\"))\n    .add_task(TaskSpec::noop(\"execute\", \"Execute Path\"));\n\nlet deliver_goal = GoalSpec::new(\"deliver\", \"Deliver Package\")\n    .add_task(TaskSpec::noop(\"release\", \"Release Object\"));\n\nlet pickup_id = pickup_goal.id.clone();\nlet navigate_id = navigate_goal.id.clone();\n\nlet mission = MissionSpec::new(\"full_delivery\")\n    .add_goal(pickup_goal)\n    .add_goal_after(navigate_goal, &pickup_id)      // After pickup\n    .add_goal_after(deliver_goal, &navigate_id);    // After navigate",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:165:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 165,
      "lineEnd": 167,
      "language": "rust",
      "code": "let sync_task = TaskSpec::noop(\"sync\", \"Synchronization Point\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:173:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 173,
      "lineEnd": 202,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MissionPlanner, TaskSpec, TaskExecutor, ExecutionContext}\nuse std::sync::Arc;\nuse std::collections::HashMap;\n\nlet task = TaskSpec::new(\n    \"custom_work\",\n    \"Custom Work Task\",\n    TaskExecutor::Custom {\n        handler: \"my_handler\".to_string(),\n        parameters: {\n            let mut params = HashMap::new();\n            params.insert(\"key\".to_string(), serde_json::json!(\"value\"));\n            params\n        },\n    },\n);\n\nlet mut planner = MissionPlanner::new();\n\n// Register the handler\nplanner.register_executor(\n    \"my_handler\",\n    Arc::new(|task: &TaskSpec, ctx: &ExecutionContext| {\n        println!(\"Executing task: {}\", task.id);\n        // Do work here...\n        Ok(Some(serde_json::json!({\"result\": \"success\"})))\n    }),\n);",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:208:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 208,
      "lineEnd": 226,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, TaskExecutor}\nuse std::collections::HashMap;\n\nlet navigate_task = TaskSpec::new(\n    \"navigate\",\n    \"Navigate to Pose\",\n    TaskExecutor::Action {\n        action_type: \"navigate_to_pose\".to_string(),\n        parameters: {\n            let mut params = HashMap::new();\n            params.insert(\"x\".to_string(), serde_json::json!(1.0));\n            params.insert(\"y\".to_string(), serde_json::json!(2.0));\n            params.insert(\"theta\".to_string(), serde_json::json!(0.0));\n            params\n        },\n    },\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:232:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 232,
      "lineEnd": 243,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, TaskExecutor}\n\nlet transition_task = TaskSpec::new(\n    \"enter_autonomous\",\n    \"Enter Autonomous Mode\",\n    TaskExecutor::StateMachine {\n        machine_id: \"robot_modes\".to_string(),\n        event: \"start_autonomous\".to_string(),\n    },\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:249:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 249,
      "lineEnd": 268,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, TaskExecutor, RetryPolicy}\nuse std::time::Duration;\n\nlet flaky_task = TaskSpec::new(\n    \"network_call\",\n    \"Network API Call\",\n    TaskExecutor::Custom {\n        handler: \"api_call\".to_string(),\n        parameters: Default::default(),\n    },\n)\n.with_retry(RetryPolicy {\n    max_attempts: 3,                              // Try up to 3 times\n    delay: Duration::from_secs(1),                // Wait 1s between retries\n    exponential_backoff: true,                    // Double delay each retry\n    max_delay: Duration::from_secs(30),           // Cap at 30s\n    retry_on: vec![\"NetworkError\".to_string()],   // Only retry these errors\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:274:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 274,
      "lineEnd": 303,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, TaskExecutor, TaskCondition, MissionPlanner}\nuse std::sync::Arc;\n\n// Task only runs if condition is met\nlet conditional_task = TaskSpec::new(\n    \"backup\",\n    \"Backup Navigation\",\n    TaskExecutor::Noop,\n)\n.with_condition(TaskCondition::Custom {\n    name: \"battery_check\".to_string(),\n    args: vec![\"high\".to_string()],\n});\n\nlet mut planner = MissionPlanner::new();\n\n// Register condition evaluator\nplanner.register_condition_evaluator(\n    \"battery_check\",\n    Arc::new(|condition, ctx| {\n        if let TaskCondition::Custom { args, .. } = condition {\n            // Check if battery level matches requirement\n            args.contains(&\"high\".to_string())\n        } else {\n            false\n        }\n    }),\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:307:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 307,
      "lineEnd": 324,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides TaskCondition\n\n// Always execute\nlet always = TaskCondition::Always;\n\n// Never execute (skip)\nlet never = TaskCondition::Never;\n\n// Execute only if another task succeeded\nlet depends = TaskCondition::TaskSucceeded(\"other_task\".to_string());\n\n// Custom condition with evaluator\nlet custom = TaskCondition::Custom {\n    name: \"my_check\".to_string(),\n    args: vec![\"arg1\".to_string()],\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:330:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 330,
      "lineEnd": 337,
      "language": "rust",
      "code": "let optional_task = TaskSpec::noop(\"optional\", \"Optional Optimization\")\n    .with_condition(TaskCondition::Custom {\n        name: \"resources_available\".to_string(),\n        args: vec![],\n    })\n    .optional();  // Won't fail mission if condition not met",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:343:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 343,
      "lineEnd": 361,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {GoalSpec, GoalFailurePolicy, TaskSpec}\n\n// Critical goal - abort entire mission on failure\nlet critical = GoalSpec::new(\"safety_check\", \"Safety Check\")\n    .with_failure_policy(GoalFailurePolicy::AbortMission)\n    .add_task(TaskSpec::noop(\"check\", \"Check Safety\"));\n\n// Optional goal - continue mission if this fails\nlet optional = GoalSpec::new(\"optimization\", \"Optimize Path\")\n    .with_failure_policy(GoalFailurePolicy::Continue)\n    .optional()\n    .add_task(TaskSpec::noop(\"optimize\", \"Optimize\"));\n\n// Retry the goal on failure\nlet retryable = GoalSpec::new(\"connect\", \"Connect to Server\")\n    .with_failure_policy(GoalFailurePolicy::RetryGoal { max_attempts: 3 })\n    .add_task(TaskSpec::noop(\"connect\", \"Establish Connection\"));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:367:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 367,
      "lineEnd": 396,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MissionPlanner, MissionEvent}\nuse std::sync::Arc;\n\nlet mut planner = MissionPlanner::new();\n\nplanner.on_event(Arc::new(|event| {\n    match event {\n        MissionEvent::MissionStarted { mission_id } => {\n            println!(\"Mission {} started\", mission_id);\n        }\n        MissionEvent::GoalStarted { mission_id, goal_id } => {\n            println!(\"Goal {} started\", goal_id);\n        }\n        MissionEvent::TaskStarted { task_id, .. } => {\n            println!(\"Task {} started\", task_id);\n        }\n        MissionEvent::TaskCompleted { task_id, success, .. } => {\n            println!(\"Task {} completed: success={}\", task_id, success);\n        }\n        MissionEvent::Progress { mission_id, progress } => {\n            println!(\"Mission {}: {:.1}% complete\", mission_id, progress * 100.0);\n        }\n        MissionEvent::MissionCompleted { mission_id, success } => {\n            println!(\"Mission {} completed: success={}\", mission_id, success);\n        }\n        _ => {}\n    }\n}));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:402:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 402,
      "lineEnd": 420,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides MissionPlannerBuilder\nuse std::time::Duration;\nuse std::sync::Arc;\n\nlet planner = MissionPlannerBuilder::new()\n    .max_concurrent_missions(4)        // Run up to 4 missions at once\n    .max_concurrent_tasks(8)           // Run up to 8 tasks per mission\n    .default_task_timeout(Duration::from_secs(60))\n    .collect_metrics(true)\n    .register_executor(\"custom\", Arc::new(|task, ctx| {\n        // Custom executor implementation\n        Ok(None)\n    }))\n    .on_event(Arc::new(|event| {\n        // Event handler\n    }))\n    .build();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:426:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 426,
      "lineEnd": 455,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MissionPlanner, SharedMissionPlanner, MissionSpec, GoalSpec, TaskSpec}\nuse std::thread;\n\nlet planner = MissionPlanner::new();\nlet shared = SharedMissionPlanner::new(planner);\n\n// Submit mission\nlet goal = GoalSpec::new(\"g1\", \"Goal\").add_task(TaskSpec::noop(\"t1\", \"Task\"));\nlet mission = MissionSpec::new(\"m1\").add_goal(goal);\nlet id = shared.submit(mission).unwrap();\nshared.start(&id).unwrap();\n\n// Tick from multiple threads\nlet shared_clone = shared.clone_arc();\nlet handle = thread::spawn(move || {\n    for _ in 0..10 {\n        shared_clone.tick().unwrap();\n        thread::sleep(std::time::Duration::from_millis(10));\n    }\n});\n\n// Main thread also ticks\nfor _ in 0..10 {\n    shared.tick().unwrap();\n    thread::sleep(std::time::Duration::from_millis(10));\n}\n\nhandle.join().unwrap();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:461:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 461,
      "lineEnd": 474,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides MissionPlanner\n\nlet mut planner = MissionPlanner::new();\n\n// After running missions...\nlet metrics = planner.metrics();\n\nprintln!(\"Total missions: {}\", metrics.total_missions);\nprintln!(\"Successful: {}\", metrics.successful_missions);\nprintln!(\"Failed: {}\", metrics.failed_missions);\nprintln!(\"Total tasks: {}\", metrics.total_tasks);\nprintln!(\"Successful tasks: {}\", metrics.successful_tasks);",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:480:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 480,
      "lineEnd": 570,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MissionSpec, GoalSpec, TaskSpec, TaskExecutor, RetryPolicy, GoalFailurePolicy}\nuse std::time::Duration;\n\nfn create_pick_and_place_mission(\n    pickup_location: (f64, f64),\n    place_location: (f64, f64),\n) -> MissionSpec {\n    // Pickup goal\n    let navigate_to_pickup = TaskSpec::new(\n        \"nav_pickup\",\n        \"Navigate to Pickup\",\n        TaskExecutor::Action {\n            action_type: \"navigate\".to_string(),\n            parameters: [\n                (\"x\".to_string(), serde_json::json!(pickup_location.0)),\n                (\"y\".to_string(), serde_json::json!(pickup_location.1)),\n            ].into_iter().collect(),\n        },\n    ).with_timeout(Duration::from_secs(60));\n\n    let detect_object = TaskSpec::new(\n        \"detect\",\n        \"Detect Object\",\n        TaskExecutor::Action {\n            action_type: \"detect_object\".to_string(),\n            parameters: Default::default(),\n        },\n    );\n\n    let grasp = TaskSpec::new(\n        \"grasp\",\n        \"Grasp Object\",\n        TaskExecutor::Action {\n            action_type: \"grasp\".to_string(),\n            parameters: Default::default(),\n        },\n    ).with_retry(RetryPolicy {\n        max_attempts: 3,\n        delay: Duration::from_millis(500),\n        exponential_backoff: false,\n        max_delay: Duration::from_secs(5),\n        retry_on: vec![\"GraspFailed\".to_string()],\n    });\n\n    let nav_id = navigate_to_pickup.id.clone();\n    let detect_id = detect_object.id.clone();\n\n    let pickup_goal = GoalSpec::new(\"pickup\", \"Pick Up Object\")\n        .with_failure_policy(GoalFailurePolicy::AbortMission)\n        .add_task(navigate_to_pickup)\n        .add_task_after(detect_object, &nav_id)\n        .add_task_after(grasp, &detect_id);\n\n    // Place goal\n    let navigate_to_place = TaskSpec::new(\n        \"nav_place\",\n        \"Navigate to Place Location\",\n        TaskExecutor::Action {\n            action_type: \"navigate\".to_string(),\n            parameters: [\n                (\"x\".to_string(), serde_json::json!(place_location.0)),\n                (\"y\".to_string(), serde_json::json!(place_location.1)),\n            ].into_iter().collect(),\n        },\n    );\n\n    let release = TaskSpec::new(\n        \"release\",\n        \"Release Object\",\n        TaskExecutor::Action {\n            action_type: \"release\".to_string(),\n            parameters: Default::default(),\n        },\n    );\n\n    let nav_place_id = navigate_to_place.id.clone();\n\n    let place_goal = GoalSpec::new(\"place\", \"Place Object\")\n        .add_task(navigate_to_place)\n        .add_task_after(release, &nav_place_id);\n\n    let pickup_goal_id = pickup_goal.id.clone();\n\n    MissionSpec::new(\"pick_and_place\")\n        .with_description(\"Pick up object and place at destination\")\n        .with_timeout(Duration::from_secs(300))\n        .add_goal(pickup_goal)\n        .add_goal_after(place_goal, &pickup_goal_id)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:574:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 574,
      "lineEnd": 619,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MissionSpec, GoalSpec, TaskSpec, TaskExecutor}\n\nfn create_multi_robot_survey_mission() -> MissionSpec {\n    // Robot 1 surveys zone A\n    let survey_a = TaskSpec::new(\"survey_a\", \"Survey Zone A\",\n        TaskExecutor::Custom {\n            handler: \"robot1_survey\".to_string(),\n            parameters: Default::default(),\n        });\n\n    // Robot 2 surveys zone B (parallel)\n    let survey_b = TaskSpec::new(\"survey_b\", \"Survey Zone B\",\n        TaskExecutor::Custom {\n            handler: \"robot2_survey\".to_string(),\n            parameters: Default::default(),\n        });\n\n    // Robot 3 surveys zone C (parallel)\n    let survey_c = TaskSpec::new(\"survey_c\", \"Survey Zone C\",\n        TaskExecutor::Custom {\n            handler: \"robot3_survey\".to_string(),\n            parameters: Default::default(),\n        });\n\n    // Merge results (after all surveys complete)\n    let merge = TaskSpec::new(\"merge\", \"Merge Survey Data\",\n        TaskExecutor::Custom {\n            handler: \"merge_surveys\".to_string(),\n            parameters: Default::default(),\n        });\n\n    let a_id = survey_a.id.clone();\n    let b_id = survey_b.id.clone();\n    let c_id = survey_c.id.clone();\n\n    let survey_goal = GoalSpec::new(\"survey\", \"Complete Survey\")\n        .add_task(survey_a)  // All three run\n        .add_task(survey_b)  // in parallel\n        .add_task(survey_c)\n        .add_task_after_all(merge, &[a_id, b_id, c_id]);\n\n    MissionSpec::new(\"multi_robot_survey\")\n        .add_goal(survey_goal)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/mission-planner:623:rust",
      "file": "content/docs/concepts/mission-planner.mdx",
      "lineStart": 623,
      "lineEnd": 667,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Node, Hub, Subscriber, Publisher, SharedMissionPlanner, MissionPlannerBuilder, MissionSpec, MissionStatus}\nuse std::sync::Arc;\n\n#[horus::node]\nstruct MissionExecutor {\n    planner: SharedMissionPlanner,\n    mission_sub: Subscriber<MissionSpec>,\n    status_pub: Publisher<MissionStatus>,\n}\n\nimpl MissionExecutor {\n    pub fn new(hub: &Hub) -> Result<Self> {\n        let planner = MissionPlannerBuilder::new()\n            .max_concurrent_missions(2)\n            .build();\n\n        Ok(Self {\n            planner: SharedMissionPlanner::new(planner),\n            mission_sub: hub.subscribe(\"missions\")?,\n            status_pub: hub.advertise(\"mission_status\")?,\n        })\n    }\n}\n\nimpl Node for MissionExecutor {\n    fn tick(&mut self) -> Result<()> {\n        // Accept new missions\n        if let Some(mission) = self.mission_sub.try_recv() {\n            let id = self.planner.submit(mission)?;\n            self.planner.start(&id)?;\n        }\n\n        // Tick the planner\n        self.planner.tick()?;\n\n        // Publish status updates\n        for status in self.planner.all_mission_statuses()? {\n            self.status_pub.publish(&status)?;\n        }\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/multi-language:20:bash",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 20,
      "lineEnd": 23,
      "language": "bash",
      "code": "horus new my-project\n# Select: Rust (option 2)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:42:bash",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 42,
      "lineEnd": 45,
      "language": "bash",
      "code": "horus new my-project\n# Select: Python (option 1)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:55:python",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 55,
      "lineEnd": 60,
      "language": "python",
      "code": "# Python publisher\nimport horus\nnode = horus.Node(name=\"sensor\", pubs=\"temperature\")\nnode.send(\"temperature\", 25.5)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:62:rust",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 62,
      "lineEnd": 68,
      "language": "rust",
      "code": "// Rust subscriber (in another process)\nlet hub = Hub::<f32>::new(\"temperature\")?;\nif let Some(temp) = hub.recv(&mut None) {\n    println!(\"Temperature: {}\", temp);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/multi-language:76:python",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 76,
      "lineEnd": 88,
      "language": "python",
      "code": "# Python publisher (pose_publisher.py)\nfrom horus import Hub, Pose2D\n\n# Create typed hub - pass message type to constructor\nhub = Hub(Pose2D)\n\nwhile True:\n    # Create and send Pose2D message\n    pose = Pose2D(x=1.0, y=2.0, theta=0.5)\n    hub.send(pose)\n    time.sleep(0.1)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:90:rust",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 90,
      "lineEnd": 99,
      "language": "rust",
      "code": "// Rust subscriber (in another process)\nuse horus::prelude::*;\nuse horus::prelude::*; // Provides geometry::Pose2D;\n\nlet hub = Hub::<Pose2D>::new(\"pose2d\")?;\nif let Some(pose) = hub.recv(&mut None) {\n    println!(\"Received: x={}, y={}, theta={}\", pose.x, pose.y, pose.theta);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/multi-language:112:python",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 112,
      "lineEnd": 121,
      "language": "python",
      "code": "from horus import Hub, Pose2D, CmdVel\n\n# Create typed hubs - pass message type to constructor\npose_hub = Hub(Pose2D)\npose_hub.send(Pose2D(x=1.0, y=2.0, theta=0.5))\n\ncmd_hub = Hub(CmdVel)\ncmd_hub.send(CmdVel(linear=1.0, angular=0.5))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:127:python",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 127,
      "lineEnd": 135,
      "language": "python",
      "code": "from horus import Hub\n\n# Generic Hub - pass topic name as string\nhub = Hub(\"my_topic\")\nhub.send({\"any\": \"python\", \"object\": [1, 2, 3]})  # Dicts, lists, any Python type\n\n# Note: Generic hubs use JSON serialization for simple types",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:168:bash",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 168,
      "lineEnd": 174,
      "language": "bash",
      "code": "# Mix Python and Rust nodes\nhorus run sensor.py controller.rs visualizer.py\n\n# Mix Rust and Python\nhorus run lidar_driver.rs planner.py motor_control.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:186:python",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 186,
      "lineEnd": 201,
      "language": "python",
      "code": "# sensor.py - Python sensor node\nimport horus\nfrom horus import Hub, LaserScan\n\n# Create Hub once outside tick function\nhub = Hub(\"lidar\")\n\ndef tick(node):\n    scan = LaserScan()\n    scan.ranges = read_lidar()  # Your hardware driver\n    hub.send(scan)\n\nnode = horus.Node(name=\"lidar_sensor\", tick=tick, rate=10)\nhorus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:203:rust",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 203,
      "lineEnd": 219,
      "language": "rust",
      "code": "// planner.rs - Rust planning node\nuse horus::prelude::*;\nuse horus::prelude::*; // Provides {sensor::LaserScan, cmd_vel::CmdVel};\n\nfn main() -> Result<()> {\n    let scan_hub = Hub::<LaserScan>::new(\"lidar\")?;\n    let cmd_hub = Hub::<CmdVel>::new(\"cmd_vel\")?;\n\n    loop {\n        if let Some(scan) = scan_hub.recv(&mut None) {\n            let cmd = plan_path(&scan);  // Your planning logic\n            cmd_hub.send(cmd, &mut None).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/multi-language:221:bash",
      "file": "content/docs/concepts/multi-language.mdx",
      "lineStart": 221,
      "lineEnd": 226,
      "language": "bash",
      "code": "# Run both together\nhorus run sensor.py planner.rs\n\n# Both processes communicate via shared memory",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:15:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 15,
      "lineEnd": 31,
      "language": "rust",
      "code": "// === MACHINE 1 (Producer @ 192.168.1.10) ===\nuse horus::prelude::*;\n\n// Connect to consumer at 192.168.1.20:9000\nlet output: Link<SensorData> = Link::producer(\"sensors@192.168.1.20:9000\")?;\noutput.send(data, &mut ctx)?;\n\n// === MACHINE 2 (Consumer @ 192.168.1.20) ===\nuse horus::prelude::*;\n\n// Listen for producer on port 9000\nlet input: Link<SensorData> = Link::consumer(\"sensors@0.0.0.0:9000\")?;\nif let Some(data) = input.recv(&mut ctx) {\n    process(data);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:35:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 35,
      "lineEnd": 51,
      "language": "rust",
      "code": "// === MACHINE 1 (Publisher @ 192.168.1.10) ===\nuse horus::prelude::*;\n\n// Publish to network\nlet pub_hub: Hub<Status> = Hub::new(\"status@192.168.1.20\")?;\npub_hub.send(status, &mut ctx)?;\n\n// === MACHINE 2 (Subscriber @ 192.168.1.20) ===\nuse horus::prelude::*;\n\n// Subscribe from network\nlet sub_hub: Hub<Status> = Hub::new(\"status@192.168.1.20\")?;\nif let Some(status) = sub_hub.recv(&mut ctx) {\n    process(status);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:58:python",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 58,
      "lineEnd": 69,
      "language": "python",
      "code": "from horus import Link, SensorData\n\n# === MACHINE 1 (Producer) ===\noutput = Link.producer(SensorData, \"sensors@192.168.1.20:9000\")\noutput.send(data)\n\n# === MACHINE 2 (Consumer) ===\ninput_link = Link.consumer(SensorData, \"sensors@0.0.0.0:9000\")\nif msg := input_link.recv():\n    process(msg)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:72:python",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 72,
      "lineEnd": 82,
      "language": "python",
      "code": "from horus import Hub, Status\n\n# Network hub with endpoint parameter\nhub = Hub(Status, endpoint=\"status@192.168.1.20:8000\")\nhub.send(status)\n\n# Receive\nif msg := hub.recv():\n    process(msg)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:85:python",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 85,
      "lineEnd": 94,
      "language": "python",
      "code": "from horus import Hub, RouterClient, CmdVel\n\n# Method 1: Implicit router endpoint\nrouter_hub = Hub(CmdVel, endpoint=\"cmdvel@router\")\n\n# Method 2: Explicit RouterClient\nrouter = RouterClient(\"192.168.1.100\", 7777)\nhub = Hub(CmdVel, endpoint=router.endpoint(\"cmdvel\"))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:105:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 105,
      "lineEnd": 109,
      "language": "rust",
      "code": "Link::producer(\"topic@192.168.1.20:9000\")?     // Connect to specific IP:port\nLink::producer(\"topic@hostname:9000\")?         // Connect to hostname\nLink::producer(\"topic@drone.local:9000\")?      // mDNS/Avahi hostname",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:112:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 112,
      "lineEnd": 115,
      "language": "rust",
      "code": "Link::consumer(\"topic@0.0.0.0:9000\")?          // Listen on port 9000 (all interfaces)\nLink::consumer(\"topic@192.168.1.20:9000\")?     // Listen on specific interface",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:119:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 119,
      "lineEnd": 124,
      "language": "rust",
      "code": "Hub::new(\"topic@192.168.1.20\")?                // Direct UDP (default port)\nHub::new(\"topic@192.168.1.20:8000\")?           // Direct UDP (custom port)\nHub::new(\"topic@localhost\")?                    // Unix socket (localhost optimization)\nHub::new(\"topic@router\")?                       // Router backend (WAN/NAT traversal)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:128:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 128,
      "lineEnd": 133,
      "language": "rust",
      "code": "// No '@' symbol = local shared memory\nHub::new(\"topic\")?\nLink::producer(\"topic\")?\nLink::consumer(\"topic\")?",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:156:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 156,
      "lineEnd": 163,
      "language": "rust",
      "code": "// Robot sends IMU data to ground station\n// Robot (192.168.1.50)\nlet imu_output: Link<ImuData> = Link::producer(\"imu@192.168.1.100:9000\")?;\n\n// Ground station (192.168.1.100)\nlet imu_input: Link<ImuData> = Link::consumer(\"imu@0.0.0.0:9000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:184:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 184,
      "lineEnd": 194,
      "language": "rust",
      "code": "// Multiple robots publish position, central server aggregates\n// Robot 1\nlet pos_pub: Hub<Position> = Hub::new(\"positions@192.168.1.100\")?;\n\n// Robot 2\nlet pos_pub: Hub<Position> = Hub::new(\"positions@192.168.1.100\")?;\n\n// Central server\nlet positions: Hub<Position> = Hub::new(\"positions@0.0.0.0:8000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:239:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 239,
      "lineEnd": 266,
      "language": "rust",
      "code": "// === ROBOT 1 (192.168.1.10) ===\nstruct Robot1 {\n    // Publish own position\n    position_pub: Hub<Position>,\n\n    // Subscribe to fleet positions\n    fleet_positions: Hub<Position>,\n\n    // Local control loop (ultra-fast)\n    imu_link: Link<ImuData>,\n    motors_link: Link<MotorCmd>,\n}\n\nimpl Robot1 {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            position_pub: Hub::new(\"fleet.positions@router\")?,\n            fleet_positions: Hub::new(\"fleet.positions@router\")?,\n            imu_link: Link::consumer(\"imu\")?,      // Local\n            motors_link: Link::producer(\"motors\")?, // Local\n        })\n    }\n}\n\n// === ROBOT 2 (192.168.1.20) ===\n// Same structure, different IP",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:270:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 270,
      "lineEnd": 306,
      "language": "rust",
      "code": "// === EDGE DEVICE (192.168.1.50) - Raspberry Pi ===\nstruct EdgeSensor {\n    // Capture camera locally\n    camera: Hub<RawImage>,\n\n    // Send to processing server\n    image_output: Link<RawImage>,\n}\n\nimpl EdgeSensor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            camera: Hub::new(\"camera\")?,  // Local\n            image_output: Link::producer(\"images@192.168.1.100:9000\")?, // Network\n        })\n    }\n}\n\n// === PROCESSING SERVER (192.168.1.100) - Powerful GPU ===\nstruct ProcessingServer {\n    // Receive from edge device\n    image_input: Link<RawImage>,\n\n    // Process and send results back\n    detections_output: Link<Detections>,\n}\n\nimpl ProcessingServer {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            image_input: Link::consumer(\"images@0.0.0.0:9000\")?,          // Network listen\n            detections_output: Link::producer(\"detect@192.168.1.50:9001\")?, // Send back\n        })\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:310:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 310,
      "lineEnd": 323,
      "language": "rust",
      "code": "// === SENSOR NODE 1 (192.168.1.51) ===\nlet temp1: Hub<Temperature> = Hub::new(\"temps@192.168.1.100\")?;\n\n// === SENSOR NODE 2 (192.168.1.52) ===\nlet temp2: Hub<Temperature> = Hub::new(\"temps@192.168.1.100\")?;\n\n// === SENSOR NODE 3 (192.168.1.53) ===\nlet temp3: Hub<Temperature> = Hub::new(\"temps@192.168.1.100\")?;\n\n// === AGGREGATOR (192.168.1.100) ===\nlet temps: Hub<Temperature> = Hub::new(\"temps@0.0.0.0:8000\")?;\n// Receives from all sensor nodes",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:327:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 327,
      "lineEnd": 366,
      "language": "rust",
      "code": "// === DRONE (192.168.1.50) ===\nstruct Drone {\n    // Local: Critical flight control (ultra-fast)\n    imu: Link<ImuData>,\n    motors: Link<MotorCmd>,\n\n    // Network: Telemetry to GCS\n    telemetry: Hub<DroneStatus>,\n\n    // Network: Commands from GCS\n    commands: Hub<Command>,\n}\n\nimpl Drone {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            imu: Link::consumer(\"imu\")?,          // Local: 248ns\n            motors: Link::producer(\"motors\")?,     // Local: 248ns\n            telemetry: Hub::new(\"telem@192.168.1.100\")?,   // Network: &lt;50µs\n            commands: Hub::new(\"cmd@0.0.0.0:8001\")?,       // Network listen\n        })\n    }\n}\n\n// === GROUND CONTROL STATION (192.168.1.100) ===\nstruct GroundStation {\n    telemetry_sub: Hub<DroneStatus>,\n    command_pub: Hub<Command>,\n}\n\nimpl GroundStation {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            telemetry_sub: Hub::new(\"telem@0.0.0.0:8000\")?,  // Listen for drone\n            command_pub: Hub::new(\"cmd@192.168.1.50:8001\")?, // Send to drone\n        })\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:375:toml",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 375,
      "lineEnd": 383,
      "language": "toml",
      "code": "[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@192.168.1.100:8000\"\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera@192.168.1.50:9000\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:386:toml",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 386,
      "lineEnd": 394,
      "language": "toml",
      "code": "[hubs.telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry\"  # Local for testing\n\n[hubs.camera]\nname = \"camera\"\nendpoint = \"camera\"  # Local for testing",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:397:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 397,
      "lineEnd": 401,
      "language": "rust",
      "code": "// Automatically loads from horus.toml or horus_dev.toml\nlet telemetry: Hub<Status> = Hub::from_config(\"telemetry\")?;\nlet camera: Link<Image> = Link::producer_from_config(\"camera\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:407:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 407,
      "lineEnd": 415,
      "language": "bash",
      "code": "# Development (local)\nexport HORUS_CONFIG=horus_dev.toml\nhorus run robot.rs\n\n# Production (network)\nexport HORUS_CONFIG=horus.toml\nhorus run --release robot.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:421:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 421,
      "lineEnd": 432,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet link: Link<Data> = match Link::producer(\"data@192.168.1.100:9000\") {\n    Ok(l) => l,\n    Err(e) => {\n        eprintln!(\"Failed to connect: {}\", e);\n        // Retry or fallback to local mode\n        Link::producer(\"data\")?\n    }\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:436:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 436,
      "lineEnd": 457,
      "language": "rust",
      "code": "struct NetworkNode {\n    data_link: Link<SensorData>,\n    last_recv: std::time::Instant,\n}\n\nimpl Node for NetworkNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_link.recv(&mut ctx) {\n            self.last_recv = std::time::Instant::now();\n            self.process(data);\n        } else {\n            // Check for timeout\n            if self.last_recv.elapsed() > std::time::Duration::from_secs(5) {\n                if let Some(ref mut c) = ctx {\n                    c.log_error(\"Network timeout - no data received for 5s\");\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:461:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 461,
      "lineEnd": 485,
      "language": "rust",
      "code": "struct RobotWithFallback {\n    // Try network first\n    telemetry_network: Option<Hub<Status>>,\n\n    // Fallback to local logging\n    telemetry_local: Hub<Status>,\n}\n\nimpl Node for RobotWithFallback {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let status = self.get_status();\n\n        // Try network first\n        if let Some(ref net) = self.telemetry_network {\n            if net.send(status.clone(), &mut ctx).is_ok() {\n                return;  // Success!\n            }\n        }\n\n        // Fallback to local logging\n        self.telemetry_local.send(status, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:493:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 493,
      "lineEnd": 499,
      "language": "bash",
      "code": "# Increase TCP buffer sizes (Linux)\nsudo sysctl -w net.core.rmem_max=16777216\nsudo sysctl -w net.core.wmem_max=16777216\nsudo sysctl -w net.ipv4.tcp_rmem=\"4096 87380 16777216\"\nsudo sysctl -w net.ipv4.tcp_wmem=\"4096 65536 16777216\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:505:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 505,
      "lineEnd": 509,
      "language": "bash",
      "code": "# Increase UDP buffer sizes\nsudo sysctl -w net.core.rmem_default=8388608\nsudo sysctl -w net.core.wmem_default=8388608",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:515:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 515,
      "lineEnd": 518,
      "language": "bash",
      "code": "# Disable WiFi power saving\nsudo iw dev wlan0 set power_save off",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:524:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 524,
      "lineEnd": 528,
      "language": "bash",
      "code": "# Mark HORUS packets with DSCP (Differentiated Services Code Point)\nsudo iptables -t mangle -A OUTPUT -p tcp --dport 9000 -j DSCP --set-dscp 46\nsudo iptables -t mangle -A OUTPUT -p udp --dport 8000 -j DSCP --set-dscp 46",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:534:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 534,
      "lineEnd": 538,
      "language": "bash",
      "code": "# Allow HORUS ports\nsudo ufw allow 8000:9999/tcp  # Link (TCP)\nsudo ufw allow 8000:9999/udp  # Hub (UDP)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:542:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 542,
      "lineEnd": 546,
      "language": "bash",
      "code": "# Allow inbound HORUS traffic\nsudo iptables -A INPUT -p tcp --dport 9000 -j ACCEPT\nsudo iptables -A INPUT -p udp --dport 8000 -j ACCEPT",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:558:toml",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 558,
      "lineEnd": 566,
      "language": "toml",
      "code": "# Future feature (not yet implemented)\n[hubs.secure_telemetry]\nname = \"telemetry\"\nendpoint = \"telemetry@192.168.1.100:8000\"\ntls = true\ncert = \"/path/to/cert.pem\"\nkey = \"/path/to/key.pem\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:580:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 580,
      "lineEnd": 590,
      "language": "bash",
      "code": "# Check if consumer is listening\nss -tulpn | grep :9000\n\n# Check firewall\nsudo ufw status\nsudo iptables -L\n\n# Test connectivity\nnc -zv 192.168.1.100 9000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:602:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 602,
      "lineEnd": 611,
      "language": "bash",
      "code": "# Measure ping latency\nping -i 0.001 192.168.1.100  # 1ms interval\n\n# Check network interface stats\nip -s link show eth0\n\n# Disable WiFi power save\nsudo iw dev wlan0 set power_save off",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:623:bash",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 623,
      "lineEnd": 632,
      "language": "bash",
      "code": "# Check packet loss\nping -c 100 192.168.1.100\n\n# Increase UDP buffers\nsudo sysctl -w net.core.rmem_default=8388608\n\n# Check WiFi signal\niwconfig wlan0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/network-communication:637:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 637,
      "lineEnd": 640,
      "language": "rust",
      "code": "// Critical control loop: Link over network\nlet motors: Link<MotorCmd> = Link::producer(\"motors@robot:9000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:643:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 643,
      "lineEnd": 646,
      "language": "rust",
      "code": "// Status to multiple subscribers: Hub\nlet status: Hub<Status> = Hub::new(\"status@monitoring:8000\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:649:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 649,
      "lineEnd": 652,
      "language": "rust",
      "code": "// Flight control stays on-board (local)\nlet imu: Link<ImuData> = Link::consumer(\"imu\")?;  // 248ns, not network",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:655:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 655,
      "lineEnd": 658,
      "language": "rust",
      "code": "// Don't hardcode IPs\nlet telem: Hub<Status> = Hub::from_config(\"telemetry\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:661:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 661,
      "lineEnd": 666,
      "language": "rust",
      "code": "if telemetry.send(status, &mut ctx).is_err() {\n    ctx.log_warning(\"Telemetry unavailable\");\n    // Continue operating locally\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:669:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 669,
      "lineEnd": 672,
      "language": "rust",
      "code": "// This won't work - network latency too high\n// Use local shared memory instead",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/network-communication:675:rust",
      "file": "content/docs/concepts/network-communication.mdx",
      "lineStart": 675,
      "lineEnd": 677,
      "language": "rust",
      "code": "telemetry.send(status, &mut ctx).ok();  // Bad! Silently fails",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:16:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 16,
      "lineEnd": 48,
      "language": "rust",
      "code": "struct SensorNode {\n    publisher: Hub<f32>,\n    counter: u32,\n}\n\nimpl SensorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            publisher: Hub::new(\"temperature\")?,\n            counter: 0,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str {\n        \"SensorNode\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let temp = 20.0 + (self.counter as f32 * 0.1);\n        self.publisher.send(temp, &mut ctx).ok();\n        self.counter += 1;\n    }\n}\n\nimpl Default for SensorNode {\n    fn default() -> Self {\n        Self::new().expect(\"Failed to create SensorNode\")\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:51:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 51,
      "lineEnd": 64,
      "language": "rust",
      "code": "node! {\n    SensorNode {\n        pub { temperature: f32 -> \"temperature\" }\n        data { counter: u32 = 0 }\n\n        tick(ctx) {\n            let temp = 20.0 + (self.counter as f32 * 0.1);\n            self.temperature.send(temp, &mut ctx).ok();\n            self.counter += 1;\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:70:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 70,
      "lineEnd": 84,
      "language": "rust",
      "code": "node! {\n    NodeName {\n        name: \"custom_name\",  // Explicit node name (optional)\n        rate 100.0     // Tick rate in Hz (optional)\n        pub { ... }    // Publishers (optional)\n        sub { ... }    // Subscribers (optional)\n        data { ... }   // Internal state (optional)\n        tick(ctx) { ... }   // Main loop (required)\n        init(ctx) { ... }   // Startup (optional)\n        shutdown(ctx) { ... } // Cleanup (optional)\n        impl { ... }   // Custom methods (optional)\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:94:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 94,
      "lineEnd": 103,
      "language": "rust",
      "code": "node! {\n    FlightControllerNode {\n        name: \"flight_controller\",  // Custom name instead of \"flight_controller_node\"\n\n        pub { status: String -> \"fc.status\" }\n        tick(ctx) { ... }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:122:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 122,
      "lineEnd": 139,
      "language": "rust",
      "code": "// Example: Multiple IMU sensors with explicit names\nnode! {\n    IMUSensor {\n        name: \"imu_front\",\n        pub { data: ImuData -> \"sensors.imu_front\" }\n        tick(ctx) { ... }\n    }\n}\n\nnode! {\n    IMUSensor {  // Same struct definition...\n        name: \"imu_rear\",  // ...but different runtime identity\n        pub { data: ImuData -> \"sensors.imu_rear\" }\n        tick(ctx) { ... }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:145:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 145,
      "lineEnd": 147,
      "language": "rust",
      "code": "rate 100.0  // Run at 100 Hz (100 times per second)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:163:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 163,
      "lineEnd": 169,
      "language": "rust",
      "code": "pub {\n    // Syntax: name: Type -> \"topic\"\n    velocity: f32 -> \"robot.velocity\",\n    status: String -> \"robot.status\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:180:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 180,
      "lineEnd": 186,
      "language": "rust",
      "code": "sub {\n    // Syntax: name: Type -> \"topic\"\n    commands: String -> \"user.commands\",\n    sensors: f32 -> \"sensors.temperature\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:197:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 197,
      "lineEnd": 203,
      "language": "rust",
      "code": "data {\n    counter: u32 = 0,\n    buffer: Vec<f32> = Vec::new(),\n    last_time: Instant = Instant::now()\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:211:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 211,
      "lineEnd": 224,
      "language": "rust",
      "code": "tick(ctx) {\n    // Read inputs\n    if let Some(cmd) = self.commands.recv(&mut ctx) {\n        // Process\n        let result = process(cmd);\n        // Send outputs\n        self.status.send(result, &mut ctx).ok();\n    }\n\n    // Update state\n    self.counter += 1;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:232:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 232,
      "lineEnd": 237,
      "language": "rust",
      "code": "init(ctx) {\n    ctx.log_info(\"Starting up\");\n    self.buffer.reserve(1000); // Pre-allocate\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:248:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 248,
      "lineEnd": 253,
      "language": "rust",
      "code": "shutdown(ctx) {\n    ctx.log_info(&format!(\"Processed {} messages\", self.counter));\n    // Save state, close files, etc.\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:259:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 259,
      "lineEnd": 269,
      "language": "rust",
      "code": "impl {\n    fn calculate(&self, x: f32) -> f32 {\n        x * 2.0 + self.counter as f32\n    }\n\n    fn reset(&mut self) {\n        self.counter = 0;\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:275:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 275,
      "lineEnd": 297,
      "language": "rust",
      "code": "node! {\n    MotorController {\n        rate 1000.0  // 1kHz control loop\n\n        sub { target_velocity: f32 -> \"motor.target\" }\n        pub { pwm_output: f32 -> \"motor.pwm\" }\n        data {\n            kp: f32 = 0.5,\n            current_velocity: f32 = 0.0\n        }\n\n        tick(ctx) {\n            if let Some(target) = self.target_velocity.recv(&mut ctx) {\n                // Simple P controller\n                let error = target - self.current_velocity;\n                let output = (self.kp * error).clamp(-1.0, 1.0);\n                self.pwm_output.send(output, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:301:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 301,
      "lineEnd": 311,
      "language": "rust",
      "code": "node! {\n    HeartbeatNode {\n        pub { alive: bool -> \"system.heartbeat\" }\n\n        tick(ctx) {\n            self.alive.send(true, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:315:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 315,
      "lineEnd": 327,
      "language": "rust",
      "code": "node! {\n    LoggerNode {\n        sub { messages: String -> \"logs\" }\n\n        tick(ctx) {\n            if let Some(msg) = self.messages.recv(&mut ctx) {\n                ctx.log_info(&format!(\"[LOG] {}\", msg));\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:331:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 331,
      "lineEnd": 344,
      "language": "rust",
      "code": "node! {\n    DoubleNode {\n        sub { input: f32 -> \"numbers\" }\n        pub { output: f32 -> \"doubled\" }\n\n        tick(ctx) {\n            if let Some(num) = self.input.recv(&mut ctx) {\n                self.output.send(num * 2.0, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:348:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 348,
      "lineEnd": 374,
      "language": "rust",
      "code": "node! {\n    AverageNode {\n        sub { input: f32 -> \"values\" }\n        pub { output: f32 -> \"average\" }\n        data {\n            buffer: Vec<f32> = Vec::new(),\n            max_size: usize = 10\n        }\n\n        tick(ctx) {\n            if let Some(value) = self.input.recv(&mut ctx) {\n                self.buffer.push(value);\n\n                // Keep only last 10 values\n                if self.buffer.len() > self.max_size {\n                    self.buffer.remove(0);\n                }\n\n                // Calculate average\n                let avg: f32 = self.buffer.iter().sum::<f32>() / self.buffer.len() as f32;\n                self.output.send(avg, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:378:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 378,
      "lineEnd": 409,
      "language": "rust",
      "code": "node! {\n    FileLoggerNode {\n        sub { data: String -> \"logs\" }\n        data { file: Option<std::fs::File> = None }\n\n        init(ctx) {\n            use std::fs::OpenOptions;\n            self.file = OpenOptions::new()\n                .create(true)\n                .append(true)\n                .open(\"log.txt\")\n                .ok();\n            ctx.log_info(\"File opened\");\n        }\n\n        tick(ctx) {\n            if let Some(msg) = self.data.recv(&mut ctx) {\n                if let Some(file) = &mut self.file {\n                    use std::io::Write;\n                    writeln!(file, \"{}\", msg).ok();\n                }\n            }\n        }\n\n        shutdown(ctx) {\n            ctx.log_info(\"Closing file\");\n            self.file = None; // Closes the file\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:415:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 415,
      "lineEnd": 421,
      "language": "rust",
      "code": "// Good\npub { motor_speed: f32 -> \"motors.speed\" }\n\n// Bad\npub { x: f32 -> \"data\" }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:425:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 425,
      "lineEnd": 438,
      "language": "rust",
      "code": "// Good - quick operation\ntick(ctx) {\n    if let Some(x) = self.input.recv(&mut ctx) {\n        let y = x * 2.0;\n        self.output.send(y, &mut ctx).ok();\n    }\n}\n\n// Bad - slow operation\ntick(ctx) {\n    std::thread::sleep(Duration::from_secs(1)); // Blocks everything!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:442:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 442,
      "lineEnd": 450,
      "language": "rust",
      "code": "init(ctx) {\n    self.buffer.reserve(1000); // Do this once\n}\n\ntick(ctx) {\n    // Not in tick - would allocate every tick!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:458:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 458,
      "lineEnd": 464,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nnode! {\n    MyNode { ... }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:470:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 470,
      "lineEnd": 476,
      "language": "rust",
      "code": "pub {\n    speed: f32 -> \"speed\",\n    direction: f32 -> \"direction\",\n    status: String -> \"status\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:482:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 482,
      "lineEnd": 490,
      "language": "rust",
      "code": "node! {\n    MinimalNode {\n        tick(ctx) {\n            ctx.log_info(\"Hello!\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/node-macro:496:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 496,
      "lineEnd": 500,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\nscheduler.add(Box::new(MyNode::new()?), 0, Some(true));\nscheduler.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:510:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 510,
      "lineEnd": 520,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel; // If using library types\n\nnode! {\n    MyNode {\n        pub { cmd: CmdVel -> \"cmd_vel\" }\n        ...\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:526:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 526,
      "lineEnd": 532,
      "language": "rust",
      "code": "// Wrong\npub { cmd: f32 \"topic\" }\n\n// Right\npub { cmd: f32 -> \"topic\" }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:536:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 536,
      "lineEnd": 542,
      "language": "rust",
      "code": "// Wrong\nnode! { my_node { ... } }\n\n// Right\nnode! { MyNode { ... } }",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/node-macro:548:rust",
      "file": "content/docs/concepts/node-macro.mdx",
      "lineStart": 548,
      "lineEnd": 557,
      "language": "rust",
      "code": "node! {\n    MyNode {\n        name: \"robot1_controller\",  // Custom runtime name\n        tick(ctx) { ... }\n    }\n}\n\n// Now node.name() returns \"robot1_controller\" instead of \"my_node\"",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:34:rust",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 34,
      "lineEnd": 50,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides StateMachineBuilder\n\n// Robot operating modes - switch based on events\nlet modes = StateMachineBuilder::<RobotContext>::new(\"robot_modes\")\n    .initial_state(\"idle\").done()\n    .state(\"autonomous\").done()\n    .state(\"manual\").done()\n    .state(\"emergency\").done()\n\n    .transition(\"idle\", \"autonomous\").on_event(\"start_auto\").done()\n    .transition(\"idle\", \"manual\").on_event(\"enable_teleop\").done()\n    .transition(\"autonomous\", \"emergency\").on_event(\"e_stop\").done()\n    .transition(\"manual\", \"emergency\").on_event(\"e_stop\").done()\n\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:62:rust",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 62,
      "lineEnd": 89,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MissionPlannerBuilder, GoalSpec, TaskSpec}\n\n// Pick and place mission - structured task hierarchy\nlet mission = MissionPlannerBuilder::new()\n    .mission(\"warehouse_pickup\")\n        .add_goal(GoalSpec::new(\"pick_item\")\n            .add_task(TaskSpec::action(\"navigate_to_shelf\")\n                .action(|_ctx| async { /* nav code */ Ok(()) })\n            )\n            .add_task(TaskSpec::action(\"grab_item\")\n                .action(|_ctx| async { /* gripper code */ Ok(()) })\n                .depends_on(\"navigate_to_shelf\")\n            )\n        )\n        .add_goal(GoalSpec::new(\"place_item\")\n            .depends_on(\"pick_item\")\n            .add_task(TaskSpec::action(\"navigate_to_bin\")\n                .action(|_ctx| async { /* nav code */ Ok(()) })\n            )\n            .add_task(TaskSpec::action(\"release_item\")\n                .action(|_ctx| async { /* release code */ Ok(()) })\n                .depends_on(\"navigate_to_bin\")\n            )\n        )\n        .done()\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:100:text",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 100,
      "lineEnd": 118,
      "language": "text",
      "code": "Is your behavior...?\n\n├── Reactive to external events?\n│   └── STATE MACHINE\n│       Examples: E-stop handling, mode switching, UI flows\n│\n├── A sequence of steps to achieve a goal?\n│   └── MISSION PLANNER\n│       Examples: Pick-and-place, navigation sequences, calibration\n│\n├── Both event-driven AND goal-oriented?\n│   └── COMBINE THEM (see Integration below)\n│       Examples: Autonomous robot with mode management\n│\n└── Simple node coordination?\n    └── Use Scheduler directly\n        Examples: Sensor fusion, control loops",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:126:rust",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 126,
      "lineEnd": 184,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {StateMachineBuilder, MissionPlanner, MissionSpec, GoalSpec, TaskSpec, MissionId}\n\nstruct RobotContext {\n    mission_planner: MissionPlanner,\n    current_mission: Option<MissionId>,\n}\n\nlet robot_fsm = StateMachineBuilder::<RobotContext>::new(\"robot\")\n    .initial_state(\"idle\")\n        .on_entry(|ctx| {\n            // Cancel any running mission when entering idle\n            if let Some(id) = ctx.current_mission.take() {\n                let _ = ctx.mission_planner.cancel_mission(&id);\n            }\n        })\n        .done()\n\n    .state(\"executing_mission\")\n        .on_entry(|ctx| {\n            // Start a new mission\n            let mission = MissionSpec::new(\"current_task\")\n                .add_goal(GoalSpec::new(\"main_goal\")\n                    .add_task(TaskSpec::noop(\"do_work\"))\n                );\n            ctx.current_mission = Some(ctx.mission_planner.submit_mission(mission).unwrap());\n        })\n        .on_tick(|ctx| {\n            // Check mission progress\n            ctx.mission_planner.tick().unwrap();\n        })\n        .done()\n\n    .state(\"paused\")\n        .on_entry(|ctx| {\n            if let Some(ref id) = ctx.current_mission {\n                let _ = ctx.mission_planner.pause_mission(id);\n            }\n        })\n        .done()\n\n    .transition(\"idle\", \"executing_mission\")\n        .on_event(\"start_mission\")\n        .done()\n\n    .transition(\"executing_mission\", \"idle\")\n        .on_event(\"mission_complete\")\n        .done()\n\n    .transition(\"executing_mission\", \"paused\")\n        .on_event(\"pause\")\n        .done()\n\n    .transition(\"paused\", \"executing_mission\")\n        .on_event(\"resume\")\n        .done()\n\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:190:rust",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 190,
      "lineEnd": 237,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TaskSpec, StateMachineBuilder}\n\n// A task that uses a state machine internally\nlet docking_task = TaskSpec::state_machine(\n    \"dock_to_charger\",\n    StateMachineBuilder::<DockingContext>::new(\"docking\")\n        .initial_state(\"approaching\")\n            .on_tick(|ctx| {\n                // Drive toward dock\n                ctx.distance_to_dock -= 0.1;\n            })\n            .done()\n        .state(\"aligning\")\n            .on_tick(|ctx| {\n                // Fine alignment\n            })\n            .done()\n        .state(\"connecting\")\n            .on_entry(|ctx| {\n                // Activate charging connection\n            })\n            .done()\n        .state(\"docked\")\n            .done()\n\n        .transition(\"approaching\", \"aligning\")\n            .on_event(\"close_enough\")\n            .with_guard(|ctx| ctx.distance_to_dock < 0.5)\n            .done()\n        .transition(\"aligning\", \"connecting\")\n            .on_event(\"aligned\")\n            .done()\n        .transition(\"connecting\", \"docked\")\n            .on_event(\"connected\")\n            .done()\n\n        .build()?,\n);\n\nlet mission = MissionSpec::new(\"go_charge\")\n    .add_goal(GoalSpec::new(\"charge\")\n        .add_task(TaskSpec::action(\"navigate_to_dock_area\")\n            .action(|_| async { Ok(()) })\n        )\n        .add_task(docking_task.depends_on(\"navigate_to_dock_area\"))\n    );",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:243:rust",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 243,
      "lineEnd": 282,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {StateMachine, MissionPlanner, Event, MissionEvent}\n\nstruct OrchestratorContext {\n    fsm: StateMachine<FsmContext>,\n    fsm_ctx: FsmContext,\n    planner: MissionPlanner,\n}\n\nimpl OrchestratorContext {\n    fn tick(&mut self) -> Result<()> {\n        // Tick mission planner\n        self.planner.tick()?;\n\n        // Check for mission events and forward to FSM\n        while let Some(event) = self.planner.poll_event() {\n            match event {\n                MissionEvent::MissionCompleted { .. } => {\n                    self.fsm.process_event(\n                        &Event::new(\"mission_complete\"),\n                        &mut self.fsm_ctx\n                    )?;\n                }\n                MissionEvent::MissionFailed { .. } => {\n                    self.fsm.process_event(\n                        &Event::new(\"mission_failed\"),\n                        &mut self.fsm_ctx\n                    )?;\n                }\n                _ => {}\n            }\n        }\n\n        // Tick FSM\n        self.fsm.tick(&mut self.fsm_ctx)?;\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/orchestration:288:rust",
      "file": "content/docs/concepts/orchestration.mdx",
      "lineStart": 288,
      "lineEnd": 472,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {StateMachineBuilder, StateMachine, MissionSpec, GoalSpec, TaskSpec, MissionPlanner, Event, StateId, MissionEvent, Node, Subscriber}\n\n// Robot context shared between FSM and Mission Planner\nstruct AMRContext {\n    battery_level: f32,\n    localized: bool,\n    has_payload: bool,\n    emergency_stop: bool,\n}\n\n// High-level robot modes (State Machine)\nfn create_mode_fsm() -> Result<StateMachine<AMRContext>> {\n    StateMachineBuilder::<AMRContext>::new(\"amr_modes\")\n        // Startup state\n        .initial_state(\"booting\")\n            .on_entry(|_| println!(\"AMR initializing...\"))\n            .done()\n\n        // Ready to receive commands\n        .state(\"idle\")\n            .on_entry(|_| println!(\"AMR ready\"))\n            .done()\n\n        // Executing a mission\n        .state(\"on_mission\")\n            .on_tick(|ctx| {\n                // Monitor battery during mission\n                if ctx.battery_level < 0.15 {\n                    println!(\"Low battery warning!\");\n                }\n            })\n            .done()\n\n        // Autonomous charging\n        .state(\"charging\")\n            .on_tick(|ctx| {\n                ctx.battery_level = (ctx.battery_level + 0.01).min(1.0);\n            })\n            .done()\n\n        // Emergency stopped\n        .state(\"emergency\")\n            .on_entry(|ctx| {\n                ctx.emergency_stop = true;\n                eprintln!(\"EMERGENCY STOP!\");\n            })\n            .done()\n\n        // Boot complete\n        .transition(\"booting\", \"idle\")\n            .on_event(\"boot_complete\")\n            .with_guard(|ctx| ctx.localized)\n            .done()\n\n        // Start mission\n        .transition(\"idle\", \"on_mission\")\n            .on_event(\"mission_start\")\n            .with_guard(|ctx| ctx.battery_level > 0.2)\n            .done()\n\n        // Mission complete\n        .transition(\"on_mission\", \"idle\")\n            .on_event(\"mission_complete\")\n            .done()\n\n        // Go charge\n        .transition(\"idle\", \"charging\")\n            .on_event(\"charge\")\n            .done()\n\n        .transition(\"on_mission\", \"charging\")\n            .on_event(\"low_battery\")\n            .done()\n\n        // Charging complete\n        .transition(\"charging\", \"idle\")\n            .on_event(\"charged\")\n            .with_guard(|ctx| ctx.battery_level > 0.9)\n            .done()\n\n        // Emergency from any active state\n        .transition(\"idle\", \"emergency\").on_event(\"e_stop\").done()\n        .transition(\"on_mission\", \"emergency\").on_event(\"e_stop\").done()\n        .transition(\"charging\", \"emergency\").on_event(\"e_stop\").done()\n\n        // Recovery from emergency\n        .transition(\"emergency\", \"idle\")\n            .on_event(\"reset\")\n            .with_guard(|ctx| !ctx.emergency_stop)\n            .done()\n\n        .build()\n}\n\n// Delivery mission (Mission Planner)\nfn create_delivery_mission(pickup: &str, dropoff: &str) -> MissionSpec {\n    MissionSpec::new(\"delivery\")\n        .add_goal(GoalSpec::new(\"pickup\")\n            .add_task(TaskSpec::action(\"navigate_to_pickup\")\n                .action(move |_ctx| async move {\n                    println!(\"Navigating to pickup: {}\", pickup);\n                    Ok(())\n                })\n            )\n            .add_task(TaskSpec::action(\"load_payload\")\n                .action(|_ctx| async {\n                    println!(\"Loading payload...\");\n                    Ok(())\n                })\n                .depends_on(\"navigate_to_pickup\")\n            )\n        )\n        .add_goal(GoalSpec::new(\"delivery\")\n            .depends_on(\"pickup\")\n            .add_task(TaskSpec::action(\"navigate_to_dropoff\")\n                .action(move |_ctx| async move {\n                    println!(\"Navigating to dropoff: {}\", dropoff);\n                    Ok(())\n                })\n            )\n            .add_task(TaskSpec::action(\"unload_payload\")\n                .action(|_ctx| async {\n                    println!(\"Unloading payload...\");\n                    Ok(())\n                })\n                .depends_on(\"navigate_to_dropoff\")\n            )\n        )\n}\n\n// Main orchestrator node\n#[horus::node]\nstruct AMROrchestrator {\n    mode_fsm: StateMachine<AMRContext>,\n    mission_planner: MissionPlanner,\n    ctx: AMRContext,\n    command_sub: Subscriber<String>,\n}\n\nimpl Node for AMROrchestrator {\n    fn tick(&mut self) -> Result<()> {\n        // Handle incoming commands\n        if let Some(cmd) = self.command_sub.try_recv() {\n            match cmd.as_str() {\n                \"deliver:A:B\" => {\n                    let mission = create_delivery_mission(\"A\", \"B\");\n                    self.mission_planner.submit_mission(mission)?;\n                    self.mode_fsm.process_event(\n                        &Event::new(\"mission_start\"),\n                        &mut self.ctx\n                    )?;\n                }\n                \"emergency\" => {\n                    self.mode_fsm.process_event(\n                        &Event::new(\"e_stop\"),\n                        &mut self.ctx\n                    )?;\n                }\n                _ => {}\n            }\n        }\n\n        // Tick mission planner if on mission\n        if self.mode_fsm.current_state() == Some(&StateId::named(\"on_mission\")) {\n            self.mission_planner.tick()?;\n\n            // Check for mission completion\n            while let Some(event) = self.mission_planner.poll_event() {\n                if matches!(event, MissionEvent::MissionCompleted { .. }) {\n                    self.mode_fsm.process_event(\n                        &Event::new(\"mission_complete\"),\n                        &mut self.ctx\n                    )?;\n                }\n            }\n        }\n\n        // Tick FSM\n        self.mode_fsm.tick(&mut self.ctx)?;\n\n        Ok(())\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:24:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 24,
      "lineEnd": 45,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {RtNode, RtPriority, RtClass, DeadlineMissPolicy}\nuse std::time::Duration;\n\nimpl RtNode for YourControlNode {\n    fn wcet_budget(&self) -> Duration {\n        Duration::from_micros(100) // 100μs worst-case execution time\n    }\n\n    fn deadline(&self) -> Duration {\n        Duration::from_millis(1) // 1ms deadline for 1kHz control\n    }\n\n    fn rt_priority(&self) -> RtPriority {\n        RtPriority::Critical // Highest priority\n    }\n\n    fn rt_class(&self) -> RtClass {\n        RtClass::Hard // Must never miss deadline\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:82:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 82,
      "lineEnd": 100,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::time::Duration;\n\nlet mut scheduler = Scheduler::new();\n\n// Add an RT node with explicit constraints\nscheduler.add_rt(\n    Box::new(MotorControlNode::new()),\n    0,  // Priority 0 (highest)\n    Duration::from_micros(100),  // 100μs WCET budget\n    Duration::from_millis(1),    // 1ms deadline\n);\n\n// Mix with regular nodes\nscheduler.add(Box::new(SensorNode::new()), 10, Some(true));\n\nscheduler.run();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:106:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 106,
      "lineEnd": 129,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet mut scheduler = Scheduler::new();\n\n// Configure for safety-critical operation\nscheduler.set_config(SchedulerConfig::safety_critical());\n\n// This configuration enables:\n// - WCET enforcement\n// - Deadline monitoring\n// - Watchdog timers (100ms timeout)\n// - Emergency stop on violations\n// - Triple redundancy\n// - Memory locking (mlockall)\n// - Real-time scheduling class (SCHED_FIFO)\n\nscheduler.add_rt(\n    Box::new(SurgicalRobotControl::new()),\n    0,\n    Duration::from_micros(50),\n    Duration::from_micros(500),\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:135:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 135,
      "lineEnd": 152,
      "language": "rust",
      "code": "// Configure for maximum performance\nscheduler.set_config(SchedulerConfig::high_performance());\n\n// This configuration enables:\n// - JIT compilation (37ns tick time)\n// - 10kHz control loops\n// - All CPU cores and GPUs\n// - Memory locking\n// - Minimal monitoring overhead\n\nscheduler.add_rt(\n    Box::new(TractionControl::new()),\n    0,\n    Duration::from_micros(20),\n    Duration::from_micros(100), // 10kHz\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:160:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 160,
      "lineEnd": 177,
      "language": "rust",
      "code": "impl RtNode for SafetyCriticalNode {\n    fn pre_condition(&self) -> bool {\n        // Verify system is safe before execution\n        self.system_armed && self.sensors_valid\n    }\n\n    fn post_condition(&self) -> bool {\n        // Verify command was sent successfully\n        self.command_acknowledged\n    }\n\n    fn invariant(&self) -> bool {\n        // System safety invariant that must always hold\n        self.emergency_stop_available && self.watchdog_active\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:183:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 183,
      "lineEnd": 192,
      "language": "rust",
      "code": "fn deadline_miss_policy(&self) -> DeadlineMissPolicy {\n    match self.criticality_level {\n        Critical => DeadlineMissPolicy::EmergencyStop,\n        Important => DeadlineMissPolicy::Degrade,\n        Normal => DeadlineMissPolicy::Skip,\n        Low => DeadlineMissPolicy::Warn,\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:198:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 198,
      "lineEnd": 202,
      "language": "rust",
      "code": "fn fallback_node(&self) -> Option<Box<dyn RtNode>> {\n    Some(Box::new(SimplifiedController::new()))\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:209:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 209,
      "lineEnd": 212,
      "language": "rust",
      "code": "scheduler.set_config(SchedulerConfig::standard());\n// 60Hz control, fault tolerance, monitoring enabled",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:215:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 215,
      "lineEnd": 218,
      "language": "rust",
      "code": "scheduler.set_config(SchedulerConfig::safety_critical());\n// 1kHz control, triple redundancy, zero tolerance",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:221:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 221,
      "lineEnd": 224,
      "language": "rust",
      "code": "scheduler.set_config(SchedulerConfig::high_performance());\n// 10kHz control, JIT compilation, all resources",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:227:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 227,
      "lineEnd": 230,
      "language": "rust",
      "code": "scheduler.set_config(SchedulerConfig::space());\n// GPS time sync, power management, radiation tolerance",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:233:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 233,
      "lineEnd": 237,
      "language": "rust",
      "code": "let mut config = SchedulerConfig::swarm();\nconfig.set_custom(\"swarm_id\", ConfigValue::Integer(42));\nscheduler.set_config(config);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:255:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 255,
      "lineEnd": 286,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\n\n// Critical RT nodes (priority 0-10)\nscheduler.add_rt(\n    Box::new(FlightControl::new()),\n    0,\n    Duration::from_micros(100),\n    Duration::from_millis(1),\n);\n\n// Important processing (priority 11-50)\nscheduler.add(\n    Box::new(PathPlanning::new()),\n    20,\n    Some(true),\n);\n\n// Normal tasks (priority 51-100)\nscheduler.add(\n    Box::new(TelemetryLogger::new()),\n    60,\n    Some(true),\n);\n\n// Background tasks (priority 100+)\nscheduler.add(\n    Box::new(DataUploader::new()),\n    150,\n    Some(false),\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:293:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 293,
      "lineEnd": 298,
      "language": "rust",
      "code": "// If typical execution is 75μs\nfn wcet_budget(&self) -> Duration {\n    Duration::from_micros(100) // Add 25% margin\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:303:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 303,
      "lineEnd": 307,
      "language": "rust",
      "code": "fn deadline(&self) -> Duration {\n    self.wcet_budget() * 2\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:320:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 320,
      "lineEnd": 329,
      "language": "rust",
      "code": "#[test]\nfn test_wcet_compliance() {\n    let node = MotorControl::new();\n    let start = Instant::now();\n    node.tick(None);\n    let duration = start.elapsed();\n    assert!(duration <= node.wcet_budget());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:336:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 336,
      "lineEnd": 346,
      "language": "rust",
      "code": "impl RtNode for YourNode {\n    fn wcet_budget(&self) -> Duration {\n        Duration::from_micros(100)\n    }\n\n    fn deadline(&self) -> Duration {\n        Duration::from_millis(1)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:349:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 349,
      "lineEnd": 360,
      "language": "rust",
      "code": "// Before\nscheduler.add(Box::new(node), 0, Some(false));\n\n// After\nscheduler.add_rt(\n    Box::new(node),\n    0,\n    Duration::from_micros(100),\n    Duration::from_millis(1),\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:363:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 363,
      "lineEnd": 365,
      "language": "rust",
      "code": "scheduler.set_config(SchedulerConfig::safety_critical());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/realtime-nodes:413:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 413,
      "lineEnd": 489,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, RtNode, RtPriority, RtClass, SchedulerConfig, Node, NodeInfo, Result}\nuse std::time::Duration;\n\nstruct MotorControlNode {\n    pwm_value: f32,\n}\n\nimpl Node for MotorControlNode {\n    fn name(&self) -> &'static str {\n        \"motor_control\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Motor control initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read sensors, compute control, send PWM\n        self.pwm_value = self.compute_control();\n        self.send_pwm_signal();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        self.pwm_value = 0.0;  // Safe shutdown\n        ctx.log_info(\"Motor control shutdown\");\n        Ok(())\n    }\n}\n\nimpl RtNode for MotorControlNode {\n    fn wcet_budget(&self) -> Duration {\n        Duration::from_micros(100)\n    }\n\n    fn deadline(&self) -> Duration {\n        Duration::from_millis(1)\n    }\n\n    fn rt_priority(&self) -> RtPriority {\n        RtPriority::Critical\n    }\n\n    fn rt_class(&self) -> RtClass {\n        RtClass::Hard\n    }\n\n    fn pre_condition(&self) -> bool {\n        // Verify sensors are valid\n        true\n    }\n\n    fn post_condition(&self) -> bool {\n        // Verify PWM was sent\n        true\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure for safety-critical operation\n    scheduler.set_config(SchedulerConfig::safety_critical());\n\n    // Add RT control node\n    scheduler.add_rt(\n        Box::new(MotorControlNode { pwm_value: 0.0 }),\n        0,\n        Duration::from_micros(100),\n        Duration::from_millis(1),\n    );\n\n    // Run the system\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/realtime-nodes:495:rust",
      "file": "content/docs/concepts/realtime-nodes.mdx",
      "lineStart": 495,
      "lineEnd": 508,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// System-level: Configure kernel RT features\nRtConfig::hard_realtime(Some(&[2, 3])).apply()?;\n\n// Node-level: Add nodes with timing constraints\nscheduler.add_rt(\n    Box::new(ControlNode::new()),\n    0,\n    Duration::from_micros(100),  // WCET\n    Duration::from_millis(1),    // Deadline\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/robot-architectures:82:rust",
      "file": "content/docs/concepts/robot-architectures.mdx",
      "lineStart": 82,
      "lineEnd": 114,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, JoystickNode, DifferentialDriveNode, DcMotorNode, Result}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Input: Joystick (Priority 0 - runs first)\n    let joystick = JoystickNode::new()?;\n    scheduler.add(Box::new(joystick), 0, Some(true));\n\n    // Control: Differential drive (Priority 1)\n    let diff_drive = DifferentialDriveNode::new(\n        \"joystick.input\",   // Input topic\n        \"motor.left\",       // Left motor output\n        \"motor.right\",      // Right motor output\n        0.3                 // Wheel separation (meters)\n    )?;\n    scheduler.add(Box::new(diff_drive), 1, Some(true));\n\n    // Actuators: DC Motors (Priority 2 - run last)\n    let mut left_motor = DcMotorNode::new()?;\n    left_motor.configure_gpio(12, 13);  // PWM, DIR pins\n    left_motor.set_input_topic(\"motor.left\");\n    scheduler.add(Box::new(left_motor), 2, Some(true));\n\n    let mut right_motor = DcMotorNode::new()?;\n    right_motor.configure_gpio(18, 19);\n    right_motor.set_input_topic(\"motor.right\");\n    scheduler.add(Box::new(right_motor), 2, Some(true));\n\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/robot-architectures:187:rust",
      "file": "content/docs/concepts/robot-architectures.mdx",
      "lineStart": 187,
      "lineEnd": 234,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, EmergencyStopNode, LidarNode, CollisionDetectorNode, PathPlannerNode, DifferentialDriveNode, BldcMotorNode, EscProtocol, Result}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // SAFETY LAYER (Priority 0) - Always runs first!\n    let estop = EmergencyStopNode::new(\"cmd_vel\")?;\n    scheduler.add(Box::new(estop), 0, Some(true));\n\n    // SENSOR LAYER (Priority 1)\n    let mut lidar = LidarNode::new()?;\n    lidar.configure_serial(\"/dev/ttyUSB0\", 115200);\n    scheduler.add(Box::new(lidar), 1, Some(true));\n\n    // PERCEPTION LAYER (Priority 2)\n    let mut detector = CollisionDetectorNode::new()?;\n    detector.set_input_topic(\"lidar.scan\");\n    detector.set_output_topic(\"obstacles\");\n    detector.set_safety_distance(0.5);  // 50cm\n    scheduler.add(Box::new(detector), 2, Some(true));\n\n    // PLANNING LAYER (Priority 3)\n    let mut planner = PathPlannerNode::new()?;\n    planner.set_obstacle_topic(\"obstacles\");\n    planner.set_output_topic(\"cmd_vel\");\n    scheduler.add(Box::new(planner), 3, Some(true));\n\n    // CONTROL LAYER (Priority 4)\n    let diff_drive = DifferentialDriveNode::new(\n        \"cmd_vel\", \"motor.left\", \"motor.right\", 0.3\n    )?;\n    scheduler.add(Box::new(diff_drive), 4, Some(true));\n\n    // ACTUATOR LAYER (Priority 5)\n    let mut left_motor = BldcMotorNode::new()?;\n    left_motor.configure_gpio(12, EscProtocol::DShot600);\n    left_motor.set_input_topic(\"motor.left\");\n    scheduler.add(Box::new(left_motor), 5, Some(true));\n\n    let mut right_motor = BldcMotorNode::new()?;\n    right_motor.configure_gpio(13, EscProtocol::DShot600);\n    right_motor.set_input_topic(\"motor.right\");\n    scheduler.add(Box::new(right_motor), 5, Some(true));\n\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/robot-architectures:298:rust",
      "file": "content/docs/concepts/robot-architectures.mdx",
      "lineStart": 298,
      "lineEnd": 327,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, LidarNode, ImuNode, OdometryNode, LocalizationNode, Result}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // SENSORS (Priority 1 - parallel execution)\n    let mut lidar = LidarNode::new()?;\n    lidar.set_output_topic(\"lidar.scan\");\n    scheduler.add(Box::new(lidar), 1, Some(true));\n\n    let mut imu = ImuNode::new()?;\n    imu.configure_i2c(\"/dev/i2c-1\", 0x68);  // MPU6050\n    imu.set_output_topic(\"imu.data\");\n    scheduler.add(Box::new(imu), 1, Some(true));\n\n    let mut odom = OdometryNode::new()?;\n    odom.configure_encoders(17, 18, 27, 22);  // Left A/B, Right A/B\n    odom.set_output_topic(\"odom.twist\");\n    scheduler.add(Box::new(odom), 1, Some(true));\n\n    // FUSION (Priority 2)\n    let mut localization = LocalizationNode::new()?;\n    localization.subscribe_topics(&[\"lidar.scan\", \"imu.data\", \"odom.twist\"]);\n    localization.set_output_topic(\"robot.pose\");\n    scheduler.add(Box::new(localization), 2, Some(true));\n\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/robot-architectures:399:rust",
      "file": "content/docs/concepts/robot-architectures.mdx",
      "lineStart": 399,
      "lineEnd": 436,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, SafetyMonitorNode, CameraNode, YOLOv8DetectorNode, DifferentialDriveNode, Result}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // SAFETY (Priority 0)\n    let safety = SafetyMonitorNode::new()?;\n    scheduler.add(Box::new(safety), 0, Some(true));\n\n    // SENSOR (Priority 1)\n    let mut camera = CameraNode::new()?;\n    camera.configure_device(\"/dev/video0\");\n    camera.set_resolution(640, 480);\n    camera.set_fps(30);\n    camera.set_output_topic(\"camera.image\");\n    scheduler.add(Box::new(camera), 1, Some(true));\n\n    // PERCEPTION (Priority 2)\n    let mut detector = YOLOv8DetectorNode::new()?;\n    detector.load_model(\"yolov8n.onnx\");  // Nano model for speed\n    detector.set_input_topic(\"camera.image\");\n    detector.set_output_topic(\"detections\");\n    detector.set_confidence_threshold(0.5);\n    scheduler.add(Box::new(detector), 2, Some(true));\n\n    // CONTROL (Priority 4)\n    let diff_drive = DifferentialDriveNode::new(\n        \"cmd_vel\", \"motor.left\", \"motor.right\", 0.3\n    )?;\n    scheduler.add(Box::new(diff_drive), 4, Some(true));\n\n    // ACTUATORS (Priority 5)\n    // ... motor nodes ...\n\n    scheduler.run()\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:37:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 37,
      "lineEnd": 81,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {StateMachine, State, Transition, StateId, Event, StateMachineError}\n\n// Define your context - data the FSM operates on\nstruct RobotContext {\n    battery_level: f32,\n    motors_enabled: bool,\n}\n\nfn main() -> Result<(), StateMachineError> {\n    // Create a state machine\n    let mut fsm = StateMachine::<RobotContext>::new(\"robot_modes\")\n        .add_state(State::new(\"idle\").initial())\n        .add_state(State::new(\"moving\"))\n        .add_state(State::new(\"stopped\"))\n        .add_transition(\n            Transition::new(\"idle\", \"moving\")\n                .on_event(\"start\")\n        )\n        .add_transition(\n            Transition::new(\"moving\", \"stopped\")\n                .on_event(\"stop\")\n        )\n        .add_transition(\n            Transition::new(\"stopped\", \"idle\")\n                .on_event(\"reset\")\n        )\n        .build()?;\n\n    let mut ctx = RobotContext {\n        battery_level: 1.0,\n        motors_enabled: false,\n    };\n\n    // Start the FSM\n    fsm.start(&mut ctx)?;\n    assert_eq!(fsm.current_state(), Some(&StateId::named(\"idle\")));\n\n    // Process events to trigger transitions\n    fsm.process_event(&Event::new(\"start\"), &mut ctx)?;\n    assert_eq!(fsm.current_state(), Some(&StateId::named(\"moving\")));\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/state-machines:87:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 87,
      "lineEnd": 108,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides State\n\nstruct RobotContext {\n    motors_enabled: bool,\n    position: f32,\n}\n\nlet moving_state = State::<RobotContext>::new(\"moving\")\n    .on_entry(|ctx| {\n        println!(\"Entering moving state\");\n        ctx.motors_enabled = true;\n    })\n    .on_tick(|ctx| {\n        // Called each update cycle while in this state\n        ctx.position += 0.1;\n    })\n    .on_exit(|ctx| {\n        println!(\"Exiting moving state\");\n        ctx.motors_enabled = false;\n    });",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:114:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 114,
      "lineEnd": 128,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Transition\n\nstruct RobotContext {\n    battery_level: f32,\n    sensors_ok: bool,\n}\n\nlet transition = Transition::<RobotContext>::new(\"idle\", \"moving\")\n    .on_event(\"start\")\n    .with_guard(|ctx| {\n        // Only allow transition if battery is sufficient and sensors work\n        ctx.battery_level > 0.2 && ctx.sensors_ok\n    });",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:134:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 134,
      "lineEnd": 190,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides StateMachineBuilder\nuse std::time::Duration;\n\nstruct RobotContext {\n    ready: bool,\n    task_complete: bool,\n}\n\nlet fsm = StateMachineBuilder::<RobotContext>::new(\"task_executor\")\n    // Initial state\n    .initial_state(\"waiting\")\n        .on_entry(|ctx| {\n            ctx.ready = false;\n            ctx.task_complete = false;\n        })\n        .done()\n\n    // Working state with timeout\n    .state(\"working\")\n        .on_entry(|ctx| println!(\"Starting work\"))\n        .on_tick(|ctx| {\n            // Do work each tick\n        })\n        .with_timeout(Duration::from_secs(30), \"timeout\")\n        .done()\n\n    // Completed state\n    .state(\"completed\")\n        .on_entry(|ctx| ctx.task_complete = true)\n        .done()\n\n    // Error state\n    .state(\"error\")\n        .on_entry(|_| eprintln!(\"Task failed!\"))\n        .done()\n\n    // Transitions\n    .transition(\"waiting\", \"working\")\n        .on_event(\"start\")\n        .with_guard(|ctx| ctx.ready)\n        .done()\n\n    .transition(\"working\", \"completed\")\n        .on_event(\"done\")\n        .done()\n\n    .transition(\"working\", \"error\")\n        .on_event(\"error\")\n        .done()\n\n    .transition(\"working\", \"error\")\n        .on_event(\"timeout\")  // From timeout\n        .done()\n\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:196:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 196,
      "lineEnd": 199,
      "language": "rust",
      "code": "// Process event immediately\nfsm.process_event(&Event::new(\"start\"), &mut ctx)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:205:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 205,
      "lineEnd": 214,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Event, EventPriority}\n\n// Queue events with different priorities\nfsm.queue_event(Event::new(\"low_priority_event\"))?;\nfsm.queue_event(Event::high_priority(\"emergency_stop\"))?;\n\n// Process all queued events (high priority first)\nfsm.process_queue(&mut ctx)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:218:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 218,
      "lineEnd": 229,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Event, EventPriority}\n\n// Normal priority (default)\nlet normal = Event::new(\"update\");\n\n// High priority - processed first\nlet urgent = Event::high_priority(\"emergency\");\n\n// Custom priority\nlet custom = Event::with_priority(\"command\", EventPriority::Critical);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:239:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 239,
      "lineEnd": 254,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides toggle_machine\n\n// Creates FSM that toggles between \"off\" and \"on\" on \"toggle\" event\nlet mut fsm = toggle_machine::<RobotContext>(\"power\", \"off\", \"on\", \"toggle\")?;\n\nlet mut ctx = RobotContext::default();\nfsm.start(&mut ctx)?;\nassert_eq!(fsm.current_state(), Some(&StateId::named(\"off\")));\n\nfsm.process_event(&Event::new(\"toggle\"), &mut ctx)?;\nassert_eq!(fsm.current_state(), Some(&StateId::named(\"on\")));\n\nfsm.process_event(&Event::new(\"toggle\"), &mut ctx)?;\nassert_eq!(fsm.current_state(), Some(&StateId::named(\"off\")));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:260:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 260,
      "lineEnd": 278,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides sequential_machine\n\n// Progress through calibration steps\nlet mut fsm = sequential_machine::<RobotContext>(\n    \"calibration\",\n    &[\"start\", \"zero_sensors\", \"test_motors\", \"verify\", \"complete\"],\n    \"next\"  // Event that advances to next state\n)?;\n\nlet mut ctx = RobotContext::default();\nfsm.start(&mut ctx)?;\n\n// Advance through states\nfsm.process_event(&Event::new(\"next\"), &mut ctx)?;  // -> zero_sensors\nfsm.process_event(&Event::new(\"next\"), &mut ctx)?;  // -> test_motors\nfsm.process_event(&Event::new(\"next\"), &mut ctx)?;  // -> verify\nfsm.process_event(&Event::new(\"next\"), &mut ctx)?;  // -> complete",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:284:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 284,
      "lineEnd": 294,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides mode_selector_machine\n\n// Robot operation modes\nlet mut fsm = mode_selector_machine::<RobotContext>(\n    \"operation_mode\",\n    &[\"manual\", \"autonomous\", \"calibration\", \"maintenance\"],\n    \"select\",  // Event to select mode (with mode name as data)\n    \"back\"     // Event to return to hub\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:300:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 300,
      "lineEnd": 330,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SharedStateMachine, StateMachine, State, Transition}\nuse std::sync::Arc;\nuse std::thread;\n\n// Create a shared FSM\nlet fsm = StateMachine::<RobotContext>::new(\"shared\")\n    .add_state(State::new(\"idle\").initial())\n    .add_state(State::new(\"active\"))\n    .add_transition(Transition::new(\"idle\", \"active\").on_event(\"activate\"))\n    .build()?;\n\nlet shared = SharedStateMachine::new(fsm);\nlet mut ctx = RobotContext::default();\n\n// Start the FSM\nshared.start(&mut ctx)?;\n\n// Clone for use in threads\nlet shared_clone = shared.clone();\n\nthread::spawn(move || {\n    // Safe to query state from another thread\n    if shared_clone.is_running() {\n        println!(\"FSM is running\");\n    }\n});\n\n// Query current state (thread-safe)\nassert_eq!(shared.current_state(), Some(StateId::named(\"idle\")));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:336:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 336,
      "lineEnd": 343,
      "language": "rust",
      "code": "let metrics = fsm.metrics();\n\nprintln!(\"Successful transitions: {}\", metrics.successful_transitions);\nprintln!(\"Failed transitions: {}\", metrics.failed_transitions);\nprintln!(\"Events processed: {}\", metrics.events_processed);\nprintln!(\"Current state duration: {:?}\", metrics.current_state_duration);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:349:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 349,
      "lineEnd": 444,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides StateMachineBuilder\n\nstruct RobotContext {\n    battery_level: f32,\n    emergency_stop: bool,\n    localized: bool,\n}\n\nlet robot_modes = StateMachineBuilder::<RobotContext>::new(\"robot_modes\")\n    // Boot state\n    .initial_state(\"booting\")\n        .on_entry(|_| println!(\"Robot booting...\"))\n        .done()\n\n    // Idle - ready but not moving\n    .state(\"idle\")\n        .on_entry(|_| println!(\"Robot ready\"))\n        .done()\n\n    // Autonomous navigation\n    .state(\"autonomous\")\n        .on_tick(|ctx| {\n            // Run navigation logic\n        })\n        .done()\n\n    // Manual teleoperation\n    .state(\"manual\")\n        .on_entry(|_| println!(\"Manual control active\"))\n        .done()\n\n    // Emergency stopped\n    .state(\"emergency\")\n        .on_entry(|ctx| {\n            ctx.emergency_stop = true;\n            eprintln!(\"EMERGENCY STOP ACTIVATED\");\n        })\n        .done()\n\n    // Charging\n    .state(\"charging\")\n        .on_tick(|ctx| {\n            ctx.battery_level += 0.01;  // Simulate charging\n        })\n        .done()\n\n    // Transitions\n    .transition(\"booting\", \"idle\")\n        .on_event(\"boot_complete\")\n        .done()\n\n    .transition(\"idle\", \"autonomous\")\n        .on_event(\"start_autonomous\")\n        .with_guard(|ctx| ctx.localized && ctx.battery_level > 0.2)\n        .done()\n\n    .transition(\"idle\", \"manual\")\n        .on_event(\"enable_manual\")\n        .done()\n\n    .transition(\"autonomous\", \"idle\")\n        .on_event(\"stop\")\n        .done()\n\n    .transition(\"manual\", \"idle\")\n        .on_event(\"disable_manual\")\n        .done()\n\n    // Emergency stop from any active state\n    .transition(\"autonomous\", \"emergency\")\n        .on_event(\"emergency_stop\")\n        .done()\n\n    .transition(\"manual\", \"emergency\")\n        .on_event(\"emergency_stop\")\n        .done()\n\n    // Recovery from emergency\n    .transition(\"emergency\", \"idle\")\n        .on_event(\"reset\")\n        .with_guard(|ctx| !ctx.emergency_stop)\n        .done()\n\n    // Charging transitions\n    .transition(\"idle\", \"charging\")\n        .on_event(\"dock_connected\")\n        .done()\n\n    .transition(\"charging\", \"idle\")\n        .on_event(\"undock\")\n        .with_guard(|ctx| ctx.battery_level > 0.3)\n        .done()\n\n    .build()?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:448:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 448,
      "lineEnd": 511,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides StateMachineBuilder\n\nstruct NavContext {\n    goal_reached: bool,\n    obstacle_detected: bool,\n    path_valid: bool,\n}\n\nlet navigation_fsm = StateMachineBuilder::<NavContext>::new(\"navigation\")\n    .initial_state(\"idle\")\n        .done()\n\n    .state(\"planning\")\n        .on_entry(|ctx| ctx.path_valid = false)\n        .done()\n\n    .state(\"following_path\")\n        .on_tick(|ctx| {\n            // Execute path following\n        })\n        .done()\n\n    .state(\"avoiding_obstacle\")\n        .on_entry(|_| println!(\"Obstacle avoidance active\"))\n        .done()\n\n    .state(\"goal_reached\")\n        .on_entry(|ctx| ctx.goal_reached = true)\n        .done()\n\n    // Start navigation\n    .transition(\"idle\", \"planning\")\n        .on_event(\"navigate_to\")\n        .done()\n\n    // Path ready\n    .transition(\"planning\", \"following_path\")\n        .on_event(\"path_found\")\n        .with_guard(|ctx| ctx.path_valid)\n        .done()\n\n    // Obstacle detected\n    .transition(\"following_path\", \"avoiding_obstacle\")\n        .on_event(\"obstacle\")\n        .done()\n\n    // Obstacle cleared\n    .transition(\"avoiding_obstacle\", \"following_path\")\n        .on_event(\"clear\")\n        .done()\n\n    // Goal reached\n    .transition(\"following_path\", \"goal_reached\")\n        .on_event(\"arrived\")\n        .done()\n\n    // Reset\n    .transition(\"goal_reached\", \"idle\")\n        .on_event(\"reset\")\n        .done()\n\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/state-machines:517:rust",
      "file": "content/docs/concepts/state-machines.mdx",
      "lineStart": 517,
      "lineEnd": 566,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Node, Hub, Subscriber, StateMachine, StateMachineBuilder, Event}\n\nstruct RobotModeContext {\n    current_velocity: f32,\n}\n\n#[horus::node]\nstruct ModeController {\n    fsm: StateMachine<RobotModeContext>,\n    ctx: RobotModeContext,\n    cmd_sub: Subscriber<String>,\n}\n\nimpl ModeController {\n    pub fn new(hub: &Hub) -> Result<Self> {\n        let fsm = StateMachineBuilder::<RobotModeContext>::new(\"mode_ctrl\")\n            .initial_state(\"idle\").done()\n            .state(\"active\").done()\n            .transition(\"idle\", \"active\").on_event(\"start\").done()\n            .transition(\"active\", \"idle\").on_event(\"stop\").done()\n            .build()?;\n\n        Ok(Self {\n            fsm,\n            ctx: RobotModeContext { current_velocity: 0.0 },\n            cmd_sub: hub.subscribe(\"mode_commands\")?,\n        })\n    }\n}\n\nimpl Node for ModeController {\n    fn init(&mut self) -> Result<()> {\n        self.fsm.start(&mut self.ctx)?;\n        Ok(())\n    }\n\n    fn tick(&mut self) -> Result<()> {\n        // Check for mode commands\n        if let Some(cmd) = self.cmd_sub.try_recv() {\n            self.fsm.process_event(&Event::new(&cmd), &mut self.ctx)?;\n        }\n\n        // Tick the FSM (runs on_tick callbacks)\n        self.fsm.tick(&mut self.ctx)?;\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/what-is-horus:47:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 47,
      "lineEnd": 63,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a publisher\nlet publisher: Hub<f32> = Hub::new(\"temperature\")?;\n\n// Create a subscriber\nlet subscriber: Hub<f32> = Hub::new(\"temperature\")?;\n\n// Send data\npublisher.send(25.0, &mut ctx).ok();\n\n// Receive data\nif let Some(temp) = subscriber.recv(&mut ctx) {\n    println!(\"Temperature: {:.1}C\", temp);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/what-is-horus:67:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 67,
      "lineEnd": 76,
      "language": "rust",
      "code": "node! {\n    SensorNode {\n        pub { temperature: f32 -> \"temperature\" }\n        tick(ctx) {\n            self.temperature.send(25.0, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/what-is-horus:80:bash",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 80,
      "lineEnd": 89,
      "language": "bash",
      "code": "# Create a new project\nhorus new my_project\n\n# Run your application\nhorus run\n\n# Monitor in real-time\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/what-is-horus:100:python",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 100,
      "lineEnd": 114,
      "language": "python",
      "code": "import horus\n\ndef sensor_tick(node):\n    node.send(\"temperature\", 25.0)\n\nsensor = horus.Node(\n    name=\"sensor\",\n    pubs=[\"temperature\"],\n    tick=sensor_tick,\n    rate=10\n)\n\nhorus.run(sensor)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/what-is-horus:137:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 137,
      "lineEnd": 155,
      "language": "rust",
      "code": "impl Node for MySensor {\n    fn name(&self) -> &'static str { \"MySensor\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor starting up\");\n        Ok(())\n    }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Read sensor, send data - runs repeatedly\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor shutting down\");\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/what-is-horus:165:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 165,
      "lineEnd": 179,
      "language": "rust",
      "code": "// Node A publishes temperature\nlet pub_a: Hub<f32> = Hub::new(\"temperature\")?;\npub_a.send(25.0, &mut ctx);\n\n// Node B also publishes temperature\nlet pub_b: Hub<f32> = Hub::new(\"temperature\")?;\npub_b.send(30.0, &mut ctx);\n\n// Node C receives from both\nlet sub: Hub<f32> = Hub::new(\"temperature\")?;\nif let Some(temp) = sub.recv(&mut ctx) {\n    println!(\"Got: {}\", temp);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/what-is-horus:185:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 185,
      "lineEnd": 191,
      "language": "rust",
      "code": "// Create a publisher\nlet publisher: Hub<f32> = Hub::new(\"temperature\")?;\n\n// Create a subscriber (same topic name)\nlet subscriber: Hub<f32> = Hub::new(\"temperature\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/what-is-horus:201:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 201,
      "lineEnd": 211,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\n\n// Add nodes with priorities\nscheduler.add(Box::new(SensorNode::new()?), 0, Some(true));  // Priority 0 (highest)\nscheduler.add(Box::new(ProcessNode::new()?), 1, Some(true)); // Priority 1\nscheduler.add(Box::new(DisplayNode::new()?), 2, Some(true)); // Priority 2\n\n// Run (Ctrl+C to stop)\nscheduler.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/concepts/what-is-horus:263:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 263,
      "lineEnd": 271,
      "language": "rust",
      "code": "fn main() {\n    loop {\n        let temp = read_sensor();\n        let filtered = process(temp);\n        display(filtered);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/concepts/what-is-horus:280:rust",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 280,
      "lineEnd": 289,
      "language": "rust",
      "code": "// SensorNode - reusable, testable, independent\nstruct SensorNode { data_pub: Hub<f32> }\n\n// ProcessNode - can swap implementation\nstruct ProcessNode { data_sub: Hub<f32>, processed_pub: Hub<f32> }\n\n// DisplayNode - can replace with LogNode, etc.\nstruct DisplayNode { data_sub: Hub<f32> }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/concepts/what-is-horus:325:text",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 325,
      "lineEnd": 353,
      "language": "text",
      "code": "+-------------------------------------------+\n|         Your Application                  |\n+-------------------------------------------+\n|                                           |\n|  +--------+  +--------+  +--------+       |\n|  | Sensor |  | Process|  |Display |       |\n|  |  Node  |  |  Node  |  |  Node  |       |\n|  +---+----+  +---+----+  +---+----+       |\n|      |pub        |sub/pub    |sub         |\n|      v           v           v            |\n+-------------------------------------------+\n|         Shared Memory Topics              |\n|     \"sensor.temp\"  \"filtered.temp\"        |\n+-------------------------------------------+\n|         HORUS Framework                   |\n|  - Hub (Pub/Sub Communication)            |\n|  - Scheduler (Priority Execution)         |\n|  - Logging (Debugging & Metrics)          |\n|  - Monitor (Real-time Monitoring)       |\n+-------------------------------------------+\n         ^\n         | Uses platform shared memory\n         v\n+-------------------------------------------+\n|         Operating System                  |\n|  (Linux/macOS/Windows supported)          |\n+-------------------------------------------+",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/concepts/what-is-horus:374:bash",
      "file": "content/docs/concepts/what-is-horus.mdx",
      "lineStart": 374,
      "lineEnd": 377,
      "language": "bash",
      "code": "df -h /dev/shm           # Available space\nls -lh /dev/shm/horus/   # Active topics",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:28:text",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 28,
      "lineEnd": 32,
      "language": "text",
      "code": "Camera Node ──Hub──> Vision Node ──Hub──> Control Node\n   (Fast)            (AI/CV)             (Real-time)\n   ~16ms             ~20-50ms            ~1ms",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:44:bash",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 44,
      "lineEnd": 46,
      "language": "bash",
      "code": "horus run --enable opencv",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:50:yaml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 50,
      "lineEnd": 53,
      "language": "yaml",
      "code": "enable:\n  - opencv",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:56:bash",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 56,
      "lineEnd": 58,
      "language": "bash",
      "code": "horus run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:62:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 62,
      "lineEnd": 65,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"opencv-backend\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:71:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 71,
      "lineEnd": 88,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, CameraNode, Result}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Camera node with OpenCV backend\n    let mut camera = CameraNode::new()?;\n    camera.set_device_id(0);  // Default camera\n    camera.set_resolution(640, 480);\n    camera.set_fps(30.0);\n    camera.set_topic(\"camera.raw\");\n\n    scheduler.add(Box::new(camera), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:92:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 92,
      "lineEnd": 153,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse opencv::{\n    prelude::*,\n    core::{Mat, Vector},\n    imgproc,\n    videoio::{VideoCapture, CAP_ANY}\n};\n\n#[derive(Clone, Debug)]\npub struct ImageFrame {\n    pub stamp_nanos: u64,\n    pub width: u32,\n    pub height: u32,\n    pub data: Vec<u8>,\n}\n\npub struct VisionProcessorNode {\n    camera_sub: Hub<ImageFrame>,\n    detections_pub: Hub<String>,\n}\n\nimpl VisionProcessorNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            detections_pub: Hub::new(\"vision.detections\")?,\n        })\n    }\n\n    fn process_frame(&self, frame_data: &[u8], width: u32, height: u32) -> Option<String> {\n        // Convert to OpenCV Mat\n        let mut mat = Mat::from_slice(frame_data).ok()?;\n        let mat = mat.reshape(3, height as i32).ok()?;\n\n        // Convert to grayscale\n        let mut gray = Mat::default();\n        imgproc::cvt_color(&mat, &mut gray, imgproc::COLOR_BGR2GRAY, 0).ok()?;\n\n        // Simple edge detection\n        let mut edges = Mat::default();\n        imgproc::canny(&gray, &mut edges, 50.0, 150.0, 3, false).ok()?;\n\n        // Count edge pixels (simple object detection metric)\n        let edge_count = imgproc::count_non_zero(&edges).ok()?;\n\n        Some(format!(\"edges_detected:{}\", edge_count))\n    }\n}\n\nimpl Node for VisionProcessorNode {\n    fn name(&self) -> &'static str { \"VisionProcessorNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            if let Some(result) = self.process_frame(&frame.data, frame.width, frame.height) {\n                self.detections_pub.send(result, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:166:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 166,
      "lineEnd": 171,
      "language": "toml",
      "code": "[dependencies]\nort = \"2.0\"  # ONNX Runtime bindings\nndarray = \"0.15\"\nimage = \"0.24\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:174:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 174,
      "lineEnd": 237,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse ort::{GraphOptimizationLevel, Session};\nuse ndarray::{Array, IxDyn};\nuse image::{DynamicImage, imageops::FilterType};\n\n#[derive(Clone, Debug)]\npub struct Detection {\n    pub class_id: usize,\n    pub confidence: f32,\n    pub bbox: [f32; 4],  // x, y, w, h\n}\n\npub struct YOLOv8Node {\n    camera_sub: Hub<ImageFrame>,\n    detections_pub: Hub<Vec<Detection>>,\n    session: Session,\n}\n\nimpl YOLOv8Node {\n    pub fn new(model_path: &str) -> Result<Self> {\n        // Load ONNX model\n        let session = Session::builder()\n            .map_err(|e| Error::Config(format!(\"ONNX error: {}\", e)))?\n            .with_optimization_level(GraphOptimizationLevel::Level3)\n            .map_err(|e| Error::Config(format!(\"ONNX error: {}\", e)))?\n            .commit_from_file(model_path)\n            .map_err(|e| Error::Config(format!(\"Failed to load model: {}\", e)))?;\n\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            detections_pub: Hub::new(\"vision.detections\")?,\n            session,\n        })\n    }\n\n    fn preprocess_image(&self, img_data: &[u8], width: u32, height: u32) -> Option<Array<f32, IxDyn>> {\n        // Resize to 640x640, convert RGB to CHW format, normalize to 0-1\n        // See: https://docs.rs/image and https://docs.rs/ndarray for details\n        todo!(\"Implement using image and ndarray crates\")\n    }\n\n    fn run_inference(&self, input: Array<f32, IxDyn>) -> Option<Vec<Detection>> {\n        // Run ONNX model and parse YOLOv8 output format [batch, 84, 8400]\n        // Filter by confidence threshold, extract bounding boxes and classes\n        // See: https://docs.rs/ort for ONNX Runtime usage\n        todo!(\"Implement YOLOv8 output parsing\")\n    }\n}\n\nimpl Node for YOLOv8Node {\n    fn name(&self) -> &'static str { \"YOLOv8Node\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            if let Some(input) = self.preprocess_image(&frame.data, frame.width, frame.height) {\n                if let Some(detections) = self.run_inference(input) {\n                    self.detections_pub.send(detections, &mut ctx).ok();\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:240:bash",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 240,
      "lineEnd": 244,
      "language": "bash",
      "code": "# Export from Ultralytics\npip install ultralytics\npython -c \"from ultralytics import YOLO; model = YOLO('yolov8n.pt'); model.export(format='onnx')\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:251:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 251,
      "lineEnd": 254,
      "language": "toml",
      "code": "[dependencies]\ntflite = \"0.9\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:257:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 257,
      "lineEnd": 332,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse tflite::{FlatBufferModel, InterpreterBuilder, ops::builtin::BuiltinOpResolver};\n\npub struct TFLiteClassifierNode {\n    camera_sub: Hub<ImageFrame>,\n    class_pub: Hub<String>,\n    interpreter: tflite::Interpreter,\n    labels: Vec<String>,\n}\n\nimpl TFLiteClassifierNode {\n    pub fn new(model_path: &str, labels_path: &str) -> Result<Self> {\n        // Load TFLite model\n        let model = FlatBufferModel::build_from_file(model_path)\n            .map_err(|e| Error::Config(format!(\"TFLite error: {}\", e)))?;\n\n        let resolver = BuiltinOpResolver::default();\n        let builder = InterpreterBuilder::new(model, resolver)\n            .map_err(|e| Error::Config(format!(\"Builder error: {}\", e)))?;\n\n        let mut interpreter = builder.build()\n            .map_err(|e| Error::Config(format!(\"Interpreter error: {}\", e)))?;\n\n        interpreter.allocate_tensors()\n            .map_err(|e| Error::Config(format!(\"Allocation error: {}\", e)))?;\n\n        // Load class labels\n        let labels = std::fs::read_to_string(labels_path)\n            .map_err(|e| Error::Config(format!(\"Labels error: {}\", e)))?\n            .lines()\n            .map(String::from)\n            .collect();\n\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            class_pub: Hub::new(\"vision.classification\")?,\n            interpreter,\n            labels,\n        })\n    }\n\n    fn classify(&mut self, img_data: &[u8]) -> Option<String> {\n        // Preprocess and set input tensor\n        let input_tensor = self.interpreter.input(0)?;\n        // ... preprocessing code ...\n\n        // Run inference\n        self.interpreter.invoke().ok()?;\n\n        // Get output\n        let output_tensor = self.interpreter.output(0)?;\n        let scores = output_tensor.data::<f32>();\n\n        // Find top class\n        let (max_idx, max_score) = scores\n            .iter()\n            .enumerate()\n            .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())?;\n\n        Some(format!(\"{}: {:.2}%\", self.labels[max_idx], max_score * 100.0))\n    }\n}\n\nimpl Node for TFLiteClassifierNode {\n    fn name(&self) -> &'static str { \"TFLiteClassifierNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            if let Some(result) = self.classify(&frame.data) {\n                self.class_pub.send(result, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:339:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 339,
      "lineEnd": 342,
      "language": "toml",
      "code": "[dependencies]\ntract-onnx = \"0.21\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:345:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 345,
      "lineEnd": 397,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse tract_onnx::prelude::*;\n\npub struct TractInferenceNode {\n    camera_sub: Hub<ImageFrame>,\n    output_pub: Hub<String>,\n    model: SimplePlan<TypedFact, Box<dyn TypedOp>, Graph<TypedFact, Box<dyn TypedOp>>>,\n}\n\nimpl TractInferenceNode {\n    pub fn new(model_path: &str) -> Result<Self> {\n        // Load ONNX model with Tract\n        let model = tract_onnx::onnx()\n            .model_for_path(model_path)\n            .map_err(|e| Error::Config(format!(\"Tract error: {}\", e)))?\n            .into_optimized()\n            .map_err(|e| Error::Config(format!(\"Optimization error: {}\", e)))?\n            .into_runnable()\n            .map_err(|e| Error::Config(format!(\"Runnable error: {}\", e)))?;\n\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            output_pub: Hub::new(\"vision.output\")?,\n            model,\n        })\n    }\n\n    fn run_inference(&self, input_data: &[f32]) -> Option<String> {\n        let input = tract_ndarray::arr1(input_data).into_dyn();\n        let result = self.model.run(tvec!(input.into())).ok()?;\n\n        // Process output\n        let output = result[0].to_array_view::<f32>().ok()?;\n        Some(format!(\"Inference result: {:?}\", output))\n    }\n}\n\nimpl Node for TractInferenceNode {\n    fn name(&self) -> &'static str { \"TractInferenceNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            // Convert frame to input format\n            let input_data: Vec<f32> = frame.data.iter().map(|&x| x as f32 / 255.0).collect();\n\n            if let Some(result) = self.run_inference(&input_data) {\n                self.output_pub.send(result, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:429:bash",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 429,
      "lineEnd": 438,
      "language": "bash",
      "code": "# Hugging Face\nhuggingface-cli download ultralytics/yolov8n --include \"*.onnx\"\n\n# TensorFlow Hub\nwget https://tfhub.dev/tensorflow/lite-model/ssd_mobilenet_v1/1/metadata/1?lite-format=tflite\n\n# ONNX Model Zoo\nwget https://github.com/onnx/models/raw/main/vision/object_detection_segmentation/yolov4/model/yolov4.onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:453:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 453,
      "lineEnd": 456,
      "language": "toml",
      "code": "[dependencies]\nllama_cpp_rs = \"0.4\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:459:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 459,
      "lineEnd": 522,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse llama_cpp_rs::{LlamaModel, LlamaParams, LlamaContext};\n\npub struct LLMCommandNode {\n    text_sub: Hub<String>,  // Natural language commands\n    cmd_pub: Hub<String>,   // Structured robot commands\n    context: LlamaContext,\n}\n\nimpl LLMCommandNode {\n    pub fn new(model_path: &str) -> Result<Self> {\n        // Load LLaMA model (Llama 2, Mistral, Phi, etc.)\n        let params = LlamaParams::default();\n        let model = LlamaModel::load_from_file(model_path, params)\n            .map_err(|e| Error::Config(format!(\"Failed to load LLM: {}\", e)))?;\n\n        let context = model.create_context(LlamaParams::default())\n            .map_err(|e| Error::Config(format!(\"Context error: {}\", e)))?;\n\n        Ok(Self {\n            text_sub: Hub::new(\"speech.text\")?,\n            cmd_pub: Hub::new(\"robot.commands\")?,\n            context,\n        })\n    }\n\n    fn generate_command(&mut self, user_input: &str) -> Option<String> {\n        let prompt = format!(\n            \"You are a robot command interpreter. Convert natural language to JSON commands.\\n\\\n            User: {}\\n\\\n            Command (JSON): \",\n            user_input\n        );\n\n        // Generate response\n        let output = self.context.predict(\n            prompt,\n            64,  // max tokens\n            true,  // echo prompt\n            |token| {\n                // Token callback\n                print!(\"{}\", token);\n                true\n            }\n        ).ok()?;\n\n        // Extract JSON command\n        Some(output.trim().to_string())\n    }\n}\n\nimpl Node for LLMCommandNode {\n    fn name(&self) -> &'static str { \"LLMCommandNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(text) = self.text_sub.recv(&mut ctx) {\n            if let Some(command) = self.generate_command(&text) {\n                self.cmd_pub.send(command, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:525:bash",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 525,
      "lineEnd": 531,
      "language": "bash",
      "code": "# Download a model (Llama 2, Mistral, Phi-2, etc.)\nwget https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.2-GGUF/resolve/main/mistral-7b-instruct-v0.2.Q4_K_M.gguf\n\n# Run with HORUS\nhorus run robot_with_llm.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:546:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 546,
      "lineEnd": 552,
      "language": "toml",
      "code": "[dependencies]\ncandle-core = \"0.3\"\ncandle-nn = \"0.3\"\ncandle-transformers = \"0.3\"\ntokenizers = \"0.15\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:555:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 555,
      "lineEnd": 621,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse candle_core::{Device, Tensor};\nuse candle_transformers::models::llama::{Llama, Config};\nuse tokenizers::Tokenizer;\n\npub struct CandleLLMNode {\n    text_sub: Hub<String>,\n    response_pub: Hub<String>,\n    model: Llama,\n    tokenizer: Tokenizer,\n    device: Device,\n}\n\nimpl CandleLLMNode {\n    pub fn new(model_path: &str, tokenizer_path: &str) -> Result<Self> {\n        let device = Device::cuda_if_available(0)\n            .map_err(|e| Error::Config(format!(\"Device error: {}\", e)))?;\n\n        let config = Config::default();\n        let model = Llama::load(model_path, &config, &device)\n            .map_err(|e| Error::Config(format!(\"Model load error: {}\", e)))?;\n\n        let tokenizer = Tokenizer::from_file(tokenizer_path)\n            .map_err(|e| Error::Config(format!(\"Tokenizer error: {}\", e)))?;\n\n        Ok(Self {\n            text_sub: Hub::new(\"user.input\")?,\n            response_pub: Hub::new(\"llm.response\")?,\n            model,\n            tokenizer,\n            device,\n        })\n    }\n\n    fn generate(&self, prompt: &str, max_tokens: usize) -> Option<String> {\n        // Tokenize input\n        let encoding = self.tokenizer.encode(prompt, true).ok()?;\n        let tokens = encoding.get_ids();\n\n        let input_tensor = Tensor::new(tokens, &self.device).ok()?\n            .unsqueeze(0).ok()?;\n\n        // Generate response\n        let output = self.model.forward(&input_tensor, 0).ok()?;\n\n        // Decode tokens\n        let output_tokens: Vec<u32> = output\n            .to_vec1::<u32>()\n            .ok()?;\n\n        self.tokenizer.decode(&output_tokens, true).ok()\n    }\n}\n\nimpl Node for CandleLLMNode {\n    fn name(&self) -> &'static str { \"CandleLLMNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(input) = self.text_sub.recv(&mut ctx) {\n            if let Some(response) = self.generate(&input, 100) {\n                self.response_pub.send(response, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:630:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 630,
      "lineEnd": 635,
      "language": "toml",
      "code": "[dependencies]\nreqwest = { version = \"0.11\", features = [\"blocking\", \"json\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:638:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 638,
      "lineEnd": 733,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse reqwest::blocking::Client;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize)]\nstruct ChatRequest {\n    model: String,\n    messages: Vec<ChatMessage>,\n    temperature: f32,\n    max_tokens: u32,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct ChatMessage {\n    role: String,\n    content: String,\n}\n\n#[derive(Deserialize)]\nstruct ChatResponse {\n    choices: Vec<ChatChoice>,\n}\n\n#[derive(Deserialize)]\nstruct ChatChoice {\n    message: ChatMessage,\n}\n\npub struct GPT4PlannerNode {\n    goal_sub: Hub<String>,\n    plan_pub: Hub<String>,\n    client: Client,\n    api_key: String,\n    conversation: Vec<ChatMessage>,\n}\n\nimpl GPT4PlannerNode {\n    pub fn new(api_key: String) -> Result<Self> {\n        let system_prompt = ChatMessage {\n            role: \"system\".to_string(),\n            content: \"You are a robot task planner. Generate step-by-step plans in JSON format.\".to_string(),\n        };\n\n        Ok(Self {\n            goal_sub: Hub::new(\"user.goal\")?,\n            plan_pub: Hub::new(\"robot.plan\")?,\n            client: Client::new(),\n            api_key,\n            conversation: vec![system_prompt],\n        })\n    }\n\n    fn generate_plan(&mut self, goal: &str) -> Option<String> {\n        // Add user message\n        self.conversation.push(ChatMessage {\n            role: \"user\".to_string(),\n            content: goal.to_string(),\n        });\n\n        let request = ChatRequest {\n            model: \"gpt-4-turbo-preview\".to_string(),\n            messages: self.conversation.clone(),\n            temperature: 0.7,\n            max_tokens: 500,\n        };\n\n        let response = self.client\n            .post(\"https://api.openai.com/v1/chat/completions\")\n            .header(\"Authorization\", format!(\"Bearer {}\", self.api_key))\n            .json(&request)\n            .send()\n            .ok()?;\n\n        let chat_response: ChatResponse = response.json().ok()?;\n        let assistant_message = chat_response.choices[0].message.clone();\n\n        // Add to conversation history\n        self.conversation.push(assistant_message.clone());\n\n        Some(assistant_message.content)\n    }\n}\n\nimpl Node for GPT4PlannerNode {\n    fn name(&self) -> &'static str { \"GPT4PlannerNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(goal) = self.goal_sub.recv(&mut ctx) {\n            if let Some(plan) = self.generate_plan(&goal) {\n                self.plan_pub.send(plan, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:738:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 738,
      "lineEnd": 821,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse reqwest::blocking::Client;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize)]\nstruct ClaudeRequest {\n    model: String,\n    max_tokens: u32,\n    messages: Vec<ClaudeMessage>,\n}\n\n#[derive(Serialize, Deserialize)]\nstruct ClaudeMessage {\n    role: String,\n    content: String,\n}\n\n#[derive(Deserialize)]\nstruct ClaudeResponse {\n    content: Vec<ContentBlock>,\n}\n\n#[derive(Deserialize)]\nstruct ContentBlock {\n    text: String,\n}\n\npub struct ClaudeReasoningNode {\n    sensor_sub: Hub<String>,  // Sensor readings as JSON\n    decision_pub: Hub<String>,\n    client: Client,\n    api_key: String,\n}\n\nimpl ClaudeReasoningNode {\n    pub fn new(api_key: String) -> Result<Self> {\n        Ok(Self {\n            sensor_sub: Hub::new(\"sensors.summary\")?,\n            decision_pub: Hub::new(\"robot.decision\")?,\n            client: Client::new(),\n            api_key,\n        })\n    }\n\n    fn reason(&self, sensor_data: &str) -> Option<String> {\n        let request = ClaudeRequest {\n            model: \"claude-3-opus-20240229\".to_string(),\n            max_tokens: 1024,\n            messages: vec![ClaudeMessage {\n                role: \"user\".to_string(),\n                content: format!(\n                    \"Given these robot sensor readings: {}\\n\\\n                    What should the robot do next? Respond with a JSON action.\",\n                    sensor_data\n                ),\n            }],\n        };\n\n        let response = self.client\n            .post(\"https://api.anthropic.com/v1/messages\")\n            .header(\"x-api-key\", &self.api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .json(&request)\n            .send()\n            .ok()?;\n\n        let claude_response: ClaudeResponse = response.json().ok()?;\n        Some(claude_response.content[0].text.clone())\n    }\n}\n\nimpl Node for ClaudeReasoningNode {\n    fn name(&self) -> &'static str { \"ClaudeReasoningNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(sensors) = self.sensor_sub.recv(&mut ctx) {\n            if let Some(decision) = self.reason(&sensors) {\n                self.decision_pub.send(decision, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:829:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 829,
      "lineEnd": 903,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse reqwest::blocking::Client;\nuse serde::{Deserialize, Serialize};\nuse base64::{Engine as _, engine::general_purpose};\n\n#[derive(Serialize)]\nstruct VisionMessage {\n    role: String,\n    content: Vec<VisionContent>,\n}\n\n#[derive(Serialize)]\n#[serde(tag = \"type\", rename_all = \"lowercase\")]\nenum VisionContent {\n    Text { text: String },\n    ImageUrl { image_url: ImageUrl },\n}\n\n#[derive(Serialize)]\nstruct ImageUrl {\n    url: String,\n    detail: String,\n}\n\npub struct SceneUnderstandingNode {\n    camera_sub: Hub<ImageFrame>,\n    description_pub: Hub<String>,\n    client: Client,\n    api_key: String,\n}\n\nimpl SceneUnderstandingNode {\n    pub fn new(api_key: String) -> Result<Self> {\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            description_pub: Hub::new(\"scene.description\")?,\n            client: Client::new(),\n            api_key,\n        })\n    }\n\n    fn understand_scene(&self, image_data: &[u8]) -> Option<String> {\n        // Convert to base64\n        let base64_image = general_purpose::STANDARD.encode(image_data);\n\n        // Construct vision API request with base64 image\n        let response = client.post(\"https://api.openai.com/gpt-4-vision\")\n            .json(&json!({\n                \"model\": \"gpt-4-vision-preview\",\n                \"messages\": [{\"role\": \"user\", \"content\": [{\"type\": \"image_url\", \"image_url\": {\"url\": format!(\"data:image/jpeg;base64,{}\", base64_image)}}]}]\n            }))\n            .send()\n            .ok()?;\n\n        let result: serde_json::Value = response.json().ok()?;\n        Some(result[\"choices\"][0][\"message\"][\"content\"].as_str()?.to_string())\n    }\n}\n\nimpl Node for SceneUnderstandingNode {\n    fn name(&self) -> &'static str { \"SceneUnderstandingNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            // Process every 30th frame to reduce API calls\n            if frame.stamp_nanos % 30 == 0 {\n                if let Some(description) = self.understand_scene(&frame.data) {\n                    self.description_pub.send(description, &mut ctx).ok();\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:907:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 907,
      "lineEnd": 971,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Scheduler, DifferentialDriveNode, Result}\n\n// Combine speech recognition + LLM + robot control\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // 1. Speech-to-text (via external service or Whisper)\n    let speech_node = SpeechRecognitionNode::new()?;\n\n    // 2. LLM converts natural language to commands\n    let api_key = std::env::var(\"OPENAI_API_KEY\")\n        .expect(\"Set OPENAI_API_KEY environment variable\");\n    let llm_node = GPT4PlannerNode::new(api_key)?;\n\n    // 3. Command parser extracts motor commands\n    let parser_node = CommandParserNode::new()?;\n\n    // 4. Motor control\n    let drive_node = DifferentialDriveNode::new();\n\n    // Add nodes\n    scheduler.add(Box::new(speech_node), 0, Some(true));\n    scheduler.add(Box::new(llm_node), 1, Some(true));\n    scheduler.add(Box::new(parser_node), 2, Some(true));\n    scheduler.add(Box::new(drive_node), 3, Some(true));\n\n    // User says: \"Move forward slowly\"\n    //  GPT-4: {\"action\": \"move\", \"linear\": 0.3, \"angular\": 0.0}\n    //  Robot moves forward at 0.3 m/s\n\n    scheduler.run()?;\n    Ok(())\n}\n\npub struct CommandParserNode {\n    llm_sub: Hub<String>,\n    cmd_pub: Hub<(f32, f32)>,\n}\n\nimpl CommandParserNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            llm_sub: Hub::new(\"robot.plan\")?,\n            cmd_pub: Hub::new(\"motor.cmd\")?,\n        })\n    }\n}\n\nimpl Node for CommandParserNode {\n    fn name(&self) -> &'static str { \"CommandParserNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(json_str) = self.llm_sub.recv(&mut ctx) {\n            // Parse JSON from LLM\n            if let Ok(cmd) = serde_json::from_str::<serde_json::Value>(&json_str) {\n                let linear = cmd[\"linear\"].as_f64().unwrap_or(0.0) as f32;\n                let angular = cmd[\"angular\"].as_f64().unwrap_or(0.0) as f32;\n\n                self.cmd_pub.send((linear, angular), ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:976:text",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 976,
      "lineEnd": 986,
      "language": "text",
      "code": "Local LLMs (llama.cpp):\n  - Phi-2 (2.7B):     ~100-500ms per response (CPU)\n  - Mistral 7B:       ~500-2000ms (CPU), ~50-200ms (GPU)\n  - Llama 2 13B:      ~1-4s (CPU), ~100-400ms (GPU)\n\nCloud APIs:\n  - GPT-4:            ~1-5s per request\n  - Claude:           ~1-3s per request\n  - GPT-4 Vision:     ~2-6s per request",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:991:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 991,
      "lineEnd": 1010,
      "language": "rust",
      "code": "use std::collections::HashMap;\n\nstruct CachedLLMNode {\n    cache: HashMap<String, String>,\n    // ... llm fields\n}\n\nimpl CachedLLMNode {\n    fn get_response(&mut self, input: &str) -> String {\n        if let Some(cached) = self.cache.get(input) {\n            return cached.clone();\n        }\n\n        let response = self.generate(input);\n        self.cache.insert(input.to_string(), response.clone());\n        response\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1013:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1013,
      "lineEnd": 1017,
      "language": "rust",
      "code": "if frame_count % 30 == 0 {  // Only every 30 frames\n    run_llm_inference();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1025:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1025,
      "lineEnd": 1032,
      "language": "rust",
      "code": "use tokio::spawn;\n\nspawn(async move {\n    let response = llm.generate(prompt).await;\n    response_hub.send(response, None).ok();\n});",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1052:python",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1052,
      "lineEnd": 1069,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport sys\nimport json\n\n# Your ML model here (YOLOv8, TensorFlow, PyTorch, etc.)\ndef detect_objects(image_path):\n    # Mock detection for example\n    return [\n        {\"class\": \"person\", \"confidence\": 0.95, \"bbox\": [100, 100, 200, 300]},\n        {\"class\": \"car\", \"confidence\": 0.87, \"bbox\": [300, 150, 500, 400]}\n    ]\n\nif __name__ == \"__main__\":\n    image_path = sys.argv[1]\n    detections = detect_objects(image_path)\n    print(json.dumps(detections))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:1072:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1072,
      "lineEnd": 1124,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::process::Command;\nuse std::fs;\n\npub struct PythonMLNode {\n    camera_sub: Hub<ImageFrame>,\n    detections_pub: Hub<String>,\n    frame_count: u64,\n}\n\nimpl PythonMLNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            detections_pub: Hub::new(\"ml.detections\")?,\n            frame_count: 0,\n        })\n    }\n\n    fn run_inference(&self, image_data: &[u8]) -> Option<String> {\n        // Save image temporarily\n        let temp_path = format!(\"/tmp/frame_{}.jpg\", self.frame_count);\n        fs::write(&temp_path, image_data).ok()?;\n\n        // Run Python script\n        let output = Command::new(\"python3\")\n            .arg(\"object_detector.py\")\n            .arg(&temp_path)\n            .output()\n            .ok()?;\n\n        // Parse JSON output\n        String::from_utf8(output.stdout).ok()\n    }\n}\n\nimpl Node for PythonMLNode {\n    fn name(&self) -> &'static str { \"PythonMLNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            // Run inference every 10th frame (throttle to reduce load)\n            if self.frame_count % 10 == 0 {\n                if let Some(detections) = self.run_inference(&frame.data) {\n                    self.detections_pub.send(detections, &mut ctx).ok();\n                }\n            }\n            self.frame_count += 1;\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1129:python",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1129,
      "lineEnd": 1143,
      "language": "python",
      "code": "from fastapi import FastAPI, File, UploadFile\nimport uvicorn\n\napp = FastAPI()\n\n@app.post(\"/detect\")\nasync def detect_objects(file: UploadFile = File(...)):\n    # Your ML inference here\n    detections = [{\"class\": \"person\", \"confidence\": 0.95}]\n    return {\"detections\": detections}\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1146:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1146,
      "lineEnd": 1187,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse reqwest::blocking::Client;\n\npub struct HTTPInferenceNode {\n    camera_sub: Hub<ImageFrame>,\n    detections_pub: Hub<String>,\n    client: Client,\n}\n\nimpl HTTPInferenceNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            detections_pub: Hub::new(\"ml.detections\")?,\n            client: Client::new(),\n        })\n    }\n\n    fn run_inference(&self, image_data: &[u8]) -> Option<String> {\n        let response = self.client\n            .post(\"http://localhost:8000/detect\")\n            .body(image_data.to_vec())\n            .send()\n            .ok()?;\n\n        response.text().ok()\n    }\n}\n\nimpl Node for HTTPInferenceNode {\n    fn name(&self) -> &'static str { \"HTTPInferenceNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            if let Some(detections) = self.run_inference(&frame.data) {\n                self.detections_pub.send(detections, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1198:toml",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1198,
      "lineEnd": 1204,
      "language": "toml",
      "code": "[dependencies]\nreqwest = { version = \"0.11\", features = [\"blocking\", \"json\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nbase64 = \"0.21\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:1207:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1207,
      "lineEnd": 1302,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse reqwest::blocking::Client;\nuse serde::{Deserialize, Serialize};\nuse base64::{Engine as _, engine::general_purpose};\n\n#[derive(Serialize)]\nstruct VisionRequest {\n    model: String,\n    messages: Vec<Message>,\n    max_tokens: u32,\n}\n\n#[derive(Serialize)]\nstruct Message {\n    role: String,\n    content: Vec<Content>,\n}\n\n#[derive(Serialize)]\n#[serde(tag = \"type\", rename_all = \"lowercase\")]\nenum Content {\n    Text { text: String },\n    ImageUrl { image_url: ImageUrl },\n}\n\n#[derive(Serialize)]\nstruct ImageUrl {\n    url: String,\n}\n\n#[derive(Deserialize)]\nstruct VisionResponse {\n    choices: Vec<Choice>,\n}\n\n#[derive(Deserialize)]\nstruct Choice {\n    message: ResponseMessage,\n}\n\n#[derive(Deserialize)]\nstruct ResponseMessage {\n    content: String,\n}\n\npub struct OpenAIVisionNode {\n    camera_sub: Hub<ImageFrame>,\n    description_pub: Hub<String>,\n    client: Client,\n    api_key: String,\n}\n\nimpl OpenAIVisionNode {\n    pub fn new(api_key: String) -> Result<Self> {\n        Ok(Self {\n            camera_sub: Hub::new(\"camera.raw\")?,\n            description_pub: Hub::new(\"vision.description\")?,\n            client: Client::new(),\n            api_key,\n        })\n    }\n\n    fn analyze_image(&self, image_data: &[u8]) -> Option<String> {\n        // Convert to base64\n        let base64_image = general_purpose::STANDARD.encode(image_data);\n\n        // Construct vision API request with base64 image\n        let response = client.post(\"https://api.openai.com/gpt-4-vision\")\n            .json(&json!({\n                \"model\": \"gpt-4-vision-preview\",\n                \"messages\": [{\"role\": \"user\", \"content\": [{\"type\": \"image_url\", \"image_url\": {\"url\": format!(\"data:image/jpeg;base64,{}\", base64_image)}}]}]\n            }))\n            .send()\n            .ok()?;\n\n        let vision_response: VisionResponse = response.json().ok()?;\n        Some(vision_response.choices[0].message.content.clone())\n    }\n}\n\nimpl Node for OpenAIVisionNode {\n    fn name(&self) -> &'static str { \"OpenAIVisionNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(frame) = self.camera_sub.recv(&mut ctx) {\n            // Only analyze every 30th frame to avoid API costs\n            if frame.stamp_nanos % 30 == 0 {\n                if let Some(description) = self.analyze_image(&frame.data) {\n                    self.description_pub.send(description, &mut ctx).ok();\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1310:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1310,
      "lineEnd": 1375,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Hub, CameraNode, DifferentialDriveNode, Result}\n\n// Simple vision-based follower\npub struct ObjectFollowerNode {\n    vision_sub: Hub<String>,\n    cmd_pub: Hub<(f32, f32)>,\n}\n\nimpl ObjectFollowerNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            vision_sub: Hub::new(\"vision.detections\")?,\n            cmd_pub: Hub::new(\"motor.cmd\")?,\n        })\n    }\n}\n\nimpl Node for ObjectFollowerNode {\n    fn name(&self) -> &'static str { \"ObjectFollowerNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(detection) = self.vision_sub.recv(&mut ctx) {\n            // Parse edge count from detection string\n            if let Some(count_str) = detection.strip_prefix(\"edges_detected:\") {\n                if let Ok(edge_count) = count_str.parse::<i32>() {\n                    // Simple behavior: move forward if edges detected, stop if not\n                    let (linear, angular) = if edge_count > 1000 {\n                        (0.5, 0.0)  // Move forward\n                    } else {\n                        (0.0, 0.3)  // Turn to search\n                    };\n\n                    self.cmd_pub.send((linear, angular), ctx).ok();\n                }\n            }\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Camera capture (if opencv-backend feature enabled)\n    let mut camera = CameraNode::new()?;\n    camera.set_topic(\"camera.raw\");\n\n    // Vision processing\n    let vision = VisionProcessorNode::new()?;\n\n    // Decision making\n    let follower = ObjectFollowerNode::new()?;\n\n    // Motor control\n    let drive = DifferentialDriveNode::new();\n\n    // Add in priority order\n    scheduler.add(Box::new(camera), 0, Some(true));     // Highest priority\n    scheduler.add(Box::new(vision), 1, Some(true));     // Process images\n    scheduler.add(Box::new(follower), 2, Some(true));   // Make decisions\n    scheduler.add(Box::new(drive), 3, Some(true));      // Control motors\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:1384:text",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1384,
      "lineEnd": 1390,
      "language": "text",
      "code": "Camera:      ~16ms  (30 FPS)\nVision:      ~5-50ms (OpenCV/ML inference)\nDecision:    ~1μs   (HORUS Hub communication)\nControl:     ~1μs   (HORUS Hub communication)\nMotors:      ~1ms   (Hardware actuator delay)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ai-integration:1395:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1395,
      "lineEnd": 1399,
      "language": "rust",
      "code": "if frame_count % 10 == 0 {\n    run_expensive_inference();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1402:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1402,
      "lineEnd": 1414,
      "language": "rust",
      "code": "use std::sync::mpsc;\nlet (tx, rx) = mpsc::channel();\n\n// In tick():\ntx.send(frame_data).ok();\n\n// Separate thread:\nwhile let Ok(data) = rx.recv() {\n    let result = expensive_ml(data);\n    result_hub.send(result, None).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1417:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1417,
      "lineEnd": 1420,
      "language": "rust",
      "code": "// OpenCV can use GPU acceleration automatically\nopencv::core::set_use_optimized(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1430:rust",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1430,
      "lineEnd": 1437,
      "language": "rust",
      "code": "if let Some(result) = try_inference(&data) {\n    control_pub.send(result, &mut ctx).ok();\n} else {\n    // Fallback behavior\n    control_pub.send(default_safe_command(), &mut ctx).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ai-integration:1440:bash",
      "file": "content/docs/development/ai-integration.mdx",
      "lineStart": 1440,
      "lineEnd": 1442,
      "language": "bash",
      "code": "horus monitor  # Watch node timing and message flow",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:13:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 13,
      "lineEnd": 59,
      "language": "bash",
      "code": "# Project Management\nhorus init                 # Initialize workspace in current directory\nhorus new <name>           # Create a new project\nhorus run [file]           # Build and run your app\nhorus build                # Build without running\nhorus test                 # Run tests\nhorus check                # Validate dependencies and environment\nhorus clean                # Clean build artifacts and shared memory\n\n# Monitoring & Debugging\nhorus monitor [port]       # Monitor your system (web or TUI)\nhorus topic <command>      # Topic introspection (list, echo, info, hz, pub)\nhorus node <command>       # Node management (list, info, kill, restart)\nhorus log [node]           # View and filter logs\nhorus doctor               # System diagnostics and health check\n\n# Simulation\nhorus sim2d                # Launch 2D simulator\nhorus sim3d                # Launch 3D simulator\n\n# Coordinate Frames\nhorus hf <command>         # HORUS Frames (list, echo, tree, info, can, hz)\n\n# Package Management\nhorus pkg <command>        # Manage packages (install, publish, etc.)\nhorus add <name>           # Add package, driver, or plugin (smart detection)\nhorus remove <name>        # Remove package, driver, or plugin\nhorus driver <command>     # Driver management (list, info, search)\nhorus plugin <command>     # Plugin management (list, enable, disable)\nhorus cache <command>      # Cache management (info, clean, purge)\n\n# Parameters & Messages\nhorus param <command>      # Parameter management (get, set, list, dump)\nhorus msg <command>        # Message type introspection (list, show, md5)\n\n# Advanced\nhorus launch <file>        # Launch multiple nodes from YAML\nhorus deploy [target]      # Deploy to remote robot\nhorus bridge <command>     # ROS2 bridge for interoperability\nhorus hardware <command>   # Hardware discovery and platform detection\nhorus record <command>     # Record/replay for debugging and testing\n\n# Environment & Auth\nhorus env <command>        # Save/restore environments\nhorus auth <command>       # Login to registry",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:71:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 71,
      "lineEnd": 77,
      "language": "bash",
      "code": "# Initialize in current directory (uses directory name)\nhorus init\n\n# Initialize with custom name\nhorus init --name my_robot",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:81:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 81,
      "lineEnd": 86,
      "language": "bash",
      "code": "horus init [OPTIONS]\n\nOptions:\n  -n, --name <NAME>    Workspace name (defaults to directory name)",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:91:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 91,
      "lineEnd": 95,
      "language": "bash",
      "code": "cd ~/my-robot-code\nhorus init\n# Creates horus.yaml with project configuration",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:98:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 98,
      "lineEnd": 100,
      "language": "bash",
      "code": "horus init --name sensor_array",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:119:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 119,
      "lineEnd": 128,
      "language": "bash",
      "code": "# Interactive mode (asks you questions)\nhorus new my_project\n\n# Rust with node! macro (recommended for reduced boilerplate)\nhorus new my_project --macro\n\n# Python project\nhorus new my_project --python",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:132:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 132,
      "lineEnd": 140,
      "language": "bash",
      "code": "horus new <NAME> [OPTIONS]\n\nOptions:\n  -m, --macro              Rust with node! macro (less boilerplate)\n  -r, --rust               Plain Rust project\n  -p, --python             Python project\n  -o, --output <PATH>      Where to create it (default: current directory)",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:145:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 145,
      "lineEnd": 149,
      "language": "bash",
      "code": "horus new temperature_monitor --macro\ncd temperature_monitor\nhorus run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:152:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 152,
      "lineEnd": 156,
      "language": "bash",
      "code": "horus new sensor_test --python\ncd sensor_test\npython main.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:159:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 159,
      "lineEnd": 161,
      "language": "bash",
      "code": "horus new robot_controller --output ~/projects/robots",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:173:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 173,
      "lineEnd": 182,
      "language": "bash",
      "code": "# Run current directory (finds main.rs or main.py)\nhorus run\n\n# Run specific file\nhorus run src/controller.rs\n\n# Run optimized (release mode)\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:186:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 186,
      "lineEnd": 198,
      "language": "bash",
      "code": "horus run [FILE] [OPTIONS] [-- ARGS]\n\nOptions:\n  -r, --release            Optimize for speed (recommended for benchmarks)\n  -c, --clean              Remove cached build artifacts and dependencies\n                           (Use after updating HORUS or when compilation fails)\n  -d, --drivers <LIST>     Override detected drivers (comma-separated)\n                           Example: --drivers camera,lidar,imu\n  -e, --enable <LIST>      Enable capabilities (comma-separated)\n                           Example: --enable cuda,editor,python\n  -- <ARGS>                Arguments for your program",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:204:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 204,
      "lineEnd": 213,
      "language": "bash",
      "code": "# Enable CUDA GPU acceleration\nhorus run --enable cuda\n\n# Enable multiple capabilities\nhorus run --enable cuda,editor,python\n\n# Combine with hardware features\nhorus run --enable gpio,i2c --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:230:yaml",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 230,
      "lineEnd": 234,
      "language": "yaml",
      "code": "enable:\n  - cuda\n  - editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:251:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 251,
      "lineEnd": 257,
      "language": "bash",
      "code": "horus run  # Debug mode\n# You see: [IPC: 1862ns | Tick: 87μs] - Looks slow!\n\nhorus run --release  # Release mode\n# You see: [IPC: 947ns | Tick: 2μs] - Actually fast!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:314:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 314,
      "lineEnd": 317,
      "language": "bash",
      "code": "horus run\n# Fast iteration, slower execution",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:320:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 320,
      "lineEnd": 323,
      "language": "bash",
      "code": "horus run --release\n# See real speed",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:326:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 326,
      "lineEnd": 328,
      "language": "bash",
      "code": "horus run --build-only --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:331:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 331,
      "lineEnd": 333,
      "language": "bash",
      "code": "horus run --clean --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:336:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 336,
      "lineEnd": 339,
      "language": "bash",
      "code": "# Clean removes cached dependencies from .horus/target/\nhorus run --clean",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:342:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 342,
      "lineEnd": 344,
      "language": "bash",
      "code": "horus run -- --config robot.yaml --verbose",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:360:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 360,
      "lineEnd": 364,
      "language": "bash",
      "code": "cd your_multi_crate_project\ncargo build --release\ncargo run --release",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:367:rust",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 367,
      "lineEnd": 383,
      "language": "rust",
      "code": "// main.rs - everything in one file\nuse horus::prelude::*;\n\nstruct SensorNode { /* ... */ }\nimpl Node for SensorNode { /* ... */ }\n\nstruct ControlNode { /* ... */ }\nimpl Node for ControlNode { /* ... */ }\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));\n    scheduler.add(Box::new(ControlNode::new()?), 1, Some(true));\n    scheduler.run()\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:390:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 390,
      "lineEnd": 393,
      "language": "bash",
      "code": "horus run \"nodes/*.py\"          # Run all Python nodes concurrently\nhorus run \"src/*.rs\"            # Run all Rust nodes concurrently",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:407:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 407,
      "lineEnd": 428,
      "language": "bash",
      "code": "$ horus run \"nodes/*.py\"\n Executing 3 files concurrently:\n  1. nodes/sensor.py (python)\n  2. nodes/controller.py (python)\n  3. nodes/logger.py (python)\n\n Phase 1: Building all files...\n Phase 2: Starting all processes...\n   Started [sensor]\n   Started [controller]\n   Started [logger]\n\n All processes running. Press Ctrl+C to stop.\n\n[sensor] Sensor reading: 25.3°C\n[controller] Motor speed: 45%\n[logger] System operational\n[sensor] Sensor reading: 26.1°C\n[controller] Motor speed: 50%\n[logger] System operational",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:453:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 453,
      "lineEnd": 459,
      "language": "bash",
      "code": "# Check current project\nhorus check\n\n# Check specific package\nhorus check my-package",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:472:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 472,
      "lineEnd": 481,
      "language": "bash",
      "code": "$ horus check\n HORUS framework installed (v0.1.0)\n Cargo toolchain found (1.70.0)\n Python bindings available (3.11)\n Shared memory accessible (/dev/shm)\n All dependencies satisfied\n\n Environment is ready!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:484:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 484,
      "lineEnd": 491,
      "language": "bash",
      "code": "$ horus check\n HORUS framework installed (v0.1.0)\n[FAIL] Missing dependency: horus-vision (required by horus.yaml)\n[FAIL] Shared memory not writable (/dev/shm)\n\n[WARNING] Fix these issues and run 'horus check' again",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:496:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 496,
      "lineEnd": 499,
      "language": "bash",
      "code": "horus check\n# Ensure environment is ready",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:502:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 502,
      "lineEnd": 506,
      "language": "bash",
      "code": "horus pkg install sensor-drivers\nhorus check\n# Verify installation succeeded",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:509:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 509,
      "lineEnd": 512,
      "language": "bash",
      "code": "horus check\n# Identify missing dependencies",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:515:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 515,
      "lineEnd": 522,
      "language": "bash",
      "code": "#!/bin/bash\nif ! horus check; then\n  echo \"Environment validation failed\"\n  exit 1\nfi\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:534:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 534,
      "lineEnd": 543,
      "language": "bash",
      "code": "# Launch default simulation\nhorus sim2d\n\n# Launch with world configuration\nhorus sim2d --world warehouse.yaml\n\n# Headless mode (for testing)\nhorus sim2d --headless",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:547:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 547,
      "lineEnd": 559,
      "language": "bash",
      "code": "horus sim2d [OPTIONS]\n\nOptions:\n  --headless                 Run without GUI (for CI/CD)\n  --world <FILE>             World configuration file\n  --world-image <FILE>       World image file (PNG, JPG, PGM) - occupancy grid\n  --resolution <FLOAT>       Resolution in meters per pixel for world image\n  --threshold <0-255>        Obstacle threshold (darker = obstacle)\n  --robot <FILE>             Robot configuration file\n  --topic <PREFIX>           HORUS topic prefix (default: /robot)\n  --name <NAME>              Robot name for logging (default: robot)",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:573:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 573,
      "lineEnd": 582,
      "language": "bash",
      "code": "# Terminal 1: Launch simulator with world\nhorus sim2d --world maze.yaml\n\n# Terminal 2: Run your navigation code\nhorus run navigation.rs --release\n\n# Terminal 3: Monitor\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:585:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 585,
      "lineEnd": 590,
      "language": "bash",
      "code": "horus sim2d --headless &\nSIM_PID=$!\nhorus run test_behavior.rs --release\nkill $SIM_PID",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:593:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 593,
      "lineEnd": 596,
      "language": "bash",
      "code": "# Load a PGM/PNG map as world\nhorus sim2d --world-image map.pgm --resolution 0.05 --threshold 128",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:602:rust",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 602,
      "lineEnd": 634,
      "language": "rust",
      "code": "// Same code works in sim and on real robot!\nuse horus::prelude::*;\n\nstruct RobotController {\n    cmd_pub: Hub<CmdVel>,\n    lidar_sub: Hub<LaserScan>,\n}\n\nimpl RobotController {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            lidar_sub: Hub::new(\"scan\")?,\n        })\n    }\n}\n\nimpl Node for RobotController {\n    fn name(&self) -> &'static str {\n        \"RobotController\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read simulated LiDAR\n        if let Some(scan) = self.lidar_sub.recv(&mut ctx) {\n            // Send commands to simulated robot\n            let cmd = calculate_motion(&scan);\n            self.cmd_pub.send(cmd, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:648:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 648,
      "lineEnd": 657,
      "language": "bash",
      "code": "# Launch default 3D simulation\nhorus sim3d\n\n# Launch with URDF robot\nhorus sim3d --robot turtlebot3.urdf\n\n# Headless mode for RL training\nhorus sim3d --headless --seed 42",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:661:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 661,
      "lineEnd": 669,
      "language": "bash",
      "code": "horus sim3d [OPTIONS]\n\nOptions:\n  --headless         Run without GUI (for RL training, CI/CD)\n  --seed <U64>       Random seed for deterministic simulation\n  --robot <FILE>     Robot URDF file to load\n  --world <FILE>     World/scene configuration file",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:683:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 683,
      "lineEnd": 685,
      "language": "bash",
      "code": "horus sim3d --robot my_robot.urdf --world warehouse.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:688:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 688,
      "lineEnd": 691,
      "language": "bash",
      "code": "# Same seed = same simulation\nhorus sim3d --headless --seed 12345",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:694:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 694,
      "lineEnd": 696,
      "language": "bash",
      "code": "horus sim3d --world obstacle_course.yaml --robot quadruped.urdf",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:710:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 710,
      "lineEnd": 722,
      "language": "bash",
      "code": "# Web monitor (opens in browser)\nhorus monitor\n\n# Different port\nhorus monitor 8080\n\n# Text-based (for SSH)\nhorus monitor --tui\n\n# Reset monitor password before starting\nhorus monitor --reset-password",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:736:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 736,
      "lineEnd": 742,
      "language": "bash",
      "code": "# Terminal 1: Run your app\nhorus run --release\n\n# Terminal 2: Watch it\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:745:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 745,
      "lineEnd": 748,
      "language": "bash",
      "code": "horus monitor\n# Visit http://your-computer-ip:3000 from phone",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:751:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 751,
      "lineEnd": 754,
      "language": "bash",
      "code": "ssh robot@192.168.1.100\nhorus monitor --tui",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:768:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 768,
      "lineEnd": 783,
      "language": "bash",
      "code": "# Install a package\nhorus pkg install <package>\n\n# Remove a package\nhorus pkg remove <package>\n\n# List packages\nhorus pkg list\n\n# Publish current package to registry\nhorus pkg publish\n\n# Unpublish a package from registry\nhorus pkg unpublish <package> <version>",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:788:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 788,
      "lineEnd": 790,
      "language": "bash",
      "code": "horus pkg install pid-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:793:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 793,
      "lineEnd": 795,
      "language": "bash",
      "code": "horus pkg install pid-controller --ver 1.2.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:798:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 798,
      "lineEnd": 800,
      "language": "bash",
      "code": "horus pkg install common-utils --global",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:803:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 803,
      "lineEnd": 805,
      "language": "bash",
      "code": "horus pkg list",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:808:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 808,
      "lineEnd": 810,
      "language": "bash",
      "code": "horus pkg list sensor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:813:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 813,
      "lineEnd": 815,
      "language": "bash",
      "code": "horus pkg remove pid-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:818:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 818,
      "lineEnd": 824,
      "language": "bash",
      "code": "# First login\nhorus auth login\n\n# Then publish from your project directory\nhorus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:827:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 827,
      "lineEnd": 829,
      "language": "bash",
      "code": "horus pkg unpublish my-package 1.0.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:841:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 841,
      "lineEnd": 847,
      "language": "bash",
      "code": "# Save current environment\nhorus env freeze\n\n# Load saved environment\nhorus env restore <file>",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:852:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 852,
      "lineEnd": 855,
      "language": "bash",
      "code": "horus env freeze\n# Creates horus-freeze.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:858:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 858,
      "lineEnd": 860,
      "language": "bash",
      "code": "horus env restore teammate-setup.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:863:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 863,
      "lineEnd": 866,
      "language": "bash",
      "code": "# On production machine\nhorus env restore production.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:878:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 878,
      "lineEnd": 890,
      "language": "bash",
      "code": "# Login with GitHub\nhorus auth login\n\n# Generate API key (for CI/CD)\nhorus auth generate-key\n\n# Check who you are\nhorus auth whoami\n\n# Logout\nhorus auth logout",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:895:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 895,
      "lineEnd": 898,
      "language": "bash",
      "code": "horus auth login\n# Opens browser for GitHub login",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:901:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 901,
      "lineEnd": 903,
      "language": "bash",
      "code": "horus auth whoami",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:906:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 906,
      "lineEnd": 909,
      "language": "bash",
      "code": "horus auth generate-key --name github-actions --environment ci-cd\n# Save the generated key in your CI secrets",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:912:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 912,
      "lineEnd": 914,
      "language": "bash",
      "code": "horus auth logout",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:926:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 926,
      "lineEnd": 935,
      "language": "bash",
      "code": "# Build current project\nhorus build\n\n# Build in release mode\nhorus build --release\n\n# Clean build (remove cached artifacts first)\nhorus build --clean",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:939:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 939,
      "lineEnd": 947,
      "language": "bash",
      "code": "horus build [OPTIONS]\n\nOptions:\n  -r, --release    Build in release mode (optimized)\n  -c, --clean      Clean before building\n  -h, --help       Print help\n  -V, --version    Print version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:952:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 952,
      "lineEnd": 955,
      "language": "bash",
      "code": "horus build --release\n# Exit code 0 = success, non-zero = failure",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:958:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 958,
      "lineEnd": 960,
      "language": "bash",
      "code": "horus build --clean --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:972:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 972,
      "lineEnd": 981,
      "language": "bash",
      "code": "# Run all tests\nhorus test\n\n# Run with parallel execution\nhorus test --parallel\n\n# Run simulation tests\nhorus test --sim",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:985:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 985,
      "lineEnd": 995,
      "language": "bash",
      "code": "horus test [OPTIONS]\n\nOptions:\n  -r, --release        Run tests in release mode\n  -p, --parallel       Run tests in parallel\n  -s, --sim            Run simulation-based tests\n  -i, --integration    Run integration tests\n  -h, --help           Print help\n  -V, --version        Print version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1000:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1000,
      "lineEnd": 1002,
      "language": "bash",
      "code": "horus test --parallel --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1005:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1005,
      "lineEnd": 1007,
      "language": "bash",
      "code": "horus test --integration --sim",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1019:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1019,
      "lineEnd": 1028,
      "language": "bash",
      "code": "# Clean everything (build + shared memory + cache)\nhorus clean --all\n\n# Only clean shared memory\nhorus clean --shm\n\n# Preview what would be cleaned\nhorus clean --dry-run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1032:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1032,
      "lineEnd": 1041,
      "language": "bash",
      "code": "horus clean [OPTIONS]\n\nOptions:\n      --shm      Only clean shared memory\n  -a, --all      Clean everything (build cache + shared memory + horus cache)\n  -n, --dry-run  Show what would be cleaned without removing anything\n  -h, --help     Print help\n  -V, --version  Print version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1046:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1046,
      "lineEnd": 1048,
      "language": "bash",
      "code": "horus clean --shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1051:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1051,
      "lineEnd": 1054,
      "language": "bash",
      "code": "horus clean --all\nhorus build --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1066:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1066,
      "lineEnd": 1072,
      "language": "bash",
      "code": "horus topic list              # List all active topics\nhorus topic echo <topic>      # Print messages as they arrive\nhorus topic info <topic>      # Show topic details (type, publishers, subscribers)\nhorus topic hz <topic>        # Measure publishing rate\nhorus topic pub <topic> <msg> # Publish a message",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1077:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1077,
      "lineEnd": 1083,
      "language": "bash",
      "code": "horus topic list\n# Output:\n# /cmd_vel (CmdVel) - 2 publishers, 1 subscriber\n# /scan (LaserScan) - 1 publisher, 3 subscribers\n# /odom (Odometry) - 1 publisher, 1 subscriber",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1086:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1086,
      "lineEnd": 1089,
      "language": "bash",
      "code": "horus topic echo /scan\n# Prints each LaserScan message as it arrives",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1092:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1092,
      "lineEnd": 1095,
      "language": "bash",
      "code": "horus topic hz /cmd_vel\n# Output: average rate: 50.0 Hz, min: 49.2, max: 50.8",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1098:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1098,
      "lineEnd": 1100,
      "language": "bash",
      "code": "horus topic pub /cmd_vel '{\"linear\": [1.0, 0.0, 0.0], \"angular\": [0.0, 0.0, 0.5]}'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1112:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1112,
      "lineEnd": 1119,
      "language": "bash",
      "code": "horus node list               # List all running nodes\nhorus node info <node>        # Show detailed node information\nhorus node kill <node>        # Terminate a node\nhorus node restart <node>     # Restart a node\nhorus node pause <node>       # Pause a node's tick execution\nhorus node resume <node>      # Resume a paused node",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1124:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1124,
      "lineEnd": 1131,
      "language": "bash",
      "code": "horus node list\n# Output:\n# NAME              PID     RATE   CPU    MEMORY   STATUS\n# SensorNode        12345   100Hz  1.2%   10MB     Running\n# ControllerNode    12346   50Hz   2.5%   15MB     Running\n# LoggerNode        12347   10Hz   0.1%   5MB      Paused",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1134:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1134,
      "lineEnd": 1137,
      "language": "bash",
      "code": "horus node info SensorNode\n# Shows: tick count, error count, subscribed topics, published topics",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1140:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1140,
      "lineEnd": 1142,
      "language": "bash",
      "code": "horus node restart ControllerNode",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1145:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1145,
      "lineEnd": 1149,
      "language": "bash",
      "code": "horus node pause SensorNode\n# ... inspect state ...\nhorus node resume SensorNode",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:1161:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1161,
      "lineEnd": 1173,
      "language": "bash",
      "code": "# View all recent logs\nhorus log\n\n# Filter by node\nhorus log SensorNode\n\n# Follow logs in real-time\nhorus log --follow\n\n# Show only errors\nhorus log --level error",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1177:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1177,
      "lineEnd": 1191,
      "language": "bash",
      "code": "horus log [OPTIONS] [NODE]\n\nArguments:\n  [NODE]  Filter by node name\n\nOptions:\n  -l, --level <LEVEL>  Filter by log level (trace, debug, info, warn, error)\n  -s, --since <SINCE>  Show logs from last duration (e.g., \"5m\", \"1h\", \"30s\")\n  -f, --follow         Follow log output in real-time\n  -n, --count <COUNT>  Number of recent log entries to show\n      --clear          Clear logs instead of viewing\n      --clear-all      Clear all logs (including file-based logs)\n  -h, --help           Print help",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:1196:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1196,
      "lineEnd": 1198,
      "language": "bash",
      "code": "horus log SensorNode --follow",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1201:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1201,
      "lineEnd": 1203,
      "language": "bash",
      "code": "horus log --level error --since 10m",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1206:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1206,
      "lineEnd": 1208,
      "language": "bash",
      "code": "horus log --level warn --count 50",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1220:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1220,
      "lineEnd": 1226,
      "language": "bash",
      "code": "# Run diagnostics\nhorus doctor\n\n# Verbose output with details\nhorus doctor --verbose",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1230:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1230,
      "lineEnd": 1236,
      "language": "bash",
      "code": "horus doctor [OPTIONS]\n\nOptions:\n  -v, --verbose  Show detailed diagnostic information\n  -h, --help     Print help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1240:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1240,
      "lineEnd": 1251,
      "language": "bash",
      "code": "$ horus doctor\n[OK] HORUS CLI installed (v0.1.7)\n[OK] Rust toolchain available (1.75.0)\n[OK] Python 3.11 detected\n[OK] Shared memory accessible (/dev/shm/horus)\n[OK] No stale processes found\n[OK] Registry reachable (https://horus-registry.dev)\n[!] GPU: No CUDA device found (optional)\n\nOverall: System healthy",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1263:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1263,
      "lineEnd": 1272,
      "language": "bash",
      "code": "horus param list [node]           # List all parameters (or for specific node)\nhorus param get <node> <param>    # Get parameter value\nhorus param set <node> <param> <value>  # Set parameter value\nhorus param delete <node> <param> # Delete a parameter\nhorus param reset <node>          # Reset parameters to defaults\nhorus param load <file>           # Load parameters from file\nhorus param save <file>           # Save parameters to file\nhorus param dump [node]           # Dump all parameters as YAML",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1277:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1277,
      "lineEnd": 1284,
      "language": "bash",
      "code": "horus param list\n# Output:\n# /SensorNode/sample_rate: 100\n# /SensorNode/filter_size: 5\n# /ControllerNode/kp: 1.5\n# /ControllerNode/ki: 0.1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1287:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1287,
      "lineEnd": 1290,
      "language": "bash",
      "code": "horus param set ControllerNode kp 2.0\nhorus param set ControllerNode ki 0.2",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1293:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1293,
      "lineEnd": 1299,
      "language": "bash",
      "code": "# Save current params\nhorus param save robot_config.yaml\n\n# Later, restore them\nhorus param load robot_config.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1311:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1311,
      "lineEnd": 1318,
      "language": "bash",
      "code": "horus hf list                    # List all frames\nhorus hf echo <frame>            # Print transform updates\nhorus hf tree                    # Show frame tree hierarchy\nhorus hf info <frame>            # Detailed frame information\nhorus hf can <source> <target>   # Check if transform is possible\nhorus hf hz <frame>              # Measure transform update rate",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1323:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1323,
      "lineEnd": 1331,
      "language": "bash",
      "code": "horus hf tree\n# Output:\n# world\n# └── base_link\n#     ├── laser_frame\n#     ├── camera_frame\n#     └── imu_frame",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1334:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1334,
      "lineEnd": 1337,
      "language": "bash",
      "code": "horus hf echo laser_frame\n# Prints: translation [x, y, z] rotation [qx, qy, qz, qw]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1340:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1340,
      "lineEnd": 1343,
      "language": "bash",
      "code": "horus hf can laser_frame world\n# Output: Yes, chain: laser_frame -> base_link -> world",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1355:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1355,
      "lineEnd": 1359,
      "language": "bash",
      "code": "horus msg list               # List all message types\nhorus msg show <type>        # Show message definition\nhorus msg md5 <type>         # Show MD5 hash (for compatibility checking)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1364:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1364,
      "lineEnd": 1371,
      "language": "bash",
      "code": "horus msg list\n# Output:\n# CmdVel (horus_library::messages::motion)\n# LaserScan (horus_library::messages::sensor)\n# Odometry (horus_library::messages::navigation)\n# Image (horus_library::messages::perception)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1374:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1374,
      "lineEnd": 1382,
      "language": "bash",
      "code": "horus msg show CmdVel\n# Output:\n# struct CmdVel {\n#   linear: [f64; 3],   // m/s [x, y, z]\n#   angular: [f64; 3],  // rad/s [roll, pitch, yaw]\n#   timestamp: u64,     // nanoseconds\n# }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1394:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1394,
      "lineEnd": 1403,
      "language": "bash",
      "code": "# Launch from file\nhorus launch robot.yaml\n\n# Preview without launching\nhorus launch robot.yaml --dry-run\n\n# Launch with namespace\nhorus launch robot.yaml --namespace robot1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1407:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1407,
      "lineEnd": 1418,
      "language": "bash",
      "code": "horus launch [OPTIONS] <FILE>\n\nArguments:\n  <FILE>  Path to launch file (YAML)\n\nOptions:\n  -n, --dry-run                Show what would launch without actually launching\n      --namespace <NAMESPACE>  Namespace prefix for all nodes\n      --list                   List nodes in the launch file without launching\n  -h, --help                   Print help",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:1422:yaml",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1422,
      "lineEnd": 1442,
      "language": "yaml",
      "code": "# robot.yaml\nnodes:\n  - name: sensor_node\n    file: src/sensor.rs\n    rate: 100\n    params:\n      sample_rate: 100\n\n  - name: controller\n    file: src/controller.rs\n    rate: 50\n    depends_on: [sensor_node]\n    params:\n      kp: 1.5\n      ki: 0.1\n\n  - name: logger\n    file: src/logger.py\n    rate: 10",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1447:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1447,
      "lineEnd": 1449,
      "language": "bash",
      "code": "horus launch robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1452:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1452,
      "lineEnd": 1455,
      "language": "bash",
      "code": "horus launch robot.yaml --namespace robot1\nhorus launch robot.yaml --namespace robot2",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1467:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1467,
      "lineEnd": 1476,
      "language": "bash",
      "code": "# Deploy to configured target\nhorus deploy robot@192.168.1.100\n\n# Deploy and run immediately\nhorus deploy robot@192.168.1.100 --run\n\n# Deploy to specific architecture\nhorus deploy robot@192.168.1.100 --arch aarch64",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1480:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1480,
      "lineEnd": 1496,
      "language": "bash",
      "code": "horus deploy [OPTIONS] [TARGET]\n\nArguments:\n  [TARGET]  Target host (user@host or configured target name)\n\nOptions:\n  -d, --dir <REMOTE_DIR>     Remote directory (default: ~/horus_deploy)\n  -a, --arch <ARCH>          Target architecture (aarch64, armv7, x86_64, native)\n  -r, --run                  Run the project after deploying\n      --debug                Build in debug mode instead of release\n  -p, --port <PORT>          SSH port (default: 22)\n  -i, --identity <IDENTITY>  SSH identity file\n  -n, --dry-run              Show what would be done without doing it\n      --list                 List configured deployment targets\n  -h, --help                 Print help",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:1501:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1501,
      "lineEnd": 1503,
      "language": "bash",
      "code": "horus deploy pi@raspberrypi.local --arch aarch64",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1506:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1506,
      "lineEnd": 1508,
      "language": "bash",
      "code": "horus deploy ubuntu@jetson.local --arch aarch64 --run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1511:yaml",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1511,
      "lineEnd": 1520,
      "language": "yaml",
      "code": "deploy:\n  targets:\n    jetson:\n      host: ubuntu@192.168.1.50\n      arch: aarch64\n    pi:\n      host: pi@192.168.1.51\n      arch: aarch64",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1523:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1523,
      "lineEnd": 1525,
      "language": "bash",
      "code": "horus deploy jetson --run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1537:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1537,
      "lineEnd": 1541,
      "language": "bash",
      "code": "horus bridge ros2              # Start ROS2 bridge\nhorus bridge list              # List discoverable ROS2 topics\nhorus bridge info              # Show bridge information and capabilities",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1546:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1546,
      "lineEnd": 1554,
      "language": "bash",
      "code": "# Terminal 1: Start bridge\nhorus bridge ros2\n\n# Terminal 2: Run HORUS nodes\nhorus run\n\n# ROS2 nodes can now see HORUS topics and vice versa",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1557:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1557,
      "lineEnd": 1562,
      "language": "bash",
      "code": "horus bridge list\n# Output:\n# /ros2/cmd_vel (geometry_msgs/Twist)\n# /ros2/scan (sensor_msgs/LaserScan)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1574:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1574,
      "lineEnd": 1581,
      "language": "bash",
      "code": "horus hardware scan            # Scan for connected devices\nhorus hardware platform        # Show platform information\nhorus hardware suggest         # Suggest HORUS configuration\nhorus hardware info <device>   # Get device details\nhorus hardware export          # Export config to TOML\nhorus hardware watch           # Watch for hotplug events",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1586:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1586,
      "lineEnd": 1593,
      "language": "bash",
      "code": "horus hardware scan\n# Output:\n# [OK] USB Camera: /dev/video0 (Logitech C920)\n# [OK] Serial: /dev/ttyUSB0 (FTDI)\n# [OK] I2C: /dev/i2c-1 (available)\n# [OK] GPIO: /dev/gpiochip0 (54 lines)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1596:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1596,
      "lineEnd": 1606,
      "language": "bash",
      "code": "horus hardware suggest\n# Output:\n# Suggested horus.yaml configuration:\n# drivers:\n#   - camera: /dev/video0\n#   - serial: /dev/ttyUSB0\n# enable:\n#   - i2c\n#   - gpio",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1609:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1609,
      "lineEnd": 1612,
      "language": "bash",
      "code": "horus hardware watch\n# Monitors USB connect/disconnect events",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1624:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1624,
      "lineEnd": 1636,
      "language": "bash",
      "code": "# Add a package (auto-detected)\nhorus add pid-controller\n\n# Add with specific version\nhorus add sensor-fusion --ver 1.2.0\n\n# Force install as driver\nhorus add camera-driver --driver\n\n# Install globally\nhorus add common-utils --global",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1640:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1640,
      "lineEnd": 1654,
      "language": "bash",
      "code": "horus add [OPTIONS] <NAME>\n\nArguments:\n  <NAME>  Package/driver/plugin name to add\n\nOptions:\n  -v, --ver <VER>  Specific version (optional)\n      --driver     Force install as driver\n      --plugin     Force install as plugin\n      --local      Force local installation\n  -g, --global     Force global installation\n      --no-system  Skip installing system dependencies\n  -h, --help       Print help",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:1659:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1659,
      "lineEnd": 1662,
      "language": "bash",
      "code": "horus add kalman-filter\nhorus add pid-controller --ver 2.0.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1665:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1665,
      "lineEnd": 1668,
      "language": "bash",
      "code": "horus add realsense-driver --driver\nhorus add rplidar-driver --driver",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1680:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1680,
      "lineEnd": 1689,
      "language": "bash",
      "code": "# Remove a package\nhorus remove pid-controller\n\n# Remove and purge unused dependencies\nhorus remove sensor-fusion --purge\n\n# Remove global package\nhorus remove common-utils --global",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1693:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1693,
      "lineEnd": 1703,
      "language": "bash",
      "code": "horus remove [OPTIONS] <NAME>\n\nArguments:\n  <NAME>  Package/driver/plugin name to remove\n\nOptions:\n  -g, --global   Remove from global scope\n      --purge    Also remove unused dependencies\n  -h, --help     Print help",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/cli-reference:1715:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1715,
      "lineEnd": 1719,
      "language": "bash",
      "code": "horus driver list             # List all available drivers\nhorus driver info <driver>    # Show driver details\nhorus driver search <query>   # Search for drivers",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1724:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1724,
      "lineEnd": 1730,
      "language": "bash",
      "code": "horus driver search camera\n# Output:\n# realsense-driver (Intel RealSense D4xx, L5xx)\n# oak-driver (Luxonis OAK-D)\n# usb-camera (Generic V4L2 cameras)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1733:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1733,
      "lineEnd": 1736,
      "language": "bash",
      "code": "horus driver info realsense-driver\n# Shows: supported devices, dependencies, configuration options",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1748:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1748,
      "lineEnd": 1753,
      "language": "bash",
      "code": "horus plugin list              # List installed plugins\nhorus plugin enable <plugin>   # Enable a disabled plugin\nhorus plugin disable <plugin>  # Disable a plugin\nhorus plugin verify            # Verify plugin integrity",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1758:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1758,
      "lineEnd": 1764,
      "language": "bash",
      "code": "horus plugin list\n# Output:\n# [x] horus-ros2-bridge (enabled)\n# [ ] horus-zenoh (disabled)\n# [x] horus-tensorrt (enabled)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1767:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1767,
      "lineEnd": 1769,
      "language": "bash",
      "code": "horus plugin disable horus-ros2-bridge",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1781:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1781,
      "lineEnd": 1786,
      "language": "bash",
      "code": "horus cache info               # Show cache statistics\nhorus cache list               # List cached packages\nhorus cache clean              # Remove unused packages\nhorus cache purge              # Remove ALL cached packages",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1791:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1791,
      "lineEnd": 1798,
      "language": "bash",
      "code": "horus cache info\n# Output:\n# Location: ~/.horus/cache\n# Total size: 1.2 GB\n# Packages: 45\n# Last cleaned: 7 days ago",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1801:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1801,
      "lineEnd": 1804,
      "language": "bash",
      "code": "horus cache clean\n# Removes packages not used by any project",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1816:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1816,
      "lineEnd": 1824,
      "language": "bash",
      "code": "horus record list              # List all recordings\nhorus record info <session>    # Show recording details\nhorus record replay <session>  # Replay a recording\nhorus record delete <session>  # Delete a recording\nhorus record diff <a> <b>      # Compare two recordings\nhorus record export <session>  # Export to different format\nhorus record inject <session>  # Inject recorded data into live scheduler",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1829:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1829,
      "lineEnd": 1835,
      "language": "bash",
      "code": "horus record list\n# Output:\n# ID         DATE                 DURATION   NODES   SIZE\n# rec_001    2024-01-15 10:30:00  5m 23s     4       45MB\n# rec_002    2024-01-15 14:15:00  2m 10s     3       18MB",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1838:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1838,
      "lineEnd": 1840,
      "language": "bash",
      "code": "horus record replay rec_001",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1843:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1843,
      "lineEnd": 1846,
      "language": "bash",
      "code": "horus record diff rec_001 rec_002\n# Shows differences in timing, message counts, errors",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1849:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1849,
      "lineEnd": 1852,
      "language": "bash",
      "code": "# Use recorded sensor data with live controller\nhorus record inject rec_001 --nodes SensorNode",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1860:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1860,
      "lineEnd": 1870,
      "language": "bash",
      "code": "# Create a project\nhorus new my_first_app --macro\ncd my_first_app\n\n# Run it\nhorus run --release\n\n# Monitor it (new terminal)\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1874:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1874,
      "lineEnd": 1883,
      "language": "bash",
      "code": "# Make changes to code\nvim src/main.rs\n\n# Test quickly\nhorus run\n\n# Test for real\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1887:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1887,
      "lineEnd": 1896,
      "language": "bash",
      "code": "# Clean build\nhorus run --clean --release\n\n# Save the environment\nhorus env freeze --output production.yaml\n\n# Run in production mode\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1900:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1900,
      "lineEnd": 1909,
      "language": "bash",
      "code": "# Login once\nhorus auth login\n\n# Publish\nhorus pkg publish\n\n# Others can now:\nhorus pkg install your-package-name",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1919:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1919,
      "lineEnd": 1923,
      "language": "bash",
      "code": "export PATH=\"$HOME/.cargo/bin:$PATH\"\necho 'export PATH=\"$HOME/.cargo/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1927:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1927,
      "lineEnd": 1933,
      "language": "bash",
      "code": "# Use different port\nhorus monitor 3001\n\n# Or kill the old process\nlsof -ti:3000 | xargs kill -9",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1947:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1947,
      "lineEnd": 1950,
      "language": "bash",
      "code": "# Clean all HORUS shared memory (if needed after crashes)\nrm -rf /dev/shm/horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1958:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1958,
      "lineEnd": 1968,
      "language": "bash",
      "code": "# Custom registry (for companies)\nexport HORUS_REGISTRY_URL=https://your-company-registry.com\n\n# Debug mode (see what's happening)\nexport RUST_LOG=debug\nhorus run\n\n# CI/CD authentication\nexport HORUS_API_KEY=your-key-here",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/cli-reference:1976:bash",
      "file": "content/docs/development/cli-reference.mdx",
      "lineStart": 1976,
      "lineEnd": 1979,
      "language": "bash",
      "code": "./install.sh             # Install or update HORUS\n./verify.sh              # Check installation health",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/error-handling:13:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 13,
      "lineEnd": 20,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn my_function() -> Result<()> {\n    // Your code here\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:64:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 64,
      "lineEnd": 87,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Configuration error\nlet err = Error::config(\"Invalid frequency: must be positive\");\n\n// Backend error with context\nlet err = Error::backend(\"mpu6050\", \"I2C bus error\");\n\n// Node error with context\nlet err = Error::node(\"MotorController\", \"Failed to initialize PWM\");\n\n// Communication error\nlet err = Error::communication(\"Topic not found: /cmd_vel\");\n\n// Memory error\nlet err = Error::memory(\"Failed to allocate 1GB for buffer\");\n\n// Resource not found\nlet err = Error::not_found(\"Robot configuration file\");\n\n// Invalid input\nlet err = Error::invalid_input(\"Speed must be between 0 and 100\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:91:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 91,
      "lineEnd": 97,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet err = Error::Timeout(\"Operation exceeded 5s timeout\".to_string());\nlet err = Error::PermissionDenied(\"/dev/ttyUSB0\".to_string());\nlet err = Error::AlreadyExists(\"Session 'main' already exists\".to_string());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:103:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 103,
      "lineEnd": 115,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn load_robot_config(path: &str) -> Result<Config> {\n    // File I/O errors automatically convert to Error::Io\n    let content = std::fs::read_to_string(path)?;\n\n    // JSON errors automatically convert to Error::Serialization\n    let config: Config = serde_json::from_str(&content)?;\n\n    Ok(config)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/error-handling:136:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 136,
      "lineEnd": 146,
      "language": "rust",
      "code": "fn handle_error(err: Error) {\n    if err.is_not_found() {\n        println!(\"Resource missing, creating default...\");\n    } else if err.is_timeout() {\n        println!(\"Operation timed out, retrying...\");\n    } else if err.is_permission_denied() {\n        println!(\"Access denied, check permissions\");\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:150:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 150,
      "lineEnd": 168,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nmatch result {\n    Ok(value) => process(value),\n    Err(Error::NotFound(resource)) => {\n        eprintln!(\"Resource not found: {}\", resource);\n    }\n    Err(Error::Backend { backend, message }) => {\n        eprintln!(\"Backend {} failed: {}\", backend, message);\n    }\n    Err(Error::Node { node, message }) => {\n        eprintln!(\"Node {} error: {}\", node, message);\n    }\n    Err(e) => {\n        eprintln!(\"Unexpected error: {}\", e);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:176:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 176,
      "lineEnd": 190,
      "language": "rust",
      "code": "use horus_sim3d::error::{EnhancedError, ErrorCategory};\n\n// Basic error\nlet err = EnhancedError::new(\"Something went wrong\");\n\n// With full context\nlet err = EnhancedError::new(\"Invalid joint configuration\")\n    .with_file(\"robot.urdf\")\n    .with_line(42)\n    .with_column(15)\n    .with_category(ErrorCategory::URDFError)\n    .with_hint(\"Joint limits must have lower < upper\")\n    .with_suggestion(\"Change: <limit lower=\\\"1.0\\\" upper=\\\"0.0\\\"/> to <limit lower=\\\"0.0\\\" upper=\\\"1.0\\\"/>\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:194:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 194,
      "lineEnd": 232,
      "language": "rust",
      "code": "use horus_sim3d::error::EnhancedError;\n\n// File not found with suggestions\nlet err = EnhancedError::file_not_found(\"/path/to/robot.urdf\");\n// Output includes: verification command, path check hints\n\n// Mesh loading error with format-specific hints\nlet err = EnhancedError::mesh_load_failed(\n    \"model.obj\",\n    \"Invalid vertex data at line 42\"\n);\n\n// URDF parsing error with validation suggestions\nlet err = EnhancedError::urdf_parse_failed(\n    \"robot.urdf\",\n    \"Unknown joint type 'slider'\"\n);\n\n// Mesh reference not found (common URDF issue)\nlet err = EnhancedError::mesh_reference_not_found(\n    \"robot.urdf\",\n    \"package://my_robot/meshes/wheel.stl\",\n    &searched_paths,\n);\n\n// Physics parameter validation\nlet err = EnhancedError::invalid_physics_value(\n    \"friction\",\n    -0.5,\n    (0.0, 1.0),  // valid range\n);\n\n// Generic validation error\nlet err = EnhancedError::validation_failed(\n    \"mass\",\n    \"must be positive (got -1.5)\"\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:249:text",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 249,
      "lineEnd": 258,
      "language": "text",
      "code": "Error in 'robot.urdf' at line 42, column 15:\n  Invalid joint configuration\n\nHint: Joint limits must have lower < upper\n\nSuggestion:\n   Change: <limit lower=\"1.0\" upper=\"0.0\"/>\n   to: <limit lower=\"0.0\" upper=\"1.0\"/>",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/error-handling:264:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 264,
      "lineEnd": 270,
      "language": "rust",
      "code": "// Good: Specific error with context\nreturn Err(Error::backend(\"IMU\", \"I2C read failed on register 0x3B\"));\n\n// Avoid: Generic error\nreturn Err(Error::Other(\"error\".to_string()));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:274:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 274,
      "lineEnd": 282,
      "language": "rust",
      "code": "fn initialize_sensor() -> Result<()> {\n    open_i2c_bus().map_err(|e| {\n        Error::backend(\"IMU\", format!(\"Failed to open I2C: {}\", e))\n    })?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/error-handling:286:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 286,
      "lineEnd": 297,
      "language": "rust",
      "code": "fn get_config() -> Result<Config> {\n    match load_config_file(\"config.yaml\") {\n        Ok(config) => Ok(config),\n        Err(Error::NotFound(_)) => {\n            // Expected: use defaults\n            Ok(Config::default())\n        }\n        Err(e) => Err(e),  // Propagate unexpected errors\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:301:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 301,
      "lineEnd": 313,
      "language": "rust",
      "code": "use horus_sim3d::error::EnhancedError;\n\nfn load_robot(path: &str) -> Result<Robot, EnhancedError> {\n    let urdf = std::fs::read_to_string(path).map_err(|e| {\n        EnhancedError::file_not_found(path)\n    })?;\n\n    parse_urdf(&urdf).map_err(|e| {\n        EnhancedError::urdf_parse_failed(path, e.to_string())\n    })\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/error-handling:317:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 317,
      "lineEnd": 329,
      "language": "rust",
      "code": "use tracing::error;\n\nfn critical_operation() -> Result<()> {\n    match do_something_important() {\n        Ok(result) => Ok(result),\n        Err(e) => {\n            error!(\"Critical operation failed: {}\", e);\n            Err(e)\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:335:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 335,
      "lineEnd": 346,
      "language": "rust",
      "code": "impl Node for MyNode {\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Handle errors in tick - don't propagate\n        if let Err(e) = self.process_data() {\n            error!(\"Processing failed: {}\", e);\n            // Optionally publish status\n            self.publish_error_status(e);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/error-handling:350:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 350,
      "lineEnd": 360,
      "language": "rust",
      "code": "impl MyNode {\n    pub fn new(config: Config) -> Result<Self> {\n        let backend = config.backend.connect().map_err(|e| {\n            Error::node(\"MyNode\", format!(\"Backend init failed: {}\", e))\n        })?;\n\n        Ok(Self { backend })\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/error-handling:364:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 364,
      "lineEnd": 377,
      "language": "rust",
      "code": "fn read_sensor(&mut self) -> Option<SensorData> {\n    match self.backend.read() {\n        Ok(data) => Some(data),\n        Err(e) => {\n            self.error_count += 1;\n            if self.error_count > 10 {\n                error!(\"Sensor failing repeatedly: {}\", e);\n            }\n            None  // Return None instead of crashing\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:381:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 381,
      "lineEnd": 407,
      "language": "rust",
      "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n    use horus::prelude::*;\n\n    #[test]\n    fn test_returns_not_found_for_missing_file() {\n        let result = load_config(\"nonexistent.yaml\");\n        assert!(matches!(result, Err(Error::NotFound(_))));\n    }\n\n    #[test]\n    fn test_returns_config_error_for_invalid_yaml() {\n        let result = parse_config(\"invalid: [yaml\");\n        assert!(matches!(result, Err(Error::Config(_))));\n    }\n\n    #[test]\n    fn test_error_context() {\n        let err = Error::node(\"TestNode\", \"test message\");\n        let display = format!(\"{}\", err);\n        assert!(display.contains(\"TestNode\"));\n        assert!(display.contains(\"test message\"));\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/error-handling:413:rust",
      "file": "content/docs/development/error-handling.mdx",
      "lineStart": 413,
      "lineEnd": 431,
      "language": "rust",
      "code": "use anyhow::{Context, Result as AnyhowResult};\nuse horus::prelude::*;\n\nfn load_robot() -> AnyhowResult<Robot> {\n    let config = load_config(\"robot.yaml\")\n        .context(\"Failed to load robot configuration\")?;\n\n    let robot = Robot::from_config(config)\n        .context(\"Failed to create robot from config\")?;\n\n    Ok(robot)\n}\n\n// Convert back to horus::Result if needed\nfn horus_function() -> Result<Robot> {\n    load_robot().map_err(|e| Error::from(e))\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:17:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 17,
      "lineEnd": 35,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    // Create discovery instance\n    let discovery = HardwareDiscovery::new()?;\n\n    // Get platform info\n    println!(\"Platform: {:?}\", discovery.platform());\n\n    // Scan all hardware\n    let report = discovery.scan_all();\n\n    // Print summary\n    println!(\"{}\", report.summary());\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/hardware-discovery:38:text",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 38,
      "lineEnd": 49,
      "language": "text",
      "code": "Platform: RaspberryPi4\nHardware Discovery Summary:\n  USB devices: 12\n  Serial ports: 3\n  I2C buses: 2 (14 devices)\n  SPI buses: 1\n  CAN interfaces: 1\n  GPIO chips: 1 (54 lines)\n  Cameras: 1\n  Network interfaces: 3",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/hardware-discovery:57:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 57,
      "lineEnd": 81,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet detector = PlatformDetector::new();\nlet platform = detector.detect();\n\nmatch platform {\n    Platform::RaspberryPi4 => println!(\"Running on Pi 4\"),\n    Platform::RaspberryPi5 => println!(\"Running on Pi 5\"),\n    Platform::JetsonNano => println!(\"Running on Jetson Nano\"),\n    Platform::JetsonOrin => println!(\"Running on Jetson Orin\"),\n    Platform::BeagleBoneBlack => println!(\"Running on BeagleBone\"),\n    Platform::GenericLinux => println!(\"Generic Linux system\"),\n    Platform::Unknown => println!(\"Unknown platform\"),\n}\n\n// Get platform capabilities\nlet caps = detector.capabilities();\nprintln!(\"Has GPIO: {}\", caps.has_gpio);\nprintln!(\"Has I2C: {}\", caps.has_i2c);\nprintln!(\"Has SPI: {}\", caps.has_spi);\nprintln!(\"Has CAN: {}\", caps.has_can);\nprintln!(\"Has PWM: {}\", caps.has_pwm);\nprintln!(\"GPU: {:?}\", caps.gpu);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:101:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 101,
      "lineEnd": 110,
      "language": "rust",
      "code": "let discovery = HardwareDiscovery::new()?;\nlet report = discovery.scan_all();\n\n// Access results\nprintln!(\"USB devices: {}\", report.usb_devices.len());\nprintln!(\"Serial ports: {}\", report.serial_ports.len());\nprintln!(\"I2C devices: {}\", report.i2c_devices.len());\nprintln!(\"Cameras: {}\", report.cameras.len());",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:116:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 116,
      "lineEnd": 131,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet discovery = HardwareDiscovery::new()?;\n\n// Only scan for sensors\nlet options = DiscoveryOptions::default()\n    .with_categories(CategoryFilter::only(&[\n        DeviceCategory::Camera,\n        DeviceCategory::Lidar,\n        DeviceCategory::Imu,\n        DeviceCategory::Gps,\n    ]));\n\nlet report = discovery.scan_with_options(&options);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:135:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 135,
      "lineEnd": 156,
      "language": "rust",
      "code": "pub enum DeviceCategory {\n    Microcontroller,   // Arduino, Teensy, ESP32, STM32\n    SerialAdapter,     // FTDI, CP210x, CH340\n    MotorController,   // ODrive, VESC, RoboClaw\n    ServoController,   // Dynamixel, Pololu Maestro\n    Lidar,             // RPLIDAR, Velodyne, Livox\n    DepthCamera,       // RealSense, ZED, Azure Kinect\n    Camera,            // USB cameras, CSI cameras\n    Imu,               // MPU6050, BNO055, ICM-20948\n    Gps,               // u-blox, NMEA GPS modules\n    CanAdapter,        // PEAK, Kvaser, Canable\n    Joystick,          // Gamepads, RC controllers\n    Bluetooth,         // Bluetooth adapters\n    Audio,             // USB microphones, speakers\n    Network,           // WiFi, Ethernet adapters\n    Power,             // Battery monitors, power supplies\n    Display,           // HDMI, LCD displays\n    Storage,           // USB drives, SD cards\n    Other,             // Unclassified devices\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:166:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 166,
      "lineEnd": 183,
      "language": "rust",
      "code": "let discovery = HardwareDiscovery::new()?;\nlet report = discovery.scan_all();\n\nfor device in &report.usb_devices {\n    println!(\"USB: {} (VID:{:04X} PID:{:04X})\",\n        device.product.as_deref().unwrap_or(\"Unknown\"),\n        device.vendor_id,\n        device.product_id\n    );\n\n    // Get device info from database\n    if let Some(info) = discovery.database().lookup_usb(device.vendor_id, device.product_id) {\n        println!(\"  Identified as: {} ({})\", info.name, info.category.name());\n        println!(\"  Driver: {:?}\", info.driver);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:208:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 208,
      "lineEnd": 225,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut i2c = I2cDiscovery::new();\n    let buses = i2c.enumerate_buses();\n\n    for bus in buses {\n        println!(\"I2C Bus {} ({}):\", bus.bus_number, bus.path.display());\n\n        for device in &bus.devices {\n            println!(\"  0x{:02X}: {}\",\n                device.address,\n                device.name.as_deref().unwrap_or(\"Unknown\")\n            );\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:236:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 236,
      "lineEnd": 249,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut spi = SpiDiscovery::new();\n    let buses = spi.enumerate_buses();\n\n    for bus in buses {\n        println!(\"SPI Bus {}:\", bus.bus_number);\n        for cs in &bus.chip_selects {\n            println!(\"  CS{}: {}\", cs.chip_select, cs.device_path.display());\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:253:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 253,
      "lineEnd": 265,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut can = CanDiscovery::new();\n    let interfaces = can.enumerate_interfaces();\n\n    for iface in interfaces {\n        println!(\"CAN: {} ({:?})\", iface.name, iface.interface_type);\n        println!(\"  State: {:?}\", iface.state);\n        println!(\"  Bitrate: {} bps\", iface.bitrate.unwrap_or(0));\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:269:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 269,
      "lineEnd": 287,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut gpio = GpioDiscovery::new();\n    let chips = gpio.enumerate_chips();\n\n    for chip in chips {\n        println!(\"GPIO Chip: {} ({})\", chip.name, chip.label);\n        println!(\"  Lines: {}\", chip.num_lines);\n\n        for line in &chip.lines {\n            if line.consumer.is_some() {\n                println!(\"  Line {}: {} (in use by {:?})\",\n                    line.offset, line.name, line.consumer);\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:291:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 291,
      "lineEnd": 308,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut pwm = PwmDiscovery::new();\n    let chips = pwm.enumerate_chips();\n\n    for chip in chips {\n        println!(\"PWM Chip {} ({} channels):\", chip.chip_number, chip.num_channels);\n\n        for channel in &chip.channels {\n            println!(\"  Channel {}: {}Hz, {:?} polarity\",\n                channel.channel_number,\n                channel.frequency.unwrap_or(0),\n                channel.polarity);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:316:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 316,
      "lineEnd": 334,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut cameras = CameraDiscovery::new();\n    let devices = cameras.enumerate_cameras();\n\n    for camera in devices {\n        println!(\"Camera: {} ({:?})\", camera.name, camera.camera_type);\n        println!(\"  Path: {}\", camera.device_path.display());\n\n        for format in &camera.formats {\n            println!(\"  Format: {:?} {}x{} @ {}fps\",\n                format.pixel_format,\n                format.width, format.height,\n                format.fps);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:338:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 338,
      "lineEnd": 354,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut bluetooth = BluetoothDiscovery::new();\n    let adapters = bluetooth.enumerate_adapters();\n\n    for adapter in adapters {\n        println!(\"Bluetooth: {} ({:?})\", adapter.name, adapter.adapter_type);\n        println!(\"  Address: {}\", adapter.address);\n        println!(\"  State: {:?}\", adapter.state);\n\n        for device in &adapter.devices {\n            println!(\"  Device: {} ({})\", device.name, device.address);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:358:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 358,
      "lineEnd": 378,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut network = NetworkDiscovery::new();\n    let interfaces = network.enumerate_interfaces();\n\n    for iface in interfaces {\n        println!(\"Network: {} ({:?})\", iface.name, iface.interface_type);\n        println!(\"  State: {:?}\", iface.state);\n\n        if let Some(ip) = &iface.ip_address {\n            println!(\"  IP: {}\", ip);\n        }\n\n        if let Some(wifi) = &iface.wifi_info {\n            println!(\"  WiFi SSID: {}\", wifi.ssid);\n            println!(\"  Signal: {} dBm\", wifi.signal_strength);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:382:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 382,
      "lineEnd": 399,
      "language": "rust",
      "code": "#[cfg(target_os = \"linux\")]\n{\n    let mut audio = AudioDiscovery::new();\n    let cards = audio.enumerate_cards();\n\n    for card in cards {\n        println!(\"Audio: {} ({:?})\", card.card_name, card.device_type);\n        println!(\"  Driver: {:?}\", card.driver);\n        println!(\"  Playback: {}, Capture: {}\",\n            card.can_playback(), card.can_capture());\n\n        for device in &card.devices {\n            println!(\"  Device: {} ({:?})\", device.device_name, device.direction);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:407:bash",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 407,
      "lineEnd": 419,
      "language": "bash",
      "code": "# Full hardware scan\nhorus doctor --hardware\n\n# Specific categories\nhorus doctor --hardware --categories usb,i2c,camera\n\n# JSON output for scripting\nhorus doctor --hardware --json\n\n# Verbose with device database lookup\nhorus doctor --hardware --verbose",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/hardware-discovery:422:text",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 422,
      "lineEnd": 450,
      "language": "text",
      "code": "HORUS Hardware Discovery\n========================\n\nPlatform: Raspberry Pi 4 Model B Rev 1.4\n  CPU: 4 cores @ 1500 MHz\n  Memory: 4 GB\n  GPU: VideoCore VI\n\nUSB Devices (8):\n  ✓ RPLIDAR A2 (Slamtec)         /dev/ttyUSB0\n  ✓ Intel RealSense D435         /dev/video0\n  ✓ Arduino Mega 2560            /dev/ttyACM0\n  ✓ Xbox Wireless Controller     /dev/input/js0\n\nI2C Devices (5):\n  Bus 1:\n    ✓ 0x28: BNO055 IMU\n    ✓ 0x40: PCA9685 PWM Driver\n    ✓ 0x76: BME280 Environmental Sensor\n\nSerial Ports (3):\n  /dev/ttyUSB0: RPLIDAR A2 (115200 baud)\n  /dev/ttyACM0: Arduino Mega 2560\n  /dev/ttyAMA0: Raspberry Pi UART\n\nCAN Interfaces (1):\n  can0: SocketCAN (1000000 bps, UP)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/hardware-discovery:458:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 458,
      "lineEnd": 490,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn auto_configure_robot() -> Result<Vec<Box<dyn Node>>> {\n    let discovery = HardwareDiscovery::new()?;\n    let report = discovery.scan_all();\n\n    let mut nodes: Vec<Box<dyn Node>> = Vec::new();\n\n    // Auto-configure LiDAR if found\n    for device in &report.usb_devices {\n        if let Some(info) = discovery.database().lookup_usb(device.vendor_id, device.product_id) {\n            match info.category {\n                DeviceCategory::Lidar => {\n                    if let Some(port) = &device.serial_port {\n                        #[cfg(feature = \"rplidar\")]\n                        nodes.push(Box::new(LidarNode::new(port)?));\n                    }\n                }\n                DeviceCategory::Imu => {\n                    // Configure IMU node\n                }\n                DeviceCategory::Camera => {\n                    // Configure camera node\n                }\n                _ => {}\n            }\n        }\n    }\n\n    Ok(nodes)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/hardware-discovery:502:rust",
      "file": "content/docs/development/hardware-discovery.mdx",
      "lineStart": 502,
      "lineEnd": 514,
      "language": "rust",
      "code": "// Good: Scan once, use many times\nlet discovery = HardwareDiscovery::new()?;\nlet report = discovery.scan_all();\n\n// Check required hardware\nlet has_lidar = report.usb_devices.iter()\n    .any(|d| d.product.as_deref().map_or(false, |p| p.contains(\"RPLIDAR\")));\n\nif !has_lidar {\n    eprintln!(\"Warning: LiDAR not detected, using simulation\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/library-reference:21:toml",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 21,
      "lineEnd": 24,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = \"0.1\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/library-reference:27:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 27,
      "lineEnd": 29,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {CmdVel, LaserScan, ImuNode, ...}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:42:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 42,
      "lineEnd": 47,
      "language": "rust",
      "code": "pub struct CmdVel {\n    pub linear: f64,   // Linear velocity (m/s)\n    pub angular: f64,  // Angular velocity (rad/s)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:53:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 53,
      "lineEnd": 59,
      "language": "rust",
      "code": "let cmd = CmdVel {\n    linear: 1.5,   // Move forward at 1.5 m/s\n    angular: 0.5,  // Turn at 0.5 rad/s\n};\ncmd_hub.send(cmd, &mut ctx).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:64:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 64,
      "lineEnd": 75,
      "language": "rust",
      "code": "pub struct Twist {\n    pub linear: Vector3,   // Linear velocity (m/s)\n    pub angular: Vector3,  // Angular velocity (rad/s)\n}\n\npub struct Vector3 {\n    pub x: f64,\n    pub y: f64,\n    pub z: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:83:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 83,
      "lineEnd": 94,
      "language": "rust",
      "code": "pub struct PIDState {\n    pub kp: f64,           // Proportional gain\n    pub ki: f64,           // Integral gain\n    pub kd: f64,           // Derivative gain\n    pub setpoint: f64,     // Target value\n    pub error: f64,        // Current error\n    pub integral: f64,     // Accumulated integral\n    pub derivative: f64,   // Error derivative\n    pub output: f64,       // Control output\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:103:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 103,
      "lineEnd": 114,
      "language": "rust",
      "code": "pub struct LaserScan {\n    pub ranges: [f32; 360],        // Distance readings (m)\n    pub angle_min: f32,            // Start angle (rad)\n    pub angle_max: f32,            // End angle (rad)\n    pub angle_increment: f32,      // Angular resolution\n    pub time_increment: f32,       // Time between readings\n    pub scan_time: f32,            // Total scan time\n    pub range_min: f32,            // Minimum valid range\n    pub range_max: f32,            // Maximum valid range\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:120:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 120,
      "lineEnd": 128,
      "language": "rust",
      "code": "if let Some(scan) = lidar_hub.recv(&mut ctx) {\n    for (i, range) in scan.ranges.iter().enumerate() {\n        if *range < 0.5 {  // Obstacle within 0.5m\n            ctx.log_warning(\"Obstacle detected!\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:133:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 133,
      "lineEnd": 147,
      "language": "rust",
      "code": "pub struct IMU {\n    pub orientation: Quaternion,        // Orientation\n    pub angular_velocity: Vector3,      // Gyroscope (rad/s)\n    pub linear_acceleration: Vector3,   // Accelerometer (m/s²)\n    pub timestamp: u64,                 // Microseconds\n}\n\npub struct Quaternion {\n    pub w: f64,\n    pub x: f64,\n    pub y: f64,\n    pub z: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:155:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 155,
      "lineEnd": 169,
      "language": "rust",
      "code": "pub struct Image {\n    pub width: u32,\n    pub height: u32,\n    pub encoding: ImageEncoding,\n    pub data: [u8; MAX_IMAGE_SIZE],  // Fixed-size buffer\n}\n\npub enum ImageEncoding {\n    RGB8,    // 8-bit RGB\n    BGR8,    // 8-bit BGR\n    MONO8,   // 8-bit grayscale\n    JPEG,    // JPEG compressed\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:178:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 178,
      "lineEnd": 189,
      "language": "rust",
      "code": "pub struct Odometry {\n    pub pose: Pose,      // Position estimate\n    pub twist: Twist,    // Velocity estimate\n    pub timestamp: u64,\n}\n\npub struct Pose {\n    pub position: Vector3,\n    pub orientation: Quaternion,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:197:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 197,
      "lineEnd": 203,
      "language": "rust",
      "code": "pub struct Path {\n    pub waypoints: [Pose; MAX_WAYPOINTS],\n    pub length: usize,\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:212:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 212,
      "lineEnd": 230,
      "language": "rust",
      "code": "pub struct KeyboardInput {\n    pub key: KeyCode,\n    pub event: KeyEvent,\n    pub modifiers: KeyModifiers,\n}\n\npub enum KeyCode {\n    Up, Down, Left, Right,\n    W, A, S, D,\n    Space, Enter, Esc,\n    // ... full keyboard\n}\n\npub enum KeyEvent {\n    Press,\n    Release,\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:235:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 235,
      "lineEnd": 243,
      "language": "rust",
      "code": "if let Some(input) = keyboard_hub.recv(&mut ctx) {\n    match (input.key, input.event) {\n        (KeyCode::W, KeyEvent::Press) => move_forward(),\n        (KeyCode::Space, KeyEvent::Press) => stop(),\n        _ => {}\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:248:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 248,
      "lineEnd": 254,
      "language": "rust",
      "code": "pub struct JoystickInput {\n    pub axes: [f32; 8],      // Analog axes [-1.0, 1.0]\n    pub buttons: [bool; 16], // Button states\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:269:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 269,
      "lineEnd": 285,
      "language": "rust",
      "code": "pub struct Health {\n    pub status: HealthStatus,\n    pub cpu_percent: f32,\n    pub memory_mb: u64,\n    pub error_count: u32,\n    pub warning_count: u32,\n    pub message: [u8; 256],  // Status message\n}\n\npub enum HealthStatus {\n    Healthy,\n    Warning,\n    Error,\n    Critical,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:290:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 290,
      "lineEnd": 299,
      "language": "rust",
      "code": "pub struct SystemInfo {\n    pub cpu_usage: f32,\n    pub memory_usage: u64,\n    pub disk_usage: u64,\n    pub network_tx: u64,\n    pub network_rx: u64,\n    pub uptime_seconds: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:327:text",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 327,
      "lineEnd": 333,
      "language": "text",
      "code": "KeyboardInputNode (priority 0)\n\n    ──> SnakeControlNode (priority 2)\n\n    ──> GUINode (priority 3)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/library-reference:336:bash",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 336,
      "lineEnd": 338,
      "language": "bash",
      "code": "horus run horus_library/apps/snakesim/snake_scheduler/main.rs --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/library-reference:350:bash",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 350,
      "lineEnd": 352,
      "language": "bash",
      "code": "horus run horus_library/apps/tanksim/main.rs --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/library-reference:373:bash",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 373,
      "lineEnd": 375,
      "language": "bash",
      "code": "horus sim2d",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/library-reference:378:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 378,
      "lineEnd": 388,
      "language": "rust",
      "code": "// Create simulated robot\nlet robot = Sim2DRobot::from_urdf(\"robot.urdf\")?;\n\n// Connect to HORUS nodes\nrobot.subscribe_to_hub(\"cmd_vel\");\nrobot.publish_to_hub(\"odom\");\n\n// Run simulation\nsimulator.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/library-reference:396:toml",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 396,
      "lineEnd": 409,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"full\"] }\n\n# Or specific features:\nhorus_library = { version = \"0.1\", features = [\n    \"control-nodes\",     # PID, differential drive\n    \"input-nodes\",       # Keyboard, joystick\n    \"safety-nodes\",      # E-stop, safety monitor\n    \"basic-sensors\",     # Camera, LIDAR, IMU\n    \"industrial-nodes\",  # Modbus\n    \"raspberry-pi\",      # RPi-specific hardware\n]}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/library-reference:437:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 437,
      "lineEnd": 442,
      "language": "rust",
      "code": "// Good - fixed size, safe for shared memory\npub struct LaserScan {\n    pub ranges: [f32; 360],  // Fixed array\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:445:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 445,
      "lineEnd": 451,
      "language": "rust",
      "code": "// Bad - heap allocation, not safe for shared memory\npub struct BadMessage {\n    pub data: Vec<f32>,      // Heap-allocated\n    pub name: String,        // Heap-allocated\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:456:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 456,
      "lineEnd": 474,
      "language": "rust",
      "code": "impl CameraNode {\n    pub fn new(device: &str) -> Self {\n        Self {\n            device: device.to_string(),\n            width: 640,    // Default resolution\n            height: 480,\n            fps: 30,       // Default FPS\n            // ...\n        }\n    }\n\n    pub fn with_resolution(mut self, width: u32, height: u32) -> Self {\n        self.width = width;\n        self.height = height;\n        self\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/library-reference:477:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 477,
      "lineEnd": 485,
      "language": "rust",
      "code": "// Default configuration\nlet camera = CameraNode::new(\"/dev/video0\")?;\n\n// Custom configuration\nlet camera = CameraNode::new(\"/dev/video0\")?\n    .with_resolution(1920, 1080)\n    .with_fps(60);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/library-reference:490:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 490,
      "lineEnd": 505,
      "language": "rust",
      "code": "impl MyNode {\n    pub fn new(config: Config) -> Result<Self, Box<dyn Error>> {\n        // Validate configuration\n        if config.port == 0 {\n            return Err(\"Invalid port\".into());\n        }\n\n        // Initialize hardware\n        let device = Device::open(config.device)\n            .map_err(|e| format!(\"Failed to open device: {}\", e))?;\n\n        Ok(Self { device, config })\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/library-reference:508:rust",
      "file": "content/docs/development/library-reference.mdx",
      "lineStart": 508,
      "lineEnd": 520,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    match self.read_sensor() {\n        Ok(data) => {\n            self.output.send(data, &mut ctx).ok();\n        }\n        Err(e) => {\n            ctx.log_error(&format!(\"Sensor error: {}\", e));\n            self.error_count += 1;\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/monitor-security:15:bash",
      "file": "content/docs/development/monitor-security.mdx",
      "lineStart": 15,
      "lineEnd": 22,
      "language": "bash",
      "code": "horus monitor\n\n[SECURITY] HORUS Monitor - First Time Setup\nPassword: ********\nConfirm password: ********\n[SUCCESS] Password set successfully!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor-security:26:bash",
      "file": "content/docs/development/monitor-security.mdx",
      "lineStart": 26,
      "lineEnd": 28,
      "language": "bash",
      "code": "horus monitor -r",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor-security:32:bash",
      "file": "content/docs/development/monitor-security.mdx",
      "lineStart": 32,
      "lineEnd": 42,
      "language": "bash",
      "code": "# Login\ncurl -X POST http://localhost:3000/api/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"password\": \"your_password\"}'\n# Returns: {\"token\": \"abc123...\"}\n\n# Use token for requests\ncurl http://localhost:3000/api/nodes \\\n  -H \"Authorization: Bearer abc123...\"",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/monitor-security:57:bash",
      "file": "content/docs/development/monitor-security.mdx",
      "lineStart": 57,
      "lineEnd": 63,
      "language": "bash",
      "code": "# Local only (default)\nhorus monitor\n\n# Allow network access (set password first!)\nhorus monitor --host 0.0.0.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor-security:71:bash",
      "file": "content/docs/development/monitor-security.mdx",
      "lineStart": 71,
      "lineEnd": 74,
      "language": "bash",
      "code": "rm ~/.horus/monitor_password.hash\nhorus monitor  # Re-prompts for password",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor:77:bash",
      "file": "content/docs/development/monitor.mdx",
      "lineStart": 77,
      "lineEnd": 83,
      "language": "bash",
      "code": "# Start your robot\nhorus run\n\n# In another terminal, start monitor\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor:252:text",
      "file": "content/docs/development/monitor.mdx",
      "lineStart": 252,
      "lineEnd": 254,
      "language": "text",
      "code": "http://localhost:3000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor:257:text",
      "file": "content/docs/development/monitor.mdx",
      "lineStart": 257,
      "lineEnd": 259,
      "language": "text",
      "code": "http://192.168.1.100:3000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/monitor:314:bash",
      "file": "content/docs/development/monitor.mdx",
      "lineStart": 314,
      "lineEnd": 316,
      "language": "bash",
      "code": "horus monitor --tui",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:16:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 16,
      "lineEnd": 20,
      "language": "rust",
      "code": "// Hardcoded - requires recompile to change\nlet max_speed = 1.5;\nlet pid_kp = 1.0;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:23:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 23,
      "lineEnd": 27,
      "language": "rust",
      "code": "// Dynamic - change at runtime via monitor or CLI\nlet max_speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\nlet pid_kp = ctx.params.get_f64(\"control.pid.kp\", 1.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:42:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 42,
      "lineEnd": 44,
      "language": "rust",
      "code": "Arc<RwLock<BTreeMap<String, Value>>>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:49:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 49,
      "lineEnd": 65,
      "language": "yaml",
      "code": "motion:\n  max_speed: 1.5\n  acceleration: 0.5\n  deceleration: 0.8\ncontrol:\n  pid:\n    kp: 1.0\n    ki: 0.1\n    kd: 0.01\nsafety:\n  emergency_stop: false\n  collision_threshold: 0.3\nsensors:\n  lidar_rate_hz: 10\n  camera_resolution: [1920, 1080]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:81:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 81,
      "lineEnd": 90,
      "language": "rust",
      "code": "// Good: Hierarchical structure\nctx.params.get_f64(\"motion.max_speed\", 1.5);\nctx.params.get_f64(\"control.pid.kp\", 1.0);\nctx.params.get_i32(\"sensors.lidar_rate_hz\", 10);\n\n// Avoid: Flat structure\nctx.params.get_f64(\"max_speed\", 1.5);\nctx.params.get_f64(\"kp\", 1.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:104:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 104,
      "lineEnd": 128,
      "language": "rust",
      "code": "node! {\n    VelocityController {\n        data {\n            max_speed: f64 = 1.5,\n            acceleration: f64 = 0.5\n        }\n\n        init(ctx) {\n            // Load parameters on initialization\n            self.max_speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\n            self.acceleration = ctx.params.get_f64(\"motion.acceleration\", 0.5);\n\n            ctx.log_info(&format!(\"Max speed: {} m/s\", self.max_speed));\n            ctx.log_info(&format!(\"Acceleration: {} m/s²\", self.acceleration));\n        }\n\n        tick(ctx) {\n            // Use parameters\n            let target_velocity = self.max_speed;\n            // ...\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/development/parameters:133:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 133,
      "lineEnd": 138,
      "language": "rust",
      "code": "// If parameter doesn't exist, returns default value\nlet speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\nlet enabled = ctx.params.get_bool(\"features.auto_mode\", false);\nlet rate = ctx.params.get_i32(\"sensors.update_rate_hz\", 60);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:141:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 141,
      "lineEnd": 146,
      "language": "rust",
      "code": "// Returns Option<T> - None if parameter doesn't exist\nif let Some(speed) = ctx.params.get::<f64>(\"motion.max_speed\") {\n    self.max_speed = speed;\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:149:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 149,
      "lineEnd": 155,
      "language": "rust",
      "code": "// Update parameter value\nctx.params.set(\"motion.max_speed\", 2.0).ok();\n\n// Set complex types\nctx.params.set(\"sensors.camera_resolution\", vec![1920, 1080]).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:158:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 158,
      "lineEnd": 165,
      "language": "rust",
      "code": "// Convenience methods with type inference\nlet max_speed: f64 = ctx.params.get_f64(\"motion.max_speed\", 1.5);\nlet node_name: String = ctx.params.get_string(\"node.name\", \"default\");\nlet enabled: bool = ctx.params.get_bool(\"features.enabled\", true);\nlet count: i32 = ctx.params.get_i32(\"samples.count\", 100);\nlet id: u64 = ctx.params.get_u64(\"node.id\", 0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:170:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 170,
      "lineEnd": 194,
      "language": "rust",
      "code": "node! {\n    AdaptiveController {\n        data {\n            max_speed: f64 = 1.5,\n            last_speed_check: u64 = 0\n        }\n\n        tick(ctx) {\n            // Check every 60 ticks (~1 second at 60 Hz)\n            if self.last_speed_check % 60 == 0 {\n                // Reload parameter\n                let new_speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\n\n                if new_speed != self.max_speed {\n                    ctx.log_info(&format!(\"Speed updated: {}  {}\", self.max_speed, new_speed));\n                    self.max_speed = new_speed;\n                }\n            }\n\n            self.last_speed_check += 1;\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:201:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 201,
      "lineEnd": 210,
      "language": "rust",
      "code": "// Set array\nctx.params.set(\"waypoints\", vec![1.0, 2.5, 3.0, 4.5]).ok();\n\n// Get array\nlet waypoints: Vec<f64> = ctx.params\n    .get::<Vec<serde_json::Value>>(\"waypoints\")\n    .map(|v| v.iter().filter_map(|x| x.as_f64()).collect())\n    .unwrap_or_default();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:213:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 213,
      "lineEnd": 227,
      "language": "rust",
      "code": "use serde_json::json;\n\n// Set nested object\nlet config = json!({\n    \"ip\": \"192.168.1.100\",\n    \"port\": 8080,\n    \"timeout_ms\": 5000\n});\nctx.params.set(\"network.config\", config).ok();\n\n// Get nested values\nlet ip = ctx.params.get_string(\"network.config.ip\", \"localhost\");\nlet port = ctx.params.get_i32(\"network.config.port\", 8080);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:233:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 233,
      "lineEnd": 259,
      "language": "yaml",
      "code": "# ~/.horus/config/params.yaml (auto-generated)\nmotion:\n  max_linear_velocity: 1.0\n  max_angular_velocity: 1.0\n  acceleration_limit: 0.5\n\nsensors:\n  lidar_rate_hz: 10\n  camera_rate_hz: 30\n  imu_rate_hz: 100\n\nsafety:\n  emergency_stop_enabled: true\n  collision_threshold: 0.5\n  max_tilt_angle_deg: 30.0\n\ncontrol:\n  pid_linear:\n    kp: 1.0\n    ki: 0.1\n    kd: 0.01\n  pid_angular:\n    kp: 1.0\n    ki: 0.1\n    kd: 0.01",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:273:bash",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 273,
      "lineEnd": 281,
      "language": "bash",
      "code": "# Start monitor\nhorus monitor\n\n# Navigate to Parameters tab\n#  View all parameters\n#  Edit values inline\n#  Changes auto-save to disk",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:295:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 295,
      "lineEnd": 299,
      "language": "rust",
      "code": "// RuntimeParams saves automatically on set()\n// But you can force a save\nctx.params.save_to_disk().ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:302:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 302,
      "lineEnd": 305,
      "language": "rust",
      "code": "// Reload from disk (useful after external edit)\nctx.params.load_from_disk().ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:311:bash",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 311,
      "lineEnd": 318,
      "language": "bash",
      "code": "# Edit parameters file\nvim ~/.horus/config/params.yaml\n\n# Changes take effect:\n# - Immediately if node reloads\n# - On next restart if not",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:321:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 321,
      "lineEnd": 337,
      "language": "yaml",
      "code": "# Use spaces (2 or 4), not tabs\nmotion:\n  max_speed: 2.0        # number\n  mode: \"auto\"          # string (quotes optional for simple strings)\n  enabled: true         # boolean\n\nsensors:\n  rates: [10, 30, 100]  # array\n\n# Comments are preserved\ncontrol:\n  pid:\n    kp: 1.0   # Proportional gain\n    ki: 0.1   # Integral gain\n    kd: 0.01  # Derivative gain",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:343:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 343,
      "lineEnd": 384,
      "language": "rust",
      "code": "node! {\n    PIDController {\n        data {\n            kp: f64 = 1.0,\n            ki: f64 = 0.1,\n            kd: f64 = 0.01,\n            integral: f64 = 0.0,\n            last_error: f64 = 0.0\n        }\n\n        init(ctx) {\n            // Load PID gains\n            self.kp = ctx.params.get_f64(\"control.pid.kp\", 1.0);\n            self.ki = ctx.params.get_f64(\"control.pid.ki\", 0.1);\n            self.kd = ctx.params.get_f64(\"control.pid.kd\", 0.01);\n\n            ctx.log_info(&format!(\"PID: Kp={}, Ki={}, Kd={}\", self.kp, self.ki, self.kd));\n        }\n\n        tick(ctx) {\n            // Compute PID output\n            let error = self.compute_error();\n            self.integral += error;\n            let derivative = error - self.last_error;\n\n            let output = self.kp * error + self.ki * self.integral + self.kd * derivative;\n\n            self.last_error = error;\n\n            // Use output...\n        }\n\n        impl {\n            fn compute_error(&self) -> f64 {\n                // Your error calculation\n                0.0\n            }\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/development/parameters:396:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 396,
      "lineEnd": 432,
      "language": "rust",
      "code": "node! {\n    AdvancedController {\n        data {\n            enable_obstacle_avoidance: bool = false,\n            enable_path_planning: bool = false,\n            enable_localization: bool = true\n        }\n\n        init(ctx) {\n            self.enable_obstacle_avoidance = ctx.params.get_bool(\"features.obstacle_avoidance\", false);\n            self.enable_path_planning = ctx.params.get_bool(\"features.path_planning\", false);\n            self.enable_localization = ctx.params.get_bool(\"features.localization\", true);\n        }\n\n        tick(ctx) {\n            if self.enable_localization {\n                self.update_localization();\n            }\n\n            if self.enable_obstacle_avoidance {\n                self.avoid_obstacles();\n            }\n\n            if self.enable_path_planning {\n                self.plan_path();\n            }\n        }\n\n        impl {\n            fn update_localization(&mut self) { /* ... */ }\n            fn avoid_obstacles(&mut self) { /* ... */ }\n            fn plan_path(&mut self) { /* ... */ }\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/parameters:436:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 436,
      "lineEnd": 468,
      "language": "rust",
      "code": "node! {\n    NetworkNode {\n        data {\n            server_url: String = String::from(\"localhost:8080\"),\n            timeout_ms: u64 = 5000,\n            retry_count: i32 = 3\n        }\n\n        init(ctx) {\n            // Load environment-specific parameters\n            let env = ctx.params.get_string(\"environment\", \"development\");\n\n            match env.as_str() {\n                \"production\" => {\n                    self.server_url = ctx.params.get_string(\"network.prod_url\", \"prod.example.com:8080\");\n                    self.timeout_ms = ctx.params.get_u64(\"network.prod_timeout_ms\", 3000);\n                },\n                \"staging\" => {\n                    self.server_url = ctx.params.get_string(\"network.staging_url\", \"staging.example.com:8080\");\n                    self.timeout_ms = ctx.params.get_u64(\"network.staging_timeout_ms\", 5000);\n                },\n                _ => {\n                    self.server_url = ctx.params.get_string(\"network.dev_url\", \"localhost:8080\");\n                    self.timeout_ms = ctx.params.get_u64(\"network.dev_timeout_ms\", 10000);\n                }\n            }\n\n            ctx.log_info(&format!(\"Connecting to {} (timeout: {}ms)\", self.server_url, self.timeout_ms));\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:472:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 472,
      "lineEnd": 502,
      "language": "rust",
      "code": "node! {\n    SensorPublisher {\n        data {\n            publish_rate_hz: u64 = 10,\n            last_publish: std::time::Instant = std::time::Instant::now()\n        }\n\n        init(ctx) {\n            self.publish_rate_hz = ctx.params.get_u64(\"sensors.publish_rate_hz\", 10);\n            ctx.log_info(&format!(\"Publishing at {} Hz\", self.publish_rate_hz));\n        }\n\n        tick(ctx) {\n            let interval = std::time::Duration::from_millis(1000 / self.publish_rate_hz);\n\n            if self.last_publish.elapsed() >= interval {\n                // Publish sensor data\n                self.publish_data(ctx);\n                self.last_publish = std::time::Instant::now();\n            }\n        }\n\n        impl {\n            fn publish_data(&mut self, ctx: Option<&mut NodeInfo>) {\n                // Publishing logic\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:509:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 509,
      "lineEnd": 524,
      "language": "yaml",
      "code": "# Good\nmotion:\n  max_linear_velocity: 1.5\n  max_angular_velocity: 2.0\ncontrol:\n  pid:\n    kp: 1.0\n    ki: 0.1\n\n# Bad\nmax_linear_velocity: 1.5\nmax_angular_velocity: 2.0\npid_kp: 1.0\npid_ki: 0.1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:527:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 527,
      "lineEnd": 537,
      "language": "yaml",
      "code": "# Good\nsensors:\n  lidar_scan_rate_hz: 10\n  camera_resolution_width: 1920\n\n# Bad\nsensors:\n  rate: 10\n  w: 1920",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:540:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 540,
      "lineEnd": 550,
      "language": "yaml",
      "code": "# Good (snake_case)\nmotion:\n  max_speed: 1.5\n  acceleration_limit: 0.5\n\n# Bad (mixed casing)\nmotion:\n  maxSpeed: 1.5\n  acceleration_limit: 0.5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:556:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 556,
      "lineEnd": 562,
      "language": "rust",
      "code": "// Good - provides fallback\nlet speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\n\n// Bad - panics if missing\nlet speed = ctx.params.get::<f64>(\"motion.max_speed\").unwrap();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:565:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 565,
      "lineEnd": 573,
      "language": "rust",
      "code": "// Good - safe defaults\nlet emergency_stop = ctx.params.get_bool(\"safety.emergency_stop\", true);  // Default to safe state\nlet max_speed = ctx.params.get_f64(\"motion.max_speed\", 1.0);  // Default to slow\n\n// Bad - unsafe defaults\nlet emergency_stop = ctx.params.get_bool(\"safety.emergency_stop\", false);  // Unsafe!\nlet max_speed = ctx.params.get_f64(\"motion.max_speed\", 100.0);  // Too fast!",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:578:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 578,
      "lineEnd": 596,
      "language": "yaml",
      "code": "motion:\n  # Maximum linear velocity in m/s (default: 1.5)\n  max_linear_velocity: 1.5\n\n  # Maximum angular velocity in rad/s (default: 2.0)\n  max_angular_velocity: 2.0\n\ncontrol:\n  pid:\n    # Proportional gain - affects responsiveness (range: 0.1-10.0)\n    kp: 1.0\n\n    # Integral gain - affects steady-state error (range: 0.01-1.0)\n    ki: 0.1\n\n    # Derivative gain - affects damping (range: 0.001-0.1)\n    kd: 0.01",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:599:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 599,
      "lineEnd": 606,
      "language": "rust",
      "code": "init(ctx) {\n    // Load PID gains (tuning range: Kp=0.1-10, Ki=0.01-1, Kd=0.001-0.1)\n    self.kp = ctx.params.get_f64(\"control.pid.kp\", 1.0);\n    self.ki = ctx.params.get_f64(\"control.pid.ki\", 0.1);\n    self.kd = ctx.params.get_f64(\"control.pid.kd\", 0.01);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:611:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 611,
      "lineEnd": 626,
      "language": "rust",
      "code": "init(ctx) {\n    // Load with validation\n    let speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\n\n    // Clamp to safe range\n    self.max_speed = speed.max(0.0).min(5.0);  // 0-5 m/s\n\n    if speed != self.max_speed {\n        ctx.log_warning(&format!(\n            \"max_speed {} out of range, clamped to {}\",\n            speed, self.max_speed\n        ));\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:632:bash",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 632,
      "lineEnd": 642,
      "language": "bash",
      "code": "# Save current parameters to preset\nhorus monitor\n#  Parameters tab  Export  Save as \"aggressive_tuning.yaml\"\n\n# Switch to different preset\ncp ~/.horus/config/params.yaml ~/.horus/config/params_backup.yaml\ncp aggressive_tuning.yaml ~/.horus/config/params.yaml\n\n# Restart application to load new parameters",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:653:bash",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 653,
      "lineEnd": 665,
      "language": "bash",
      "code": "# Check YAML syntax\ncat ~/.horus/config/params.yaml\n\n# Validate YAML\nyamllint ~/.horus/config/params.yaml\n\n# Check permissions\nls -la ~/.horus/config/params.yaml\n\n# Should be readable\nchmod 644 ~/.horus/config/params.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:674:bash",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 674,
      "lineEnd": 683,
      "language": "bash",
      "code": "# Create config directory\nmkdir -p ~/.horus/config\n\n# Set permissions\nchmod 755 ~/.horus/config\n\n# Manually save from code\nctx.params.save_to_disk().ok();",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:690:text",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 690,
      "lineEnd": 692,
      "language": "text",
      "code": "Parameter 'motion.max_speed' expected f64, got String",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:697:yaml",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 697,
      "lineEnd": 703,
      "language": "yaml",
      "code": "# Wrong - string\nmax_speed: \"1.5\"\n\n# Correct - number\nmax_speed: 1.5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:706:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 706,
      "lineEnd": 709,
      "language": "rust",
      "code": "// Try as number first, then parse string as fallback\nlet speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:720:bash",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 720,
      "lineEnd": 726,
      "language": "bash",
      "code": "# Backup\ncp ~/.horus/config/params.yaml ~/.horus/config/params_backup.yaml\n\n# After update, restore if needed\ncp ~/.horus/config/params_backup.yaml ~/.horus/config/params.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/parameters:750:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 750,
      "lineEnd": 766,
      "language": "rust",
      "code": "data {\n    max_speed: f64 = 1.5,\n    reload_counter: u64 = 0\n}\n\ntick(ctx) {\n    // Reload every 60 ticks (~1 second)\n    if self.reload_counter % 60 == 0 {\n        self.max_speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\n    }\n    self.reload_counter += 1;\n\n    // Use cached value\n    let velocity = calculate_velocity(self.max_speed);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/parameters:769:rust",
      "file": "content/docs/development/parameters.mdx",
      "lineStart": 769,
      "lineEnd": 774,
      "language": "rust",
      "code": "tick(ctx) {\n    // Wasteful - reads same value 60 times per second\n    let max_speed = ctx.params.get_f64(\"motion.max_speed\", 1.5);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/ros2-bridge:13:text",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 13,
      "lineEnd": 24,
      "language": "text",
      "code": "┌─────────────┐     Zenoh      ┌─────────────┐\n│   ROS2      │◄──────────────►│   HORUS     │\n│   Nodes     │   (CDR msgs)   │   Bridge    │\n└─────────────┘                └──────┬──────┘\n                                      │\n                                      ▼ Shared Memory\n                               ┌─────────────┐\n                               │   HORUS     │\n                               │   Nodes     │\n                               └─────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:36:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 36,
      "lineEnd": 42,
      "language": "bash",
      "code": "# Bridge selected topics bidirectionally\nhorus bridge ros2 --topics /scan,/odom,/cmd_vel\n\n# Bridge with a specific ROS2 domain ID\nhorus bridge ros2 --domain 42 --topics /scan",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:46:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 46,
      "lineEnd": 52,
      "language": "bash",
      "code": "# Discover and bridge all available topics\nhorus bridge ros2 --all\n\n# Bridge all topics in a specific namespace\nhorus bridge ros2 --namespace /robot1 --all",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:56:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 56,
      "lineEnd": 62,
      "language": "bash",
      "code": "# ROS2 → HORUS only (subscribe from ROS2)\nhorus bridge ros2 --direction in --topics /scan,/odom\n\n# HORUS → ROS2 only (publish to ROS2)\nhorus bridge ros2 --direction out --topics /cmd_vel",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:84:rust",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 84,
      "lineEnd": 88,
      "language": "rust",
      "code": "// In your HORUS node, access the bridged topic:\nlet odom = Link::consumer(\"robot.odom\")?;  // Receives from ROS2 /robot/odom\nlet cmd = Hub::new(\"cmd_vel\")?;            // Publishes to ROS2 /cmd_vel",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ros2-bridge:104:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 104,
      "lineEnd": 113,
      "language": "bash",
      "code": "# Use sensor-optimized QoS (best effort, small queue)\nhorus bridge ros2 --qos sensor --topics /scan\n\n# Use reliable QoS for commands\nhorus bridge ros2 --qos reliable --topics /cmd_vel\n\n# Keep all messages (for logging/recording)\nhorus bridge ros2 --qos keep-all --topics /diagnostics",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:125:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 125,
      "lineEnd": 131,
      "language": "bash",
      "code": "# Connect to ROS2 domain 0 (default)\nhorus bridge ros2 --domain 0\n\n# Connect to a different domain\nhorus bridge ros2 --domain 42 --topics /scan",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:135:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 135,
      "lineEnd": 141,
      "language": "bash",
      "code": "# Only bridge topics under /robot1\nhorus bridge ros2 --namespace /robot1 --all\n\n# Bridge specific robot's topics\nhorus bridge ros2 --namespace /arm_left --topics /joint_states",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:147:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 147,
      "lineEnd": 153,
      "language": "bash",
      "code": "# Bridge specific services\nhorus bridge ros2 --services /get_map,/set_parameters\n\n# Bridge all discovered services\nhorus bridge ros2 --all-services",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:157:rust",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 157,
      "lineEnd": 163,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Hub\n\n// Call a bridged ROS2 service\nlet client = Hub::service_client(\"get_map\")?;\nlet response = client.call(GetMapRequest::default())?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/ros2-bridge:169:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 169,
      "lineEnd": 175,
      "language": "bash",
      "code": "# Bridge navigation action\nhorus bridge ros2 --actions /navigate_to_pose\n\n# Bridge all discovered actions\nhorus bridge ros2 --all-actions",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:181:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 181,
      "lineEnd": 184,
      "language": "bash",
      "code": "# Bridge transforms (enabled by default with --all)\nhorus bridge ros2 --topics /tf,/tf_static",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:192:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 192,
      "lineEnd": 195,
      "language": "bash",
      "code": "# Bridge parameters from specific nodes\nhorus bridge ros2 --param-nodes /controller_manager,/robot_state_publisher",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:203:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 203,
      "lineEnd": 210,
      "language": "bash",
      "code": "# Enable recovery with custom settings\nhorus bridge ros2 --recovery \\\n  --max-retries 5 \\\n  --retry-delay 1000 \\\n  --backoff-multiplier 2.0 \\\n  --max-delay 30000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:223:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 223,
      "lineEnd": 226,
      "language": "bash",
      "code": "# Limit message rate per topic\nhorus bridge ros2 --rate-limit 100 --topics /scan",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:234:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 234,
      "lineEnd": 240,
      "language": "bash",
      "code": "# Show bridge status\nhorus bridge ros2 status\n\n# Show detailed per-topic stats\nhorus bridge ros2 status --detailed",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:293:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 293,
      "lineEnd": 296,
      "language": "bash",
      "code": "# Register custom message definition\nhorus bridge ros2 --msg-path /path/to/my_msgs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:302:bash",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 302,
      "lineEnd": 311,
      "language": "bash",
      "code": "# Terminal 1: Start the bridge\nhorus bridge ros2 \\\n  --topics /scan,/odom,/map \\\n  --direction in \\\n  --topics /cmd_vel \\\n  --direction out \\\n  --services /get_plan \\\n  --actions /navigate_to_pose",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/ros2-bridge:313:rust",
      "file": "content/docs/development/ros2-bridge.mdx",
      "lineStart": 313,
      "lineEnd": 337,
      "language": "rust",
      "code": "// HORUS node consuming ROS2 data\nuse horus::prelude::*; // Provides {Hub, Node, NodeInfo}\n\nstruct NavigationNode {\n    scan: Hub<LaserScan>,\n    odom: Hub<Odometry>,\n    cmd_vel: Hub<Twist>,\n}\n\nimpl Node for NavigationNode {\n    fn name(&self) -> &'static str { \"navigation\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Read ROS2 sensor data (bridged automatically)\n        if let Some(scan) = self.scan.try_recv() {\n            // Process laser scan from ROS2\n        }\n\n        // Send velocity command (bridged to ROS2)\n        let cmd = Twist { linear: Vector3 { x: 0.5, ..Default::default() }, ..Default::default() };\n        self.cmd_vel.send(cmd, &mut ctx);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:17:bash",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 17,
      "lineEnd": 19,
      "language": "bash",
      "code": "horus run --enable editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:23:yaml",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 23,
      "lineEnd": 26,
      "language": "yaml",
      "code": "enable:\n  - editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:29:bash",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 29,
      "lineEnd": 31,
      "language": "bash",
      "code": "horus sim3d",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:37:toml",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 37,
      "lineEnd": 40,
      "language": "toml",
      "code": "[dependencies]\nhorus_sim3d = { version = \"0.1\", features = [\"editor\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:42:bash",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 42,
      "lineEnd": 44,
      "language": "bash",
      "code": "cargo run -p sim3d --features editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:50:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 50,
      "lineEnd": 59,
      "language": "rust",
      "code": "use horus_sim3d::editor::EditorPlugin;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(EditorPlugin)\n        .run();\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-editor:65:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 65,
      "lineEnd": 87,
      "language": "rust",
      "code": "use horus_sim3d::editor::{EditorState, GizmoMode, EditorCameraMode};\n\nfn configure_editor(mut editor_state: ResMut<EditorState>) {\n    // Enable/disable the editor\n    editor_state.enabled = true;\n\n    // Show/hide panels\n    editor_state.show_inspector = true;\n    editor_state.show_hierarchy = true;\n    editor_state.show_toolbar = true;\n\n    // Configure snapping\n    editor_state.snap_to_grid = true;\n    editor_state.grid_size = 0.1;  // 10cm grid\n\n    // Set gizmo mode\n    editor_state.gizmo_mode = GizmoMode::Translate;\n\n    // Set camera mode\n    editor_state.camera_mode = EditorCameraMode::Orbit;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:117:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 117,
      "lineEnd": 132,
      "language": "rust",
      "code": "use horus_sim3d::editor::selection::Selectable;\n\ncommands.spawn((\n    PbrBundle {\n        mesh: meshes.add(Cuboid::new(1.0, 1.0, 1.0)),\n        material: materials.add(Color::rgb(0.8, 0.2, 0.2)),\n        transform: Transform::from_xyz(0.0, 0.5, 0.0),\n        ..default()\n    },\n    Selectable::new(\"MyObject\"),\n));\n\n// Optionally disable selection\nlet selectable = Selectable::new(\"LockedObject\").with_enabled(false);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:138:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 138,
      "lineEnd": 165,
      "language": "rust",
      "code": "use horus_sim3d::editor::selection::Selection;\n\nfn handle_selection(\n    selection: Res<Selection>,\n    query: Query<&Transform>,\n) {\n    // Check if anything is selected\n    if selection.is_empty() {\n        return;\n    }\n\n    // Get primary selected entity\n    if let Some(primary) = selection.primary {\n        if let Ok(transform) = query.get(primary) {\n            println!(\"Selected at: {:?}\", transform.translation);\n        }\n    }\n\n    // Iterate all selected entities\n    for entity in selection.iter() {\n        // Process selected entity\n    }\n\n    // Check selection count\n    println!(\"{} entities selected\", selection.count());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:171:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 171,
      "lineEnd": 189,
      "language": "rust",
      "code": "use horus_sim3d::editor::selection::SelectionEvent;\n\nfn on_selection_change(mut events: EventReader<SelectionEvent>) {\n    for event in events.read() {\n        match event {\n            SelectionEvent::Selected(entity) => {\n                println!(\"Selected: {:?}\", entity);\n            }\n            SelectionEvent::Deselected(entity) => {\n                println!(\"Deselected: {:?}\", entity);\n            }\n            SelectionEvent::Cleared => {\n                println!(\"Selection cleared\");\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:205:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 205,
      "lineEnd": 212,
      "language": "rust",
      "code": "use horus_sim3d::editor::inspector::inspector_panel_system;\n\n// The inspector automatically shows:\n// - Transform (position, rotation, scale)\n// - Custom components with #[reflect] attribute\n// - Physics properties (if applicable)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:218:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 218,
      "lineEnd": 231,
      "language": "rust",
      "code": "use bevy::prelude::*;\n\n#[derive(Component, Reflect)]\n#[reflect(Component)]\npub struct RobotConfig {\n    pub max_speed: f32,\n    pub turn_rate: f32,\n    pub sensor_range: f32,\n}\n\n// Register the type with the app\napp.register_type::<RobotConfig>();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:237:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 237,
      "lineEnd": 248,
      "language": "rust",
      "code": "use horus_sim3d::editor::hierarchy::{\n    hierarchy_panel_system,\n    HierarchyCollapseState,\n};\n\n// The hierarchy shows:\n// - Named entities\n// - Parent-child relationships\n// - Selection state\n// - Expand/collapse controls",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:254:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 254,
      "lineEnd": 271,
      "language": "rust",
      "code": "use horus_sim3d::editor::undo::UndoStack;\n\nfn undo_redo(\n    keyboard: Res<ButtonInput<KeyCode>>,\n    mut undo_stack: ResMut<UndoStack>,\n) {\n    // Ctrl+Z to undo\n    if keyboard.pressed(KeyCode::ControlLeft) && keyboard.just_pressed(KeyCode::KeyZ) {\n        undo_stack.undo();\n    }\n\n    // Ctrl+Y or Ctrl+Shift+Z to redo\n    if keyboard.pressed(KeyCode::ControlLeft) && keyboard.just_pressed(KeyCode::KeyY) {\n        undo_stack.redo();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:277:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 277,
      "lineEnd": 286,
      "language": "rust",
      "code": "use horus_sim3d::editor::camera::editor_camera_system;\n\n// Camera controls:\n// - Right-click + drag: Orbit/look around\n// - Middle-click + drag: Pan\n// - Scroll: Zoom in/out\n// - F: Focus on selection\n// - 1-6: Switch to preset views",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:290:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 290,
      "lineEnd": 297,
      "language": "rust",
      "code": "use horus_sim3d::editor::EditorState;\n\nfn setup_camera(mut editor_state: ResMut<EditorState>) {\n    // Use orthographic views for precision work\n    editor_state.camera_mode = EditorCameraMode::Top;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-editor:301:rust",
      "file": "content/docs/development/sim3d-editor.mdx",
      "lineStart": 301,
      "lineEnd": 382,
      "language": "rust",
      "code": "use bevy::prelude::*;\nuse horus_sim3d::editor::{\n    EditorPlugin, EditorState, GizmoMode,\n    selection::{Selectable, Selection},\n};\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(EditorPlugin)\n        .add_systems(Startup, setup_scene)\n        .add_systems(Update, handle_selection)\n        .run();\n}\n\nfn setup_scene(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<StandardMaterial>>,\n    mut editor_state: ResMut<EditorState>,\n) {\n    // Configure editor\n    editor_state.enabled = true;\n    editor_state.snap_to_grid = true;\n    editor_state.grid_size = 0.5;\n    editor_state.gizmo_mode = GizmoMode::Translate;\n\n    // Spawn ground plane (not selectable)\n    commands.spawn(PbrBundle {\n        mesh: meshes.add(Plane3d::default().mesh().size(20.0, 20.0)),\n        material: materials.add(Color::rgb(0.3, 0.3, 0.3)),\n        ..default()\n    });\n\n    // Spawn selectable objects\n    for i in 0..5 {\n        commands.spawn((\n            PbrBundle {\n                mesh: meshes.add(Cuboid::new(1.0, 1.0, 1.0)),\n                material: materials.add(Color::rgb(0.8, 0.2 + i as f32 * 0.15, 0.2)),\n                transform: Transform::from_xyz(i as f32 * 2.0 - 4.0, 0.5, 0.0),\n                ..default()\n            },\n            Selectable::new(format!(\"Cube_{}\", i)),\n        ));\n    }\n\n    // Camera\n    commands.spawn(Camera3dBundle {\n        transform: Transform::from_xyz(5.0, 5.0, 10.0)\n            .looking_at(Vec3::ZERO, Vec3::Y),\n        ..default()\n    });\n\n    // Light\n    commands.spawn(DirectionalLightBundle {\n        directional_light: DirectionalLight {\n            illuminance: 10000.0,\n            shadows_enabled: true,\n            ..default()\n        },\n        transform: Transform::from_rotation(Quat::from_euler(\n            EulerRot::XYZ, -0.4, 0.4, 0.0\n        )),\n        ..default()\n    });\n}\n\nfn handle_selection(\n    selection: Res<Selection>,\n    names: Query<&Selectable>,\n) {\n    if selection.is_changed() && !selection.is_empty() {\n        if let Some(primary) = selection.primary {\n            if let Ok(selectable) = names.get(primary) {\n                println!(\"Selected: {}\", selectable.name);\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:15:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 15,
      "lineEnd": 29,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::MultiRobotPlugin;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(MultiRobotPlugin::default())\n        .run();\n}\n\n// Configure maximum robots\nApp::new()\n    .add_plugins(MultiRobotPlugin { max_robots: 50 })\n    .run();",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:37:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 37,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::RobotId;\n\n// Create robot IDs\nlet id1 = RobotId::new(\"robot_01\");\nlet id2 = RobotId::from(\"robot_02\");\nlet id3 = RobotId::from(String::from(\"robot_03\"));\n\n// Access ID as string\nprintln!(\"Robot: {}\", id1.as_str());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:53:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 53,
      "lineEnd": 66,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::Robot;\n\ncommands.spawn((\n    TransformBundle::default(),\n    Robot::new(\"robot_01\", \"turtlebot3\"),\n));\n\n// Create inactive robot\ncommands.spawn((\n    TransformBundle::default(),\n    Robot::new(\"robot_02\", \"ur5e\").with_active(false),\n));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:72:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 72,
      "lineEnd": 93,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::MultiRobotManager;\n\nfn manage_robots(manager: Res<MultiRobotManager>) {\n    // Get robot count\n    println!(\"{} robots registered\", manager.count());\n\n    // Get all robot IDs\n    for id in manager.get_all_ids() {\n        println!(\"  - {}\", id.as_str());\n    }\n\n    // Check if robot exists\n    let id = RobotId::new(\"robot_01\");\n    if manager.contains(&id) {\n        // Get entity for robot\n        if let Some(entity) = manager.get_robot(&id) {\n            println!(\"Robot entity: {:?}\", entity);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:99:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 99,
      "lineEnd": 119,
      "language": "rust",
      "code": "fn manual_registration(\n    mut manager: ResMut<MultiRobotManager>,\n    mut commands: Commands,\n) {\n    // Spawn and register\n    let entity = commands.spawn((\n        TransformBundle::default(),\n        Robot::new(\"manual_robot\", \"custom\"),\n    )).id();\n\n    // Manual registration (usually automatic)\n    manager.register(RobotId::new(\"manual_robot\"), entity)?;\n\n    // Unregister\n    manager.unregister(&RobotId::new(\"old_robot\"));\n\n    // Clear all\n    manager.clear();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:127:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 127,
      "lineEnd": 141,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::communication::{\n    CommunicationManager, ChannelConfig, RobotMessage\n};\n\nfn setup_communication(mut commands: Commands) {\n    let config = ChannelConfig {\n        max_queue_size: 1000,      // Messages per robot\n        max_message_size: 1024 * 1024,  // 1 MB\n        bandwidth_limit: Some(10_000_000),  // 10 MB/s (optional)\n    };\n\n    commands.insert_resource(CommunicationManager::new(config));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:145:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 145,
      "lineEnd": 172,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::communication::CommunicationManager;\n\nfn send_messages(\n    mut comm: ResMut<CommunicationManager>,\n    time: Res<Time>,\n) {\n    let sender = RobotId::new(\"robot_01\");\n    let receiver = RobotId::new(\"robot_02\");\n    let payload = b\"Hello from robot_01!\".to_vec();\n\n    // Send to specific robot\n    comm.send_message(\n        sender.clone(),\n        Some(receiver),\n        payload,\n        time.elapsed_secs_f64(),\n    ).expect(\"Failed to send\");\n\n    // Broadcast to all robots\n    comm.send_message(\n        sender,\n        None,  // None = broadcast\n        b\"Broadcast message\".to_vec(),\n        time.elapsed_secs_f64(),\n    ).expect(\"Failed to broadcast\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:176:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 176,
      "lineEnd": 200,
      "language": "rust",
      "code": "fn receive_messages(mut comm: ResMut<CommunicationManager>) {\n    let robot_id = RobotId::new(\"robot_02\");\n\n    // Check pending messages\n    let pending = comm.pending_count(&robot_id);\n    println!(\"{} messages waiting\", pending);\n\n    // Peek at next message\n    if let Some(msg) = comm.peek_message(&robot_id) {\n        println!(\"Next message from: {}\", msg.from.as_str());\n    }\n\n    // Receive and process messages\n    while let Some(msg) = comm.receive_message(&robot_id) {\n        println!(\"Received {} bytes from {}\",\n            msg.size_bytes(),\n            msg.from.as_str());\n\n        if msg.is_broadcast() {\n            println!(\"  (broadcast message)\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:206:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 206,
      "lineEnd": 219,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::communication::{Communicator, RobotMessage};\n\nfn handle_message(msg: &RobotMessage) {\n    println!(\"Got message: {:?}\", msg.payload);\n}\n\ncommands.spawn((\n    Robot::new(\"robot_01\", \"sensor_bot\"),\n    Communicator {\n        on_message: Some(handle_message),\n    },\n));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:223:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 223,
      "lineEnd": 233,
      "language": "rust",
      "code": "fn show_stats(comm: Res<CommunicationManager>) {\n    let stats = comm.get_stats();\n\n    println!(\"Communication Statistics:\");\n    println!(\"  Sent: {} messages\", stats.sent_count);\n    println!(\"  Received: {} messages\", stats.received_count);\n    println!(\"  Bytes transmitted: {}\", stats.bytes_transmitted);\n    println!(\"  Active robots: {}\", stats.active_robots);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:241:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 241,
      "lineEnd": 263,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::coordination::SwarmAgent;\n\ncommands.spawn((\n    TransformBundle::from_transform(Transform::from_xyz(0.0, 0.0, 0.0)),\n    Robot::new(\"swarm_01\", \"drone\"),\n    SwarmAgent {\n        separation_distance: 2.0,    // Min distance between agents\n        alignment_weight: 1.0,       // Match neighbor velocity\n        cohesion_weight: 1.0,        // Move toward group center\n        separation_weight: 1.5,      // Avoid collisions (higher priority)\n        max_speed: 2.0,              // Maximum velocity\n        perception_radius: 5.0,      // Neighbor detection range\n    },\n));\n\n// Use defaults\ncommands.spawn((\n    TransformBundle::default(),\n    Robot::new(\"swarm_02\", \"drone\"),\n    SwarmAgent::default(),\n));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:282:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 282,
      "lineEnd": 304,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::coordination::{FormationController, FormationType};\n\n// Create formation leader\nlet leader_id = commands.spawn((\n    TransformBundle::from_transform(Transform::from_xyz(0.0, 0.0, 0.0)),\n    Robot::new(\"leader\", \"turtlebot3\"),\n)).id();\n\n// Create followers in line formation\nfor i in 0..4 {\n    commands.spawn((\n        TransformBundle::default(),\n        Robot::new(format!(\"follower_{}\", i), \"turtlebot3\"),\n        FormationController {\n            formation_type: FormationType::Line,\n            formation_index: i,\n            scale: 1.0,\n            leader: Some(RobotId::new(\"leader\")),\n        },\n    ));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:318:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 318,
      "lineEnd": 322,
      "language": "rust",
      "code": "let mut controller = FormationController::new(FormationType::Circle, 0);\ncontroller.scale = 2.0;  // Double the formation size\ncontroller.leader = Some(RobotId::new(\"leader\"));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:326:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 326,
      "lineEnd": 347,
      "language": "rust",
      "code": "fn change_formation(\n    mut query: Query<&mut FormationController>,\n    keyboard: Res<ButtonInput<KeyCode>>,\n) {\n    if keyboard.just_pressed(KeyCode::Digit1) {\n        for mut fc in query.iter_mut() {\n            fc.formation_type = FormationType::Line;\n        }\n    }\n    if keyboard.just_pressed(KeyCode::Digit2) {\n        for mut fc in query.iter_mut() {\n            fc.formation_type = FormationType::Circle;\n        }\n    }\n    if keyboard.just_pressed(KeyCode::Digit3) {\n        for mut fc in query.iter_mut() {\n            fc.formation_type = FormationType::Wedge;\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:355:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 355,
      "lineEnd": 377,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::coordination::ConsensusState;\n\nfn setup_consensus(mut commands: Commands) {\n    commands.insert_resource(ConsensusState::new(0.1));  // threshold\n}\n\nfn run_consensus(mut consensus: ResMut<ConsensusState>) {\n    // Each robot contributes its value\n    consensus.set_value(RobotId::new(\"robot_01\"), 10.0);\n    consensus.set_value(RobotId::new(\"robot_02\"), 15.0);\n    consensus.set_value(RobotId::new(\"robot_03\"), 12.0);\n\n    // Check consensus\n    let avg = consensus.average();\n    let var = consensus.variance();\n    println!(\"Average: {:.2}, Variance: {:.4}\", avg, var);\n\n    if consensus.is_converged() {\n        println!(\"Consensus reached!\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:385:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 385,
      "lineEnd": 407,
      "language": "rust",
      "code": "use horus_sim3d::multi_robot::coordination::TaskAllocation;\n\nfn allocate_tasks(mut allocation: ResMut<TaskAllocation>) {\n    // Define costs for each robot-task pair\n    allocation.set_cost(RobotId::new(\"robot_01\"), \"pickup_A\".to_string(), 5.0);\n    allocation.set_cost(RobotId::new(\"robot_01\"), \"pickup_B\".to_string(), 10.0);\n    allocation.set_cost(RobotId::new(\"robot_02\"), \"pickup_A\".to_string(), 8.0);\n    allocation.set_cost(RobotId::new(\"robot_02\"), \"pickup_B\".to_string(), 3.0);\n\n    // Run greedy allocation\n    let robots = vec![RobotId::new(\"robot_01\"), RobotId::new(\"robot_02\")];\n    let tasks = vec![\"pickup_A\".to_string(), \"pickup_B\".to_string()];\n    allocation.allocate_greedy(&robots, &tasks);\n\n    // Get assignments\n    for robot in &robots {\n        if let Some(task) = allocation.get_assignment(robot) {\n            println!(\"{} assigned to {}\", robot.as_str(), task);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-multi-robot:411:rust",
      "file": "content/docs/development/sim3d-multi-robot.mdx",
      "lineStart": 411,
      "lineEnd": 562,
      "language": "rust",
      "code": "use bevy::prelude::*;\nuse horus_sim3d::multi_robot::{\n    MultiRobotPlugin, Robot, RobotId, MultiRobotManager,\n    communication::{CommunicationManager, ChannelConfig},\n    coordination::{SwarmAgent, FormationController, FormationType, ConsensusState},\n};\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(MultiRobotPlugin { max_robots: 20 })\n        .add_systems(Startup, setup_robots)\n        .add_systems(Update, (control_robots, show_stats))\n        .run();\n}\n\nfn setup_robots(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<StandardMaterial>>,\n) {\n    // Spawn swarm of drones\n    for i in 0..10 {\n        let x = (i % 5) as f32 * 3.0 - 6.0;\n        let z = (i / 5) as f32 * 3.0 - 3.0;\n\n        commands.spawn((\n            PbrBundle {\n                mesh: meshes.add(Sphere::new(0.3)),\n                material: materials.add(Color::rgb(0.2, 0.6, 0.9)),\n                transform: Transform::from_xyz(x, 1.0, z),\n                ..default()\n            },\n            Robot::new(format!(\"drone_{}\", i), \"quadcopter\"),\n            SwarmAgent::default(),\n        ));\n    }\n\n    // Spawn leader for formation\n    commands.spawn((\n        PbrBundle {\n            mesh: meshes.add(Sphere::new(0.4)),\n            material: materials.add(Color::rgb(0.9, 0.2, 0.2)),\n            transform: Transform::from_xyz(0.0, 1.0, 10.0),\n            ..default()\n        },\n        Robot::new(\"leader\", \"turtlebot3\"),\n    ));\n\n    // Spawn formation followers\n    for i in 0..4 {\n        commands.spawn((\n            PbrBundle {\n                mesh: meshes.add(Cuboid::new(0.5, 0.3, 0.6)),\n                material: materials.add(Color::rgb(0.2, 0.9, 0.2)),\n                transform: Transform::from_xyz(i as f32 * 2.0, 0.15, 10.0),\n                ..default()\n            },\n            Robot::new(format!(\"follower_{}\", i), \"turtlebot3\"),\n            FormationController {\n                formation_type: FormationType::Wedge,\n                formation_index: i,\n                scale: 1.5,\n                leader: Some(RobotId::new(\"leader\")),\n            },\n        ));\n    }\n\n    // Ground\n    commands.spawn(PbrBundle {\n        mesh: meshes.add(Plane3d::default().mesh().size(50.0, 50.0)),\n        material: materials.add(Color::rgb(0.3, 0.3, 0.3)),\n        ..default()\n    });\n\n    // Camera\n    commands.spawn(Camera3dBundle {\n        transform: Transform::from_xyz(0.0, 20.0, 20.0)\n            .looking_at(Vec3::ZERO, Vec3::Y),\n        ..default()\n    });\n\n    // Light\n    commands.spawn(DirectionalLightBundle {\n        directional_light: DirectionalLight {\n            illuminance: 10000.0,\n            shadows_enabled: true,\n            ..default()\n        },\n        transform: Transform::from_rotation(Quat::from_euler(\n            EulerRot::XYZ, -0.5, 0.5, 0.0\n        )),\n        ..default()\n    });\n}\n\nfn control_robots(\n    keyboard: Res<ButtonInput<KeyCode>>,\n    mut query: Query<&mut FormationController>,\n    mut leader_query: Query<&mut Transform, (With<Robot>, Without<FormationController>)>,\n    time: Res<Time>,\n) {\n    // Move leader with arrow keys\n    for mut transform in leader_query.iter_mut() {\n        let speed = 3.0 * time.delta_secs();\n        if keyboard.pressed(KeyCode::ArrowUp) {\n            transform.translation.z -= speed;\n        }\n        if keyboard.pressed(KeyCode::ArrowDown) {\n            transform.translation.z += speed;\n        }\n        if keyboard.pressed(KeyCode::ArrowLeft) {\n            transform.translation.x -= speed;\n        }\n        if keyboard.pressed(KeyCode::ArrowRight) {\n            transform.translation.x += speed;\n        }\n    }\n\n    // Change formation with number keys\n    for mut fc in query.iter_mut() {\n        if keyboard.just_pressed(KeyCode::Digit1) {\n            fc.formation_type = FormationType::Line;\n        }\n        if keyboard.just_pressed(KeyCode::Digit2) {\n            fc.formation_type = FormationType::Circle;\n        }\n        if keyboard.just_pressed(KeyCode::Digit3) {\n            fc.formation_type = FormationType::Wedge;\n        }\n        if keyboard.just_pressed(KeyCode::Digit4) {\n            fc.formation_type = FormationType::Grid;\n        }\n    }\n}\n\nfn show_stats(\n    manager: Res<MultiRobotManager>,\n    comm: Res<CommunicationManager>,\n    keyboard: Res<ButtonInput<KeyCode>>,\n) {\n    if keyboard.just_pressed(KeyCode::KeyI) {\n        println!(\"\\n=== Multi-Robot Status ===\");\n        println!(\"Registered robots: {}\", manager.count());\n\n        let stats = comm.get_stats();\n        println!(\"Messages sent: {}\", stats.sent_count);\n        println!(\"Bytes transmitted: {}\", stats.bytes_transmitted);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-recording:15:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 15,
      "lineEnd": 24,
      "language": "rust",
      "code": "use horus_sim3d::recording::RecordingPlugin;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(RecordingPlugin)\n        .run();\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/sim3d-recording:34:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 34,
      "lineEnd": 44,
      "language": "rust",
      "code": "use horus_sim3d::recording::trajectory::TrajectoryPoint;\n\nlet point = TrajectoryPoint {\n    timestamp: 1.5,\n    position: Vec3::new(1.0, 0.5, 2.0),\n    rotation: Quat::IDENTITY,\n    linear_velocity: Vec3::new(0.5, 0.0, 0.0),\n    angular_velocity: Vec3::ZERO,\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:50:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 50,
      "lineEnd": 66,
      "language": "rust",
      "code": "use horus_sim3d::recording::trajectory::{RecordingSession, TrajectoryPoint};\n\nfn start_recording(mut session: ResMut<RecordingSession>, time: Res<Time>) {\n    session.start(time.elapsed_secs_f64());\n    println!(\"Recording started\");\n}\n\nfn stop_recording(mut session: ResMut<RecordingSession>) {\n    session.stop();\n\n    // Save to file\n    let path = std::path::PathBuf::from(\"recordings/session.json\");\n    session.save_to_file(&path).expect(\"Failed to save\");\n    println!(\"Saved {} trajectories\", session.trajectories.len());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:72:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 72,
      "lineEnd": 81,
      "language": "rust",
      "code": "use horus_sim3d::recording::trajectory::TrajectoryRecorder;\n\ncommands.spawn((\n    TransformBundle::default(),\n    RigidBody::Dynamic,\n    TrajectoryRecorder::new(30.0),  // Record at 30 Hz\n    Name::new(\"TrackedRobot\"),\n));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:87:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 87,
      "lineEnd": 103,
      "language": "rust",
      "code": "use horus_sim3d::recording::trajectory::Trajectory;\n\nfn analyze_trajectory(trajectory: &Trajectory) {\n    // Get duration\n    println!(\"Duration: {:.2}s\", trajectory.duration());\n\n    // Get point at specific time (interpolated)\n    if let Some(point) = trajectory.get_point_at(2.5) {\n        println!(\"Position at 2.5s: {:?}\", point.position);\n    }\n\n    // Sample at fixed intervals\n    let sampled = trajectory.sample(0.1);  // 10 Hz\n    println!(\"Sampled {} points\", sampled.len());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:109:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 109,
      "lineEnd": 134,
      "language": "rust",
      "code": "use horus_sim3d::recording::trajectory::{Trajectory, TrajectoryPlayback};\n\nfn setup_playback(\n    mut commands: Commands,\n    trajectory: Trajectory,\n) {\n    let mut playback = TrajectoryPlayback::new(trajectory);\n    playback.loop_playback = true;\n    playback.playback_speed = 1.0;\n\n    commands.spawn((\n        TransformBundle::default(),\n        playback,\n    ));\n}\n\nfn control_playback(mut query: Query<&mut TrajectoryPlayback>) {\n    for mut playback in query.iter_mut() {\n        playback.play();        // Start playback\n        playback.pause();       // Pause\n        playback.reset();       // Go to start\n        playback.playback_speed = 2.0;  // 2x speed\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:142:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 142,
      "lineEnd": 169,
      "language": "rust",
      "code": "use horus_sim3d::recording::time_control::{TimeControl, TimeControlMode, TimeScalePresets};\n\nfn configure_time(mut time_control: ResMut<TimeControl>) {\n    // Pause simulation\n    time_control.pause();\n\n    // Resume\n    time_control.resume();\n\n    // Toggle pause\n    time_control.toggle_pause();\n\n    // Slow motion\n    time_control.set_slow_motion(0.25);  // 0.25x speed\n\n    // Fast forward\n    time_control.set_fast_forward(4.0);  // 4x speed\n\n    // Use presets\n    time_control.set_time_scale(TimeScalePresets::HALF_SPEED);\n    time_control.set_time_scale(TimeScalePresets::DOUBLE_SPEED);\n\n    // Frame stepping\n    time_control.enable_frame_stepping();\n    time_control.step_frame_forward();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:197:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 197,
      "lineEnd": 211,
      "language": "rust",
      "code": "use horus_sim3d::recording::time_control::{\n    TimeControlRecording, TimeKeyframe, TimeControlMode\n};\n\nfn setup_scripted_time(mut recording: ResMut<TimeControlRecording>) {\n    // Slow down at t=2.0 for dramatic effect\n    recording.add_keyframe(TimeKeyframe::new(0.0, 1.0, TimeControlMode::Normal));\n    recording.add_keyframe(TimeKeyframe::new(2.0, 0.25, TimeControlMode::SlowMotion));\n    recording.add_keyframe(TimeKeyframe::new(4.0, 1.0, TimeControlMode::Normal));\n\n    recording.loop_playback = true;\n    recording.play();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:217:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 217,
      "lineEnd": 229,
      "language": "rust",
      "code": "use horus_sim3d::recording::time_control::TimeStats;\n\nfn show_stats(time_control: Res<TimeControl>, time: Res<Time>) {\n    let stats = TimeStats::from_time_control(&time_control, time.elapsed_secs_f64());\n\n    println!(\"Real time: {:.2}s\", stats.real_time_elapsed);\n    println!(\"Sim time: {:.2}s\", stats.simulation_time_elapsed);\n    println!(\"Frame count: {}\", stats.frame_count);\n    println!(\"FPS: {:.1}\", stats.average_fps);\n    println!(\"Time ratio: {:.2}x\", stats.get_time_ratio());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:237:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 237,
      "lineEnd": 251,
      "language": "rust",
      "code": "use horus_sim3d::recording::video_export::{\n    VideoRecordingConfig, VideoFormat, VideoRecorder\n};\n\nlet config = VideoRecordingConfig::new(\n    std::path::PathBuf::from(\"output/video\"),\n    1920, 1080  // Resolution\n)\n.with_framerate(60)\n.with_format(VideoFormat::ImageSequence)\n.with_quality(90);  // JPEG quality\n\nlet recorder = VideoRecorder::new(config);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:263:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 263,
      "lineEnd": 300,
      "language": "rust",
      "code": "use horus_sim3d::recording::video_export::{VideoRecorder, VideoFrame, ImageDataFormat};\n\nfn video_recording(\n    mut recorder: ResMut<VideoRecorder>,\n    time: Res<Time>,\n) {\n    // Start recording\n    if !recorder.active {\n        recorder.start_recording(time.elapsed_secs_f64());\n    }\n\n    // Check if frame should be captured\n    if recorder.should_capture_frame(time.elapsed_secs_f64()) {\n        // Get frame data from render target\n        let frame_data: Vec<u8> = capture_screen(); // Your capture function\n\n        let frame = VideoFrame::new(\n            recorder.frame_count,\n            time.elapsed_secs_f64(),\n            1920, 1080,\n            frame_data,\n            ImageDataFormat::RGB8,\n        );\n\n        recorder.add_frame(frame);\n    }\n}\n\nfn finish_video(recorder: Res<VideoRecorder>) {\n    // Export all frames to disk\n    recorder.export_frames().expect(\"Failed to export\");\n\n    println!(\"Exported {} frames\", recorder.frame_count);\n    println!(\"Duration: {:.2}s\", recorder.get_duration());\n    println!(\"Size: ~{:.1} MB\", recorder.get_estimated_size_mb());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:304:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 304,
      "lineEnd": 315,
      "language": "rust",
      "code": "use horus_sim3d::recording::video_export::FrameConverter;\n\n// Convert RGBA to RGB (remove alpha)\nlet rgb_data = FrameConverter::rgba_to_rgb(&rgba_data);\n\n// Convert RGB to RGBA (add alpha)\nlet rgba_data = FrameConverter::rgb_to_rgba(&rgb_data, 255);\n\n// Flip image vertically (OpenGL convention)\nlet flipped = FrameConverter::flip_vertical(&data, width, height, 3);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:321:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 321,
      "lineEnd": 329,
      "language": "rust",
      "code": "use horus_sim3d::recording::video_export::ScreenshotCapture;\n\ncommands.spawn(ScreenshotCapture::new(\n    std::path::PathBuf::from(\"screenshots/capture.png\")\n));\n\n// The screenshot component auto-disables after capture",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:337:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 337,
      "lineEnd": 386,
      "language": "rust",
      "code": "use horus_sim3d::recording::sensor_data::{SensorData, ImageFormat};\n\n// Camera image\nlet image = SensorData::Image {\n    width: 640,\n    height: 480,\n    format: ImageFormat::RGB8,\n    data: pixel_data,\n};\n\n// LiDAR scan\nlet scan = SensorData::LaserScan {\n    ranges: vec![1.5, 2.0, 2.5, /* ... */],\n    intensities: Some(vec![0.8, 0.9, 0.7]),\n    angle_min: -std::f32::consts::PI,\n    angle_max: std::f32::consts::PI,\n    angle_increment: 0.01,\n    range_min: 0.1,\n    range_max: 30.0,\n};\n\n// IMU data\nlet imu = SensorData::IMU {\n    orientation: [0.0, 0.0, 0.0, 1.0],\n    angular_velocity: [0.0, 0.0, 0.1],\n    linear_acceleration: [0.0, 0.0, 9.81],\n};\n\n// Odometry\nlet odom = SensorData::Odometry {\n    position: [1.0, 2.0, 0.0],\n    orientation: [0.0, 0.0, 0.0, 1.0],\n    linear_velocity: [0.5, 0.0, 0.0],\n    angular_velocity: [0.0, 0.0, 0.1],\n};\n\n// GPS\nlet gps = SensorData::GPS {\n    latitude: 37.7749,\n    longitude: -122.4194,\n    altitude: 10.0,\n};\n\n// Custom data\nlet custom = SensorData::Custom {\n    data_type: \"my_sensor\".to_string(),\n    data: serialized_bytes,\n};",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:390:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 390,
      "lineEnd": 436,
      "language": "rust",
      "code": "use horus_sim3d::recording::sensor_data::{\n    SensorBagRecorder, SensorMessage, SensorData, ImageFormat\n};\n\nfn setup_recorder(mut commands: Commands) {\n    commands.insert_resource(SensorBagRecorder::new(\"experiment_001\".to_string()));\n}\n\nfn record_sensors(\n    mut recorder: ResMut<SensorBagRecorder>,\n    time: Res<Time>,\n) {\n    if !recorder.active {\n        recorder.start_recording();\n    }\n\n    // Record camera data\n    recorder.record_message(SensorMessage {\n        timestamp: time.elapsed_secs_f64(),\n        topic: \"camera.rgb\".to_string(),\n        data: SensorData::Image {\n            width: 640,\n            height: 480,\n            format: ImageFormat::RGB8,\n            data: get_camera_data(),\n        },\n    });\n\n    // Record IMU data\n    recorder.record_message(SensorMessage {\n        timestamp: time.elapsed_secs_f64(),\n        topic: \"imu.data\".to_string(),\n        data: SensorData::IMU {\n            orientation: get_orientation(),\n            angular_velocity: get_angular_velocity(),\n            linear_acceleration: get_acceleration(),\n        },\n    });\n}\n\nfn save_bag(recorder: Res<SensorBagRecorder>) {\n    let mut bag = recorder.bag.clone();\n    let path = std::path::PathBuf::from(\"data/experiment.bag\");\n    bag.save_to_file(&path).expect(\"Failed to save bag\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:442:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 442,
      "lineEnd": 454,
      "language": "rust",
      "code": "use horus_sim3d::recording::sensor_data::RecordSensor;\n\ncommands.spawn((\n    Camera3dBundle::default(),\n    RecordSensor::new(\"camera.front\".to_string(), 30.0),  // 30 Hz\n));\n\ncommands.spawn((\n    ImuSensor::default(),\n    RecordSensor::new(\"imu.data\".to_string(), 100.0),  // 100 Hz\n));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:460:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 460,
      "lineEnd": 495,
      "language": "rust",
      "code": "use horus_sim3d::recording::sensor_data::{SensorBag, SensorBagPlayback};\n\nfn setup_playback(mut commands: Commands) {\n    let path = std::path::PathBuf::from(\"data/experiment.bag\");\n    let bag = SensorBag::load_from_file(&path).expect(\"Failed to load bag\");\n\n    let mut playback = SensorBagPlayback::new(bag);\n    playback.loop_playback = true;\n    playback.playback_speed = 1.0;\n\n    commands.insert_resource(playback);\n}\n\nfn process_playback(\n    mut playback: ResMut<SensorBagPlayback>,\n    time: Res<Time>,\n) {\n    playback.play();\n\n    // Get messages for current time\n    let messages = playback.get_messages_at_time(time.delta_secs_f64());\n\n    for msg in messages {\n        match &msg.data {\n            SensorData::Image { width, height, .. } => {\n                println!(\"Camera frame: {}x{}\", width, height);\n            }\n            SensorData::IMU { angular_velocity, .. } => {\n                println!(\"IMU: {:?}\", angular_velocity);\n            }\n            _ => {}\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:501:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 501,
      "lineEnd": 519,
      "language": "rust",
      "code": "use horus_sim3d::recording::sensor_data::BagStatistics;\n\nfn analyze_bag(bag: &SensorBag) {\n    let stats = BagStatistics::from_bag(bag);\n\n    println!(\"Duration: {:.2}s\", stats.duration);\n    println!(\"Total messages: {}\", stats.total_messages);\n    println!(\"Estimated size: {:.2} MB\", stats.estimated_size_mb);\n\n    for (topic, topic_stats) in &stats.topics {\n        println!(\"  {}: {} msgs @ {:.1} Hz ({})\",\n            topic,\n            topic_stats.message_count,\n            topic_stats.frequency,\n            topic_stats.message_type);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:523:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 523,
      "lineEnd": 532,
      "language": "rust",
      "code": "// Get all messages for a topic\nlet camera_msgs = bag.get_messages(\"camera.rgb\");\n\n// Get messages in time range\nlet msgs = bag.get_messages_in_range(2.0, 5.0);\n\n// Export to JSON for analysis\nbag.export_to_json(&std::path::PathBuf::from(\"data/analysis.json\"))?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/sim3d-recording:536:rust",
      "file": "content/docs/development/sim3d-recording.mdx",
      "lineStart": 536,
      "lineEnd": 623,
      "language": "rust",
      "code": "use bevy::prelude::*;\nuse horus_sim3d::recording::{\n    RecordingPlugin,\n    trajectory::{RecordingSession, TrajectoryRecorder},\n    time_control::{TimeControl, TimeControlMode},\n    sensor_data::{SensorBagRecorder, SensorMessage, SensorData},\n};\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(RecordingPlugin)\n        .add_systems(Startup, setup)\n        .add_systems(Update, (control_recording, record_sensors))\n        .run();\n}\n\nfn setup(mut commands: Commands) {\n    // Spawn robot with trajectory recording\n    commands.spawn((\n        TransformBundle::default(),\n        TrajectoryRecorder::new(60.0),\n        Name::new(\"Robot\"),\n    ));\n\n    // Initialize sensor bag recorder\n    commands.insert_resource(SensorBagRecorder::new(\"session\".to_string()));\n}\n\nfn control_recording(\n    keyboard: Res<ButtonInput<KeyCode>>,\n    mut session: ResMut<RecordingSession>,\n    mut time_control: ResMut<TimeControl>,\n    time: Res<Time>,\n) {\n    // R: Start/stop recording\n    if keyboard.just_pressed(KeyCode::KeyR) {\n        if session.active {\n            session.stop();\n            println!(\"Recording stopped\");\n        } else {\n            session.start(time.elapsed_secs_f64());\n            println!(\"Recording started\");\n        }\n    }\n\n    // Space: Toggle pause\n    if keyboard.just_pressed(KeyCode::Space) {\n        time_control.toggle_pause();\n    }\n\n    // [ and ]: Adjust time scale\n    if keyboard.just_pressed(KeyCode::BracketLeft) {\n        time_control.set_time_scale(time_control.time_scale * 0.5);\n    }\n    if keyboard.just_pressed(KeyCode::BracketRight) {\n        time_control.set_time_scale(time_control.time_scale * 2.0);\n    }\n}\n\nfn record_sensors(\n    mut recorder: ResMut<SensorBagRecorder>,\n    session: Res<RecordingSession>,\n    time: Res<Time>,\n) {\n    if session.active && !recorder.active {\n        recorder.start_recording();\n    } else if !session.active && recorder.active {\n        recorder.stop_recording();\n    }\n\n    // Record sensor data while session is active\n    if recorder.active {\n        // Example: Record odometry\n        recorder.record_message(SensorMessage {\n            timestamp: time.elapsed_secs_f64(),\n            topic: \"odom\".to_string(),\n            data: SensorData::Odometry {\n                position: [0.0, 0.0, 0.0],\n                orientation: [0.0, 0.0, 0.0, 1.0],\n                linear_velocity: [0.0, 0.0, 0.0],\n                angular_velocity: [0.0, 0.0, 0.0],\n            },\n        });\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:66:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 66,
      "lineEnd": 73,
      "language": "bash",
      "code": "# Ubuntu/Debian - Install dependencies\nsudo apt install -y pkg-config libx11-dev libasound2-dev libudev-dev\n\n# Set environment variables\nexport PKG_CONFIG_ALLOW_SYSTEM_LIBS=1\nexport PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:77:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 77,
      "lineEnd": 84,
      "language": "bash",
      "code": "# Launch simulator\nhorus sim2d\n\n# Or with specific options\nhorus sim2d --world warehouse.yaml\nhorus sim2d --headless  # No GUI (for testing)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:110:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 110,
      "lineEnd": 144,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\nstruct NavigationNode {\n    cmd_pub: Hub<CmdVel>,\n    scan_sub: Hub<LaserScan>,\n}\n\nimpl NavigationNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            scan_sub: Hub::new(\"scan\")?,\n        })\n    }\n}\n\nimpl Node for NavigationNode {\n    fn name(&self) -> &'static str {\n        \"NavigationNode\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read simulated LiDAR\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            // Compute motion command\n            let cmd = avoid_obstacles(&scan);\n\n            // Send to simulated robot\n            self.cmd_pub.send(cmd, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:156:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 156,
      "lineEnd": 165,
      "language": "bash",
      "code": "# Terminal 1: Launch simulator with maze\nhorus sim2d --world maze.yaml\n\n# Terminal 2: Run your navigation code\nhorus run navigation.rs --release\n\n# Terminal 3: Monitor performance\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:169:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 169,
      "lineEnd": 188,
      "language": "bash",
      "code": "#!/bin/bash\n# Automated test script\n\n# Start simulator in headless mode\nhorus sim2d --headless &\nSIM_PID=$!\n\n# Wait for simulator to initialize\nsleep 2\n\n# Run test\ntimeout 30 horus run test_navigation.rs --release\nTEST_RESULT=$?\n\n# Stop simulator\nkill $SIM_PID\n\nexit $TEST_RESULT",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:194:yaml",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 194,
      "lineEnd": 212,
      "language": "yaml",
      "code": "# warehouse.yaml\nworld:\n  size: [20.0, 20.0]\n\nobstacles:\n  - type: box\n    position: [5.0, 5.0]\n    size: [2.0, 1.0]\n\n  - type: circle\n    position: [10.0, 8.0]\n    radius: 1.5\n\nrobots:\n  - name: robot1\n    position: [1.0, 1.0]\n    orientation: 0.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:215:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 215,
      "lineEnd": 217,
      "language": "bash",
      "code": "horus sim2d --world warehouse.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:223:yaml",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 223,
      "lineEnd": 245,
      "language": "yaml",
      "code": "physics:\n  rate_hz: 240\n  gravity: [0.0, 0.0]\n\nrendering:\n  window_size: [1280, 720]\n  target_fps: 60\n\nrobot:\n  max_linear_vel: 0.5  # m/s\n  max_angular_vel: 2.0 # rad/s\n  wheel_radius: 0.05   # meters\n  wheel_separation: 0.2\n\nsensors:\n  lidar:\n    num_rays: 360\n    max_range: 10.0\n    fov: 6.28318  # 2π (360°)\n    rate_hz: 10\n    noise_std: 0.01",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:249:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 249,
      "lineEnd": 262,
      "language": "bash",
      "code": "horus sim2d [OPTIONS]\n\nOptions:\n  --headless                 Run without GUI (for CI/CD)\n  --world <FILE>             World configuration file\n  --world-image <FILE>       World image file (PNG, JPG, PGM)\n  --resolution <FLOAT>       Resolution in meters per pixel\n  --threshold <0-255>        Obstacle threshold (darker = obstacle)\n  --robot <FILE>             Robot configuration file\n  --topic <PREFIX>           HORUS topic prefix (default: /robot)\n  --name <NAME>              Robot name for logging (default: robot)\n  -h, --help                 Show help",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/development/simulation:377:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 377,
      "lineEnd": 383,
      "language": "rust",
      "code": "// Get transform between frames\nlet transform = tf_tree.get_transform(\"base_link\", \"camera_link\")?;\n\n// Visualize TF tree\nhorus sim3d --tf-view",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/simulation:388:python",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 388,
      "lineEnd": 402,
      "language": "python",
      "code": "import gymnasium as gym\nimport horus_sim3d\n\n# Create vectorized environment (1024 parallel instances)\nenv = gym.make_vec(\"HorusNav3D-v0\", num_envs=1024)\n\nobs, info = env.reset()\n\nfor step in range(1_000_000):\n    actions = policy(obs)\n    obs, rewards, dones, truncated, info = env.step(actions)\n\n    # 100K+ steps per second!",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:419:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 419,
      "lineEnd": 422,
      "language": "bash",
      "code": "# Import Gazebo world\nhorus sim3d --import-sdf warehouse.world",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:425:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 425,
      "lineEnd": 429,
      "language": "rust",
      "code": "// Spawn objects at runtime\nscene.spawn_box(position, size, material);\nscene.spawn_urdf(\"turtlebot3.urdf\", pose);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/simulation:432:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 432,
      "lineEnd": 438,
      "language": "bash",
      "code": "# Save current scene\nhorus sim3d --save-scene my_world.yaml\n\n# Load scene\nhorus sim3d --scene my_world.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:442:text",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 442,
      "lineEnd": 471,
      "language": "text",
      "code": "┌─────────────────────────────────────────────────────┐\n│                  User Interface                      │\n├──────────────┬──────────────┬───────────────────────┤\n│ CLI          │ GUI (egui)   │ Python (Gym)          │\n│ horus sim3d  │ Debug panels │ RL training           │\n└──────┬───────┴──────┬───────┴──────┬────────────────┘\n       │              │              │\n┌──────▼──────────────▼──────────────▼────────────────┐\n│           Simulation Core (Bevy ECS)                │\n├─────────────────────────────────────────────────────┤\n│                                                     │\n│  ┌────────────┐  ┌────────────┐  ┌──────────────┐ │\n│  │  Physics   │  │  Sensors   │  │  TF System   │ │\n│  │ (Rapier3D) │  │ Simulation │  │  (frames)    │ │\n│  └─────┬──────┘  └─────┬──────┘  └──────┬───────┘ │\n│        │               │                │         │\n│  ┌─────▼───────────────▼────────────────▼───────┐  │\n│  │         HORUS Hub Bridge                     │  │\n│  │  • Publish sensor data                       │  │\n│  │  • Subscribe to cmd_vel                      │  │\n│  │  • Publish /tf transforms                    │  │\n│  └──────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────┘\n         │                            │\n┌────────▼─────────┐        ┌─────────▼──────────────┐\n│  Visual Rendering│        │  Headless RL Mode      │\n│  (60 FPS)        │        │  (100K+ steps/sec)     │\n└──────────────────┘        └────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:496:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 496,
      "lineEnd": 517,
      "language": "bash",
      "code": "# Visual mode (default)\nhorus sim3d\n\n# Headless RL training\nhorus sim3d --headless --num-envs 1024\n\n# Load URDF robot\nhorus sim3d --robot turtlebot3.urdf\n\n# Import Gazebo world\nhorus sim3d --import-sdf warehouse.world\n\n# Enable TF visualization\nhorus sim3d --tf-view\n\n# Debug mode with editor\nhorus sim3d --editor\n\n# Specific scenario\nhorus sim3d --scenario manipulation_task",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:521:python",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 521,
      "lineEnd": 548,
      "language": "python",
      "code": "# train_navigation.py\nimport gymnasium as gym\nfrom stable_baselines3 import PPO\nimport horus_sim3d\n\n# Create environment\nenv = gym.make_vec(\"HorusNav3D-v0\",\n                   num_envs=1024,\n                   domain_randomization=True)\n\n# Train agent\nmodel = PPO(\"MlpPolicy\", env, verbose=1)\nmodel.learn(total_timesteps=10_000_000)\n\n# Save policy\nmodel.save(\"navigation_policy\")\n\n# Evaluate in visual mode\neval_env = gym.make(\"HorusNav3D-v0\", render_mode=\"human\")\nobs, _ = eval_env.reset()\n\nfor _ in range(1000):\n    action, _ = model.predict(obs)\n    obs, reward, done, truncated, info = eval_env.step(action)\n    if done or truncated:\n        obs, _ = eval_env.reset()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:626:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 626,
      "lineEnd": 636,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {ImuNode, ImuBackend, GpsNode, GpsBackend, LidarNode, LidarBackend}\n\n// Explicit simulation mode\nlet imu = ImuNode::new_with_backend(\"imu\", ImuBackend::Simulation)?;\nlet gps = GpsNode::new_with_backend(\"gps.fix\", GpsBackend::Simulation)?;\nlet lidar = LidarNode::new_with_backend(\"scan\", LidarBackend::Simulation)?;\n\n// Default constructors use simulation mode\nlet imu = ImuNode::new()?;  // Simulation by default",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/simulation:659:python",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 659,
      "lineEnd": 674,
      "language": "python",
      "code": "from horus.nodes import (\n    SerialNode, JoystickNode, KeyboardNode,\n    ImuNode, GpsNode, CameraNode, LidarNode\n)\n\n# Explicit simulation mode\nserial = SerialNode(port=\"/dev/ttyUSB0\", simulation=True)\nimu = ImuNode(i2c_bus=1, simulation=True)\ngps = GpsNode(port=\"/dev/ttyACM0\", simulation=True)\ncamera = CameraNode(device_id=0, simulation=True)\nlidar = LidarNode(port=\"/dev/ttyUSB0\", simulation=True)\n\n# Auto-fallback: If hardware unavailable, switches to simulation\nserial = SerialNode(port=\"/dev/ttyUSB0\")  # Falls back if port doesn't exist",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:692:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 692,
      "lineEnd": 710,
      "language": "rust",
      "code": "// Rust: Auto-fallback on hardware error\nimpl Node for ImuNode {\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        match self.backend {\n            ImuBackend::Mpu6050 => {\n                if let Err(e) = self.initialize_mpu6050() {\n                    ctx.log_warning(&format!(\"MPU6050 init failed: {}, falling back to simulation\", e));\n                    self.backend = ImuBackend::Simulation;\n                }\n            }\n            ImuBackend::Simulation => {\n                ctx.log_info(\"IMU running in simulation mode\");\n            }\n        }\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:712:python",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 712,
      "lineEnd": 725,
      "language": "python",
      "code": "# Python: Auto-fallback on hardware error\ndef _init(self, node):\n    if self.simulation:\n        self.log_info(\"ImuNode running in simulation mode\")\n        return\n\n    try:\n        self._bus = smbus2.SMBus(self.i2c_bus)\n        self._bus.write_byte_data(self.i2c_address, 0x6B, 0)  # Wake MPU6050\n    except Exception as e:\n        self.log_error(f\"Failed to initialize IMU: {e}\")\n        self.simulation = True  # Auto-fallback",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:754:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 754,
      "lineEnd": 760,
      "language": "bash",
      "code": "# Start with simulation\nhorus run examples/my_robot.rs  # Uses simulation by default\n\n# Then test with hardware\nhorus run examples/my_robot.rs --enable hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:763:toml",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 763,
      "lineEnd": 768,
      "language": "toml",
      "code": "# Cargo.toml\n[features]\ndefault = []  # Simulation by default\nhardware = [\"mpu6050\", \"rplidar\", \"gpio\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:771:yaml",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 771,
      "lineEnd": 775,
      "language": "yaml",
      "code": "# .github/workflows/test.yml\n- name: Run tests\n  run: horus test  # No hardware needed",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:778:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 778,
      "lineEnd": 786,
      "language": "rust",
      "code": "// Start with all simulation\nlet imu = ImuNode::new()?;  // Simulation\nlet gps = GpsNode::new()?;  // Simulation\n\n// Enable hardware one-by-one\nlet imu = ImuNode::new_with_backend(\"imu\", ImuBackend::Mpu6050)?;\nlet gps = GpsNode::new()?;  // Still simulation",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/simulation:795:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 795,
      "lineEnd": 801,
      "language": "rust",
      "code": "// Same code in simulation and reality\nlet cmd_pub = Hub::<CmdVel>::new(\"cmd_vel\")?;\nlet scan_sub = Hub::<LaserScan>::new(\"scan\")?;\n\n// HORUS handles whether it's sim or real hardware",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/simulation:809:rust",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 809,
      "lineEnd": 812,
      "language": "rust",
      "code": "// horus_library/messages - works everywhere\nuse horus::prelude::*; // Provides {CmdVel, LaserScan, Odometry};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/simulation:823:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 823,
      "lineEnd": 833,
      "language": "bash",
      "code": "# Develop in sim2d (fast iteration)\nhorus sim\nhorus run navigation.rs\n\n# Refine in sim3d (realistic testing)\nhorus sim3d --robot your_robot.urdf\n\n# Deploy to real hardware\nhorus run --remote 192.168.1.100 navigation.rs",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/simulation:836:yaml",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 836,
      "lineEnd": 843,
      "language": "yaml",
      "code": "# Match real robot specs\nrobot:\n  max_linear_vel: 0.22   # Your robot's max speed\n  max_angular_vel: 2.84\n  wheel_radius: 0.033\n  wheel_separation: 0.16",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:846:yaml",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 846,
      "lineEnd": 852,
      "language": "yaml",
      "code": "sensors:\n  lidar:\n    noise_std: 0.01      # Realistic sensor noise\n  odometry:\n    drift_rate: 0.001    # Wheel slip",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/simulation:898:bash",
      "file": "content/docs/development/simulation.mdx",
      "lineStart": 898,
      "lineEnd": 903,
      "language": "bash",
      "code": "horus_library/apps/\n├── snakesim/        # Snake game (sim2d demo)\n├── tanksim/         # Tank simulation (sim2d)\n└── sim3d_examples/  # sim3d examples (coming soon)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/static-analysis:15:rust",
      "file": "content/docs/development/static-analysis.mdx",
      "lineStart": 15,
      "lineEnd": 22,
      "language": "rust",
      "code": "// WRONG: Two producers on same topic\nLink::producer(\"sensor_data\")?;  // Node A\nLink::producer(\"sensor_data\")?;  // Node B - SPSC violation!\n\n// FIX: Use Hub for multiple producers\nHub::new(\"sensor_data\")?;  // Supports MPMC",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/static-analysis:26:bash",
      "file": "content/docs/development/static-analysis.mdx",
      "lineStart": 26,
      "lineEnd": 35,
      "language": "bash",
      "code": "horus check\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n  Static Analysis Warnings\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n  Link topic 'sensor_data' has 2 producers (expected 1 for SPSC)\n    Hint: Use Hub for multiple producers.",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:42:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 42,
      "lineEnd": 145,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// The node we want to test\npub struct TemperatureSensor {\n    temp_pub: Hub<f32>,\n    reading: f32,\n}\n\nimpl TemperatureSensor {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            temp_pub: Hub::new(\"temperature\")?,\n            reading: 20.0,\n        })\n    }\n\n    // Make this public so tests can inspect it\n    pub fn get_reading(&self) -> f32 {\n        self.reading\n    }\n}\n\nimpl Node for TemperatureSensor {\n    fn name(&self) -> &'static str {\n        \"TemperatureSensor\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Increment reading each tick\n        self.reading += 0.5;\n\n        // Publish temperature\n        self.temp_pub.send(self.reading, &mut ctx).ok();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor shutdown\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(TemperatureSensor::new()?), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n// ============================================================================\n// TESTS\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sensor_initialization() {\n        // Test that sensor initializes with correct default value\n        let sensor = TemperatureSensor::new().unwrap();\n        assert_eq!(sensor.get_reading(), 20.0);\n    }\n\n    #[test]\n    fn test_sensor_init_lifecycle() {\n        let mut sensor = TemperatureSensor::new().unwrap();\n        let mut ctx = NodeInfo::new(\"TemperatureSensor\".to_string(), true);\n\n        // Test init() method\n        let result = sensor.init(&mut ctx);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_sensor_tick_increments_reading() {\n        let mut sensor = TemperatureSensor::new().unwrap();\n\n        // Run tick 5 times\n        for i in 1..=5 {\n            sensor.tick(None);\n\n            // Verify reading increments by 0.5 each tick\n            let expected = 20.0 + (i as f32 * 0.5);\n            assert_eq!(sensor.get_reading(), expected);\n        }\n    }\n\n    #[test]\n    fn test_sensor_shutdown() {\n        let mut sensor = TemperatureSensor::new().unwrap();\n        let mut ctx = NodeInfo::new(\"TemperatureSensor\".to_string(), true);\n\n        // Test shutdown() method\n        let result = sensor.shutdown(&mut ctx);\n        assert!(result.is_ok());\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:149:bash",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 149,
      "lineEnd": 151,
      "language": "bash",
      "code": "horus test",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:155:text",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 155,
      "lineEnd": 163,
      "language": "text",
      "code": "running 4 tests\ntest tests::test_sensor_initialization ... ok\ntest tests::test_sensor_init_lifecycle ... ok\ntest tests::test_sensor_tick_increments_reading ... ok\ntest tests::test_sensor_shutdown ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/testing:168:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 168,
      "lineEnd": 174,
      "language": "rust",
      "code": "#[test]\nfn test_node_creation() {\n    let node = MyNode::new().unwrap();\n    assert_eq!(node.some_field, expected_value);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:177:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 177,
      "lineEnd": 184,
      "language": "rust",
      "code": "#[test]\nfn test_init() {\n    let mut node = MyNode::new().unwrap();\n    let mut ctx = NodeInfo::new(\"MyNode\".to_string(), true);\n    assert!(node.init(&mut ctx).is_ok());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:187:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 187,
      "lineEnd": 195,
      "language": "rust",
      "code": "#[test]\nfn test_tick_logic() {\n    let mut node = MyNode::new().unwrap();\n    node.tick(None);\n    // Verify state changes\n    assert_eq!(node.counter, 1);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:198:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 198,
      "lineEnd": 205,
      "language": "rust",
      "code": "#[test]\nfn test_shutdown() {\n    let mut node = MyNode::new().unwrap();\n    let mut ctx = NodeInfo::new(\"MyNode\".to_string(), true);\n    assert!(node.shutdown(&mut ctx).is_ok());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:215:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 215,
      "lineEnd": 331,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::sync::{Arc, Mutex};\n\n// Publisher node\npub struct PublisherNode {\n    data_pub: Hub<f32>,\n}\n\nimpl PublisherNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            data_pub: Hub::new(\"test_data\")?,\n        })\n    }\n}\n\nimpl Node for PublisherNode {\n    fn name(&self) -> &'static str {\n        \"PublisherNode\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.data_pub.send(42.0, &mut ctx).ok();\n    }\n}\n\n// Subscriber node that stores received data\npub struct SubscriberNode {\n    data_sub: Hub<f32>,\n    received: Arc<Mutex<Vec<f32>>>,\n}\n\nimpl SubscriberNode {\n    pub fn new(received: Arc<Mutex<Vec<f32>>>) -> Result<Self> {\n        Ok(Self {\n            data_sub: Hub::new(\"test_data\")?,\n            received,\n        })\n    }\n}\n\nimpl Node for SubscriberNode {\n    fn name(&self) -> &'static str {\n        \"SubscriberNode\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_sub.recv(&mut ctx) {\n            self.received.lock().unwrap().push(data);\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let received = Arc::new(Mutex::new(Vec::new()));\n\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(PublisherNode::new()?), 0, Some(true));\n    scheduler.add(Box::new(SubscriberNode::new(received)?), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::thread;\n    use std::time::Duration;\n\n    #[test]\n    fn test_pubsub_communication() {\n        // Shared storage for received messages\n        let received = Arc::new(Mutex::new(Vec::new()));\n\n        // Create publisher and subscriber\n        let mut pub_node = PublisherNode::new().unwrap();\n        let mut sub_node = SubscriberNode::new(Arc::clone(&received)).unwrap();\n\n        // Publish a message\n        pub_node.tick(None);\n\n        // Small delay to allow IPC (shared memory needs time to propagate)\n        thread::sleep(Duration::from_millis(10));\n\n        // Subscriber receives the message\n        sub_node.tick(None);\n\n        // Verify message was received\n        let data = received.lock().unwrap();\n        assert_eq!(data.len(), 1);\n        assert_eq!(data[0], 42.0);\n    }\n\n    #[test]\n    fn test_multiple_messages() {\n        let received = Arc::new(Mutex::new(Vec::new()));\n\n        let mut pub_node = PublisherNode::new().unwrap();\n        let mut sub_node = SubscriberNode::new(Arc::clone(&received)).unwrap();\n\n        // Publish 5 messages\n        for _ in 0..5 {\n            pub_node.tick(None);\n            thread::sleep(Duration::from_millis(5));\n            sub_node.tick(None);\n        }\n\n        // Verify all messages received\n        let data = received.lock().unwrap();\n        assert_eq!(data.len(), 5);\n        for value in data.iter() {\n            assert_eq!(*value, 42.0);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:335:bash",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 335,
      "lineEnd": 337,
      "language": "bash",
      "code": "horus test test_pubsub_communication -- --test-threads=1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:346:text",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 346,
      "lineEnd": 352,
      "language": "text",
      "code": "running 2 tests\ntest tests::test_pubsub_communication ... ok\ntest tests::test_multiple_messages ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/testing:360:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 360,
      "lineEnd": 427,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Node that processes temperature data\npub struct TemperatureProcessor {\n    input_sub: Hub<f32>,\n    output_pub: Hub<f32>,\n}\n\nimpl TemperatureProcessor {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            input_sub: Hub::new(\"input_temp\")?,\n            output_pub: Hub::new(\"output_temp\")?,\n        })\n    }\n\n    // Public method for testing business logic\n    pub fn process_temperature(&self, temp: f32) -> f32 {\n        // Convert Celsius to Fahrenheit\n        temp * 9.0 / 5.0 + 32.0\n    }\n}\n\nimpl Node for TemperatureProcessor {\n    fn name(&self) -> &'static str {\n        \"TemperatureProcessor\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(celsius) = self.input_sub.recv(&mut ctx) {\n            let fahrenheit = self.process_temperature(celsius);\n            self.output_pub.send(fahrenheit, &mut ctx).ok();\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_temperature_conversion_logic() {\n        // Test business logic WITHOUT Hub\n        let processor = TemperatureProcessor::new().unwrap();\n\n        // Test known conversions\n        assert_eq!(processor.process_temperature(0.0), 32.0);\n        assert_eq!(processor.process_temperature(100.0), 212.0);\n        assert_eq!(processor.process_temperature(-40.0), -40.0);\n    }\n\n    #[test]\n    fn test_with_mock_data() {\n        let mut processor = TemperatureProcessor::new().unwrap();\n\n        // We can't easily mock Hub, but we can test the logic\n        // by calling process_temperature directly\n        let celsius_readings = vec![0.0, 10.0, 20.0, 30.0, 100.0];\n        let expected_fahrenheit = vec![32.0, 50.0, 68.0, 86.0, 212.0];\n\n        for (celsius, expected) in celsius_readings.iter().zip(expected_fahrenheit.iter()) {\n            let result = processor.process_temperature(*celsius);\n            assert_eq!(result, *expected);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:434:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 434,
      "lineEnd": 445,
      "language": "rust",
      "code": "// Good: Business logic in testable method\npub fn process_temperature(&self, temp: f32) -> f32 {\n    temp * 9.0 / 5.0 + 32.0\n}\n\n// Test this directly without Hub\n#[test]\nfn test_logic() {\n    assert_eq!(node.process_temperature(0.0), 32.0);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:448:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 448,
      "lineEnd": 456,
      "language": "rust",
      "code": "// Use real Hubs in tests (they're lightweight)\n#[test]\nfn test_with_real_hub() {\n    let mut node = MyNode::new().unwrap();\n    node.tick(None);\n    // Verify behavior\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:459:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 459,
      "lineEnd": 471,
      "language": "rust",
      "code": "// Store results in node for verification\npub struct TestNode {\n    pub last_result: Option<f32>,\n}\n\n#[test]\nfn test_result() {\n    let mut node = TestNode::new();\n    node.tick(None);\n    assert_eq!(node.last_result, Some(42.0));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:479:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 479,
      "lineEnd": 612,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::sync::{Arc, Mutex};\n\n// Node 1: Generate numbers\npub struct GeneratorNode {\n    output_pub: Hub<u32>,\n    counter: u32,\n}\n\nimpl GeneratorNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            output_pub: Hub::new(\"numbers\")?,\n            counter: 0,\n        })\n    }\n}\n\nimpl Node for GeneratorNode {\n    fn name(&self) -> &'static str { \"GeneratorNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.counter += 1;\n        self.output_pub.send(self.counter, &mut ctx).ok();\n    }\n}\n\n// Node 2: Double the numbers\npub struct DoublerNode {\n    input_sub: Hub<u32>,\n    output_pub: Hub<u32>,\n}\n\nimpl DoublerNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            input_sub: Hub::new(\"numbers\")?,\n            output_pub: Hub::new(\"doubled\")?,\n        })\n    }\n}\n\nimpl Node for DoublerNode {\n    fn name(&self) -> &'static str { \"DoublerNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(n) = self.input_sub.recv(&mut ctx) {\n            self.output_pub.send(n * 2, &mut ctx).ok();\n        }\n    }\n}\n\n// Node 3: Collect results\npub struct CollectorNode {\n    input_sub: Hub<u32>,\n    collected: Arc<Mutex<Vec<u32>>>,\n}\n\nimpl CollectorNode {\n    pub fn new(collected: Arc<Mutex<Vec<u32>>>) -> Result<Self> {\n        Ok(Self {\n            input_sub: Hub::new(\"doubled\")?,\n            collected,\n        })\n    }\n}\n\nimpl Node for CollectorNode {\n    fn name(&self) -> &'static str { \"CollectorNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(n) = self.input_sub.recv(&mut ctx) {\n            self.collected.lock().unwrap().push(n);\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let collected = Arc::new(Mutex::new(Vec::new()));\n\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(GeneratorNode::new()?), 0, Some(true));\n    scheduler.add(Box::new(DoublerNode::new()?), 1, Some(true));\n    scheduler.add(Box::new(CollectorNode::new(collected)?), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::thread;\n    use std::time::Duration;\n\n    #[test]\n    fn test_generator_node() {\n        let mut node = GeneratorNode::new().unwrap();\n\n        // Initial state\n        assert_eq!(node.counter, 0);\n\n        // After 3 ticks\n        for _ in 0..3 {\n            node.tick(None);\n        }\n\n        assert_eq!(node.counter, 3);\n    }\n\n    #[test]\n    fn test_pipeline() {\n        let collected = Arc::new(Mutex::new(Vec::new()));\n\n        let mut gen = GeneratorNode::new().unwrap();\n        let mut dbl = DoublerNode::new().unwrap();\n        let mut col = CollectorNode::new(Arc::clone(&collected)).unwrap();\n\n        // Run 5 iterations of the pipeline\n        for _ in 0..5 {\n            gen.tick(None);\n            thread::sleep(Duration::from_millis(5));\n            dbl.tick(None);\n            thread::sleep(Duration::from_millis(5));\n            col.tick(None);\n        }\n\n        // Verify results: 1*2=2, 2*2=4, 3*2=6, 4*2=8, 5*2=10\n        let results = collected.lock().unwrap();\n        assert_eq!(*results, vec![2, 4, 6, 8, 10]);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:616:bash",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 616,
      "lineEnd": 618,
      "language": "bash",
      "code": "horus test -- --test-threads=1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:622:text",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 622,
      "lineEnd": 628,
      "language": "text",
      "code": "running 2 tests\ntest tests::test_generator_node ... ok\ntest tests::test_pipeline ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/development/testing:636:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 636,
      "lineEnd": 646,
      "language": "rust",
      "code": "// Good: Pure function (easy to test)\nfn calculate_velocity(distance: f32, time: f32) -> f32 {\n    distance / time\n}\n\n#[test]\nfn test_velocity() {\n    assert_eq!(calculate_velocity(100.0, 10.0), 10.0);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:652:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 652,
      "lineEnd": 658,
      "language": "rust",
      "code": "let results = Arc::new(Mutex::new(Vec::new()));\nlet node = TestNode::new(Arc::clone(&results))?;\n\n// Later in test\nassert_eq!(results.lock().unwrap().len(), 5);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/testing:664:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 664,
      "lineEnd": 668,
      "language": "rust",
      "code": "pub_node.tick(None);\nthread::sleep(Duration::from_millis(10));  // Allow IPC\nsub_node.tick(None);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:674:bash",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 674,
      "lineEnd": 676,
      "language": "bash",
      "code": "horus test -- --test-threads=1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:680:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 680,
      "lineEnd": 692,
      "language": "rust",
      "code": "#[test]\nfn test_no_messages() {\n    let mut node = SubscriberNode::new().unwrap();\n    node.tick(None);  // Should handle gracefully\n}\n\n#[test]\nfn test_invalid_data() {\n    let result = node.process(-1.0);\n    assert!(result.is_err());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:698:bash",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 698,
      "lineEnd": 713,
      "language": "bash",
      "code": "# Run all tests\nhorus test\n\n# Run tests sequentially (recommended for HORUS)\nhorus test -- --test-threads=1\n\n# Run specific test\nhorus test test_sensor_initialization\n\n# Run tests with output\nhorus test -- --nocapture\n\n# Run tests matching pattern\nhorus test sensor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:717:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 717,
      "lineEnd": 736,
      "language": "rust",
      "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    mod unit_tests {\n        use super::*;\n\n        #[test]\n        fn test_creation() { /* ... */ }\n    }\n\n    mod integration_tests {\n        use super::*;\n\n        #[test]\n        fn test_pipeline() { /* ... */ }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/development/testing:745:bash",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 745,
      "lineEnd": 747,
      "language": "bash",
      "code": "horus test -- --test-threads=1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/development/testing:754:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 754,
      "lineEnd": 757,
      "language": "rust",
      "code": "Hub::new(\"test_topic_1\")?  // Test 1\nHub::new(\"test_topic_2\")?  // Test 2",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/development/testing:764:rust",
      "file": "content/docs/development/testing.mdx",
      "lineStart": 764,
      "lineEnd": 766,
      "language": "rust",
      "code": "thread::sleep(Duration::from_millis(10));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/choosing-language:34:python",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 34,
      "lineEnd": 51,
      "language": "python",
      "code": "from horus import Node, Hub, Scheduler\n\nclass TempSensor(Node):\n    def __init__(self):\n        self.pub = Hub(\"temperature\")\n\n    def name(self):\n        return \"TempSensor\"\n\n    def tick(self, ctx):\n        temp = 25.0  # Read sensor\n        self.pub.send(temp, ctx)\n\nscheduler = Scheduler()\nscheduler.add(TempSensor(), priority=5)\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:54:rust",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 54,
      "lineEnd": 81,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct TempSensor {\n    pub_hub: Hub<f32>,\n}\n\nimpl TempSensor {\n    fn new() -> Result<Self> {\n        Ok(Self { pub_hub: Hub::new(\"temperature\")? })\n    }\n}\n\nimpl Node for TempSensor {\n    fn name(&self) -> &'static str { \"TempSensor\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let temp = 25.0;  // Read sensor\n        self.pub_hub.send(temp, &mut ctx).ok();\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(TempSensor::new()?), 5, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:84:rust",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 84,
      "lineEnd": 102,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nnode! {\n    name: TempSensor,\n    publishers: [temperature: f32],\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let temp = 25.0;\n        self.temperature.send(temp, &mut ctx).ok();\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(TempSensor::new()?), 5, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:141:python",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 141,
      "lineEnd": 153,
      "language": "python",
      "code": "# Quick experiment - try different approaches fast\nfrom horus import Node, Hub\n\nclass ExperimentalController(Node):\n    def tick(self, ctx):\n        # Easy to modify and test\n        if self.strategy == \"aggressive\":\n            output = self.input * 2.0\n        else:\n            output = self.input * 0.5\n        self.pub.send(output, ctx)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:157:python",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 157,
      "lineEnd": 171,
      "language": "python",
      "code": "import torch\nfrom horus import Node, Hub\n\nclass MLController(Node):\n    def __init__(self):\n        self.model = torch.load(\"my_model.pt\")\n        self.pub = Hub(\"control_output\")\n\n    def tick(self, ctx):\n        # Easy integration with PyTorch\n        with torch.no_grad():\n            output = self.model(self.sensor_data)\n        self.pub.send(output.item(), ctx)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:183:rust",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 183,
      "lineEnd": 195,
      "language": "rust",
      "code": "// Rust catches bugs at compile time\nimpl Node for SafetyMonitor {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Compiler ensures we handle all cases\n        match self.check_safety() {\n            SafetyStatus::OK => self.continue_operation(),\n            SafetyStatus::Warning(msg) => self.log_warning(&msg),\n            SafetyStatus::Critical(msg) => self.emergency_stop(&msg),\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:199:rust",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 199,
      "lineEnd": 209,
      "language": "rust",
      "code": "// Rust can sustain 10kHz+ control loops\nimpl Node for MotorController {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Microsecond-level timing is reliable\n        let error = self.target - self.position;\n        let output = self.pid.compute(error);\n        self.motor.send(output, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:213:rust",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 213,
      "lineEnd": 216,
      "language": "rust",
      "code": "// Rust has minimal runtime overhead\n// Perfect for embedded systems and single-board computers",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/choosing-language:226:text",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 226,
      "lineEnd": 232,
      "language": "text",
      "code": "┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│  Python Node    │     │   Rust Node     │     │   Rust Node     │\n│  (ML Inference) │────>│  (Controller)   │────>│  (Motor Driver) │\n│  10 Hz          │     │  100 Hz         │     │  1000 Hz        │\n└─────────────────┘     └─────────────────┘     └─────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:235:python",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 235,
      "lineEnd": 240,
      "language": "python",
      "code": "class ObjectDetector(Node):\n    def tick(self, ctx):\n        detections = self.model.detect(self.camera_image)\n        self.pub.send(detections, ctx)  # Publishes to \"detections\"",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/choosing-language:243:rust",
      "file": "content/docs/getting-started/choosing-language.mdx",
      "lineStart": 243,
      "lineEnd": 252,
      "language": "rust",
      "code": "impl Node for NavigationController {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(detections) = self.detection_sub.recv(&mut ctx) {\n            // React to Python node's output\n            self.plan_path(&detections);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/common-mistakes:16:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 16,
      "lineEnd": 19,
      "language": "rust",
      "code": "// WRONG - This will fail!\nlet hub: Hub<f32> = Hub::new(\"sensors/lidar\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:26:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 26,
      "lineEnd": 29,
      "language": "rust",
      "code": "// CORRECT - Use dots instead\nlet hub: Hub<f32> = Hub::new(\"sensors.lidar\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:36:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 36,
      "lineEnd": 46,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Only check for messages sometimes\n    if self.counter % 10 == 0 {\n        if let Some(data) = self.sensor_sub.recv(&mut ctx) {\n            self.process(data);\n        }\n    }\n    self.counter += 1;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:51:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 51,
      "lineEnd": 66,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // ALWAYS check for new messages\n    if let Some(data) = self.sensor_sub.recv(&mut ctx) {\n        self.last_data = Some(data);\n    }\n\n    // Use cached data for processing\n    if self.counter % 10 == 0 {\n        if let Some(ref data) = self.last_data {\n            self.process(data);\n        }\n    }\n    self.counter += 1;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:73:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 73,
      "lineEnd": 79,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // WRONG - This blocks the entire scheduler!\n    let data = std::fs::read_to_string(\"large_file.txt\").unwrap();\n    std::thread::sleep(Duration::from_millis(100));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:84:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 84,
      "lineEnd": 95,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    // Do slow initialization in init(), not tick()\n    self.data = std::fs::read_to_string(\"large_file.txt\")?;\n    Ok(())\n}\n\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Keep tick() fast - ideally under 1ms\n    self.process(&self.data);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:102:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 102,
      "lineEnd": 107,
      "language": "rust",
      "code": "// WRONG - Logger runs before sensor!\nscheduler.add(Box::new(logger), 0, Some(true));      // Priority 0 (highest)\nscheduler.add(Box::new(sensor), 10, Some(true));     // Priority 10\nscheduler.add(Box::new(controller), 5, Some(true));  // Priority 5",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:112:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 112,
      "lineEnd": 118,
      "language": "rust",
      "code": "// CORRECT - Proper priority ordering\nscheduler.add(Box::new(safety_monitor), 0, Some(true));  // Safety first!\nscheduler.add(Box::new(sensor), 5, Some(true));          // Then sensors\nscheduler.add(Box::new(controller), 10, Some(true));     // Then control\nscheduler.add(Box::new(logger), 100, Some(true));        // Logging last",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:125:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 125,
      "lineEnd": 135,
      "language": "rust",
      "code": "impl Node for MotorController {\n    fn name(&self) -> &'static str { \"motor\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.motor.set_velocity(self.velocity);\n    }\n\n    // No shutdown() implemented!\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/common-mistakes:140:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 140,
      "lineEnd": 155,
      "language": "rust",
      "code": "impl Node for MotorController {\n    fn name(&self) -> &'static str { \"motor\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.motor.set_velocity(self.velocity);\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // CRITICAL: Stop motor on shutdown!\n        ctx.log_info(\"Stopping motor for safe shutdown\");\n        self.motor.set_velocity(0.0);\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/common-mistakes:162:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 162,
      "lineEnd": 168,
      "language": "rust",
      "code": "#[derive(Clone, Debug)]\nstruct MyMessage {\n    name: String,        // WRONG - heap allocated\n    data: Vec<f32>,      // WRONG - heap allocated\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:173:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 173,
      "lineEnd": 179,
      "language": "rust",
      "code": "#[derive(Clone, Copy, Debug)]\nstruct MyMessage {\n    name: [u8; 32],      // CORRECT - fixed size\n    data: [f32; 10],     // CORRECT - fixed size\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:182:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 182,
      "lineEnd": 188,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// These are already designed for shared memory\nlet hub: Hub<CmdVel> = Hub::new(\"cmd_vel\")?;\nlet hub: Hub<Odometry> = Hub::new(\"odom\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:195:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 195,
      "lineEnd": 200,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // WRONG - Ignoring the Result\n    self.pub.send(data, &mut ctx);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:205:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 205,
      "lineEnd": 217,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Log if send fails\n    if let Err(data) = self.pub.send(data, &mut ctx) {\n        if let Some(ref mut c) = ctx {\n            c.log_warning(\"Failed to publish data\");\n        }\n    }\n}\n\n// Or simply use .ok() if you intentionally want to ignore errors\nself.pub.send(data, &mut ctx).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:224:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 224,
      "lineEnd": 230,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // WRONG - Creates new Hub every tick!\n    let hub: Hub<f32> = Hub::new(\"data\").unwrap();\n    hub.send(42.0, &mut ctx).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:235:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 235,
      "lineEnd": 251,
      "language": "rust",
      "code": "struct MyNode {\n    hub: Hub<f32>,  // Store Hub in struct\n}\n\nimpl MyNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            hub: Hub::new(\"data\")?,  // Create once\n        })\n    }\n}\n\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    self.hub.send(42.0, &mut ctx).ok();  // Reuse existing Hub\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:258:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 258,
      "lineEnd": 266,
      "language": "rust",
      "code": "// Publisher sends f32\nlet pub_hub: Hub<f32> = Hub::new(\"data\")?;\npub_hub.send(42.0, &mut ctx).ok();\n\n// Subscriber expects i32\nlet sub_hub: Hub<i32> = Hub::new(\"data\")?;  // WRONG TYPE!\nlet value = sub_hub.recv(&mut ctx);  // Will get garbage data",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:271:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 271,
      "lineEnd": 275,
      "language": "rust",
      "code": "// Use the SAME type for publisher and subscriber\nlet pub_hub: Hub<f32> = Hub::new(\"data\")?;\nlet sub_hub: Hub<f32> = Hub::new(\"data\")?;  // Same type!",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:278:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 278,
      "lineEnd": 282,
      "language": "rust",
      "code": "type SensorReading = f32;\nlet pub_hub: Hub<SensorReading> = Hub::new(\"sensor\")?;\nlet sub_hub: Hub<SensorReading> = Hub::new(\"sensor\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/common-mistakes:289:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 289,
      "lineEnd": 311,
      "language": "rust",
      "code": "// Manual implementation - lots of boilerplate\nstruct MySensor {\n    pub_hub: Hub<f32>,\n}\n\nimpl MySensor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            pub_hub: Hub::new(\"sensor.data\")?,\n        })\n    }\n}\n\nimpl Node for MySensor {\n    fn name(&self) -> &'static str { \"MySensor\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let data = self.read_sensor();\n        self.pub_hub.send(data, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/common-mistakes:314:rust",
      "file": "content/docs/getting-started/common-mistakes.mdx",
      "lineStart": 314,
      "lineEnd": 325,
      "language": "rust",
      "code": "// Use node! macro - 75% less code!\nnode! {\n    name: MySensor,\n    publishers: [sensor_data: f32 -> \"sensor.data\"],\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let data = self.read_sensor();\n        self.sensor_data.send(data, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:54:python",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 54,
      "lineEnd": 60,
      "language": "python",
      "code": "# Component 1: Publish sensor data\nnode.send(\"distance\", 1.5)\n\n# Component 2: Receive the data\ndistance = node.get(\"distance\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:74:bash",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 74,
      "lineEnd": 76,
      "language": "bash",
      "code": "horus --version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:90:bash",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 90,
      "lineEnd": 93,
      "language": "bash",
      "code": "horus new my_first_robot --python\ncd my_first_robot",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:101:python",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 101,
      "lineEnd": 120,
      "language": "python",
      "code": "import horus\n\n# Counter to track messages\ncount = 0\n\n# This function runs repeatedly\ndef tick(node):\n    global count\n    count += 1\n    print(f\"Hello from robot! Count: {count}\")\n\n    # Stop after 5 messages\n    if count >= 5:\n        node.request_stop()\n\n# Create and run the node\nnode = horus.Node(name=\"HelloRobot\", tick=tick, rate=1)  # 1 Hz\nhorus.run(node, duration=5)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:134:bash",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 134,
      "lineEnd": 136,
      "language": "bash",
      "code": "horus run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:139:text",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 139,
      "lineEnd": 145,
      "language": "text",
      "code": "Hello from robot! Count: 1\nHello from robot! Count: 2\nHello from robot! Count: 3\nHello from robot! Count: 4\nHello from robot! Count: 5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:153:python",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 153,
      "lineEnd": 194,
      "language": "python",
      "code": "import horus\nimport random\n\n# Node 1: Simulates a distance sensor\ndef sensor_tick(node):\n    # Simulate reading a sensor (random distance 0.5-10 meters)\n    distance = random.uniform(0.5, 10.0)\n\n    # Publish the distance\n    node.send(\"distance\", distance)\n    print(f\"Sensor: Distance {distance:.2f}m\")\n\n# Node 2: Controls motors based on sensor data\ndef motor_tick(node):\n    # Subscribe to distance data\n    distance = node.get(\"distance\")\n\n    if distance is not None:\n        if distance < 1.0:\n            print(f\"  Motor: Stopping (obstacle at {distance:.2f}m)\")\n        else:\n            print(f\"  Motor: Moving forward (clear at {distance:.2f}m)\")\n\n# Create nodes\nsensor = horus.Node(\n    name=\"DistanceSensor\",\n    pubs=[\"distance\"],\n    tick=sensor_tick,\n    rate=2\n)\n\nmotor = horus.Node(\n    name=\"MotorController\",\n    subs=[\"distance\"],\n    tick=motor_tick,\n    rate=2\n)\n\n# Run both nodes for 5 seconds\nhorus.run(sensor, motor, duration=5)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:198:bash",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 198,
      "lineEnd": 200,
      "language": "bash",
      "code": "horus run robot_with_sensor.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:203:text",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 203,
      "lineEnd": 210,
      "language": "text",
      "code": "Sensor: Distance 7.23m\n  Motor: Moving forward (clear at 7.23m)\nSensor: Distance 0.84m\n  Motor: Stopping (obstacle at 0.84m)\nSensor: Distance 5.67m\n  Motor: Moving forward (clear at 5.67m)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:229:bash",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 229,
      "lineEnd": 231,
      "language": "bash",
      "code": "horus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:258:python",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 258,
      "lineEnd": 286,
      "language": "python",
      "code": "import horus\nimport RPi.GPIO as GPIO\n\n# Setup GPIO\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(17, GPIO.OUT)  # Left motor\nGPIO.setup(18, GPIO.OUT)  # Right motor\n\ndef motor_tick(node):\n    velocity = node.get(\"cmd_vel\")\n    if velocity:\n        linear, angular = velocity\n        # Convert to motor commands\n        left_speed = linear - angular\n        right_speed = linear + angular\n        # Drive motors\n        GPIO.output(17, left_speed > 0)\n        GPIO.output(18, right_speed > 0)\n\nmotor = horus.Node(\n    name=\"MotorController\",\n    subs=[\"cmd_vel\"],\n    tick=motor_tick,\n    rate=50  # 50 Hz control loop\n)\n\nhorus.run(motor)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:292:python",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 292,
      "lineEnd": 301,
      "language": "python",
      "code": "from horus.nodes import (\n    CameraNode,      # USB/MIPI cameras\n    LidarNode,       # LiDAR sensors\n    ImuNode,         # Inertial measurement units\n    GpsNode,         # GPS receivers\n    JoystickNode,    # Game controller input\n    SerialNode,      # Serial communication\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/complete-beginners-guide:318:python",
      "file": "content/docs/getting-started/complete-beginners-guide.mdx",
      "lineStart": 318,
      "lineEnd": 384,
      "language": "python",
      "code": "import horus\n\n# Node 1: Read line sensors\ndef sensor_tick(node):\n    # Replace with actual GPIO reads\n    left_sees_line = read_left_sensor()\n    right_sees_line = read_right_sensor()\n\n    node.send(\"sensor.left\", left_sees_line)\n    node.send(\"sensor.right\", right_sees_line)\n\n# Node 2: Line following logic\ndef follower_tick(node):\n    left = node.get(\"sensor.left\")\n    right = node.get(\"sensor.right\")\n\n    if left is None or right is None:\n        return\n\n    if left and right:\n        # Both sensors on line - go straight\n        node.send(\"cmd_vel\", (1.0, 0.0))\n    elif left:\n        # Left sensor on line - turn left\n        node.send(\"cmd_vel\", (0.5, -0.3))\n    elif right:\n        # Right sensor on line - turn right\n        node.send(\"cmd_vel\", (0.5, 0.3))\n    else:\n        # Lost the line - search\n        node.send(\"cmd_vel\", (0.0, 0.5))\n\n# Node 3: Motor driver\ndef motor_tick(node):\n    cmd = node.get(\"cmd_vel\")\n    if cmd:\n        linear, angular = cmd\n        left_speed = linear - angular\n        right_speed = linear + angular\n        drive_motors(left_speed, right_speed)\n\n# Create and run nodes\nsensor = horus.Node(\n    name=\"LineSensor\",\n    pubs=[\"sensor.left\", \"sensor.right\"],\n    tick=sensor_tick,\n    rate=30\n)\n\nfollower = horus.Node(\n    name=\"LineFollower\",\n    subs=[\"sensor.left\", \"sensor.right\"],\n    pubs=[\"cmd_vel\"],\n    tick=follower_tick,\n    rate=30\n)\n\nmotor = horus.Node(\n    name=\"MotorDriver\",\n    subs=[\"cmd_vel\"],\n    tick=motor_tick,\n    rate=30\n)\n\nhorus.run(sensor, follower, motor)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:78:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 78,
      "lineEnd": 95,
      "language": "bash",
      "code": "# 1. Install Rust (takes ~2 minutes)\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource $HOME/.cargo/env\n\n# 2. Clone HORUS\ngit clone https://github.com/softmata/horus.git\ncd horus\n\n# 3. Run automated installer (takes ~5 minutes)\n./install.sh\n\n# 4. Verify it works\nhorus --help\n\n# 5. Run full verification (optional but recommended)\n./verify.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:117:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 117,
      "lineEnd": 119,
      "language": "bash",
      "code": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:124:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 124,
      "lineEnd": 126,
      "language": "bash",
      "code": "source $HOME/.cargo/env",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:129:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 129,
      "lineEnd": 132,
      "language": "bash",
      "code": "rustc --version\ncargo --version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:139:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 139,
      "lineEnd": 141,
      "language": "bash",
      "code": "git --version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:144:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 144,
      "lineEnd": 153,
      "language": "bash",
      "code": "# Ubuntu/Debian\nsudo apt install git\n\n# Fedora\nsudo dnf install git\n\n# Arch Linux\nsudo pacman -S git",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:159:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 159,
      "lineEnd": 162,
      "language": "bash",
      "code": "git clone https://github.com/softmata/horus.git\ncd horus",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:170:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 170,
      "lineEnd": 172,
      "language": "bash",
      "code": "./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:187:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 187,
      "lineEnd": 189,
      "language": "bash",
      "code": "horus --help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:197:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 197,
      "lineEnd": 199,
      "language": "bash",
      "code": "./verify.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:215:text",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 215,
      "lineEnd": 238,
      "language": "text",
      "code": "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n   HORUS Installation Verification\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nSystem Requirements:\n   Rust: 1.75.0 (>= 1.70 required)\n   Cargo: 1.75.0\n   C compiler: gcc\n\nHORUS Installation:\n   Binary: v0.3.0 at ~/.cargo/bin/horus\n   In PATH: Yes (correct binary)\n\nFunctionality Tests:\n   Command: --help\n   All subcommands: Accessible\n   Build: cargo check passes (0 warnings)\n   Binary: Debug build functional\n\nSummary:\n   All checks passed.\n   HORUS is properly installed and ready to use.",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:255:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 255,
      "lineEnd": 257,
      "language": "bash",
      "code": "python3 -c \"import horus; print('Python bindings installed successfully')\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:260:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 260,
      "lineEnd": 273,
      "language": "bash",
      "code": "# 1. Install maturin (Python build tool)\n# Option A: Via Cargo (recommended for Ubuntu 24.04+)\ncargo install maturin\n\n# Option B: Via pip (if not blocked by PEP 668)\n# pip install maturin\n\n# 2. Navigate to Python bindings\ncd horus_py\n\n# 3. Build and install (takes ~3 minutes)\nmaturin develop --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:283:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 283,
      "lineEnd": 291,
      "language": "bash",
      "code": "sudo apt update\nsudo apt install -y build-essential pkg-config \\\n  libssl-dev libudev-dev libasound2-dev \\\n  libx11-dev libxrandr-dev libxi-dev libxcursor-dev libxinerama-dev \\\n  libwayland-dev wayland-protocols libxkbcommon-dev \\\n  libvulkan-dev libfontconfig-dev libfreetype-dev \\\n  libv4l-dev",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:295:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 295,
      "lineEnd": 302,
      "language": "bash",
      "code": "sudo dnf groupinstall \"Development Tools\"\nsudo dnf install -y pkg-config openssl-devel systemd-devel alsa-lib-devel \\\n  libX11-devel libXrandr-devel libXi-devel libXcursor-devel libXinerama-devel \\\n  wayland-devel wayland-protocols-devel libxkbcommon-devel \\\n  vulkan-devel fontconfig-devel freetype-devel \\\n  libv4l-devel",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:308:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 308,
      "lineEnd": 325,
      "language": "bash",
      "code": "# Install all dependencies\nsudo apt update\nsudo apt install -y build-essential pkg-config \\\n  libssl-dev libudev-dev libasound2-dev \\\n  libx11-dev libxrandr-dev libxi-dev libxcursor-dev libxinerama-dev \\\n  libwayland-dev wayland-protocols libxkbcommon-dev \\\n  libvulkan-dev libfontconfig-dev libfreetype-dev \\\n  libv4l-dev\n\n# Raspberry Pi specific packages (GPIO, I2C, SPI support)\nsudo apt install -y libraspberrypi-dev i2c-tools python3-smbus\n\n# Enable I2C and SPI (required for sensors)\nsudo raspi-config\n# Navigate to: Interface Options → I2C → Enable\n# Navigate to: Interface Options → SPI → Enable",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:336:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 336,
      "lineEnd": 351,
      "language": "bash",
      "code": "# Install all dependencies\nsudo apt update\nsudo apt install -y build-essential pkg-config \\\n  libssl-dev libudev-dev libasound2-dev \\\n  libx11-dev libxrandr-dev libxi-dev libxcursor-dev libxinerama-dev \\\n  libwayland-dev wayland-protocols libxkbcommon-dev \\\n  libvulkan-dev libfontconfig-dev libfreetype-dev \\\n  libv4l-dev\n\n# Jetson specific packages (GPU acceleration)\nsudo apt install -y nvidia-jetpack\n\n# Verify CUDA is installed\nnvcc --version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:389:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 389,
      "lineEnd": 397,
      "language": "bash",
      "code": "sudo apt install -y libraspberrypi-dev i2c-tools python3-smbus\n\n# Enable hardware interfaces\nsudo raspi-config\n# Navigate to: Interface Options → I2C → Enable\n# Navigate to: Interface Options → SPI → Enable\n# Navigate to: Interface Options → Serial Port → Enable",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:400:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 400,
      "lineEnd": 411,
      "language": "bash",
      "code": "sudo apt install -y can-utils\n\n# Setup virtual CAN for testing\nsudo modprobe vcan\nsudo ip link add dev vcan0 type vcan\nsudo ip link set up vcan0\n\n# Test CAN tools\ncansend vcan0 123#DEADBEEF\ncandump vcan0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:414:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 414,
      "lineEnd": 424,
      "language": "bash",
      "code": "# Add Intel RealSense repository\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE\nsudo add-apt-repository \"deb https://librealsense.intel.com/Debian/apt-repo $(lsb_release -cs) main\" -u\n\n# Install RealSense SDK\nsudo apt install -y librealsense2-dev librealsense2-utils\n\n# Test camera\nrealsense-viewer",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:429:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 429,
      "lineEnd": 437,
      "language": "bash",
      "code": "# 1. Install HORUS normally (no hardware packages needed)\n./install.sh\n\n# 2. Create and run your project\nhorus new my_robot\ncd my_robot\nhorus run   # Runs in simulation mode",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:440:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 440,
      "lineEnd": 446,
      "language": "bash",
      "code": "# 1. Install system packages on the robot\nsudo apt install libraspberrypi-dev i2c-tools can-utils\n\n# 2. Enable hardware features and run\nhorus run --enable gpio,i2c --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:449:yaml",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 449,
      "lineEnd": 453,
      "language": "yaml",
      "code": "enable:\n  - gpio\n  - i2c",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:456:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 456,
      "lineEnd": 458,
      "language": "bash",
      "code": "horus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:461:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 461,
      "lineEnd": 463,
      "language": "bash",
      "code": "cargo build --release --features=\"gpio-hardware,i2c-hardware\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:507:powershell",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 507,
      "lineEnd": 520,
      "language": "powershell",
      "code": "# 1. Install Rust (using rustup-init.exe from rustup.rs)\n# Download and run: https://win.rustup.rs/x86_64\n\n# 2. Clone HORUS (in PowerShell or Git Bash)\ngit clone https://github.com/softmata/horus.git\ncd horus\n\n# 3. Run the install script (Git Bash or WSL recommended)\n./install.sh\n\n# 4. Verify installation\nhorus --help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:539:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 539,
      "lineEnd": 554,
      "language": "bash",
      "code": "# 1. Install Rust\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource $HOME/.cargo/env\n\n# 2. Install Xcode Command Line Tools (if not already installed)\nxcode-select --install\n\n# 3. Clone and build HORUS\ngit clone https://github.com/softmata/horus.git\ncd horus\n./install.sh\n\n# 4. Verify installation\nhorus --help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:577:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 577,
      "lineEnd": 586,
      "language": "bash",
      "code": "# Linux\ndf -h /dev/shm\n\n# macOS\ndf -h /tmp\n\n# Windows (PowerShell)\nGet-PSDrive -Name $env:TEMP.Substring(0,1)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:591:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 591,
      "lineEnd": 597,
      "language": "bash",
      "code": "# Temporarily increase to 2GB\nsudo mount -o remount,size=2G /dev/shm\n\n# Make permanent: edit /etc/fstab (requires sudo)\n# Add line: tmpfs /dev/shm tmpfs defaults,size=2G 0 0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:603:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 603,
      "lineEnd": 610,
      "language": "bash",
      "code": "# Navigate to HORUS directory\ncd horus\n\n# Pull latest changes and reinstall\ngit pull\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:613:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 613,
      "lineEnd": 618,
      "language": "bash",
      "code": "git fetch\ngit log HEAD..@{u}  # See what's new\ngit pull\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:624:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 624,
      "lineEnd": 630,
      "language": "bash",
      "code": "# Navigate to HORUS directory\ncd horus\n\n# Run the uninstaller\n./uninstall.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:642:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 642,
      "lineEnd": 657,
      "language": "bash",
      "code": "# Remove CLI tool\ncargo uninstall horus\n\n# Remove global cache and config\nrm -rf ~/.horus/\n\n# Remove source code\nrm -rf ~/horus/  # or wherever you cloned it\n\n# Clean up shared memory (optional - HORUS auto-cleans sessions)\n# Linux:\nrm -rf /dev/shm/horus/\n# macOS:\nrm -rf /tmp/horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:660:powershell",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 660,
      "lineEnd": 672,
      "language": "powershell",
      "code": "# Remove CLI tool\ncargo uninstall horus\n\n# Remove global cache and config\nRemove-Item -Recurse -Force \"$env:USERPROFILE\\.horus\"\n\n# Remove source code\nRemove-Item -Recurse -Force \"$env:USERPROFILE\\horus\"  # or wherever you cloned it\n\n# Clean up shared memory (optional - HORUS auto-cleans sessions)\nRemove-Item -Recurse -Force \"$env:TEMP\\horus\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/installation:678:bash",
      "file": "content/docs/getting-started/installation.mdx",
      "lineStart": 678,
      "lineEnd": 689,
      "language": "bash",
      "code": "# Navigate to HORUS source directory\ncd /path/to/horus\n\n# Clean and reinstall\ncargo clean\nrm -rf ~/.horus/cache\n./install.sh\n\n# Verify installation\n./verify.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:21:bash",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 21,
      "lineEnd": 30,
      "language": "bash",
      "code": "# Create a new HORUS project\nhorus new temperature-monitor\n\n# Select options in the interactive prompt:\n# Language: Rust (option 2)\n# Use macros: No (we'll learn the basics first)\n\ncd temperature-monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:43:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 43,
      "lineEnd": 141,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::time::Duration;\n\n//===========================================\n// SENSOR NODE - Generates temperature data\n//===========================================\n\nstruct TemperatureSensor {\n    publisher: Hub<f32>,\n    temperature: f32,\n}\n\nimpl TemperatureSensor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            publisher: Hub::new(\"temperature\")?,\n            temperature: 20.0,\n        })\n    }\n}\n\nimpl Node for TemperatureSensor {\n    fn name(&self) -> &'static str {\n        \"TemperatureSensor\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Simulate temperature change\n        self.temperature += 0.1;\n\n        // Send the reading\n        self.publisher.send(self.temperature, &mut ctx).ok();\n\n        // Wait 1 second before next reading\n        std::thread::sleep(Duration::from_secs(1));\n    }\n}\n\n//============================================\n// MONITOR NODE - Displays temperature data\n//============================================\n\nstruct TemperatureMonitor {\n    subscriber: Hub<f32>,\n}\n\nimpl TemperatureMonitor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            subscriber: Hub::new(\"temperature\")?,\n        })\n    }\n}\n\nimpl Node for TemperatureMonitor {\n    fn name(&self) -> &'static str {\n        \"TemperatureMonitor\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check for new temperature readings\n        if let Some(temp) = self.subscriber.recv(&mut ctx) {\n            println!(\"Temperature: {:.1}°C\", temp);\n        }\n    }\n}\n\n//============================================\n// MAIN - Run both nodes\n//============================================\n\nfn main() -> Result<()> {\n    eprintln!(\"Starting temperature monitoring system...\\n\");\n\n    // Create the scheduler\n    let mut scheduler = Scheduler::new();\n\n    // Add both nodes\n    // Priority 0 = sensor runs first\n    // Priority 1 = monitor runs second\n    // Logging enabled (Some(true)) to see message flow\n    scheduler.add(\n        Box::new(TemperatureSensor::new()?),\n        0,\n        Some(true)\n    );\n    scheduler.add(\n        Box::new(TemperatureMonitor::new()?),\n        1,\n        Some(true)\n    );\n\n    // Run forever (press Ctrl+C to stop)\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/getting-started/quick-start:145:bash",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 145,
      "lineEnd": 147,
      "language": "bash",
      "code": "horus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:157:text",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 157,
      "lineEnd": 165,
      "language": "text",
      "code": "Starting temperature monitoring system...\n\nTemperature: 20.1°C\nTemperature: 20.2°C\nTemperature: 20.3°C\nTemperature: 20.4°C\n...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/getting-started/quick-start:173:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 173,
      "lineEnd": 179,
      "language": "rust",
      "code": "// Create a publisher (sends data)\npublisher: Hub::new(\"temperature\")?\n\n// Create a subscriber (receives data)\nsubscriber: Hub::new(\"temperature\")?",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/quick-start:187:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 187,
      "lineEnd": 199,
      "language": "rust",
      "code": "impl Node for TemperatureSensor {\n    // Give your node a name\n    fn name(&self) -> &'static str {\n        \"TemperatureSensor\"\n    }\n\n    // This runs repeatedly\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Your logic here\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:205:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 205,
      "lineEnd": 216,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\n\n// Priority 0 = highest (runs first)\nscheduler.add(Box::new(SensorNode::new()?), 0, Some(true));\n\n// Priority 1 = lower (runs after priority 0)\nscheduler.add(Box::new(MonitorNode::new()?), 1, Some(true));\n\n// Run forever\nscheduler.run()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/getting-started/quick-start:226:bash",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 226,
      "lineEnd": 232,
      "language": "bash",
      "code": "# Terminal 1: Run sensor\nhorus run sensor.rs\n\n# Terminal 2: Run monitor (automatically connects!)\nhorus run monitor.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:240:bash",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 240,
      "lineEnd": 242,
      "language": "bash",
      "code": "horus run \"*.rs\"  # All Rust files run as separate processes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:253:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 253,
      "lineEnd": 268,
      "language": "rust",
      "code": "impl Node for TemperatureMonitor {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(temp) = self.subscriber.recv(&mut ctx) {\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\"Temperature: {:.1}°C\", temp));\n\n                // Alert if temperature exceeds threshold\n                if temp > 25.0 {\n                    c.log_warning(\"Temperature too high!\");\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:271:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 271,
      "lineEnd": 275,
      "language": "rust",
      "code": "// In main():\nscheduler.add(Box::new(HumiditySensor::new()?), 0, Some(true));\nscheduler.add(Box::new(HumidityMonitor::new()?), 1, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/quick-start:278:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 278,
      "lineEnd": 300,
      "language": "rust",
      "code": "use std::fs::OpenOptions;\nuse std::io::Write;\n\nimpl Node for TemperatureMonitor {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(temp) = self.subscriber.recv(&mut ctx) {\n            // Display\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\"Temperature: {:.1}°C\", temp));\n            }\n\n            // Save to file\n            let mut file = OpenOptions::new()\n                .create(true)\n                .append(true)\n                .open(\"temperature.log\")\n                .unwrap();\n            writeln!(file, \"{:.1}\", temp).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:351:bash",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 351,
      "lineEnd": 353,
      "language": "bash",
      "code": "ls -lh /dev/shm/horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:361:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 361,
      "lineEnd": 363,
      "language": "rust",
      "code": "Hub::new(\"temperature_sensor_1\")?",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/quick-start:369:bash",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 369,
      "lineEnd": 374,
      "language": "bash",
      "code": "# Linux\nrm -f /dev/shm/horus/topic_temperature\n# macOS\nrm -f /tmp/horus/topic_temperature",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/quick-start:382:rust",
      "file": "content/docs/getting-started/quick-start.mdx",
      "lineStart": 382,
      "lineEnd": 385,
      "language": "rust",
      "code": "scheduler.add(Box::new(Sensor::new()?), 0, Some(true));\nscheduler.add(Box::new(Monitor::new()?), 1, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:27:text",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 27,
      "lineEnd": 36,
      "language": "text",
      "code": "SensorNode          FilterNode          DisplayNode\n    |                   |                    |\n    | --raw_temp-->     |                    |\n    |                   | --filtered_temp--> |\n    |                   |                    |\n    v                   v                    v\n   Publish           Process              Display\n   25.3°C          Remove noise          \"Temp: 25.0°C\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/second-application:40:bash",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 40,
      "lineEnd": 43,
      "language": "bash",
      "code": "horus new temperature_pipeline\ncd temperature_pipeline",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/second-application:49:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 49,
      "lineEnd": 257,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::time::{Duration, Instant};\n\n// ============================================================================\n// Node 1: SensorNode - Publishes temperature readings\n// ============================================================================\n\nstruct SensorNode {\n    temp_pub: Hub<f32>,\n    last_publish: Instant,\n    reading: f32,\n}\n\nimpl SensorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            temp_pub: Hub::new(\"raw_temp\")?,\n            last_publish: Instant::now(),\n            reading: 20.0,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str {\n        \"SensorNode\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Temperature sensor initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Publish every 1 second\n        if self.last_publish.elapsed() >= Duration::from_secs(1) {\n            // Simulate realistic temperature with noise\n            // Base temperature oscillates between 20-30°C\n            let base_temp = 25.0 + (self.reading * 0.1).sin() * 5.0;\n\n            // Add random noise (+/- 2°C)\n            let noise = (self.reading * 0.7).sin() * 2.0;\n            let temperature = base_temp + noise;\n\n            // Publish raw temperature\n            self.temp_pub.send(temperature, &mut ctx).ok();\n\n            ctx.log_info(&format!(\"Published raw temp: {:.2}°C\", temperature));\n\n            self.reading += 1.0;\n            self.last_publish = Instant::now();\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor shutdown complete\");\n        Ok(())\n    }\n}\n\n// ============================================================================\n// Node 2: FilterNode - Removes noise with exponential moving average\n// ============================================================================\n\nstruct FilterNode {\n    raw_sub: Hub<f32>,\n    filtered_pub: Hub<f32>,\n    filtered_value: Option<f32>,\n    alpha: f32,  // Smoothing factor (0.0 - 1.0)\n}\n\nimpl FilterNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            raw_sub: Hub::new(\"raw_temp\")?,\n            filtered_pub: Hub::new(\"filtered_temp\")?,\n            filtered_value: None,\n            alpha: 0.3,  // 30% new data, 70% previous (smooth but responsive)\n        })\n    }\n}\n\nimpl Node for FilterNode {\n    fn name(&self) -> &'static str {\n        \"FilterNode\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(&format!(\"Filter initialized (alpha = {:.2})\", self.alpha));\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check for new temperature reading\n        if let Some(raw_temp) = self.raw_sub.recv(&mut ctx) {\n            // Apply exponential moving average filter\n            let filtered = match self.filtered_value {\n                Some(prev) => self.alpha * raw_temp + (1.0 - self.alpha) * prev,\n                None => raw_temp,  // First reading, no previous value\n            };\n\n            self.filtered_value = Some(filtered);\n\n            // Publish filtered temperature\n            self.filtered_pub.send(filtered, &mut ctx).ok();\n\n            ctx.log_info(&format!(\n                    \"Filtered: {:.2}°C -> {:.2}°C (removed {:.2}°C noise)\",\n                    raw_temp, filtered, raw_temp - filtered\n                ));\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Filter shutdown complete\");\n        Ok(())\n    }\n}\n\n// ============================================================================\n// Node 3: DisplayNode - Shows filtered temperature on console\n// ============================================================================\n\nstruct DisplayNode {\n    filtered_sub: Hub<f32>,\n    display_counter: u32,\n}\n\nimpl DisplayNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            filtered_sub: Hub::new(\"filtered_temp\")?,\n            display_counter: 0,\n        })\n    }\n}\n\nimpl Node for DisplayNode {\n    fn name(&self) -> &'static str {\n        \"DisplayNode\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Display initialized\");\n        println!(\"\\n========================================\");\n        println!(\"  Temperature Monitor - Press Ctrl+C to stop\");\n        println!(\"========================================\\n\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(temp) = self.filtered_sub.recv(&mut ctx) {\n            self.display_counter += 1;\n\n            // Display temperature with visual indicator\n            let status = if temp < 22.0 {\n                \"COLD\"\n            } else if temp > 28.0 {\n                \"HOT\"\n            } else {\n                \"NORMAL\"\n            };\n\n            println!(\n                \"[Reading #{}] Temperature: {:.1}°C - Status: {}\",\n                self.display_counter, temp, status\n            );\n\n            ctx.log_debug(&format!(\"Displayed reading #{}\", self.display_counter));\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        println!(\"\\n========================================\");\n        println!(\"  Total readings displayed: {}\", self.display_counter);\n        println!(\"========================================\\n\");\n        ctx.log_info(\"Display shutdown complete\");\n        Ok(())\n    }\n}\n\n// ============================================================================\n// Main Application - Configure and run the scheduler\n// ============================================================================\n\nfn main() -> Result<()> {\n    println!(\"Starting Temperature Pipeline...\\n\");\n\n    let mut scheduler = Scheduler::new();\n\n    // Add nodes in priority order:\n    // 1. SensorNode (Priority 0 - Highest) - Runs first to generate data\n    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));\n\n    // 2. FilterNode (Priority 1 - High) - Runs second to process data\n    scheduler.add(Box::new(FilterNode::new()?), 1, Some(true));\n\n    // 3. DisplayNode (Priority 2 - Normal) - Runs last to display results\n    scheduler.add(Box::new(DisplayNode::new()?), 2, Some(true));\n\n    println!(\"All nodes initialized. Running...\\n\");\n\n    // Run the scheduler (blocks until Ctrl+C)\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:261:bash",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 261,
      "lineEnd": 263,
      "language": "bash",
      "code": "horus run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/second-application:267:text",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 267,
      "lineEnd": 283,
      "language": "text",
      "code": "Starting Temperature Pipeline...\n\nAll nodes initialized. Running...\n\n========================================\n  Temperature Monitor - Press Ctrl+C to stop\n========================================\n\n[Reading #1] Temperature: 23.4°C - Status: NORMAL\n[Reading #2] Temperature: 24.1°C - Status: NORMAL\n[Reading #3] Temperature: 25.8°C - Status: NORMAL\n[Reading #4] Temperature: 27.2°C - Status: NORMAL\n[Reading #5] Temperature: 28.6°C - Status: HOT\n[Reading #6] Temperature: 27.9°C - Status: NORMAL\n[Reading #7] Temperature: 26.3°C - Status: NORMAL",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:287:text",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 287,
      "lineEnd": 294,
      "language": "text",
      "code": "^C\nCtrl+C received! Shutting down HORUS scheduler...\n\n========================================\n  Total readings displayed: 7\n========================================",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:300:bash",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 300,
      "lineEnd": 302,
      "language": "bash",
      "code": "horus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/second-application:324:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 324,
      "lineEnd": 330,
      "language": "rust",
      "code": "// Publish every 1 second\nif self.last_publish.elapsed() >= Duration::from_secs(1) {\n    let temperature = 25.0 + noise;\n    self.temp_pub.send(temperature, &mut ctx).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:339:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 339,
      "lineEnd": 343,
      "language": "rust",
      "code": "// Exponential moving average filter\nlet filtered = self.alpha * raw_temp + (1.0 - self.alpha) * prev;\nself.filtered_pub.send(filtered, &mut ctx).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:356:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 356,
      "lineEnd": 360,
      "language": "rust",
      "code": "if let Some(temp) = self.filtered_sub.recv(&mut ctx) {\n    println!(\"[Reading #{}] Temperature: {:.1}°C\", count, temp);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:372:text",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 372,
      "lineEnd": 381,
      "language": "text",
      "code": "Starting Temperature Pipeline...\nAll nodes initialized. Running...\n\n========================================\n  Temperature Monitor - Press Ctrl+C to stop\n========================================\n\n[Nothing appears]",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:396:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 396,
      "lineEnd": 402,
      "language": "rust",
      "code": "alpha: 0.3,  // Current: moderate smoothing\n\n// Try these alternatives:\nalpha: 0.7,  // More responsive, less smooth\nalpha: 0.1,  // Very smooth, slower response",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:418:text",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 418,
      "lineEnd": 420,
      "language": "text",
      "code": "error[E0433]: failed to resolve: use of undeclared type `Hub`",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/getting-started/second-application:433:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 433,
      "lineEnd": 436,
      "language": "rust",
      "code": "// In SensorNode::tick()\nif self.last_publish.elapsed() >= Duration::from_millis(500) {  // 2 Hz instead of 1 Hz",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:442:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 442,
      "lineEnd": 446,
      "language": "rust",
      "code": "if temp > 30.0 {\n    println!(\"  WARNING: High temperature detected!\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:452:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 452,
      "lineEnd": 463,
      "language": "rust",
      "code": "use std::fs::OpenOptions;\nuse std::io::Write;\n\nlet mut file = OpenOptions::new()\n    .create(true)\n    .append(true)\n    .open(\"temperature_log.txt\")\n    .unwrap();\n\nwriteln!(file, \"{:.1}\", temp).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:469:rust",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 469,
      "lineEnd": 473,
      "language": "rust",
      "code": "// In main()\nscheduler.add(Box::new(SensorNode::new()?), 0, Some(true));  // Sensor 1\nscheduler.add(Box::new(SensorNode::new()?), 0, Some(true));  // Sensor 2",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/getting-started/second-application:507:bash",
      "file": "content/docs/getting-started/second-application.mdx",
      "lineStart": 507,
      "lineEnd": 509,
      "language": "bash",
      "code": "horus new --example temperature_pipeline",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:14:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 14,
      "lineEnd": 20,
      "language": "yaml",
      "code": "name: my_robot\nversion: \"0.1.0\"\n\ndependencies:\n  - horus",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:23:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 23,
      "lineEnd": 53,
      "language": "yaml",
      "code": "name: my_robot_controller\nversion: \"1.2.3\"\ndescription: \"Advanced mobile robot controller with navigation\"\nauthor: \"Robotics Team\"\nlicense: \"Apache-2.0\"\nmode: release\nlanguage: rust\n\ndependencies:\n  - horus\n  - name: serde\n    version: \"1\"\n    features:\n      - derive\n  - name: tokio\n    version: \"1\"\n    features:\n      - full\n\nignore:\n  files:\n    - \"debug_*.rs\"\n    - \"**/temp/**\"\n  directories:\n    - \"experiments/\"\n    - \"old/\"\n  packages:\n    - \"ipython\"\n    - \"jupyter\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:69:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 69,
      "lineEnd": 73,
      "language": "yaml",
      "code": "name: temperature-monitor\nname: mobile_robot_controller\nname: warehouse-navigation",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:84:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 84,
      "lineEnd": 88,
      "language": "yaml",
      "code": "version: \"0.1.0\"    # Initial development\nversion: \"1.0.0\"    # First stable release\nversion: \"2.3.1\"    # Mature project",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:101:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 101,
      "lineEnd": 104,
      "language": "yaml",
      "code": "description: \"Temperature monitoring system with alerts\"\ndescription: \"Autonomous mobile robot for warehouse operations\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:115:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 115,
      "lineEnd": 119,
      "language": "yaml",
      "code": "author: \"Robotics Team\"\nauthor: \"John Doe <john@example.com>\"\nauthor: \"ACME Robotics Inc.\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:131:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 131,
      "lineEnd": 135,
      "language": "yaml",
      "code": "license: \"Apache-2.0\"\nlicense: \"MIT\"\nlicense: \"Proprietary\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:149:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 149,
      "lineEnd": 152,
      "language": "yaml",
      "code": "mode: debug    # Fast compilation, slower runtime\nmode: release  # Slower compilation, optimized runtime",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:155:bash",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 155,
      "lineEnd": 157,
      "language": "bash",
      "code": "horus run --release  # Overrides mode in horus.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:169:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 169,
      "lineEnd": 172,
      "language": "yaml",
      "code": "language: rust\nlanguage: python",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:196:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 196,
      "lineEnd": 201,
      "language": "yaml",
      "code": "dependencies:\n  - horus           # Latest from HORUS registry\n  - serde           # Auto-detected: crates.io (Rust) or PyPI (Python)\n  - numpy           # Auto-detected: PyPI",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:204:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 204,
      "lineEnd": 216,
      "language": "yaml",
      "code": "dependencies:\n  - horus\n  - name: serde\n    version: \"1.0\"\n    features:\n      - derive\n  - name: tokio\n    version: \"1\"\n    features:\n      - full\n      - rt-multi-thread",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:223:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 223,
      "lineEnd": 229,
      "language": "yaml",
      "code": "dependencies:\n  - cargo:rppal@0.14                    # Raspberry Pi GPIO\n  - cargo:tokio-serial@5.4              # Serial port\n  - cargo:serde@1.0:features=derive     # With features\n  - cargo:tokio@1:features=full,macros  # Multiple features",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:232:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 232,
      "lineEnd": 237,
      "language": "yaml",
      "code": "dependencies:\n  - pip:numpy@1.24                      # NumPy\n  - pip:opencv-python@4.8               # OpenCV\n  - pip:pyserial@3.5                    # Serial port",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:240:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 240,
      "lineEnd": 244,
      "language": "yaml",
      "code": "dependencies:\n  - path:my_driver:../drivers/my_custom_driver\n  - path:sensor_lib:./libs/sensor_lib",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:247:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 247,
      "lineEnd": 267,
      "language": "yaml",
      "code": "dependencies:\n  # Basic git dependency\n  - name: my_package\n    git: https://github.com/user/repo.git\n\n  # With specific branch\n  - name: my_driver\n    git: https://github.com/user/driver.git\n    branch: develop\n\n  # With specific tag\n  - name: sensors\n    git: https://github.com/robotics/sensors.git\n    tag: v1.2.0\n\n  # With specific commit\n  - name: utils\n    git: https://github.com/user/utils.git\n    rev: a1b2c3d4",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:309:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 309,
      "lineEnd": 312,
      "language": "yaml",
      "code": "dependencies:\n  - horus",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:315:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 315,
      "lineEnd": 321,
      "language": "yaml",
      "code": "dependencies:\n  - horus\n  - serde\n  - tokio\n  - numpy  # Python",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:324:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 324,
      "lineEnd": 339,
      "language": "yaml",
      "code": "dependencies:\n  - horus\n  - name: serde\n    version: \"1\"\n    features:\n      - derive\n  - name: tokio\n    version: \"1\"\n    features:\n      - full\n  - name: eframe\n    version: \"0.29\"\n  - name: egui\n    version: \"0.29\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:359:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 359,
      "lineEnd": 366,
      "language": "yaml",
      "code": "ignore:\n  files:\n    - \"debug_*.py\"           # Ignore debug_test.py, debug_node.py\n    - \"test_*.rs\"            # Ignore all test files\n    - \"**/experiments/**\"    # Ignore files in any experiments/ directory\n    - \"scratch.rs\"           # Ignore specific file",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:375:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 375,
      "lineEnd": 382,
      "language": "yaml",
      "code": "ignore:\n  directories:\n    - \"old/\"\n    - \"experiments/\"\n    - \"tests/\"\n    - \"benchmarks/\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:391:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 391,
      "lineEnd": 397,
      "language": "yaml",
      "code": "ignore:\n  packages:\n    - \"ipython\"      # Development shell\n    - \"jupyter\"      # Notebook environment\n    - \"pytest\"       # Testing framework",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:403:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 403,
      "lineEnd": 429,
      "language": "yaml",
      "code": "name: robot_controller\nversion: \"0.1.0\"\n\ndependencies:\n  - horus\n  - serde\n\nignore:\n  # Don't run debug files\n  files:\n    - \"debug_*.py\"\n    - \"test_*.rs\"\n    - \"**/temp/**\"\n\n  # Don't process these directories\n  directories:\n    - \"old_controllers/\"\n    - \"experiments/\"\n    - \"docs/\"\n\n  # Don't auto-install these packages\n  packages:\n    - \"ipython\"\n    - \"jupyter\"\n    - \"black\"  # Code formatter",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:439:text",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 439,
      "lineEnd": 450,
      "language": "text",
      "code": "my_project/\n├── horus.yaml              # Your configuration (edit this)\n├── main.rs                 # Your code (edit this)\n└── .horus/                 # Auto-managed (don't touch)\n    ├── packages/           # Symlinks to global cache\n    │   ├── horus -> ~/.horus/cache/horus@0.1.0/\n    │   └── serde -> ~/.horus/cache/serde@1.0.228/\n    ├── Cargo.toml          # Generated for Rust projects\n    ├── Cargo.lock          # Cargo lock file\n    └── target/             # Rust build artifacts",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:490:gitignore",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 490,
      "lineEnd": 496,
      "language": "gitignore",
      "code": "# Auto-managed HORUS environment\n.horus/\n\n# Keep configuration\n!horus.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:512:bash",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 512,
      "lineEnd": 514,
      "language": "bash",
      "code": "rm -rf .horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:517:bash",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 517,
      "lineEnd": 519,
      "language": "bash",
      "code": "horus run  # Automatically recreates .horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:527:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 527,
      "lineEnd": 547,
      "language": "yaml",
      "code": "name: temperature-monitor\nversion: \"0.1.0\"\ndescription: \"Simple temperature monitoring system\"\nauthor: \"Robotics Team\"\nlicense: \"Apache-2.0\"\nmode: release\n\ndependencies:\n  - horus\n  - name: serde\n    version: \"1\"\n    features:\n      - derive\n\nignore:\n  files:\n    - \"debug_*.rs\"\n  packages:\n    - \"ipython\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:551:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 551,
      "lineEnd": 576,
      "language": "yaml",
      "code": "name: robot-backend\nversion: \"1.0.0\"\ndescription: \"Robot control backend with sensor processing\"\nauthor: \"ACME Robotics\"\nlicense: \"Apache-2.0\"\nmode: release\nlanguage: rust\n\ndependencies:\n  - horus\n  - name: serde\n    version: \"1\"\n    features:\n      - derive\n  - name: tokio\n    version: \"1\"\n    features:\n      - full\n\nignore:\n  directories:\n    - \"tests/\"\n  packages:\n    - \"pytest\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:580:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 580,
      "lineEnd": 603,
      "language": "yaml",
      "code": "name: robot-monitor\nversion: \"1.0.0\"\ndescription: \"Real-time robot monitor and visualization\"\nauthor: \"ACME Robotics\"\nlicense: \"Apache-2.0\"\nmode: release\nlanguage: rust\n\ndependencies:\n  - horus\n  - name: eframe\n    version: \"0.29\"\n  - name: egui\n    version: \"0.29\"\n  - name: serde\n    version: \"1\"\n    features:\n      - derive\n\nignore:\n  files:\n    - \"debug_*.rs\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:609:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 609,
      "lineEnd": 630,
      "language": "yaml",
      "code": "name: vision-processor\nversion: \"0.2.0\"\ndescription: \"Computer vision processing node\"\nauthor: \"Vision Team\"\nlicense: \"MIT\"\nlanguage: python\n\ndependencies:\n  - horus_py\n  - numpy\n  - opencv-python\n  - pillow\n\nignore:\n  directories:\n    - \"notebooks/\"\n    - \"experiments/\"\n  packages:\n    - \"jupyter\"\n    - \"matplotlib\"  # Visualization only",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:637:bash",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 637,
      "lineEnd": 640,
      "language": "bash",
      "code": "git add horus.yaml\ngit commit -m \"Update dependencies: add sensor-fusion package\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:652:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 652,
      "lineEnd": 656,
      "language": "yaml",
      "code": "dependencies:\n  - name: critical-package\n    version: \"=1.2.3\"  # Exact version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:661:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 661,
      "lineEnd": 666,
      "language": "yaml",
      "code": "dependencies:\n  # Version 2.0 required for new path planning algorithm\n  - name: motion-planner\n    version: \"^2.0\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:671:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 671,
      "lineEnd": 686,
      "language": "yaml",
      "code": "# Good (minimal)\nname: my_robot\nversion: \"0.1.0\"\ndependencies:\n  - horus\n\n# Overkill for simple projects\nname: my_robot\nversion: \"0.1.0\"\ndescription: \"A robot\"\nauthor: \"Me\"\nlicense: \"MIT\"\nmode: debug\nlanguage: rust",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:694:text",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 694,
      "lineEnd": 696,
      "language": "text",
      "code": "Error: Missing required field 'name' in horus.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:702:text",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 702,
      "lineEnd": 704,
      "language": "text",
      "code": "Error: Failed to parse horus.yaml: invalid YAML syntax at line 5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:710:text",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 710,
      "lineEnd": 712,
      "language": "text",
      "code": "Error: Invalid version format: '1.0'. Expected semantic version (e.g., '1.0.0')",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:721:toml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 721,
      "lineEnd": 730,
      "language": "toml",
      "code": "[package]\nname = \"my-robot\"\nversion = \"0.1.6\"\nedition = \"2021\"\n\n[dependencies]\nserde = { version = \"1\", features = [\"derive\"] }\ntokio = { version = \"1\", features = [\"full\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:733:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 733,
      "lineEnd": 747,
      "language": "yaml",
      "code": "name: my-robot\nversion: \"0.1.0\"\n\ndependencies:\n  - horus\n  - name: serde\n    version: \"1\"\n    features:\n      - derive\n  - name: tokio\n    version: \"1\"\n    features:\n      - full",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:750:bash",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 750,
      "lineEnd": 752,
      "language": "bash",
      "code": "horus run  # HORUS generates Cargo.toml automatically",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:757:text",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 757,
      "lineEnd": 761,
      "language": "text",
      "code": "numpy==1.24.0\nopencv-python>=4.5\npillow",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/configuration:764:yaml",
      "file": "content/docs/package-management/configuration.mdx",
      "lineStart": 764,
      "lineEnd": 776,
      "language": "yaml",
      "code": "name: vision-processor\nversion: \"0.1.0\"\nlanguage: python\n\ndependencies:\n  - horus_py\n  - name: numpy\n    version: \"1.24.0\"\n  - name: opencv-python\n    version: \">=4.5\"\n  - pillow",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:30:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 30,
      "lineEnd": 39,
      "language": "text",
      "code": "~/.horus/cache/\n── horus_py@0.1.0/          # HORUS packages\n   ── lib/horus/\n── serde@1.0.228/           # External crates (from crates.io)\n   ── src/\n   ── Cargo.toml           # Cargo lives here, not your project!\n   ── lib/libserde.rlib    # Pre-compiled\n── pid-controller@1.2.0/    # More HORUS packages",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:52:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 52,
      "lineEnd": 65,
      "language": "text",
      "code": "my_robot_project/\n── horus.yaml               # Dependencies declared here\n── main.py / main.rs        # Your code\n── .horus/                  # Hidden automatic environment\n    ── packages/            # Symlinks to global cache\n       ── horus_py -> ~/.horus/cache/horus_py@0.1.0/\n       ── serde -> ~/.horus/cache/serde@1.0.228/\n    ── bin/                 # Project binaries (auto-created)\n    ── lib/                 # Project libraries (auto-created)\n    ── Cargo.toml           # Generated for Rust projects (auto-managed)\n    ── Cargo.lock           # Cargo lock file for Rust (auto-managed)\n    ── target/              # Cargo build artifacts for Rust (auto-managed)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:92:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 92,
      "lineEnd": 97,
      "language": "bash",
      "code": "# Team member clones your project\ngit clone your-repo\ncd your-repo\nhorus run  # Auto-installs dependencies and runs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:100:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 100,
      "lineEnd": 113,
      "language": "bash",
      "code": "# Without HORUS (traditional)\nproject1/node_modules/  # 500 MB\nproject2/node_modules/  # 500 MB\nproject3/node_modules/  # 500 MB\n# Total: 1.5 GB duplicated!\n\n# With HORUS (global cache)\n~/.horus/cache/         # 500 MB (shared)\nproject1/.horus/packages/  # Symlinks only (a few KB)\nproject2/.horus/packages/  # Symlinks only (a few KB)\nproject3/.horus/packages/  # Symlinks only (a few KB)\n# Total: 500 MB globally, ~10 KB per project!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:116:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 116,
      "lineEnd": 121,
      "language": "bash",
      "code": "# Different versions supported\nproject_a/horus.yaml:  serde@1.0.228\nproject_b/horus.yaml:  serde@1.0.150\n# Both work - isolated environments",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:133:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 133,
      "lineEnd": 146,
      "language": "bash",
      "code": "# Scenario: Global cache has broken package\n~/.horus/cache/\n── serde@1.0.228/  # Corrupted or incompatible\n\nmy_project/.horus/packages/\n── serde@1.0.150/  # Working local version\n\n# When you run:\nhorus run\n#  Uses local serde@1.0.150 (line 1010-1012 in run.rs)\n#  NEVER checks global cache\n#  Broken global version ignored!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:152:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 152,
      "lineEnd": 154,
      "language": "bash",
      "code": "horus pkg install serde",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:170:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 170,
      "lineEnd": 181,
      "language": "bash",
      "code": "# Option 1: Remove symlink and reinstall locally\nrm .horus/packages/serde  # Remove symlink to broken global\nhorus pkg install serde   # Installs locally (global check fails)\n\n# Option 2: Install different version locally\nhorus pkg install serde -v 1.0.150  # Specific working version\n\n# Option 3: Clear global and reinstall\nrm -rf ~/.horus/cache/serde@1.0.228/\nhorus run  # Auto-reinstalls to global",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:210:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 210,
      "lineEnd": 219,
      "language": "bash",
      "code": "# Freeze to default file (horus-freeze.yaml)\nhorus env freeze\n\n# Freeze to custom file\nhorus env freeze -o production.yaml\n\n# Freeze and publish to registry\nhorus env freeze --publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:223:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 223,
      "lineEnd": 229,
      "language": "bash",
      "code": "# Restore from local file\nhorus env restore horus-freeze.yaml\n\n# Restore from registry\nhorus env restore env_abc123",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:238:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 238,
      "lineEnd": 271,
      "language": "yaml",
      "code": "# HORUS Environment\n# Generated: 2025-10-09T14:32:15Z\n# System: Linux 6.14.0-33-generic\n\nmetadata:\n  name: \"Mobile Robot Production Environment\"\n  description: \"Stable release for lab robots\"\n  author: \"robotics-team\"\n  created_at: \"2025-10-09T14:32:15Z\"\n  horus_version: \"0.1.6\"\n\npackages:\n  # Direct dependencies\n  - name: pid-controller\n    version: 1.2.0\n    source: registry\n    checksum: sha256:a3b2c1...\n    features: [\"anti-windup\"]\n\n  - name: motion-planner\n    version: 2.0.1\n    source: registry\n    checksum: sha256:d4e5f6...\n    dependencies:\n      - pathfinding-utils: 1.2.0\n\n  - name: sensor-drivers\n    version: 1.5.0\n    source: registry\n    checksum: sha256:g7h8i9...\n\n# Total: 3 packages (+ 1 transitive dependency)",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:276:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 276,
      "lineEnd": 289,
      "language": "text",
      "code": "my_project/\n── horus-freeze.yaml       # Default freeze file\n── production.yaml         # Custom freeze file\n── environments/           # Optional: organize freeze files\n   ── dev.yaml\n   ── staging.yaml\n   ── production.yaml\n── .horus/                 # Auto-managed, don't store freeze files here\n    ── packages/           # Symlinks to global cache\n    ── bin/                # Compiled binaries\n    ── lib/                # Libraries\n    ── include/            # Headers",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:300:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 300,
      "lineEnd": 302,
      "language": "bash",
      "code": "horus env freeze [OPTIONS]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:310:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 310,
      "lineEnd": 312,
      "language": "bash",
      "code": "horus env freeze",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:315:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 315,
      "lineEnd": 332,
      "language": "text",
      "code": "Analyzing environment...\n   Found 5 packages (3 direct, 2 transitive)\n   Verified checksums\n   Generated metadata\n\nSaved to: horus-freeze.yaml\n\nPackages frozen:\n  pid-controller@1.2.0\n  motion-planner@2.0.1\n  sensor-drivers@1.5.0\n  pathfinding-utils@1.2.0 (transitive)\n  control-utils@1.0.0 (transitive)\n\nTo restore this environment:\n  horus env restore horus-freeze.yaml",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:336:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 336,
      "lineEnd": 342,
      "language": "bash",
      "code": "# Save to specific file\nhorus env freeze -o environments/production.yaml\n\n# Timestamp-based filename\nhorus env freeze -o \"backup-$(date +%Y%m%d).yaml\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:346:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 346,
      "lineEnd": 349,
      "language": "bash",
      "code": "# Freeze and upload to registry\nhorus env freeze --publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:352:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 352,
      "lineEnd": 369,
      "language": "text",
      "code": "Freezing environment...\n   Captured 5 packages\n   Generated manifest\n\nUploading to registry...\n   Uploaded\n\nEnvironment published:\n  ID: env_abc123def456\n  URL: https://marketplace.horus-registry.dev/environments/env_abc123def456\n\nShare this environment:\n  horus env restore env_abc123def456\n\nOr save locally:\n  horus env freeze -o local-copy.yaml",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:384:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 384,
      "lineEnd": 386,
      "language": "bash",
      "code": "horus env restore <FILE_OR_ID>",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:393:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 393,
      "lineEnd": 396,
      "language": "bash",
      "code": "# Restore from local file\nhorus env restore horus-freeze.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:399:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 399,
      "lineEnd": 415,
      "language": "text",
      "code": "Reading environment: horus-freeze.yaml\n  Name: Mobile Robot Production Environment\n  Packages: 5 (3 direct, 2 transitive)\n  Created: 2025-10-09\n\nRestoring environment...\n   pid-controller@1.2.0\n   motion-planner@2.0.1\n   sensor-drivers@1.5.0\n   pathfinding-utils@1.2.0 (dependency)\n   control-utils@1.0.0 (dependency)\n\nEnvironment restored successfully!\n  Location: .horus/packages/\n  Total size: 2.3 MB",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:419:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 419,
      "lineEnd": 422,
      "language": "bash",
      "code": "# Restore using environment ID\nhorus env restore env_abc123def456",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:425:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 425,
      "lineEnd": 438,
      "language": "text",
      "code": "Fetching environment from registry...\n   Downloaded env_abc123def456\n\nName: Production v2.1\nDescription: Stable release for warehouse robots\nAuthor: robotics-team\nPackages: 5\n\nRestoring...\n   All packages installed\n\nEnvironment ready!",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:446:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 446,
      "lineEnd": 456,
      "language": "bash",
      "code": "# 1. Clone project\ngit clone https://github.com/team/robot-controller\ncd robot-controller\n\n# 2. Restore environment\nhorus env restore horus-freeze.yaml\n\n# 3. Run project\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:459:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 459,
      "lineEnd": 472,
      "language": "bash",
      "code": "# 1. Install new package\nhorus pkg install new-feature\n\n# 2. Test\nhorus run --release\n\n# 3. Freeze updated environment\nhorus env freeze\n\n# 4. Commit changes\ngit add horus-freeze.yaml\ngit commit -m \"Add new-feature package\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:477:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 477,
      "lineEnd": 494,
      "language": "bash",
      "code": "# 1. Test locally\nhorus run --release\n\n# 2. Freeze environment\nhorus env freeze -o production.yaml \\\n  --name \"Production v2.1\" \\\n  --description \"Release for warehouse robots\"\n\n# 3. Publish to registry\nhorus env freeze --publish\n# Output: env_abc123def456\n\n# 4. Deploy to robot\nssh robot@192.168.1.100\nhorus env restore env_abc123def456\nhorus run --release --remote",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:499:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 499,
      "lineEnd": 509,
      "language": "bash",
      "code": "# Team lead freezes environment\nhorus env freeze --publish \\\n  --name \"Team Development Environment\" \\\n  --description \"Standard setup for all team members\"\n\n# Output: env_team_dev_001\n\n# Team members restore\nhorus env restore env_team_dev_001",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:514:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 514,
      "lineEnd": 523,
      "language": "bash",
      "code": "# Development\nhorus env freeze -o environments/dev.yaml\n\n# Staging\nhorus env freeze -o environments/staging.yaml\n\n# Production\nhorus env freeze -o environments/production.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:526:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 526,
      "lineEnd": 532,
      "language": "bash",
      "code": "# Switch to staging\nhorus env restore environments/staging.yaml\n\n# Switch to production\nhorus env restore environments/production.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:537:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 537,
      "lineEnd": 543,
      "language": "bash",
      "code": "# Restore previous working environment\nhorus env restore backup-20251008.yaml\n\n# Or restore from registry\nhorus env restore env_previous_stable",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:554:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 554,
      "lineEnd": 565,
      "language": "bash",
      "code": "# Add to git\ngit add horus-freeze.yaml\ngit commit -m \"Update environment: add sensor-fusion package\"\n\n# .gitignore (auto-generated by `horus new`)\n.horus/packages/      # Don't commit symlinks/packages\n.horus/bin/           # Don't commit compiled binaries\n.horus/lib/           # Don't commit libraries\n.horus/include/       # Don't commit headers\n.horus/cache/         # Don't commit cache",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:570:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 570,
      "lineEnd": 580,
      "language": "yaml",
      "code": "# Good\nname: \"Production v2.1 - Warehouse Robots\"\nname: \"Development - Feature Branch XYZ\"\nname: \"Staging - Pre-release Testing\"\n\n# Bad\nname: \"env1\"\nname: \"test\"\nname: \"final_final_v2\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:585:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 585,
      "lineEnd": 603,
      "language": "yaml",
      "code": "metadata:\n  name: \"Production v2.1\"\n  description: |\n    Stable production environment for warehouse robots.\n\n    Features:\n    - PID controller with anti-windup\n    - Motion planner with obstacle avoidance\n    - Sensor drivers for LIDAR and IMU\n\n    Tested on:\n    - Robot A (192.168.1.100)\n    - Robot B (192.168.1.101)\n    - Robot C (192.168.1.102)\n\n    Last updated: 2025-10-09\n    Contact: robotics-team@company.com",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:608:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 608,
      "lineEnd": 617,
      "language": "bash",
      "code": "# Before major changes\nhorus env freeze -o backup-before-upgrade.yaml\n\n# After successful testing\nhorus env freeze -o stable-$(date +%Y%m%d).yaml\n\n# Before deployment\nhorus env freeze -o production-v$(git describe --tags).yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:622:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 622,
      "lineEnd": 629,
      "language": "bash",
      "code": "# Remove unused packages\nhorus pkg list\nhorus pkg remove unused-package\n\n# Refreeze\nhorus env freeze",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:636:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 636,
      "lineEnd": 638,
      "language": "text",
      "code": "Error: Package 'legacy-driver@0.5.0' not found in registry",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:646:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 646,
      "lineEnd": 656,
      "language": "bash",
      "code": "# Option 1: Update environment file\n# Remove or replace unavailable package\n\n# Option 2: Install alternative\nhorus pkg install modern-driver\nhorus env freeze  # Update freeze file\n\n# Option 3: Use cached version\nls ~/.horus/cache/legacy-driver@0.5.0/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:661:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 661,
      "lineEnd": 665,
      "language": "text",
      "code": "Error: Checksum mismatch for 'pid-controller@1.2.0'\n  Expected: sha256:a3b2c1...\n  Got:      sha256:x9y8z7...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/environment-management:673:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 673,
      "lineEnd": 677,
      "language": "bash",
      "code": "# Reinstall the package\nhorus pkg remove pid-controller\nhorus pkg install pid-controller -v 1.2.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:682:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 682,
      "lineEnd": 686,
      "language": "text",
      "code": "Error: Cannot satisfy version constraints\n  motion-planner requires pathfinding-utils ^1.2\n  sensor-fusion requires pathfinding-utils ^1.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:689:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 689,
      "lineEnd": 699,
      "language": "bash",
      "code": "# Option 1: Install compatible version\nhorus pkg install sensor-fusion -v 2.0.0\n\n# Option 2: Edit environment file manually\n# Change pathfinding-utils version to compatible one\n\n# Option 3: Remove conflicting package\nhorus pkg remove sensor-fusion\nhorus env freeze  # Update freeze file",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:704:text",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 704,
      "lineEnd": 706,
      "language": "text",
      "code": "Error: Failed to fetch environment from registry",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:709:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 709,
      "lineEnd": 712,
      "language": "bash",
      "code": "# Use local file instead\nhorus env restore horus-freeze.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:726:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 726,
      "lineEnd": 746,
      "language": "yaml",
      "code": "name: my_robot_project\nversion: 0.1.0\nlanguage: python\ndependencies:\n  - horus_py@0.1.0\n  - numpy\n\n# Optional: Ignore files, directories, and packages\nignore:\n  files:\n    - \"debug_*.py\"          # Ignore all files starting with debug_\n    - \"test_*.rs\"           # Ignore all test files\n    - \"**/experiments/**\"   # Ignore anything in experiments directories\n  directories:\n    - \"old/\"                # Ignore old/ directory\n    - \"experiments/\"        # Ignore experiments/ directory\n  packages:\n    - \"ipython\"             # Don't auto-install ipython\n    - \"jupyter\"             # Don't auto-install jupyter",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:767:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 767,
      "lineEnd": 773,
      "language": "yaml",
      "code": "ignore:\n  files:\n    - \"debug_*.py\"\n    - \"scratch_*.rs\"\n    - \"**/temp/**\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:776:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 776,
      "lineEnd": 782,
      "language": "yaml",
      "code": "ignore:\n  directories:\n    - \"tests/\"\n    - \"experiments/\"\n    - \"benchmarks/\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:785:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 785,
      "lineEnd": 791,
      "language": "yaml",
      "code": "ignore:\n  packages:\n    - \"ipython\"      # Interactive shell for debugging\n    - \"jupyter\"      # Notebook for visualization\n    - \"pytest\"       # Testing framework",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:808:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 808,
      "lineEnd": 811,
      "language": "bash",
      "code": "horus new my_project --python\ncd my_project",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:814:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 814,
      "lineEnd": 819,
      "language": "bash",
      "code": "# Create some debug/experimental files\ntouch debug_sensor_test.py\nmkdir experiments\ntouch experiments/new_algorithm.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:822:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 822,
      "lineEnd": 830,
      "language": "yaml",
      "code": "ignore:\n  files:\n    - \"debug_*.py\"\n  directories:\n    - \"experiments/\"\n  packages:\n    - \"ipython\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:833:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 833,
      "lineEnd": 836,
      "language": "bash",
      "code": "horus run\n# Only main.py runs, debug files and experiments are ignored",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:839:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 839,
      "lineEnd": 842,
      "language": "bash",
      "code": "horus run debug_sensor_test.py\n# Ignored files can still be run explicitly",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:849:bash",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 849,
      "lineEnd": 852,
      "language": "bash",
      "code": "git add horus.yaml\ngit commit -m \"Add ignore patterns for debug files\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/environment-management:855:yaml",
      "file": "content/docs/package-management/environment-management.mdx",
      "lineStart": 855,
      "lineEnd": 865,
      "language": "yaml",
      "code": "ignore:\n  # Legacy code being phased out\n  directories:\n    - \"old_controllers/\"\n\n  # Development tools not needed in production\n  packages:\n    - \"ipython\"\n    - \"jupyter\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:39:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 39,
      "lineEnd": 56,
      "language": "bash",
      "code": "# Install from HORUS registry\nhorus pkg install pid-controller\n\n# Install from crates.io (auto-detected)\nhorus pkg install serde\nhorus pkg install tokio\n\n# Install from PyPI (auto-detected)\nhorus pkg install numpy\nhorus pkg install opencv-python\n\n# Install specific version\nhorus pkg install serde -v 1.0.200\n\n# Install globally (share across all projects)\nhorus pkg install sensor-drivers -g",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:66:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 66,
      "lineEnd": 75,
      "language": "text",
      "code": "Package 'package_name' found in BOTH PyPI and crates.io\n\nWhich package source do you want to use?\n  [1] [PYTHON] PyPI (Python package)\n  [2] [RUST] crates.io (Rust binary)\n  [3] [FAIL] Cancel installation\n\nChoice [1-3]:",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:81:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 81,
      "lineEnd": 89,
      "language": "text",
      "code": "Package 'ripgrep' v14.0.0 already installed system-wide\n\n  [1] Use system package (no download)\n  [2] Install fresh copy to HORUS\n  [3] Cancel\n\nChoice [1-3]:",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:100:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 100,
      "lineEnd": 114,
      "language": "rust",
      "code": "// In your main.rs or any file\nuse pid_controller::PIDNode;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Use the installed package\n    let pid = PIDNode::new(1.0, 0.1, 0.01);\n    scheduler.add(Box::new(pid), 5, Some(true));\n\n    scheduler.run().expect(\"Scheduler failed\");\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:118:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 118,
      "lineEnd": 127,
      "language": "bash",
      "code": "# 1. Authenticate first (one-time)\nhorus auth login\n\n# 2. Navigate to your project\ncd my-awesome-controller\n\n# 3. Publish\nhorus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:134:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 134,
      "lineEnd": 143,
      "language": "text",
      "code": "my_project/\n── .horus/\n   ── packages/\n       ── pid-controller@1.0.0/      # HORUS registry\n       ── serde@1.0.200/             # crates.io\n       ── pypi_numpy@1.24.0/         # PyPI (prefixed with pypi_)\n── src/\n    ── main.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:153:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 153,
      "lineEnd": 160,
      "language": "text",
      "code": "~/.horus/\n── cache/\n    ── pid-controller@1.0.0/         # HORUS registry\n    ── serde@1.0.200/                # crates.io\n    ── pypi_numpy@1.24.0/            # PyPI packages\n    ── git_abc123/                   # Git dependencies (via horus.yaml)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:196:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 196,
      "lineEnd": 209,
      "language": "bash",
      "code": "# Default behavior (no flags)\nhorus pkg install serde\n\n# If package exists in global cache:\n#    Install to global cache\n#    Create symlink: .horus/packages/serde -> ~/.horus/cache/serde@1.0.228/\n#    Disk efficient!\n\n# If package NOT in global cache:\n#    Install directly to .horus/packages/serde@1.0.228/\n#    No symlink, real directory\n#    Isolated from global!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:215:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 215,
      "lineEnd": 226,
      "language": "bash",
      "code": "# Scenario: Global cache has broken serde@1.0.228\n~/.horus/cache/serde@1.0.228/  # Corrupted\n\n# Fix: Install working version locally\nrm .horus/packages/serde  # Remove symlink to broken global\nhorus pkg install serde -v 1.0.150  # Install working version locally\n\n# Result:\n.horus/packages/serde@1.0.150/  # Real directory, not symlink\n# horus run will use this, ignoring broken global!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:243:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 243,
      "lineEnd": 245,
      "language": "bash",
      "code": "horus pkg install <package> [OPTIONS]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:254:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 254,
      "lineEnd": 274,
      "language": "bash",
      "code": "# From HORUS registry\nhorus pkg install pid-controller\nhorus pkg install motion-planner -v 2.0.1\n\n# From crates.io (auto-detected)\nhorus pkg install serde\nhorus pkg install tokio -v 1.35.0\nhorus pkg install clap\n\n# From PyPI (auto-detected)\nhorus pkg install numpy\nhorus pkg install opencv-python -v 4.8.0\nhorus pkg install torch\n\n# Global installation\nhorus pkg install serde -g\n\n# Install to specific workspace\nhorus pkg install pid-controller -t my-project",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:280:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 280,
      "lineEnd": 282,
      "language": "bash",
      "code": "horus pkg install ripgrep",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:285:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 285,
      "lineEnd": 292,
      "language": "text",
      "code": "Installing ripgrep from crates.io...\n  Compiling ripgrep...\n  Installing with cargo...\n\nPackage installed: ripgrep@14.0.0\nLocation: ~/.horus/cache/ripgrep@14.0.0/",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:302:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 302,
      "lineEnd": 304,
      "language": "bash",
      "code": "horus pkg install numpy",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:307:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 307,
      "lineEnd": 314,
      "language": "text",
      "code": "Installing numpy from PyPI...\n  Downloading numpy-1.24.0...\n  Installing to .horus/packages/pypi_numpy@1.24.0/\n\nPackage installed: numpy@1.24.0\nLocation: .horus/packages/pypi_numpy@1.24.0/",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:324:python",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 324,
      "lineEnd": 331,
      "language": "python",
      "code": "# In your Python node\nimport sys\nsys.path.insert(0, '.horus/packages/pypi_numpy@1.24.0')\n\nimport numpy as np\n# Or HORUS automatically adds package paths when using horus run",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:336:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 336,
      "lineEnd": 348,
      "language": "text",
      "code": "Installing pid-controller@1.2.0...\n Downloaded (245 KB)\n Extracted to .horus/packages/pid-controller@1.2.0/\n Installed dependencies: control-utils@1.0.0\n Build successful\n\nPackage installed: pid-controller@1.2.0\nLocation: .horus/packages/pid-controller@1.2.0/\n\nUsage:\n  use pid_controller::PIDNode;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:355:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 355,
      "lineEnd": 357,
      "language": "bash",
      "code": "horus pkg remove <package>",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:365:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 365,
      "lineEnd": 374,
      "language": "bash",
      "code": "# Remove local package\nhorus pkg remove motion-planner\n\n# Remove from global cache\nhorus pkg remove common-utils -g\n\n# Remove from specific workspace\nhorus pkg remove pid-controller -t my-project",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:377:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 377,
      "lineEnd": 383,
      "language": "text",
      "code": "Removing pid-controller@1.2.0...\n Removed from .horus/packages/\n Freed 892 KB\n\nPackage removed: pid-controller@1.2.0",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:390:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 390,
      "lineEnd": 392,
      "language": "bash",
      "code": "horus pkg list [QUERY] [OPTIONS]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:399:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 399,
      "lineEnd": 401,
      "language": "bash",
      "code": "horus pkg list",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:404:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 404,
      "lineEnd": 409,
      "language": "text",
      "code": "Local packages:\n  pid-controller 1.2.0\n  motion-planner 2.0.1\n  sensor-drivers 1.5.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:412:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 412,
      "lineEnd": 414,
      "language": "bash",
      "code": "horus pkg list -g",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:417:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 417,
      "lineEnd": 420,
      "language": "bash",
      "code": "# Search by keyword\nhorus pkg list sensor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:423:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 423,
      "lineEnd": 428,
      "language": "text",
      "code": "Found 3 package(s):\n  sensor-fusion 2.1.0 - Kalman filter fusion\n  sensor-drivers 1.5.0 - LIDAR/IMU/camera drivers\n  sensor-calibration 1.0.0 - Calibration tools",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:435:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 435,
      "lineEnd": 437,
      "language": "bash",
      "code": "horus pkg unpublish <package> <version> [OPTIONS]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:443:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 443,
      "lineEnd": 449,
      "language": "bash",
      "code": "# Unpublish a specific version\nhorus pkg unpublish my-package 1.0.0\n\n# Skip confirmation prompt\nhorus pkg unpublish my-package 1.0.0 -y",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:452:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 452,
      "lineEnd": 464,
      "language": "text",
      "code": "Unpublishing my-package v1.0.0...\n\nWarning: This action is IRREVERSIBLE and will:\n  • Delete my-package v1.0.0 from the registry\n  • Make this version unavailable for download\n  • Cannot be undone\n\nType the package name 'my-package' to confirm: my-package\n\n Successfully unpublished my-package v1.0.0\n   The package is no longer available on the registry",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:496:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 496,
      "lineEnd": 499,
      "language": "bash",
      "code": "# Login with GitHub\nhorus auth login",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:508:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 508,
      "lineEnd": 511,
      "language": "bash",
      "code": "# Verify you're logged in\nhorus auth whoami",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:514:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 514,
      "lineEnd": 517,
      "language": "bash",
      "code": "# Remove credentials\nhorus auth logout",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:522:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 522,
      "lineEnd": 525,
      "language": "bash",
      "code": "# Run login command\nhorus auth login",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:528:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 528,
      "lineEnd": 535,
      "language": "text",
      "code": "Opening GitHub OAuth page in browser...\n\nIf browser doesn't open automatically, visit:\n  https://github.com/login/oauth/authorize?client_id=...\n\nWaiting for authorization...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:546:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 546,
      "lineEnd": 555,
      "language": "text",
      "code": "Authorization successful!\nToken saved to ~/.horus/credentials\n\nAuthenticated as: your-username\nEmail: you@example.com\n\nYou can now publish packages with:\n  horus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:561:json",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 561,
      "lineEnd": 571,
      "language": "json",
      "code": "{\n  \"provider\": \"github\",\n  \"username\": \"your-username\",\n  \"email\": \"you@example.com\",\n  \"token\": \"gho_abc123def456...\",\n  \"refresh_token\": \"gho_xyz789...\",\n  \"expires_at\": null,\n  \"created_at\": \"2025-10-09T14:30:00Z\"\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:598:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 598,
      "lineEnd": 600,
      "language": "bash",
      "code": "horus auth logout",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:608:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 608,
      "lineEnd": 611,
      "language": "bash",
      "code": "# Interactive generation\nhorus auth generate-key",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:614:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 614,
      "lineEnd": 635,
      "language": "text",
      "code": "Generating API key...\n\nKey name (for identification): CI/CD Pipeline\nEnvironment (optional): production\nDescription (optional): GitHub Actions deployment\n\nGenerated API key:\n  horus_live_abc123def456ghi789jkl012mno345pqr678stu901\n\nWARNING: Copy this key now. It won't be shown again.\n\nSave to environment variable:\n  export HORUS_API_KEY=horus_live_abc123def456ghi789jkl012mno345pqr678stu901\n\nOr use in CI:\n  # GitHub Actions\n  - name: Publish\n    env:\n      HORUS_API_KEY: ${{ secrets.HORUS_API_KEY }}\n    run: horus pkg publish",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:638:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 638,
      "lineEnd": 642,
      "language": "bash",
      "code": "horus auth generate-key \\\n  --name \"GitHub Actions\" \\\n  --environment \"production\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:647:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 647,
      "lineEnd": 653,
      "language": "bash",
      "code": "# Set for session\nexport HORUS_API_KEY=horus_live_abc123...\n\n# Use horus commands\nhorus pkg publish",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:656:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 656,
      "lineEnd": 659,
      "language": "bash",
      "code": "# Save to file manually\necho '{\"api_key\":\"horus_live_abc123...\"}' > ~/.horus/credentials",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:668:yaml",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 668,
      "lineEnd": 704,
      "language": "yaml",
      "code": "name: Publish to HORUS Registry\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n\n      - name: Install HORUS\n        run: |\n          git clone https://github.com/softmata/horus.git /tmp/horus\n          cd /tmp/horus && ./install.sh\n\n      - name: Publish Package\n        env:\n          HORUS_API_KEY: ${{ secrets.HORUS_API_KEY }}\n        run: |\n          horus pkg publish --yes\n\n      - name: Publish Environment\n        env:\n          HORUS_API_KEY: ${{ secrets.HORUS_API_KEY }}\n        run: |\n          horus env freeze --publish \\\n            --name \"Release ${{ github.ref_name }}\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:718:yaml",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 718,
      "lineEnd": 731,
      "language": "yaml",
      "code": "publish:\n  stage: deploy\n  image: rust:latest\n  before_script:\n    - git clone https://github.com/softmata/horus.git /tmp/horus\n    - cd /tmp/horus && ./install.sh\n  script:\n    - horus pkg publish --yes\n  only:\n    - tags\n  variables:\n    HORUS_API_KEY: $CI_HORUS_API_KEY",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:744:dockerfile",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 744,
      "lineEnd": 761,
      "language": "dockerfile",
      "code": "FROM rust:1.70\n\n# Install HORUS\nRUN git clone https://github.com/softmata/horus.git /tmp/horus \\\n    && cd /tmp/horus && ./install.sh \\\n    && rm -rf /tmp/horus\n\n# Copy project\nCOPY . /app\nWORKDIR /app\n\n# Build and publish\nARG HORUS_API_KEY\nENV HORUS_API_KEY=${HORUS_API_KEY}\n\nRUN horus pkg publish --yes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:764:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 764,
      "lineEnd": 768,
      "language": "bash",
      "code": "docker build \\\n  --build-arg HORUS_API_KEY=$HORUS_API_KEY \\\n  -t my-horus-app .",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:773:groovy",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 773,
      "lineEnd": 804,
      "language": "groovy",
      "code": "pipeline {\n    agent any\n\n    environment {\n        HORUS_API_KEY = credentials('horus-api-key')\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                sh 'git clone https://github.com/softmata/horus.git /tmp/horus && cd /tmp/horus && ./install.sh'\n            }\n        }\n\n        stage('Build') {\n            steps {\n                sh 'horus build --release'\n            }\n        }\n\n        stage('Publish') {\n            when {\n                buildingTag()\n            }\n            steps {\n                sh 'horus pkg publish --yes'\n            }\n        }\n    }\n}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:830:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 830,
      "lineEnd": 835,
      "language": "bash",
      "code": "export HORUS_API_KEY=horus_live_abc123...\nexport HORUS_REGISTRY_URL=https://custom-registry.company.com\n\nhorus pkg publish",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:857:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 857,
      "lineEnd": 864,
      "language": "bash",
      "code": "# Verify permissions\nls -la ~/.horus/credentials\n# Should show: -rw------- (600)\n\n# Fix if needed\nchmod 600 ~/.horus/credentials",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:867:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 867,
      "lineEnd": 875,
      "language": "bash",
      "code": "# Backup credentials (encrypted)\ngpg -c ~/.horus/credentials\n# Creates ~/.horus/credentials.gpg\n\n# Restore\ngpg -d ~/.horus/credentials.gpg > ~/.horus/credentials\nchmod 600 ~/.horus/credentials",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:880:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 880,
      "lineEnd": 893,
      "language": "bash",
      "code": "# 1. Generate new key\nhorus auth generate-key --name \"Production 2025-Q4\"\n\n# 2. Update CI/CD secrets with the new key\n# (Do this manually in your CI/CD platform)\n\n# 3. Test new key\nexport HORUS_API_KEY=horus_live_new_key...\nhorus auth whoami\n\n# 4. Revoke old key via registry web interface\n# Visit https://marketplace.horus-registry.dev to manage keys",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:900:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 900,
      "lineEnd": 903,
      "language": "text",
      "code": "Error: Authentication required\n  Run: horus auth login",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:906:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 906,
      "lineEnd": 915,
      "language": "bash",
      "code": "# Check current status\nhorus auth whoami\n\n# Re-authenticate\nhorus auth login\n\n# Verify credentials file exists\nls -la ~/.horus/credentials",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:920:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 920,
      "lineEnd": 923,
      "language": "text",
      "code": "Error: Token expired\n  Please re-authenticate",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:926:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 926,
      "lineEnd": 933,
      "language": "bash",
      "code": "# Re-login (auto-refreshes token)\nhorus auth login\n\n# Or use API key instead\nhorus auth generate-key\nexport HORUS_API_KEY=horus_live_abc123...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:938:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 938,
      "lineEnd": 941,
      "language": "text",
      "code": "Error: Invalid API key\n  Status: 401 Unauthorized",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:950:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 950,
      "lineEnd": 960,
      "language": "bash",
      "code": "# Verify key format\necho $HORUS_API_KEY\n# Should start with: horus_live_\n\n# Check key status via registry web interface\n# Visit https://marketplace.horus-registry.dev\n\n# Generate new key\nhorus auth generate-key",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:965:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 965,
      "lineEnd": 968,
      "language": "text",
      "code": "Error: Permission denied\n  You don't have permission to publish to this package",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:976:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 976,
      "lineEnd": 984,
      "language": "bash",
      "code": "# Verify authentication\nhorus auth whoami\n\n# Check package ownership via registry web interface\n# Visit https://marketplace.horus-registry.dev\n\n# For package ownership transfer, contact registry support",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:989:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 989,
      "lineEnd": 992,
      "language": "text",
      "code": "Error: OAuth authorization failed\n  Could not complete GitHub authentication",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:995:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 995,
      "lineEnd": 1004,
      "language": "bash",
      "code": "# Re-login\nhorus auth login\n\n# Check browser popup blockers\n\n# Verify GitHub account\ncurl https://api.github.com/user \\\n  -H \"Authorization: Bearer <your-github-token>\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1011:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1011,
      "lineEnd": 1020,
      "language": "bash",
      "code": "# Set registry URL\nexport HORUS_REGISTRY_URL=https://registry.company.internal\n\n# Authenticate\nhorus auth login\n\n# Use as normal\nhorus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1025:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1025,
      "lineEnd": 1035,
      "language": "bash",
      "code": "# Save current credentials\nmv ~/.horus/credentials ~/.horus/credentials.account1\n\n# Login with second account\nhorus auth login\n\n# Switch back\nmv ~/.horus/credentials ~/.horus/credentials.account2\nmv ~/.horus/credentials.account1 ~/.horus/credentials",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1070:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1070,
      "lineEnd": 1079,
      "language": "bash",
      "code": "# 1. Navigate to package directory\ncd my-awesome-package\n\n# 2. Verify everything builds\nhorus run --build-only --release\n\n# 3. Publish\nhorus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1082:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1082,
      "lineEnd": 1102,
      "language": "text",
      "code": "Publishing my-awesome-package v1.0.0...\n\n Package metadata validated\n Build successful\n Tests passed\n Documentation generated\n\nPackage size: 245 KB (compressed)\n\nPublish to registry? [y/N]: y\n\nUploading...\n Uploaded to registry\n\nPublished: my-awesome-package@1.0.0\nRegistry URL: https://marketplace.horus-registry.dev/packages/my-awesome-package\n\nOthers can now install with:\n  horus pkg install my-awesome-package",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1113:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1113,
      "lineEnd": 1124,
      "language": "text",
      "code": "Documentation\n   Add documentation? (y/n): y\n\n   Documentation options:\n     1. External URL - Link to online documentation\n     2. Local /docs - Bundle markdown files in a /docs folder\n\n   Choose option (1/2/skip): 1\n   Enter documentation URL: https://my-package-docs.example.com\n    Documentation URL: https://my-package-docs.example.com",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1129:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1129,
      "lineEnd": 1145,
      "language": "text",
      "code": "Documentation\n    Found local /docs folder with markdown files\n   Add documentation? (y/n): y\n\n   Documentation options:\n     1. External URL - Link to online documentation\n     2. Local /docs - Bundle markdown files in a /docs folder\n\n   [i] Your /docs folder should contain .md files organized as:\n      /docs/README.md          (main documentation)\n      /docs/getting-started.md (guides)\n      /docs/api.md             (API reference)\n\n   Choose option (1/2/skip): 2\n    Will bundle local /docs folder with package",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1148:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1148,
      "lineEnd": 1158,
      "language": "text",
      "code": "my-package/\n── docs/\n   ── README.md           # Main documentation page\n   ── getting-started.md  # Installation and setup guide\n   ── api.md              # API reference\n   ── examples.md         # Usage examples\n── src/\n   ── lib.rs\n── Cargo.toml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1171:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1171,
      "lineEnd": 1177,
      "language": "text",
      "code": "Source Repository\n    Auto-detected: https://github.com/username/my-package\n   Add source repository? (y/n): y\n   Use detected URL? (y/n): y\n    Source repository: https://github.com/username/my-package",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1182:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1182,
      "lineEnd": 1193,
      "language": "text",
      "code": "Source Repository\n   Add source repository? (y/n): y\n\n   [i] Enter the URL where your code is hosted:\n      • GitHub: https://github.com/username/repo\n      • GitLab: https://gitlab.com/username/repo\n      • Other: Any public repository URL\n\n   Enter source repository URL: https://gitlab.com/robotics/my-package\n    Source repository: https://gitlab.com/robotics/my-package",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1197:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1197,
      "lineEnd": 1234,
      "language": "bash",
      "code": "$ cd my-sensor-package\n$ horus pkg publish\n\nPublishing my-sensor-package v1.0.0...\n Uploaded to registry\n\nPublished: my-sensor-package@1.0.0\n   View at: https://marketplace.horus-registry.dev/packages/my-sensor-package\n\nPackage Metadata (optional)\n   Help users discover and use your package by adding:\n\nDocumentation\n    Found local /docs folder with markdown files\n   Add documentation? (y/n): y\n\n   Documentation options:\n     1. External URL - Link to online documentation\n     2. Local /docs - Bundle markdown files in a /docs folder\n\n   [i] Your /docs folder should contain .md files organized as:\n      /docs/README.md          (main documentation)\n      /docs/getting-started.md (guides)\n      /docs/api.md             (API reference)\n\n   Choose option (1/2/skip): 2\n    Will bundle local /docs folder with package\n\nSource Repository\n    Auto-detected: https://github.com/robotics-lab/my-sensor-package\n   Add source repository? (y/n): y\n   Use detected URL? (y/n): y\n    Source repository: https://github.com/robotics-lab/my-sensor-package\n\n Updating package metadata...\nPackage metadata updated!",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1240:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1240,
      "lineEnd": 1250,
      "language": "text",
      "code": "┌─────────────────────────────────────────┐\n│  my-sensor-package      v1.0.0          │\n│                                         │\n│  High-performance sensor fusion         │\n│                                         │\n│  [View Details] [Docs] [Source]         │\n│                                         │\n│         Markdown Viewer  GitHub Repo    │\n└─────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1267:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1267,
      "lineEnd": 1274,
      "language": "bash",
      "code": "# 1. Update version in Cargo.toml\n[package]\nversion = \"1.1.0\"\n\n# 2. Publish\nhorus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1277:toml",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1277,
      "lineEnd": 1282,
      "language": "toml",
      "code": "[dependencies]\npid-controller = \"1.2.0\"       # Exact version\nmotion-planner = \"^2.0\"        # Compatible (2.x.x, not 3.0.0)\nsensor-drivers = \"~1.5.0\"      # Patch updates (1.5.x)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1290:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1290,
      "lineEnd": 1292,
      "language": "bash",
      "code": "horus pkg install robot-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1295:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1295,
      "lineEnd": 1305,
      "language": "text",
      "code": "Resolving dependencies...\n  robot-controller@1.0.0\n  ── motion-planner@2.0.1\n     ── pathfinding-utils@1.2.0\n  ── pid-controller@1.2.0\n      ── control-utils@1.0.0\n\nInstalling 5 packages...\n All dependencies installed",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1311:toml",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1311,
      "lineEnd": 1323,
      "language": "toml",
      "code": "[dependencies]\nhorus = \"0.1\"\npid-controller = { version = \"1.2\", registry = \"horus\" }\nmotion-planner = \"2.0\"\n\n# Optional dependencies\n[dependencies]\nadvanced-planning = { version = \"3.0\", optional = true }\n\n[features]\nplanning = [\"advanced-planning\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1329:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1329,
      "lineEnd": 1339,
      "language": "text",
      "code": "my-package/\n── Cargo.toml          # Package metadata\n── src/\n   ── lib.rs          # Library entry point\n   ── nodes/\n       ── my_node.rs  # Your node implementation\n── examples/\n   ── demo.rs         # Usage example\n── README.md           # Documentation",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1343:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1343,
      "lineEnd": 1352,
      "language": "rust",
      "code": "// src/lib.rs\npub mod nodes;\npub mod messages;\npub mod utils;\n\n// Re-export commonly used items\npub use nodes::MyControllerNode;\npub use messages::MyMessage;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1356:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1356,
      "lineEnd": 1388,
      "language": "rust",
      "code": "// src/nodes/my_node.rs\nuse horus::prelude::*;\n\npub struct MyControllerNode {\n    pub input: Hub<f64>,\n    pub output: Hub<f64>,\n    gain: f64,\n}\n\nimpl MyControllerNode {\n    pub fn new(gain: f64) -> Self {\n        Self {\n            input: Hub::new(\"input\").expect(\"Failed to create input hub\"),\n            output: Hub::new(\"output\").expect(\"Failed to create output hub\"),\n            gain,\n        }\n    }\n}\n\nimpl Node for MyControllerNode {\n    fn name(&self) -> &'static str {\n        \"MyController\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(value) = self.input.recv(&mut ctx) {\n            let result = value * self.gain;\n            self.output.send(result, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1392:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1392,
      "lineEnd": 1405,
      "language": "rust",
      "code": "// examples/demo.rs\nuse my_package::MyControllerNode;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    let controller = MyControllerNode::new(2.5);\n    scheduler.add(Box::new(controller), 5, Some(true));\n\n    scheduler.run().expect(\"Scheduler failed\");\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1408:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1408,
      "lineEnd": 1410,
      "language": "bash",
      "code": "horus run examples/demo.rs --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1417:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1417,
      "lineEnd": 1425,
      "language": "bash",
      "code": "# Good: Focused packages\npid-controller          # Just PID control\nmotion-planner          # Just path planning\nsensor-fusion           # Just sensor fusion\n\n# Bad: Kitchen sink package\nrobotics-everything     # Too broad, hard to maintain",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1428:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1428,
      "lineEnd": 1439,
      "language": "rust",
      "code": "// Good: Simple, clear API\npub struct PIDController {\n    pub fn new(kp: f64, ki: f64, kd: f64) -> Self { ... }\n    pub fn update(&mut self, error: f64) -> f64 { ... }\n}\n\n// Bad: Complex, unclear API\npub struct Controller {\n    pub fn do_stuff(&mut self, x: f64, y: Option<f64>, z: &str) -> Result<Vec<f64>, Box<dyn Error>> { ... }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1444:markdown",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1444,
      "lineEnd": 1457,
      "language": "markdown",
      "code": "# PID Controller\n\nProduction-ready PID controller for HORUS robotics framework.\n\n## Features\n- Anti-windup protection\n- Derivative filtering\n- Output clamping\n\n## Installation\n```bash\nhorus pkg install pid-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1460:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1460,
      "lineEnd": 1465,
      "language": "rust",
      "code": "use pid_controller::PIDController;\n\nlet mut pid = PIDController::new(1.0, 0.1, 0.01);\nlet output = pid.update(error);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1472:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1472,
      "lineEnd": 1486,
      "language": "text",
      "code": "\n### Testing\n\n**Always test before publishing:**\n```bash\n# Run tests\nhorus test\n\n# Run examples\nhorus run examples/demo.rs --release\n\n# Build in release mode\nhorus run --build-only --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1497:markdown",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1497,
      "lineEnd": 1514,
      "language": "markdown",
      "code": "# Changelog\n\n## [1.2.0] - 2025-10-09\n### Added\n- Anti-windup protection\n- Configurable output limits\n\n### Fixed\n- Derivative kick on setpoint change\n\n## [1.1.0] - 2025-09-15\n### Added\n- Derivative filtering\n\n## [1.0.0] - 2025-08-01\n- Initial stable release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1520:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1520,
      "lineEnd": 1547,
      "language": "bash",
      "code": "# 1. Create new project as library\nhorus new my-sensor-lib --rust\n\n# 2. Update Cargo.toml\n[package]\nname = \"my-sensor-lib\"\nversion = \"0.1.6\"\n\n[lib]\nname = \"my_sensor_lib\"\npath = \"src/lib.rs\"\n\n# 3. Implement in src/lib.rs\npub mod drivers;\npub mod calibration;\n\n# 4. Add examples\nmkdir examples\n# Create examples/demo.rs\n\n# 5. Test\nhorus run examples/demo.rs\n\n# 6. Publish\nhorus auth login\nhorus pkg publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1551:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1551,
      "lineEnd": 1558,
      "language": "bash",
      "code": "# Install packages\nhorus pkg install pid-controller\nhorus pkg install motion-planner\nhorus pkg install sensor-fusion\n\n# Use in your project",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1560:rust",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1560,
      "lineEnd": 1576,
      "language": "rust",
      "code": "use pid_controller::PIDController;\nuse motion_planner::AStarPlanner;\nuse sensor_fusion::KalmanFilter;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Combine multiple packages\n    let pid = PIDController::new(1.0, 0.1, 0.01);\n    let planner = AStarPlanner::new();\n    let filter = KalmanFilter::new();\n\n    // Add nodes...\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/package-management/package-management:1580:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1580,
      "lineEnd": 1586,
      "language": "bash",
      "code": "# Update specific package to newer version\nhorus pkg install pid-controller -v 1.3.0\n\n# Check available versions on registry\nhorus pkg list pid-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1593:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1593,
      "lineEnd": 1595,
      "language": "text",
      "code": "Error: Package 'nonexistent-package' not found in registry",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1598:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1598,
      "lineEnd": 1604,
      "language": "bash",
      "code": "# Check spelling\nhorus pkg list nonexistent\n\n# Search registry for correct package name\nhorus pkg list correct-package",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1609:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1609,
      "lineEnd": 1613,
      "language": "text",
      "code": "Error: Version conflict\n  robot-controller requires motion-planner ^2.0\n  sensor-fusion requires motion-planner ^1.5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1616:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1616,
      "lineEnd": 1624,
      "language": "bash",
      "code": "# Option 1: Update conflicting package\nhorus pkg install sensor-fusion -v 2.0.0  # Install compatible version\n\n# Option 2: Pin version manually\n# Edit Cargo.toml:\n[dependencies]\nmotion-planner = \"2.0\"  # Force version 2.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1629:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1629,
      "lineEnd": 1631,
      "language": "text",
      "code": "Error: Failed to build package 'my-package'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1634:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1634,
      "lineEnd": 1644,
      "language": "bash",
      "code": "# Clean and rebuild\nhorus pkg remove my-package\nhorus pkg install my-package\n\n# Check dependencies via registry web interface\n# Visit https://marketplace.horus-registry.dev\n\n# Install dependencies manually if needed\nhorus pkg install dependency-name",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1649:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1649,
      "lineEnd": 1652,
      "language": "text",
      "code": "Error: Authentication required to publish packages\nRun: horus auth login",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1655:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1655,
      "lineEnd": 1658,
      "language": "bash",
      "code": "horus auth login\n# Opens browser for GitHub OAuth",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1663:text",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1663,
      "lineEnd": 1665,
      "language": "text",
      "code": "Error: Failed to connect to registry",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1668:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1668,
      "lineEnd": 1676,
      "language": "bash",
      "code": "# Check internet connection\nping marketplace.horus-registry.dev\n\n# Try again later (registry might be down)\n\n# Use cached packages if available\nls ~/.horus/cache/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1685:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1685,
      "lineEnd": 1687,
      "language": "bash",
      "code": "curl https://marketplace.horus-registry.dev/api/packages?q=sensor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1690:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1690,
      "lineEnd": 1692,
      "language": "bash",
      "code": "curl https://marketplace.horus-registry.dev/api/packages/pid-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/package-management:1695:bash",
      "file": "content/docs/package-management/package-management.mdx",
      "lineStart": 1695,
      "lineEnd": 1697,
      "language": "bash",
      "code": "curl -o pkg.tar.gz https://marketplace.horus-registry.dev/api/packages/pid-controller/1.2.0/download",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:23:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 23,
      "lineEnd": 26,
      "language": "bash",
      "code": "# Install from registry\nhorus pkg install pid-controller",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:28:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 28,
      "lineEnd": 41,
      "language": "rust",
      "code": "use pid_controller::PIDNode;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Configure the pre-built node\n    let pid = PIDNode::new(1.0, 0.1, 0.01);  // kp, ki, kd\n    scheduler.add(Box::new(pid), 5, Some(true));\n\n    scheduler.run().expect(\"Scheduler failed\");\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:52:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 52,
      "lineEnd": 55,
      "language": "bash",
      "code": "# Visit the registry in your browser\nhttps://marketplace.horus-registry.dev",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:65:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 65,
      "lineEnd": 70,
      "language": "bash",
      "code": "# Search for specific functionality\nhorus pkg list sensor\nhorus pkg list controller\nhorus pkg list motor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:76:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 76,
      "lineEnd": 92,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Sensor nodes\nCameraNode, LidarNode, ImuNode\n\n// Control nodes\nPidControllerNode, DifferentialDriveNode\n\n// Input nodes\nKeyboardInputNode, JoystickInputNode\n\n// Safety nodes\nEmergencyStopNode, SafetyMonitorNode\n\n// And many more...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:100:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 100,
      "lineEnd": 109,
      "language": "bash",
      "code": "# Latest version\nhorus pkg install motion-planner\n\n# Specific version\nhorus pkg install sensor-fusion -v 2.1.0\n\n# Multiple packages\nhorus pkg install pid-controller motion-planner sensor-drivers",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:113:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 113,
      "lineEnd": 117,
      "language": "bash",
      "code": "# Rust packages are auto-detected\nhorus pkg install serde\nhorus pkg install tokio -v 1.35.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:121:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 121,
      "lineEnd": 125,
      "language": "bash",
      "code": "# Python packages are auto-detected\nhorus pkg install numpy\nhorus pkg install opencv-python",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:131:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 131,
      "lineEnd": 134,
      "language": "bash",
      "code": "horus run main.rs\n# horus_library is included by default",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:138:yaml",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 138,
      "lineEnd": 142,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n  - name: horus_library",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:146:toml",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 146,
      "lineEnd": 150,
      "language": "toml",
      "code": "[dependencies]\nhorus = \"0.1\"\nhorus_library = \"0.1\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:167:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 167,
      "lineEnd": 175,
      "language": "bash",
      "code": "# Check what's available\nhorus pkg list keyboard\nhorus pkg list motor\n\n# Install what you need\nhorus pkg install keyboard-input\nhorus pkg install differential-drive",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:179:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 179,
      "lineEnd": 202,
      "language": "rust",
      "code": "use keyboard_input::KeyboardNode;\nuse differential_drive::DiffDriveNode;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Keyboard input node (priority 0 - runs first)\n    let keyboard = KeyboardNode::new(\"keyboard.input\")?;\n    scheduler.add(Box::new(keyboard), 0, Some(true));\n\n    // Differential drive controller (priority 5)\n    let drive = DiffDriveNode::new(\n        \"keyboard.input\",   // Input topic\n        \"motor.left\",       // Left motor output\n        \"motor.right\",      // Right motor output\n        0.5                 // Wheel separation (meters)\n    )?;\n    scheduler.add(Box::new(drive), 5, Some(true));\n\n    scheduler.run()?;\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:212:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 212,
      "lineEnd": 217,
      "language": "bash",
      "code": "# Install components\nhorus pkg install keyboard-input\nhorus pkg install differential-drive\nhorus pkg install emergency-stop",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:219:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 219,
      "lineEnd": 248,
      "language": "rust",
      "code": "use keyboard_input::KeyboardNode;\nuse differential_drive::DiffDriveNode;\nuse emergency_stop::EStopNode;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Input\n    scheduler.add(\n        Box::new(KeyboardNode::new(\"keyboard\")?),\n        0, Some(true)\n    );\n\n    // Safety (runs first!)\n    scheduler.add(\n        Box::new(EStopNode::new(\"estop\", \"cmd_vel\")?),\n        0, Some(true)\n    );\n\n    // Drive control\n    scheduler.add(\n        Box::new(DiffDriveNode::new(\"cmd_vel\", \"motor.left\", \"motor.right\", 0.5)?),\n        1, Some(true)\n    );\n\n    scheduler.run()?;\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:252:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 252,
      "lineEnd": 256,
      "language": "bash",
      "code": "horus pkg install lidar-driver\nhorus pkg install imu-driver\nhorus pkg install kalman-filter",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:258:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 258,
      "lineEnd": 285,
      "language": "rust",
      "code": "use lidar_driver::LidarNode;\nuse imu_driver::ImuNode;\nuse kalman_filter::EKFNode;\nuse horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Sensors (priority 2)\n    scheduler.add(\n        Box::new(LidarNode::new(\"/dev/ttyUSB0\", \"scan\")?),\n        2, Some(true)\n    );\n    scheduler.add(\n        Box::new(ImuNode::new(\"/dev/i2c-1\", \"imu\")?),\n        2, Some(true)\n    );\n\n    // Fusion (priority 3 - runs after sensors)\n    scheduler.add(\n        Box::new(EKFNode::new(\"scan\", \"imu\", \"pose\")?),\n        3, Some(true)\n    );\n\n    scheduler.run()?;\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:289:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 289,
      "lineEnd": 306,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() {\n    let mut scheduler = Scheduler::new();\n\n    // Using standard library nodes\n    let camera = CameraNode::new(\"/dev/video0\", \"camera.raw\", 30)?;\n    let processor = ImageProcessorNode::new(\"camera.raw\", \"camera.processed\")?;\n    let detector = ObjectDetectorNode::new(\"camera.processed\", \"objects\")?;\n\n    scheduler.add(Box::new(camera), 2, Some(true));\n    scheduler.add(Box::new(processor), 3, Some(true));\n    scheduler.add(Box::new(detector), 3, Some(true));\n\n    scheduler.run()?;\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:316:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 316,
      "lineEnd": 323,
      "language": "rust",
      "code": "let camera = CameraNode::new(\"/dev/video0\")?\n    .with_resolution(1920, 1080)\n    .with_fps(60)\n    .with_format(ImageFormat::RGB8);\n\nscheduler.add(Box::new(camera), 2, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:329:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 329,
      "lineEnd": 339,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Set parameters\nset_param(\"motor.max_speed\", 2.0)?;\nset_param(\"motor.acceleration\", 0.5)?;\n\n// Node reads from parameters\nlet motor = MotorNode::from_params()?;\nscheduler.add(Box::new(motor), 1, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:345:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 345,
      "lineEnd": 351,
      "language": "bash",
      "code": "# Save your configuration\nhorus env freeze -o robot-config.yaml\n\n# Deploy to another robot\nhorus env restore robot-config.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:361:text",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 361,
      "lineEnd": 363,
      "language": "text",
      "code": "[Sensor] --topic--> [Filter] --topic--> [Controller] --topic--> [Actuator]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:365:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 365,
      "lineEnd": 371,
      "language": "rust",
      "code": "// Each node subscribes to previous, publishes to next\nscheduler.add(Box::new(sensor), 2, Some(true));    // Publishes \"raw\"\nscheduler.add(Box::new(filter), 3, Some(true));    // Subscribes \"raw\", publishes \"filtered\"\nscheduler.add(Box::new(controller), 4, Some(true)); // Subscribes \"filtered\", publishes \"cmd\"\nscheduler.add(Box::new(actuator), 5, Some(true));   // Subscribes \"cmd\"",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:377:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 377,
      "lineEnd": 382,
      "language": "rust",
      "code": "// All run in parallel (priority 2)\nscheduler.add(Box::new(lidar), 2, Some(true));\nscheduler.add(Box::new(camera), 2, Some(true));\nscheduler.add(Box::new(imu), 2, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:388:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 388,
      "lineEnd": 401,
      "language": "rust",
      "code": "// Priority 0 - Safety checks (runs first)\nscheduler.add(Box::new(watchdog), 0, Some(true));\nscheduler.add(Box::new(estop), 0, Some(true));\n\n// Priority 1 - Control\nscheduler.add(Box::new(controller), 1, Some(true));\n\n// Priority 2 - Sensors\nscheduler.add(Box::new(lidar), 2, Some(true));\n\n// Priority 4 - Logging (runs last)\nscheduler.add(Box::new(logger), 4, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:437:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 437,
      "lineEnd": 442,
      "language": "bash",
      "code": "# Search by device type\nhorus pkg list lidar\nhorus pkg list camera\nhorus pkg list imu",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:461:text",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 461,
      "lineEnd": 463,
      "language": "text",
      "code": "Downloads: 5,234 (last 30 days)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:466:text",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 466,
      "lineEnd": 468,
      "language": "text",
      "code": "Last updated: 2025-09-28",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:471:text",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 471,
      "lineEnd": 473,
      "language": "text",
      "code": "Documentation: 98% coverage",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:476:text",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 476,
      "lineEnd": 478,
      "language": "text",
      "code": "Issues: 2 open, 45 closed (96% resolution rate)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:487:bash",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 487,
      "lineEnd": 493,
      "language": "bash",
      "code": "horus pkg install lidar-driver\nhorus pkg install obstacle-detector\nhorus pkg install path-planner\nhorus pkg install differential-drive\nhorus pkg install emergency-stop",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/package-management/using-prebuilt-nodes:496:rust",
      "file": "content/docs/package-management/using-prebuilt-nodes.mdx",
      "lineStart": 496,
      "lineEnd": 540,
      "language": "rust",
      "code": "use lidar_driver::LidarNode;\nuse obstacle_detector::ObstacleDetectorNode;\nuse path_planner::LocalPlannerNode;\nuse differential_drive::DiffDriveNode;\nuse emergency_stop::EStopNode;\nuse horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Safety (Priority 0 - runs first)\n    scheduler.add(\n        Box::new(EStopNode::new(\"estop\", \"cmd_vel\")?),\n        0, Some(true)\n    );\n\n    // Sensors (Priority 2)\n    scheduler.add(\n        Box::new(LidarNode::new(\"/dev/ttyUSB0\", \"scan\")?),\n        2, Some(true)\n    );\n\n    // Perception (Priority 3)\n    scheduler.add(\n        Box::new(ObstacleDetectorNode::new(\"scan\", \"obstacles\")?),\n        3, Some(true)\n    );\n\n    // Planning (Priority 4)\n    scheduler.add(\n        Box::new(LocalPlannerNode::new(\"obstacles\", \"cmd_vel\")?),\n        4, Some(true)\n    );\n\n    // Control (Priority 5)\n    scheduler.add(\n        Box::new(DiffDriveNode::new(\"cmd_vel\", \"motor.left\", \"motor.right\", 0.5)?),\n        5, Some(true)\n    );\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:72:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 72,
      "lineEnd": 76,
      "language": "text",
      "code": "Average Latency: ~500 ns (Hub MPMC)\nThroughput:      2.7M msg/s\nLink SPSC:       248 ns median",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:87:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 87,
      "lineEnd": 91,
      "language": "text",
      "code": "Average Latency: ~2.2 μs (Hub MPMC)\nThroughput:      633K msg/s\nLink SPSC:       ~900 ns estimated",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:102:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 102,
      "lineEnd": 106,
      "language": "text",
      "code": "Average Latency: ~940 ns (Hub MPMC)\nThroughput:      1.8M msg/s\nLink SPSC:       ~400 ns estimated",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:117:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 117,
      "lineEnd": 121,
      "language": "text",
      "code": "Average Latency: ~1.1 μs (Hub MPMC)\nThroughput:      1.3M msg/s\nLink SPSC:       ~600 ns estimated",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:130:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 130,
      "lineEnd": 134,
      "language": "text",
      "code": "Average Latency: 1.85 μs\nThroughput:      539,529 msg/s\nData Size:       ~1.2 KB",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:137:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 137,
      "lineEnd": 141,
      "language": "text",
      "code": "Average Latency: 7.55 μs\nThroughput:      132,432 msg/s\nData Size:       ~12 KB",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:144:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 144,
      "lineEnd": 148,
      "language": "text",
      "code": "Average Latency: ~360 μs (Hub MPMC)\nThroughput:      4.7K msg/s\nData Size:       ~120 KB",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:159:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 159,
      "lineEnd": 164,
      "language": "text",
      "code": "Total Operations: 20,100 messages\nAverage Latency:  ~1.0 μs (Hub MPMC)\nThroughput:       ~1.5M msg/s\nRange:            ~500-1200 ns",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:247:python",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 247,
      "lineEnd": 261,
      "language": "python",
      "code": "from horus import Hub, CmdVel, Pose2D, Imu, Odometry, LaserScan\n\n# Create typed hub (zero-copy shared memory)\nhub = Hub(CmdVel)\nmsg = CmdVel(linear=1.5, angular=0.5)\n\n# Measure send latency\nhub.send(msg)  # ~5-10 μs\n\n# Round-trip test\nrecv_hub = Hub(CmdVel)\nhub.send(msg)\nreceived = recv_hub.recv()  # ~10-20 μs round-trip",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:267:python",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 267,
      "lineEnd": 271,
      "language": "python",
      "code": "# Small messages (CmdVel 16B): 100K+ msg/s\n# Medium messages (IMU 304B): 80K+ msg/s\n# Large messages (LaserScan 1.5KB): 40K+ msg/s",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:288:python",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 288,
      "lineEnd": 296,
      "language": "python",
      "code": "# Tests run:\n# 1. HORUS typed Hub (zero-copy)\n# 2. Python multiprocessing.Queue (pickle)\n# 3. Python shared_memory (manual struct.pack)\n# 4. pickle serialization overhead\n# 5. ZeroMQ inproc (optional)\n# 6. Redis pub/sub (optional)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:302:bash",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 302,
      "lineEnd": 309,
      "language": "bash",
      "code": "# Install HORUS Python bindings\ncd horus_py\nmaturin develop --release\n\n# Optional: Install comparison frameworks\npip install pyzmq redis",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:313:bash",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 313,
      "lineEnd": 325,
      "language": "bash",
      "code": "# Full benchmark suite\npython -m horus_py.benchmarks.run_all\n\n# Quick mode (fewer iterations)\npython -m horus_py.benchmarks.run_all --quick\n\n# JSON output\npython -m horus_py.benchmarks.run_all --json\n\n# Save results\npython -m horus_py.benchmarks.run_all --output results.json",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:329:bash",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 329,
      "lineEnd": 341,
      "language": "bash",
      "code": "# IPC latency\npython -m horus_py.benchmarks.ipc_latency\n\n# Throughput\npython -m horus_py.benchmarks.throughput\n\n# Stress test\npython -m horus_py.benchmarks.stress_test\n\n# Comparison vs alternatives\npython -m horus_py.benchmarks.comparison",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:345:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 345,
      "lineEnd": 371,
      "language": "text",
      "code": "======================================================================\n  HORUS Python IPC Latency Benchmark Suite\n  Testing with real robotics message types\n======================================================================\n\n----------------------------------------------------------------------\n  CmdVel (Motor Control Command)\n  Use case: Real-time motor control @ 1000Hz\n----------------------------------------------------------------------\n\n  CmdVel send (typed, zero-copy)\n    Message Size: 16 bytes\n    Iterations:   10,000\n    Latency (avg): 6.23 μs\n    Latency (p50): 5.89 μs\n    Latency (p95): 8.12 μs\n    Latency (p99): 12.34 μs\n    Throughput:    160,514 ops/sec\n\n  CmdVel round-trip (send + recv)\n    Message Size: 16 bytes\n    Iterations:   1,000\n    Latency (avg): 12.45 μs\n    Latency (p50): 11.23 μs\n    Throughput:    80,321 ops/sec",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:394:python",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 394,
      "lineEnd": 404,
      "language": "python",
      "code": "# Python node sends to Rust node (same shared memory!)\nfrom horus import Hub, CmdVel\n\n# Python publisher\npub = Hub(CmdVel)\npub.send(CmdVel(linear=1.0, angular=0.5))\n\n# Rust subscriber receives instantly (zero-copy)\n# Both use the same /dev/shm/horus/topics/CmdVel",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:440:python",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 440,
      "lineEnd": 460,
      "language": "python",
      "code": "from horus import TensorPool\nimport numpy as np\nimport time\n\n# Create pool (unique ID avoids stale data)\npool = TensorPool(12345)  # pool_id\n\n# Allocate tensor\nh = pool.alloc([1024, 1024], 'float32')\n\n# Zero-copy NumPy view\narr = h.numpy()  # ~15 μs, no data copied\n\n# Write data (actual memcpy)\ndata = np.random.rand(1024, 1024).astype(np.float32)\nnp.copyto(arr, data)  # ~2 ms for 4MB\n\n# Cross-process sharing\ndescriptor = h.to_descriptor()  # Share with other processes",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:475:bash",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 475,
      "lineEnd": 479,
      "language": "bash",
      "code": "cd horus\ncargo build --release --bin ipc_benchmark\n./target/release/ipc_benchmark",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:483:text",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 483,
      "lineEnd": 500,
      "language": "text",
      "code": "\n  HORUS Production Message Benchmark Suite\n  Testing with real robotics message types\n\n\n  CmdVel (Motor Control Command)\n    Size: 16 bytes | Typical rate: 1000Hz\n    Latency (avg): ~500 ns (Hub) / 248 ns (Link)\n    Throughput: 2.7M msg/s (Hub)\n\n\n  LaserScan (2D Lidar Data)\n    Size: 1480 bytes | Typical rate: 10Hz\n    Latency (avg): ~2.2 μs (Hub) / ~900 ns (Link)\n    Throughput: 633K msg/s (Hub)\n",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/benchmarks:719:rust",
      "file": "content/docs/performance/benchmarks.mdx",
      "lineStart": 719,
      "lineEnd": 721,
      "language": "rust",
      "code": "scheduler.set_config(SchedulerConfig::safety_critical());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:42:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 42,
      "lineEnd": 47,
      "language": "rust",
      "code": "#[repr(align(64))]  // Cache-line aligned\npub struct Hub<T> {\n    // Prevents false sharing between cores\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:90:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 90,
      "lineEnd": 96,
      "language": "bash",
      "code": "# SLOW: Debug build\nhorus run\n\n# FAST: Release build\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:107:toml",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 107,
      "lineEnd": 113,
      "language": "toml",
      "code": "# Cargo.toml\n[profile.release]\nopt-level = 3\nlto = \"fat\"\ncodegen-units = 1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:156:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 156,
      "lineEnd": 164,
      "language": "bash",
      "code": "# Check available SIMD features\nrustc --print cfg | grep target_feature\n\n# Common features on modern CPUs:\n# target_feature=\"avx2\"\n# target_feature=\"avx512f\" (newer CPUs)\n# target_feature=\"sse4.2\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:170:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 170,
      "lineEnd": 176,
      "language": "bash",
      "code": "# Build for your specific CPU\nRUSTFLAGS=\"-C target-cpu=native\" cargo build --release\n\n# Or specify features explicitly\nRUSTFLAGS=\"-C target-feature=+avx2,+avx512f\" cargo build --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:208:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 208,
      "lineEnd": 218,
      "language": "rust",
      "code": "// At runtime, check CPU features\n#[cfg(target_arch = \"x86_64\")]\n{\n    if is_x86_feature_detected!(\"avx512f\") {\n        println!(\"AVX-512 acceleration enabled\");\n    } else if is_x86_feature_detected!(\"avx2\") {\n        println!(\"AVX2 acceleration enabled\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:224:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 224,
      "lineEnd": 234,
      "language": "rust",
      "code": "// FAST: Fixed-size array\npub struct LaserScan {\n    pub ranges: [f32; 360],  // Stack-allocated\n}\n\n// SLOW: Dynamic vector\npub struct BadLaserScan {\n    pub ranges: Vec<f32>,  // Heap-allocated\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:240:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 240,
      "lineEnd": 251,
      "language": "rust",
      "code": "// FAST: Typed message (Rust)\nlet hub: Hub<Pose2D> = Hub::new(\"pose\")?;\nhub.send(Pose2D::new(1.0, 2.0, 0.5), &mut ctx)?;\n// IPC latency: ~500ns\n\n// SLOW: Generic message\nlet hub: Hub<GenericMessage> = Hub::new(\"pose\")?;\nlet data = GenericMessage::from_value(&pose_dict)?;\nhub.send(data, &mut ctx)?;\n// IPC latency: ~10µs (20x slower!)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/performance/performance:253:python",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 253,
      "lineEnd": 265,
      "language": "python",
      "code": "# FAST: Typed hub (Python)\nfrom horus import Node, Pose2D\n\nnode = Node(pubs={\"pose\": {\"type\": Pose2D}})\nnode.send(\"pose\", Pose2D(x=1.0, y=2.0, theta=0.5))\n# IPC: ~500ns, Logging: ~100ns\n\n# SLOW: Generic hub\nnode = Node(pubs=[\"pose\"])\nnode.send(\"pose\", {\"x\": 1.0, \"y\": 2.0, \"theta\": 0.5})\n# IPC: ~10µs, Logging: ~5µs (100x slower logging!)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:279:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 279,
      "lineEnd": 291,
      "language": "rust",
      "code": "// f32 (single precision) - sufficient for most robotics\npub struct FastPose {\n    pub x: f32,  // 4 bytes\n    pub y: f32,  // 4 bytes\n}\n\n// f64 (double precision) - scientific applications\npub struct PrecisePose {\n    pub x: f64,  // 8 bytes\n    pub y: f64,  // 8 bytes\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:297:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 297,
      "lineEnd": 311,
      "language": "rust",
      "code": "// GOOD: 8 bytes\nstruct CompactCmd {\n    linear: f32,   // 4 bytes\n    angular: f32,  // 4 bytes\n}\n\n// BAD: 1KB+ bytes\nstruct BloatedCmd {\n    linear: f32,\n    angular: f32,\n    metadata: [u8; 256],    // Unused\n    debug_info: [u8; 768],  // Unused\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:319:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 319,
      "lineEnd": 330,
      "language": "rust",
      "code": "// SLOW: 100 separate messages\nfor value in values {\n    hub.send(value, &mut ctx).ok();  // 100 IPC operations\n}\n\n// FAST: One batched message\npub struct BatchedData {\n    values: [f32; 100],\n}\nhub.send(batched, &mut ctx).ok();  // 1 IPC operation",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:340:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 340,
      "lineEnd": 352,
      "language": "rust",
      "code": "// GOOD: Fast tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = self.read_sensor();     // Quick read\n    self.process_pub.send(data, &mut ctx).ok();  // ~500ns\n}\n\n// BAD: Slow tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = std::fs::read_to_string(\"config.yaml\").unwrap();  // 1-10ms!\n    // ...\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:358:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 358,
      "lineEnd": 376,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    // Pre-allocate buffers\n    self.buffer = vec![0.0; 10000];\n\n    // Open connections\n    self.device = Device::open()?;\n\n    // Load configuration\n    self.config = Config::from_file(\"config.yaml\")?;\n\n    Ok(())\n}\n\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Use pre-allocated resources - no allocations here!\n    self.buffer[0] = self.device.read();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/performance/performance:382:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 382,
      "lineEnd": 397,
      "language": "rust",
      "code": "// BAD: Unnecessary clone\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(data) = self.sub.recv(&mut ctx) {\n        let copy = data.clone();  // Unnecessary!\n        self.process(copy);\n    }\n}\n\n// GOOD: Direct use\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(data) = self.sub.recv(&mut ctx) {\n        self.process(data);  // Already cloned by recv()\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:403:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 403,
      "lineEnd": 417,
      "language": "rust",
      "code": "// BAD: Logging every tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    ctx.log_debug(&format!(\"Tick #{}\", self.counter));  // Slow!\n    self.counter += 1;\n}\n\n// GOOD: Conditional logging\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if self.counter % 1000 == 0 {  // Log every 1000 ticks\n        ctx.log_info(&format!(\"Reached tick #{}\", self.counter));\n    }\n    self.counter += 1;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:427:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 427,
      "lineEnd": 430,
      "language": "rust",
      "code": "let scheduler = Scheduler::new();\n// Runs at ~60 FPS (16ms per tick)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:438:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 438,
      "lineEnd": 444,
      "language": "rust",
      "code": "// Critical tasks run first (priority 0 = highest)\nscheduler.add(Box::new(safety), 0, None);\n\n// Logging runs last (priority 100 = lowest)\nscheduler.add(Box::new(logger), 100, None);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:450:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 450,
      "lineEnd": 458,
      "language": "rust",
      "code": "// BAD: 50 small nodes\nfor i in 0..50 {\n    scheduler.add(Box::new(TinyNode::new(i)), 50, None);\n}\n\n// GOOD: One aggregated node\nscheduler.add(Box::new(AggregatedNode::new()), 50, None);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:480:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 480,
      "lineEnd": 483,
      "language": "bash",
      "code": "# Build with io_uring support\nhorus build --release --enable io-uring-net",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:493:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 493,
      "lineEnd": 496,
      "language": "bash",
      "code": "# Batch UDP is automatically enabled on Linux - no extra dependencies needed\nhorus build --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:503:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 503,
      "lineEnd": 506,
      "language": "bash",
      "code": "# Build with all ultra-low-latency features (io_uring)\nhorus build --release --enable ultra-low-latency",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:515:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 515,
      "lineEnd": 519,
      "language": "rust",
      "code": "// Transport is automatically selected\nlet hub: Hub<SensorData> = Hub::new(\"sensor@192.168.1.100:9870\")?;\n// Uses: io_uring > Batch UDP > Standard UDP (based on availability)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/performance/performance:523:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 523,
      "lineEnd": 528,
      "language": "rust",
      "code": "// In node context\nif let Some(ctx) = &ctx {\n    ctx.log_info(&format!(\"Transport: {}\", hub.transport_type()));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:534:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 534,
      "lineEnd": 536,
      "language": "bash",
      "code": "df -h /dev/shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:542:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 542,
      "lineEnd": 545,
      "language": "bash",
      "code": "# Increase to 4GB\nsudo mount -o remount,size=4G /dev/shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:553:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 553,
      "lineEnd": 556,
      "language": "bash",
      "code": "# Clean all HORUS shared memory (if needed after crashes)\nrm -rf /dev/shm/horus/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:562:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 562,
      "lineEnd": 568,
      "language": "rust",
      "code": "// Small messages, high frequency\nShmTopic::new(\"cmd_vel\", 100)?;  // 100 slots\n\n// Large messages, low frequency\nShmTopic::new(\"point_cloud\", 10)?;  // 10 slots",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/performance/performance:578:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 578,
      "lineEnd": 586,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(ctx) = ctx {\n        if ctx.metrics.avg_tick_duration_ms > 1.0 {\n            ctx.log_warning(\"Tick taking too long\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:599:text",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 599,
      "lineEnd": 601,
      "language": "text",
      "code": "[12:34:56.789] [IPC: 296ns | Tick: 12µs] PublisherNode --PUB--> 'cmd_vel' = 1.5",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:608:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 608,
      "lineEnd": 619,
      "language": "rust",
      "code": "use std::time::Instant;\n\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let start = Instant::now();\n\n    self.expensive_operation();\n\n    let duration = start.elapsed();\n    println!(\"Operation took: {:?}\", duration);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:625:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 625,
      "lineEnd": 631,
      "language": "bash",
      "code": "# Profile your application\nperf record --call-graph dwarf horus run --release\n\n# View results\nperf report",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:639:bash",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 639,
      "lineEnd": 645,
      "language": "bash",
      "code": "# SLOW: 50µs/tick\nhorus run\n\n# FAST: 500ns/tick\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:651:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 651,
      "lineEnd": 666,
      "language": "rust",
      "code": "// BAD\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let buffer = vec![0.0; 1000];  // Heap allocation every tick!\n}\n\n// GOOD\nstruct Node {\n    buffer: Vec<f32>,  // Pre-allocated\n}\n\nfn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    self.buffer = vec![0.0; 1000];  // Allocate once\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:672:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 672,
      "lineEnd": 685,
      "language": "rust",
      "code": "// BAD: 60 logs per second\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    ctx.log_debug(\"Tick\");  // Every 16ms!\n}\n\n// GOOD: 1 log per second\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    self.tick_count += 1;\n    if self.tick_count % 60 == 0 {\n        ctx.log_info(\"60 ticks completed\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:691:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 691,
      "lineEnd": 701,
      "language": "rust",
      "code": "// BAD: 1MB per message\npub struct HugeMessage {\n    image: [u8; 1_000_000],\n}\n\n// GOOD: Compressed or separate channel\npub struct CompressedImage {\n    data: Vec<u8>,  // JPEG compressed, ~50KB\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/performance/performance:707:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 707,
      "lineEnd": 718,
      "language": "rust",
      "code": "// BAD: Blocking I/O\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = std::fs::read(\"data.txt\").unwrap();  // Blocks!\n}\n\n// GOOD: Async or pre-loaded\nfn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    self.data = std::fs::read(\"data.txt\")?;  // Load once\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/performance/performance:740:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 740,
      "lineEnd": 764,
      "language": "rust",
      "code": "use std::time::Instant;\n\nstruct BenchmarkNode {\n    pub_hub: Hub<f32>,\n    sub_hub: Hub<f32>,\n    start_time: Option<Instant>,\n}\n\nimpl Node for BenchmarkNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Publish\n        self.start_time = Some(Instant::now());\n        self.pub_hub.send(42.0, &mut ctx).ok();\n\n        // Receive\n        if let Some(data) = self.sub_hub.recv(&mut ctx) {\n            if let Some(start) = self.start_time {\n                let latency = start.elapsed();\n                println!(\"Round-trip latency: {:?}\", latency);\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:768:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 768,
      "lineEnd": 789,
      "language": "rust",
      "code": "struct ThroughputTest {\n    pub_hub: Hub<f32>,\n    message_count: u64,\n    start_time: Instant,\n}\n\nimpl Node for ThroughputTest {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        for _ in 0..1000 {\n            self.pub_hub.send(42.0, &mut ctx).ok();\n            self.message_count += 1;\n        }\n\n        if self.message_count % 100_000 == 0 {\n            let elapsed = self.start_time.elapsed().as_secs_f64();\n            let throughput = self.message_count as f64 / elapsed;\n            println!(\"Throughput: {:.0} msg/s\", throughput);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/performance/performance:795:rust",
      "file": "content/docs/performance/performance.mdx",
      "lineStart": 795,
      "lineEnd": 807,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Configure for hard real-time operation\nlet config = RtConfig::hard_realtime(Some(&[2, 3]));  // Pin to isolated cores\nconfig.apply()?;\n\n// This enables:\n// - mlockall() - No page faults\n// - SCHED_FIFO priority 80 - Preempts normal processes\n// - CPU affinity - No migration jitter\n// - Stack prefaulting - No lazy allocation",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/python/api/async-nodes:22:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 22,
      "lineEnd": 45,
      "language": "python",
      "code": "import horus\nimport asyncio\n\nclass MyAsyncNode(horus.AsyncNode):\n    async def setup(self):\n        \"\"\"Called once at startup\"\"\"\n        self.hub = horus.AsyncHub(\"sensor_data\", dict)\n        self.api_url = \"https://api.example.com/data\"\n\n    async def tick(self):\n        \"\"\"Called each scheduler cycle - use await freely!\"\"\"\n        # Fetch from HTTP API (non-blocking)\n        async with aiohttp.ClientSession() as session:\n            async with session.get(self.api_url) as response:\n                data = await response.json()\n\n        # Publish to HORUS topic\n        await self.hub.send(data)\n\n    async def shutdown(self):\n        \"\"\"Called once at shutdown\"\"\"\n        print(\"Node shutting down\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:57:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 57,
      "lineEnd": 69,
      "language": "python",
      "code": "import horus\n\n# Create scheduler\nscheduler = horus.Scheduler()\n\n# Add async node\nnode = MyAsyncNode()\nscheduler.add(node, priority=0)\n\n# Run - scheduler handles the async event loop\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:75:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 75,
      "lineEnd": 89,
      "language": "python",
      "code": "import horus\n\n# Create async hub\nhub = horus.AsyncHub(\"my_topic\", str)\n\n# Async send\nawait hub.send(\"hello world\")\n\n# Async receive (waits for message)\nmsg = await hub.recv()\n\n# Try receive (returns None immediately if no message)\nmsg = await hub.try_recv()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:93:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 93,
      "lineEnd": 112,
      "language": "python",
      "code": "class AsyncHub:\n    def __init__(self, topic: str, msg_type: type):\n        \"\"\"Create async hub for topic with message type\"\"\"\n\n    async def send(self, msg: Any) -> None:\n        \"\"\"Send message asynchronously\"\"\"\n\n    async def recv(self) -> Any:\n        \"\"\"Receive message, waiting until available\"\"\"\n\n    async def try_recv(self) -> Optional[Any]:\n        \"\"\"Try to receive, returns None if no message\"\"\"\n\n    def subscribe(self, callback: Callable) -> None:\n        \"\"\"Subscribe with synchronous callback\"\"\"\n\n    async def async_subscribe(self, async_callback: Callable) -> None:\n        \"\"\"Subscribe with async callback\"\"\"",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:118:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 118,
      "lineEnd": 126,
      "language": "python",
      "code": "async def handle_sensor_data(msg):\n    \"\"\"Async callback - can use await!\"\"\"\n    processed = await process_data(msg)\n    await database.save(processed)\n\nhub = horus.AsyncHub(\"sensors\", dict)\nawait hub.async_subscribe(handle_sensor_data)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:132:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 132,
      "lineEnd": 150,
      "language": "python",
      "code": "import horus\n\n# Non-blocking sleep\nawait horus.sleep(0.1)\n\n# Run multiple async operations concurrently\nresults = await horus.gather(\n    fetch_sensor_a(),\n    fetch_sensor_b(),\n    fetch_sensor_c()\n)\n\n# Wait with timeout\ntry:\n    result = await horus.wait_for(slow_operation(), timeout=5.0)\nexcept asyncio.TimeoutError:\n    print(\"Operation timed out\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:154:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 154,
      "lineEnd": 217,
      "language": "python",
      "code": "import horus\nimport aiohttp\nimport asyncio\n\nclass WeatherNode(horus.AsyncNode):\n    \"\"\"Fetches weather data from API and publishes to HORUS\"\"\"\n\n    async def setup(self):\n        self.weather_pub = horus.AsyncHub(\"weather\", dict)\n        self.location = \"San Francisco\"\n        self.api_key = \"your-api-key\"\n        self.session = aiohttp.ClientSession()\n\n    async def tick(self):\n        url = f\"https://api.weather.com/v1/{self.location}?key={self.api_key}\"\n\n        try:\n            async with self.session.get(url) as response:\n                if response.status == 200:\n                    data = await response.json()\n                    await self.weather_pub.send({\n                        \"temperature\": data[\"temp\"],\n                        \"humidity\": data[\"humidity\"],\n                        \"timestamp\": data[\"timestamp\"]\n                    })\n        except aiohttp.ClientError as e:\n            print(f\"API error: {e}\")\n\n    async def shutdown(self):\n        await self.session.close()\n\n\nclass WeatherConsumer(horus.AsyncNode):\n    \"\"\"Consumes weather data and logs to database\"\"\"\n\n    async def setup(self):\n        self.weather_sub = horus.AsyncHub(\"weather\", dict)\n        # Setup async database connection\n        self.db = await asyncpg.connect(\"postgresql://localhost/robotics\")\n\n    async def tick(self):\n        weather = await self.weather_sub.try_recv()\n        if weather:\n            await self.db.execute(\n                \"INSERT INTO weather_log (temp, humidity, ts) VALUES ($1, $2, $3)\",\n                weather[\"temperature\"],\n                weather[\"humidity\"],\n                weather[\"timestamp\"]\n            )\n\n    async def shutdown(self):\n        await self.db.close()\n\n\ndef main():\n    scheduler = horus.Scheduler()\n    scheduler.add(WeatherNode(), priority=0)\n    scheduler.add(WeatherConsumer(), priority=1)\n    scheduler.run()\n\nif __name__ == \"__main__\":\n    main()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/async-nodes:237:python",
      "file": "content/docs/python/api/async-nodes.mdx",
      "lineStart": 237,
      "lineEnd": 258,
      "language": "python",
      "code": "import horus\n\nclass SyncSensorNode(horus.Node):\n    \"\"\"Regular sync node for fast sensor reading\"\"\"\n    def tick(self):\n        reading = self.sensor.read()  # Fast, blocking is OK\n        self.hub.send(reading)\n\nclass AsyncCloudNode(horus.AsyncNode):\n    \"\"\"Async node for cloud upload\"\"\"\n    async def tick(self):\n        msg = await self.hub.try_recv()\n        if msg:\n            await self.upload_to_cloud(msg)\n\n# Both work together\nscheduler = horus.Scheduler()\nscheduler.add(SyncSensorNode(), priority=0)  # High priority, runs first\nscheduler.add(AsyncCloudNode(), priority=10)  # Lower priority\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:24:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 24,
      "lineEnd": 47,
      "language": "python",
      "code": "from horus.msggen import define_message\n\n# Define a custom message type\nRobotStatus = define_message('RobotStatus', 'robot/status', [\n    ('battery_level', 'f32'),\n    ('error_code', 'i32'),\n    ('is_active', 'bool'),\n    ('timestamp', 'u64'),\n])\n\n# Create instances\nstatus = RobotStatus(battery_level=85.0, error_code=0, is_active=True, timestamp=0)\n\n# Access fields\nprint(status.battery_level)  # 85.0\nstatus.error_code = 5\n\n# Serialize for IPC\nraw_bytes = status.to_bytes()  # 17 bytes\n\n# Reconstruct from bytes\nstatus2 = RobotStatus.from_bytes(raw_bytes)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:69:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 69,
      "lineEnd": 90,
      "language": "python",
      "code": "from horus.msggen import define_numpy_message\nimport numpy as np\n\n# NumPy-based message (uses structured arrays internally)\nSensorData = define_numpy_message('SensorData', 'sensor/data', [\n    ('x', np.float32),\n    ('y', np.float32),\n    ('z', np.float32),\n    ('temperature', np.float32),\n    ('timestamp', np.uint64),\n])\n\n# Create instance\ndata = SensorData(x=1.0, y=2.0, z=3.0, temperature=25.5, timestamp=0)\n\n# Get underlying numpy structured array\narr = data.to_numpy()\n\n# Zero-copy bytes access\nraw = data.to_bytes()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:96:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 96,
      "lineEnd": 115,
      "language": "python",
      "code": "from horus import Hub\nfrom horus.msggen import define_message\n\n# Define message\nRobotStatus = define_message('RobotStatus', 'robot/status', [\n    ('battery_level', 'f32'),\n    ('error_code', 'i32'),\n])\n\n# Publisher\npub_hub = Hub(RobotStatus)\nstatus = RobotStatus(battery_level=85.0, error_code=0)\npub_hub.send(status)\n\n# Subscriber (different process)\nsub_hub = Hub(RobotStatus)\nreceived = sub_hub.recv()  # Returns RobotStatus\nprint(received.battery_level)  # 85.0",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:125:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 125,
      "lineEnd": 141,
      "language": "python",
      "code": "from horus.msggen import register_message\n\n# Register one or more messages\nregister_message('RobotStatus', 'robot/status', [\n    ('battery_level', 'f32'),\n    ('error_code', 'i32'),\n    ('is_active', 'bool'),\n    ('timestamp', 'u64'),\n])\n\nregister_message('SensorReading', 'sensor/reading', [\n    ('x', 'f64'),\n    ('y', 'f64'),\n    ('z', 'f64'),\n])",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:145:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 145,
      "lineEnd": 150,
      "language": "python",
      "code": "from horus.msggen import build_messages\n\n# Generate Rust code and rebuild\nbuild_messages()  # Runs: maturin develop --release",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:158:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 158,
      "lineEnd": 171,
      "language": "python",
      "code": "from horus import RobotStatus, SensorReading, Hub\n\n# Create typed hub\nhub = Hub(RobotStatus)\n\n# Send\nstatus = RobotStatus(battery_level=85.0, error_code=0, is_active=True, timestamp=0)\nhub.send(status)\n\n# Receive (typed!)\nreceived = hub.recv()\nprint(received.battery_level)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:177:yaml",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 177,
      "lineEnd": 199,
      "language": "yaml",
      "code": "# messages.yaml\nmessages:\n  - name: RobotStatus\n    topic: robot/status\n    fields:\n      - name: battery_level\n        type: f32\n      - name: error_code\n        type: i32\n      - name: is_active\n        type: bool\n\n  - name: SensorReading\n    topic: sensor/reading\n    fields:\n      - name: x\n        type: f64\n      - name: y\n        type: f64\n      - name: z\n        type: f64",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:201:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 201,
      "lineEnd": 206,
      "language": "python",
      "code": "from horus.msggen import generate_messages_from_yaml, build_messages\n\ngenerate_messages_from_yaml('messages.yaml')\nbuild_messages()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:212:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 212,
      "lineEnd": 219,
      "language": "python",
      "code": "from horus.msggen import check_needs_rebuild, build_messages\n\nif check_needs_rebuild():\n    build_messages()\nelse:\n    print(\"Messages are up to date\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:223:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 223,
      "lineEnd": 225,
      "language": "python",
      "code": "build_messages(force=True)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:247:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 247,
      "lineEnd": 253,
      "language": "python",
      "code": "def define_message(\n    name: str,\n    topic: str,\n    fields: List[Tuple[str, str]]\n) -> Type[RuntimeMessage]",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:266:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 266,
      "lineEnd": 272,
      "language": "python",
      "code": "def define_numpy_message(\n    name: str,\n    topic: str,\n    fields: List[Tuple[str, Any]]\n) -> Type[NumpyMessage]",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:285:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 285,
      "lineEnd": 291,
      "language": "python",
      "code": "def register_message(\n    name: str,\n    topic: str,\n    fields: List[Tuple[str, str]]\n) -> None",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:297:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 297,
      "lineEnd": 302,
      "language": "python",
      "code": "def build_messages(\n    force: bool = False,\n    verbose: bool = True\n) -> bool",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:314:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 314,
      "lineEnd": 316,
      "language": "python",
      "code": "def check_needs_rebuild() -> bool",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/custom-messages:324:python",
      "file": "content/docs/python/api/custom-messages.mdx",
      "lineStart": 324,
      "lineEnd": 362,
      "language": "python",
      "code": "#!/usr/bin/env python3\n\"\"\"Custom message example with runtime messages.\"\"\"\n\nimport horus\nfrom horus.msggen import define_message\n\n# Define custom sensor message\nMySensor = define_message('MySensor', 'my/sensor', [\n    ('distance', 'f32'),\n    ('angle', 'f32'),\n    ('confidence', 'f32'),\n    ('object_id', 'u32'),\n])\n\ndef sensor_tick(node):\n    \"\"\"Publish sensor readings.\"\"\"\n    reading = MySensor(\n        distance=2.5,\n        angle=0.785,\n        confidence=0.95,\n        object_id=42\n    )\n    node.send(\"my/sensor\", reading.to_bytes())\n\ndef processor_tick(node):\n    \"\"\"Process sensor readings.\"\"\"\n    if node.has_msg(\"my/sensor\"):\n        raw = node.get(\"my/sensor\")\n        reading = MySensor.from_bytes(raw)\n        print(f\"Object {reading.object_id}: {reading.distance}m at {reading.angle}rad\")\n\n# Create nodes\nsensor = horus.Node(\"sensor\", pubs=\"my/sensor\", tick=sensor_tick, rate=10)\nprocessor = horus.Node(\"processor\", subs=\"my/sensor\", tick=processor_tick)\n\n# Run\nhorus.run(sensor, processor, duration=3)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:33:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 33,
      "lineEnd": 36,
      "language": "bash",
      "code": "# From HORUS root directory\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:44:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 44,
      "lineEnd": 55,
      "language": "bash",
      "code": "# Install maturin (Python/Rust build tool)\n# Option A: Via Cargo (recommended for Ubuntu 24.04+)\ncargo install maturin\n\n# Option B: Via pip (if not blocked by PEP 668)\n# pip install maturin\n\n# Build and install from source\ncd horus_py\nmaturin develop --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:64:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 64,
      "lineEnd": 72,
      "language": "python",
      "code": "import horus\n\ndef process(node):\n    node.send(\"output\", \"Hello HORUS!\")\n\nnode = horus.Node(pubs=\"output\", tick=process, rate=1)\nhorus.run(node, duration=3)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:82:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 82,
      "lineEnd": 92,
      "language": "python",
      "code": "node = horus.Node(\n    name=\"my_node\",            # Optional: auto-generated if not provided\n    pubs=[\"topic1\", \"topic2\"], # Topics to publish to\n    subs=[\"input1\", \"input2\"], # Topics to subscribe to\n    tick=my_function,          # Function called repeatedly\n    rate=30,                   # Hz (default: 30)\n    init=setup_fn,             # Optional: called once at start\n    shutdown=cleanup_fn        # Optional: called once at end\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:107:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 107,
      "lineEnd": 133,
      "language": "python",
      "code": "import horus\n\nclass SensorNode(horus.Node):\n    def __init__(self):\n        super().__init__(\n            name=\"sensor\",\n            pubs=[\"temperature\"],\n            rate=10\n        )\n\n    def tick(self, info=None):\n        # Override tick method\n        self.send(\"temperature\", 25.0)\n\n    def init(self, info=None):\n        # Optional: override init\n        print(\"Sensor initialized!\")\n\n    def shutdown(self, info=None):\n        # Optional: override shutdown\n        print(\"Sensor shutting down!\")\n\n# Use it\nsensor = SensorNode()\nhorus.run(sensor)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:141:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 141,
      "lineEnd": 152,
      "language": "python",
      "code": "def my_tick(node):\n    # Check for messages\n    if node.has_msg(\"input\"):\n        data = node.get(\"input\")  # Get one message\n\n    # Get all messages\n    all_msgs = node.get_all(\"input\")\n\n    # Send messages\n    node.send(\"output\", {\"value\": 42})",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:162:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 162,
      "lineEnd": 168,
      "language": "python",
      "code": "# Single node\nhorus.run(node)\n\n# Multiple nodes\nhorus.run(node1, node2, node3, duration=10)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:176:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 176,
      "lineEnd": 190,
      "language": "python",
      "code": "import horus\n\ndef publish_temperature(node):\n    node.send(\"temperature\", 25.5)\n\nsensor = horus.Node(\n    name=\"temp_sensor\",\n    pubs=\"temperature\",\n    tick=publish_temperature,\n    rate=1  # 1 Hz\n)\n\nhorus.run(sensor, duration=10)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:194:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 194,
      "lineEnd": 209,
      "language": "python",
      "code": "import horus\n\ndef display_temperature(node):\n    if node.has_msg(\"temperature\"):\n        temp = node.get(\"temperature\")\n        print(f\"Temperature: {temp}°C\")\n\ndisplay = horus.Node(\n    name=\"display\",\n    subs=\"temperature\",\n    tick=display_temperature\n)\n\nhorus.run(display)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:213:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 213,
      "lineEnd": 237,
      "language": "python",
      "code": "import horus\n\ndef publish(node):\n    node.send(\"raw\", 42.0)\n\ndef process(node):\n    if node.has_msg(\"raw\"):\n        data = node.get(\"raw\")\n        result = data * 2.0\n        node.send(\"processed\", result)\n\ndef display(node):\n    if node.has_msg(\"processed\"):\n        value = node.get(\"processed\")\n        print(f\"Result: {value}\")\n\n# Create pipeline\npublisher = horus.Node(\"publisher\", pubs=\"raw\", tick=publish, rate=1)\nprocessor = horus.Node(\"processor\", subs=\"raw\", pubs=\"processed\", tick=process)\ndisplayer = horus.Node(\"display\", subs=\"processed\", tick=display)\n\n# Run all together\nhorus.run(publisher, processor, displayer, duration=5)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:241:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 241,
      "lineEnd": 259,
      "language": "python",
      "code": "import horus\n\n# Producer (inline)\nproducer = horus.Node(\n    pubs=\"numbers\",\n    tick=lambda n: n.send(\"numbers\", 42),\n    rate=1\n)\n\n# Transformer (inline)\ndoubler = horus.Node(\n    subs=\"numbers\",\n    pubs=\"doubled\",\n    tick=lambda n: n.send(\"doubled\", n.get(\"numbers\") * 2) if n.has_msg(\"numbers\") else None\n)\n\nhorus.run(producer, doubler, duration=5)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:263:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 263,
      "lineEnd": 290,
      "language": "python",
      "code": "import horus\n\ndef robot_controller(node):\n    # Read from multiple sensors\n    lidar_data = None\n    camera_data = None\n\n    if node.has_msg(\"lidar\"):\n        lidar_data = node.get(\"lidar\")\n\n    if node.has_msg(\"camera\"):\n        camera_data = node.get(\"camera\")\n\n    # Compute commands\n    if lidar_data and camera_data:\n        cmd = compute_navigation(lidar_data, camera_data)\n        node.send(\"motors\", cmd)\n        node.send(\"status\", \"navigating\")\n\nrobot = horus.Node(\n    name=\"robot_controller\",\n    subs=[\"lidar\", \"camera\"],\n    pubs=[\"motors\", \"status\"],\n    tick=robot_controller,\n    rate=50  # 50Hz control loop\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:294:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 294,
      "lineEnd": 327,
      "language": "python",
      "code": "import horus\n\nclass Context:\n    def __init__(self):\n        self.count = 0\n        self.file = None\n\nctx = Context()\n\ndef init_handler(node):\n    print(\"Starting up!\")\n    ctx.file = open(\"data.txt\", \"w\")\n\ndef tick_handler(node):\n    ctx.count += 1\n    data = f\"Tick {ctx.count}\"\n    node.send(\"data\", data)\n    ctx.file.write(data + \"\\n\")\n\ndef shutdown_handler(node):\n    print(f\"Processed {ctx.count} messages\")\n    ctx.file.close()\n\nnode = horus.Node(\n    pubs=\"data\",\n    init=init_handler,\n    tick=tick_handler,\n    shutdown=shutdown_handler,\n    rate=10\n)\n\nhorus.run(node, duration=5)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:339:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 339,
      "lineEnd": 345,
      "language": "python",
      "code": "scheduler = horus.Scheduler()\nscheduler.add(sensor, priority=0)     # Executes FIRST\nscheduler.add(controller, priority=1) # Executes SECOND\nscheduler.add(actuator, priority=2)   # Executes THIRD\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:351:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 351,
      "lineEnd": 375,
      "language": "python",
      "code": "import horus\nimport time\n\ndef control_tick(node):\n    if node.has_msg(\"sensor_data\"):\n        # Check message age\n        age = node.get_message_age(\"sensor_data\")\n        if age > 0.1:  # More than 100ms old\n            node.log_warning(f\"Stale data: {age*1000:.1f}ms old\")\n            return\n\n        # Or use built-in staleness detection\n        if node.is_stale(\"sensor_data\", max_age=0.1):\n            return  # Skip stale data\n\n        # Get message with timestamp\n        msg, timestamp = node.get_with_timestamp(\"sensor_data\")\n        latency = time.time() - timestamp\n        print(f\"Latency: {latency*1000:.1f}ms\")\n\n        # Process fresh data\n        data = node.get(\"sensor_data\")\n        process(data)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:388:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 388,
      "lineEnd": 397,
      "language": "bash",
      "code": "# Run multiple Python files as separate processes\nhorus run node1.py node2.py node3.py\n\n# Mix Python and Rust nodes\nhorus run sensor.rs controller.py visualizer.py\n\n# Mix Rust and Python\nhorus run lidar_driver.rs planner.py motor_control.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:403:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 403,
      "lineEnd": 413,
      "language": "python",
      "code": "# sensor_node.py\nimport horus\n\ndef sensor_tick(node):\n    data = read_lidar()  # Your sensor code\n    node.send(\"lidar_data\", data)\n\nsensor = horus.Node(name=\"lidar\", pubs=\"lidar_data\", tick=sensor_tick)\nhorus.run(sensor)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:415:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 415,
      "lineEnd": 432,
      "language": "python",
      "code": "# controller_node.py\nimport horus\n\ndef control_tick(node):\n    if node.has_msg(\"lidar_data\"):\n        data = node.get(\"lidar_data\")\n        cmd = compute_control(data)\n        node.send(\"motor_cmd\", cmd)\n\ncontroller = horus.Node(\n    name=\"controller\",\n    subs=\"lidar_data\",\n    pubs=\"motor_cmd\",\n    tick=control_tick\n)\nhorus.run(controller)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:434:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 434,
      "lineEnd": 437,
      "language": "bash",
      "code": "# Run both in separate processes\nhorus run sensor_node.py controller_node.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:447:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 447,
      "lineEnd": 493,
      "language": "python",
      "code": "import horus\nimport time\n\ndef sensor_tick(node):\n    \"\"\"High-frequency sensor (100Hz)\"\"\"\n    imu = {\"accel_x\": 1.0, \"accel_y\": 0.0, \"accel_z\": 9.8}\n    node.send(\"imu_data\", imu)\n    age = node.get_message_age(\"imu_data\")\n    node.log_info(f\"Published IMU (age: {age:.3f}s)\")\n\ndef control_tick(node):\n    \"\"\"Medium-frequency control (50Hz)\"\"\"\n    if node.has_msg(\"imu_data\"):\n        # Check for stale data\n        if node.is_stale(\"imu_data\", max_age=0.05):\n            node.log_warning(\"Stale IMU data!\")\n            return\n\n        imu = node.get(\"imu_data\")\n        cmd = {\"linear\": 1.0, \"angular\": 0.0}\n        node.send(\"cmd_vel\", cmd)\n\ndef logger_tick(node):\n    \"\"\"Low-frequency logging (10Hz)\"\"\"\n    if node.has_msg(\"cmd_vel\"):\n        msg, timestamp = node.get_with_timestamp(\"cmd_vel\")\n        latency = (time.time() - timestamp) * 1000\n        node.log_info(f\"Command latency: {latency:.1f}ms\")\n\n# Create nodes\nsensor = horus.Node(name=\"imu\", pubs=\"imu_data\", tick=sensor_tick)\ncontroller = horus.Node(name=\"ctrl\", subs=\"imu_data\", pubs=\"cmd_vel\", tick=control_tick)\nlogger = horus.Node(name=\"log\", subs=\"cmd_vel\", tick=logger_tick)\n\n# Configure with different rates and priorities\nscheduler = horus.Scheduler()\nscheduler.add(sensor, priority=0, logging=True, rate_hz=100.0)\nscheduler.add(controller, priority=1, logging=False, rate_hz=50.0)\nscheduler.add(logger, priority=2, logging=True, rate_hz=10.0)\n\nscheduler.run(duration=5.0)\n\n# Check statistics\nstats = scheduler.get_node_stats(\"imu\")\nprint(f\"Sensor: {stats['total_ticks']} ticks in 5 seconds\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:505:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 505,
      "lineEnd": 516,
      "language": "python",
      "code": "from horus import Hub, CmdVel\n\n# Local (shared memory) - default\nlocal_hub = Hub(CmdVel)\n\n# Network (UDP direct)\nnetwork_hub = Hub(CmdVel, endpoint=\"cmdvel@192.168.1.100:8000\")\n\n# Router (TCP broker for WAN/NAT traversal)\nrouter_hub = Hub(CmdVel, endpoint=\"cmdvel@router\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:546:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 546,
      "lineEnd": 567,
      "language": "python",
      "code": "from horus import Hub, CmdVel\n\n# === Send multiple messages at once ===\nhub = Hub(CmdVel)\ncommands = [\n    CmdVel(linear=1.0, angular=0.0),\n    CmdVel(linear=1.5, angular=0.2),\n    CmdVel(linear=0.0, angular=0.5),\n]\nsent = hub.send_many(commands)\nprint(f\"Sent {sent}/{len(commands)} messages\")\n\n# === Receive up to N messages ===\nmessages = hub.recv_many(10)  # Get up to 10 messages\nfor msg in messages:\n    print(f\"linear={msg.linear}, angular={msg.angular}\")\n\n# === Drain all available messages ===\nall_msgs = hub.drain()  # Get everything pending\nprint(f\"Drained {len(all_msgs)} messages\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:571:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 571,
      "lineEnd": 586,
      "language": "python",
      "code": "from horus import Hub\nimport msgpack  # pip install msgpack\n\n# For custom/large data where you control serialization\nhub = Hub(\"sensor_data\")  # Generic (untyped) topic\n\n# view() returns raw MessagePack bytes without JSON overhead\nif raw := hub.view():\n    # Parse with your own logic (msgpack, struct, numpy, etc.)\n    data = msgpack.unpackb(raw)\n    print(f\"Raw data: {data}\")\n\n# Note: view() raises TypeError for typed hubs (CmdVel, etc.)\n# because they're already optimized for direct field access",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:598:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 598,
      "lineEnd": 606,
      "language": "python",
      "code": "from horus import Hub\n\n# Generic hub (string topic = dynamic typing)\nhub = Hub(\"my.topic\")\n\n# Typed hub (class = static typing, better performance)\ntyped_hub = Hub(CmdVel)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:623:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 623,
      "lineEnd": 636,
      "language": "python",
      "code": "from horus import Hub\n\npub = Hub(\"sensor.data\")\nsub = Hub(\"sensor.data\")\n\n# Send dict, list, or any JSON-serializable data\npub.send({\"temperature\": 25.5, \"humidity\": 60.0})\npub.send([1.0, 2.0, 3.0, 4.0])\npub.send(\"status: OK\")\n\n# Receive (returns Python object)\nmsg = sub.recv()  # {\"temperature\": 25.5, \"humidity\": 60.0}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:640:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 640,
      "lineEnd": 651,
      "language": "python",
      "code": "from horus import Hub\n\npub = Hub(\"binary.data\")\nsub = Hub(\"binary.data\")\n\n# Send raw bytes (custom binary protocol)\npub.send_bytes(b'\\x01\\x02\\x03\\x04')\n\n# Receive raw bytes (no deserialization)\nraw = sub.view()  # b'\\x01\\x02\\x03\\x04'",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:655:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 655,
      "lineEnd": 669,
      "language": "python",
      "code": "from horus import Hub\nimport numpy as np\n\npub = Hub(\"numpy.data\")\nsub = Hub(\"numpy.data\")\n\n# Send NumPy array\narr = np.array([1.0, 2.0, 3.0], dtype=np.float32)\npub.send_numpy(arr)\n\n# Receive and reconstruct\nraw = sub.view()\nreceived = np.frombuffer(raw, dtype=np.float32)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:673:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 673,
      "lineEnd": 688,
      "language": "python",
      "code": "from horus import Hub\nimport json\n\npub = Hub(\"tagged.data\")\nsub = Hub(\"tagged.data\")\n\n# Send with type hint metadata\ndata = json.dumps({\"x\": 1.0, \"y\": 2.0}).encode()\npub.send_with_metadata(data, \"json\")\n\n# Receive with metadata\npayload, metadata = sub.recv_with_metadata()\nif metadata == \"json\":\n    obj = json.loads(payload)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:709:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 709,
      "lineEnd": 722,
      "language": "python",
      "code": "from horus import Link, CmdVel\n\n# === MACHINE 1 (Producer) ===\n# Connects to consumer at 192.168.1.20:9000\noutput = Link.producer(CmdVel, \"sensors@192.168.1.20:9000\")\noutput.send(CmdVel(linear=1.0, angular=0.5))\n\n# === MACHINE 2 (Consumer) ===\n# Listens on port 9000\ninput_link = Link.consumer(CmdVel, \"sensors@0.0.0.0:9000\")\nif msg := input_link.recv():\n    print(f\"Received: {msg}\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:736:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 736,
      "lineEnd": 743,
      "language": "python",
      "code": "# No \"@\" in endpoint = local shared memory\nproducer = Link.producer(CmdVel, \"motor_commands\")\nconsumer = Link.consumer(CmdVel, \"motor_commands\")\n\nproducer.send(CmdVel(linear=1.0, angular=0.0))\nmsg = consumer.recv()  # ~248ns latency",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:749:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 749,
      "lineEnd": 767,
      "language": "python",
      "code": "from horus import RouterClient, Hub, CmdVel\n\n# Create router client for explicit connection management\nrouter = RouterClient(\"192.168.1.100\", 7777)\n\n# Build endpoints through the router\ncmd_endpoint = router.endpoint(\"cmdvel\")  # Returns \"cmdvel@192.168.1.100:7777\"\npose_endpoint = router.endpoint(\"pose\")\n\n# Use endpoints with Hub\nhub = Hub(CmdVel, endpoint=cmd_endpoint)\n\n# Router properties\nprint(f\"Address: {router.address}\")        # \"192.168.1.100:7777\"\nprint(f\"Connected: {router.is_connected}\") # True\nprint(f\"Topics: {router.topics}\")          # [\"cmdvel\", \"pose\"]\nprint(f\"Uptime: {router.uptime_seconds}s\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:771:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 771,
      "lineEnd": 779,
      "language": "python",
      "code": "from horus import default_router_endpoint, router_endpoint\n\n# Default router (localhost:7777)\nep1 = default_router_endpoint(\"cmdvel\")  # \"cmdvel@router\"\n\n# Custom router address\nep2 = router_endpoint(\"cmdvel\", \"192.168.1.100\", 7777)  # \"cmdvel@192.168.1.100:7777\"",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:783:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 783,
      "lineEnd": 792,
      "language": "python",
      "code": "from horus import RouterServer\n\n# Start a local router (for development/testing)\nserver = RouterServer(port=7777)\nserver.start()\n\n# For production, use CLI instead:\n# $ horus router start --port 7777",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:806:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 806,
      "lineEnd": 828,
      "language": "python",
      "code": "# === ROBOT (192.168.1.50) ===\nfrom horus import Hub, Link, CmdVel, LaserScan\n\n# Local: Critical flight control (ultra-fast)\nimu_link = Link.consumer(ImuData, \"imu\")  # 248ns\n\n# Network: Telemetry to ground station\ntelemetry = Hub(DroneStatus, endpoint=\"telem@192.168.1.100:8000\")\n\n# Network: Commands from ground station\ncommands = Hub(Command, endpoint=\"cmd@0.0.0.0:8001\")\n\n\n# === GROUND STATION (192.168.1.100) ===\nfrom horus import Hub\n\n# Receive telemetry from robot\ntelemetry_sub = Hub(DroneStatus, endpoint=\"telem@0.0.0.0:8000\")\n\n# Send commands to robot\ncommand_pub = Hub(Command, endpoint=\"cmd@192.168.1.50:8001\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:836:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 836,
      "lineEnd": 854,
      "language": "python",
      "code": "import horus\nimport numpy as np\n\ndef process_array(node):\n    if node.has_msg(\"raw_data\"):\n        data = node.get(\"raw_data\")\n        # Convert to NumPy array\n        arr = np.array(data)\n        # Process with NumPy\n        result = np.fft.fft(arr)\n        node.send(\"fft_result\", result.tolist())\n\nprocessor = horus.Node(\n    subs=\"raw_data\",\n    pubs=\"fft_result\",\n    tick=process_array\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:858:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 858,
      "lineEnd": 882,
      "language": "python",
      "code": "import horus\nimport cv2\nimport numpy as np\n\ndef process_image(node):\n    if node.has_msg(\"camera\"):\n        img_data = node.get(\"camera\")\n        # Convert to OpenCV format\n        img = np.array(img_data, dtype=np.uint8).reshape((480, 640, 3))\n\n        # Apply OpenCV processing\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        edges = cv2.Canny(gray, 50, 150)\n\n        # Publish result\n        node.send(\"edges\", edges.flatten().tolist())\n\nvision = horus.Node(\n    subs=\"camera\",\n    pubs=\"edges\",\n    tick=process_image,\n    rate=30\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:886:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 886,
      "lineEnd": 910,
      "language": "python",
      "code": "import horus\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\nmodel = LinearRegression()\n\ndef train_model(node):\n    if node.has_msg(\"training_data\"):\n        data = node.get(\"training_data\")\n        X = np.array(data['features'])\n        y = np.array(data['labels'])\n\n        # Train model\n        model.fit(X, y)\n        score = model.score(X, y)\n\n        node.send(\"model_score\", score)\n\ntrainer = horus.Node(\n    subs=\"training_data\",\n    pubs=\"model_score\",\n    tick=train_model\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:918:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 918,
      "lineEnd": 947,
      "language": "python",
      "code": "import horus\n\nclass RobotState:\n    def __init__(self):\n        self.position = {\"x\": 0.0, \"y\": 0.0}\n        self.velocity = 0.0\n        self.last_update = 0\n\nstate = RobotState()\n\ndef update_state(node):\n    if node.has_msg(\"velocity\"):\n        state.velocity = node.get(\"velocity\")\n\n    if node.has_msg(\"position\"):\n        state.position = node.get(\"position\")\n\n    # Publish combined state\n    node.send(\"robot_state\", {\n        \"pos\": state.position,\n        \"vel\": state.velocity\n    })\n\nstate_manager = horus.Node(\n    subs=[\"velocity\", \"position\"],\n    pubs=\"robot_state\",\n    tick=update_state\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:951:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 951,
      "lineEnd": 974,
      "language": "python",
      "code": "import horus\nimport time\n\nclass RateLimiter:\n    def __init__(self, min_interval):\n        self.min_interval = min_interval\n        self.last_send = 0\n\nlimiter = RateLimiter(min_interval=0.1)  # 100ms minimum\n\ndef rate_limited_publish(node):\n    current_time = time.time()\n\n    if current_time - limiter.last_send >= limiter.min_interval:\n        node.send(\"output\", \"data\")\n        limiter.last_send = current_time\n\nnode = horus.Node(\n    pubs=\"output\",\n    tick=rate_limited_publish,\n    rate=100  # Node runs at 100Hz, but publishes at max 10Hz\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:978:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 978,
      "lineEnd": 996,
      "language": "python",
      "code": "import horus\n\ndef safe_processing(node):\n    try:\n        if node.has_msg(\"input\"):\n            data = node.get(\"input\")\n            result = risky_operation(data)\n            node.send(\"output\", result)\n    except Exception as e:\n        node.send(\"errors\", str(e))\n        print(f\"Error: {e}\")\n\nprocessor = horus.Node(\n    subs=\"input\",\n    pubs=[\"output\", \"errors\"],\n    tick=safe_processing\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1004:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1004,
      "lineEnd": 1022,
      "language": "python",
      "code": "# NEW: Use scheduler with per-node rates for optimal performance\nscheduler = horus.Scheduler()\n\n# High-frequency sensor (100Hz)\nscheduler.add(sensor, priority=0, rate_hz=100.0)\n\n# Medium-frequency control (50Hz)\nscheduler.add(controller, priority=1, rate_hz=50.0)\n\n# Low-frequency logging (10Hz)\nscheduler.add(logger, priority=2, rate_hz=10.0)\n\nscheduler.run()\n\n# Monitor performance with get_node_stats()\nstats = scheduler.get_node_stats(\"sensor\")\nprint(f\"Sensor executed {stats['total_ticks']} ticks\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1026:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1026,
      "lineEnd": 1036,
      "language": "python",
      "code": "def control_tick(node):\n    # Skip stale data to maintain real-time performance\n    if node.is_stale(\"sensor_data\", max_age=0.1):\n        node.log_warning(\"Skipping stale sensor data\")\n        return\n\n    # Process fresh data only\n    data = node.get(\"sensor_data\")\n    process(data)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1040:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1040,
      "lineEnd": 1048,
      "language": "python",
      "code": "# Send messages as Python dicts (automatically serialized to JSON)\ncmd = {\"linear\": 1.5, \"angular\": 0.8}\nnode.send(\"cmd_vel\", cmd)\n\n# Check message age using node method\nif node.get_message_age(\"cmd_vel\") > 0.1:\n    print(\"Message is stale\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1052:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1052,
      "lineEnd": 1074,
      "language": "python",
      "code": "# === Node API (for tick functions) ===\ndef batch_processor(node):\n    # Process all available messages at once\n    messages = node.get_all(\"input\")\n    if messages:\n        results = [process(msg) for msg in messages]\n        for result in results:\n            node.send(\"output\", result)\n\n# === Hub API (direct usage) ===\nfrom horus import Hub, CmdVel\n\nhub = Hub(CmdVel)\n\n# Receive in batches (1 GIL release for N messages)\nmessages = hub.recv_many(100)  # Up to 100 messages\nall_msgs = hub.drain()          # All available messages\n\n# Send in batches (1 GIL release for N messages)\ncommands = [CmdVel(linear=v, angular=0) for v in range(10)]\nsent = hub.send_many(commands)  # Returns count sent",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1078:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1078,
      "lineEnd": 1090,
      "language": "python",
      "code": "# GOOD: Fast tick\ndef good_tick(node):\n    if node.has_msg(\"input\"):\n        data = node.get(\"input\")\n        result = quick_operation(data)\n        node.send(\"output\", result)\n\n# BAD: Slow tick\ndef bad_tick(node):\n    time.sleep(1)  # Don't block!\n    data = requests.get(\"http://api.example.com\")  # Don't do I/O!",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1094:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1094,
      "lineEnd": 1105,
      "language": "python",
      "code": "from concurrent.futures import ThreadPoolExecutor\n\nexecutor = ThreadPoolExecutor(max_workers=4)\n\ndef heavy_processing_node(node):\n    if node.has_msg(\"input\"):\n        data = node.get(\"input\")\n        # Offload to thread pool\n        future = executor.submit(expensive_operation, data)\n        # Don't block - check result later or use callback",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1109:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1109,
      "lineEnd": 1114,
      "language": "bash",
      "code": "# Isolate heavy processing in separate processes\nhorus run sensor.py heavy_vision.py light_controller.py\n\n# Each node gets its own CPU core",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1122:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1122,
      "lineEnd": 1132,
      "language": "bash",
      "code": "# Debug build (fast compile, slow runtime)\ncd horus_py\nmaturin develop\n\n# Release build (slow compile, fast runtime)\nmaturin develop --release\n\n# Build wheel for distribution\nmaturin build --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1136:bash",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1136,
      "lineEnd": 1153,
      "language": "bash",
      "code": "# Install test dependencies\npip install pytest\n\n# Run all tests\npytest tests/\n\n# Run specific feature tests\nhorus run tests/test_rate_control.py    # Phase 1: Per-node rates\nhorus run tests/test_timestamps.py      # Phase 2: Timestamps\nhorus run tests/test_typed_messages.py  # Phase 3: Typed messages\n\n# With coverage\npytest --cov=horus tests/\n\n# Test multiprocess execution (Phase 4)\nhorus run tests/multiprocess_publisher.py tests/multiprocess_subscriber.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1159:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1159,
      "lineEnd": 1164,
      "language": "python",
      "code": "# If Rust bindings aren't available, automatically falls back to mock\n# You'll see: \"Warning: Rust bindings not available. Running in mock mode.\"\n\n# Use for unit testing Python logic without HORUS running",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1168:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1168,
      "lineEnd": 1181,
      "language": "python",
      "code": "# Enable logging for specific nodes\nscheduler = horus.Scheduler()\nscheduler.add(my_node, priority=0, logging=True)  # Enable logs\n\n# Check node statistics\nstats = scheduler.get_node_stats(\"my_node\")\nprint(f\"Ticks: {stats['total_ticks']}, Errors: {stats['errors_count']}\")\n\n# Monitor message timestamps\nmsg, timestamp = node.get_with_timestamp(\"topic\")\nage = time.time() - timestamp\nprint(f\"Message age: {age*1000:.1f}ms\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1193:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1193,
      "lineEnd": 1199,
      "language": "python",
      "code": "# Python node with typed hub\nfrom horus import Hub, CmdVel\n\ncmd_hub = Hub(CmdVel)  # Typed hub\ncmd_hub.send(CmdVel(linear=1.0, angular=0.5))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1201:rust",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1201,
      "lineEnd": 1210,
      "language": "rust",
      "code": "// Rust node receives\nuse horus::prelude::*;\nuse horus::prelude::*; // Provides cmd_vel::CmdVel;\n\nlet hub = Hub::<CmdVel>::new(\"cmdvel\")?;\nif let Some(cmd) = hub.recv(&mut None) {\n    println!(\"Got: linear={}, angular={}\", cmd.linear, cmd.angular);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/python/api/python-bindings:1214:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1214,
      "lineEnd": 1220,
      "language": "python",
      "code": "# Generic Hub - for custom topics\nfrom horus import Hub\n\nhub = Hub(\"my_topic\")  # Pass string for generic hub\nhub.send({\"linear\": 1.0, \"angular\": 0.5})  # Uses JSON serialization",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1231:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1231,
      "lineEnd": 1245,
      "language": "python",
      "code": "# Producer\nproducer = horus.Node(\n    pubs=\"queue\",\n    tick=lambda n: n.send(\"queue\", generate_work())\n)\n\n# Consumer\nconsumer = horus.Node(\n    subs=\"queue\",\n    tick=lambda n: process_work(n.get(\"queue\")) if n.has_msg(\"queue\") else None\n)\n\nhorus.run(producer, consumer)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1249:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1249,
      "lineEnd": 1261,
      "language": "python",
      "code": "def request_node(node):\n    node.send(\"requests\", {\"id\": 1, \"query\": \"data\"})\n\ndef response_node(node):\n    if node.has_msg(\"requests\"):\n        req = node.get(\"requests\")\n        response = handle_request(req)\n        node.send(\"responses\", response)\n\nreq = horus.Node(pubs=\"requests\", tick=request_node)\nres = horus.Node(subs=\"requests\", pubs=\"responses\", tick=response_node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1265:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1265,
      "lineEnd": 1282,
      "language": "python",
      "code": "import time\n\nclass PeriodicTask:\n    def __init__(self, interval):\n        self.interval = interval\n        self.last_run = 0\n\ntask = PeriodicTask(interval=5.0)  # Every 5 seconds\n\ndef periodic_tick(node):\n    current = time.time()\n    if current - task.last_run >= task.interval:\n        node.send(\"periodic\", \"task_executed\")\n        task.last_run = current\n\nnode = horus.Node(pubs=\"periodic\", tick=periodic_tick, rate=10)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1290:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1290,
      "lineEnd": 1295,
      "language": "python",
      "code": "# If you see: ModuleNotFoundError: No module named 'horus'\n# Rebuild and install:\ncd horus_py\nmaturin develop --release",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1299:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1299,
      "lineEnd": 1305,
      "language": "python",
      "code": "# Use release build (not debug)\nmaturin develop --release\n\n# Check tick rate isn't too high\nnode = horus.Node(tick=fn, rate=30)  # 30Hz is reasonable",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1309:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1309,
      "lineEnd": 1320,
      "language": "python",
      "code": "# Avoid accumulating data in closures\n# BAD:\nall_data = []\ndef bad_tick(node):\n    all_data.append(node.get(\"input\"))  # Memory leak!\n\n# GOOD:\ndef good_tick(node):\n    data = node.get(\"input\")\n    process_and_discard(data)  # Process immediately",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1332:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1332,
      "lineEnd": 1336,
      "language": "python",
      "code": "# Internal implementation (simplified)\nhub.send(msg, None)  #  No context = no logging\nhub.recv(&mut None)       #  No context = no logging",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1348:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1348,
      "lineEnd": 1352,
      "language": "python",
      "code": "scheduler = horus.Scheduler()\nscheduler.add(sensor, priority=0, logging=True)  # Enables console logging\nscheduler.add(controller, priority=1, logging=False)  # No console output",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1355:text",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1355,
      "lineEnd": 1358,
      "language": "text",
      "code": "[INFO] sensor: Published to topic 'lidar_data'\n[INFO] sensor: Received from topic 'commands'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1365:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1365,
      "lineEnd": 1373,
      "language": "python",
      "code": "def tick(node):\n    node.log_info(\"Processing sensor data\")\n    node.log_warning(\"Sensor reading is stale\")\n    node.log_error(\"Failed to process data\")\n    node.log_debug(\"Debug information\")\n\n# These print to console, not monitor",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1376:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1376,
      "lineEnd": 1383,
      "language": "python",
      "code": "def tick(node):\n    if node.has_msg(\"input\"):\n        data = node.get(\"input\")\n        print(f\"[{node.name}] Received: {data}\")\n        node.send(\"output\", result)\n        print(f\"[{node.name}] Published: {result}\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/api/python-bindings:1386:python",
      "file": "content/docs/python/api/python-bindings.mdx",
      "lineStart": 1386,
      "lineEnd": 1395,
      "language": "python",
      "code": "scheduler = horus.Scheduler()\nscheduler.add(node, priority=0, logging=True)\nscheduler.run(duration=10)\n\n# Get stats after running\nstats = scheduler.get_node_stats(\"my_node\")\nprint(f\"Ticks: {stats['total_ticks']}\")\nprint(f\"Errors: {stats['errors_count']}\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:31:python",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 31,
      "lineEnd": 85,
      "language": "python",
      "code": "import horus\n\nclass DatabaseNode(horus.AsyncNode):\n    \"\"\"Fetch data from database without blocking\"\"\"\n\n    async def setup(self):\n        self.query_sub = horus.AsyncHub(\"query\", str)\n        self.result_pub = horus.AsyncHub(\"result\", str)\n\n    async def tick(self):\n        # Wait for query (non-blocking!)\n        query = await self.query_sub.recv()\n\n        # Fetch from database (non-blocking!)\n        result = await self.fetch_from_db(query)\n\n        # Send result\n        await self.result_pub.send(result)\n\n    async def fetch_from_db(self, query):\n        await horus.sleep(0.5)  # Simulated async database call\n        return f\"Result for: {query}\"\n\n\nclass SensorNode(horus.AsyncNode):\n    \"\"\"Read sensor data asynchronously\"\"\"\n\n    async def setup(self):\n        self.sensor_pub = horus.AsyncHub(\"sensor_data\", float)\n\n    async def tick(self):\n        value = await self.read_sensor()\n        await self.sensor_pub.send(value)\n        await horus.sleep(0.1)\n\n    async def read_sensor(self):\n        await horus.sleep(0.05)  # Simulated sensor read\n        return 23.5\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    async def main():\n        db = DatabaseNode()\n        sensor = SensorNode()\n        await db.setup()\n        await sensor.setup()\n\n        for _ in range(10):\n            await asyncio.gather(db.tick(), sensor.tick())\n\n    asyncio.run(main())",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:93:python",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 93,
      "lineEnd": 132,
      "language": "python",
      "code": "from horus import Hub, CmdVel, Node\nimport time\n\ndef python_publisher(endpoint: str, rate_hz: float = 10.0):\n    \"\"\"Python node publishing CmdVel that Rust nodes can subscribe to\"\"\"\n\n    # Create Hub with network endpoint\n    hub = Hub(CmdVel, endpoint=endpoint)\n    node = Node(\"py_cross_lang_pub\")\n    interval = 1.0 / rate_hz\n\n    print(f\"Publishing to: {endpoint}\")\n    print(f\"Transport: {hub.transport_type}\")\n\n    while True:\n        t = time.time()\n        linear = 1.0 + 0.5 * (t % 10) / 10.0\n        angular = 0.2 * ((t % 20) - 10) / 10.0\n\n        cmd = CmdVel(linear, angular)\n        hub.send(cmd, node)\n\n        time.sleep(interval)\n\n\ndef python_subscriber(endpoint: str):\n    \"\"\"Python node subscribing to Rust publisher\"\"\"\n\n    hub = Hub(CmdVel, endpoint=endpoint)\n    node = Node(\"py_cross_lang_sub\")\n\n    print(f\"Subscribing to: {endpoint}\")\n\n    while True:\n        msg = hub.try_recv(node)\n        if msg:\n            print(f\"Received: linear={msg.linear:.2f}, angular={msg.angular:.2f}\")\n        time.sleep(0.01)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:135:bash",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 135,
      "lineEnd": 141,
      "language": "bash",
      "code": "# Python publisher, Rust subscriber\npython cross_language_example.py --mode python-pub --endpoint \"cmdvel@192.168.1.5:9000\"\n\n# Python subscriber, Rust publisher\npython cross_language_example.py --mode python-sub --endpoint \"cmdvel@192.168.1.5:9000\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:149:python",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 149,
      "lineEnd": 190,
      "language": "python",
      "code": "import numpy as np\nfrom horus import Node, run\nfrom horus.ml_utils import ONNXInferenceNode, PerformanceMonitor\n\nclass PoseEstimationNode(ONNXInferenceNode):\n    \"\"\"Human pose estimation using MoveNet/MediaPipe\"\"\"\n\n    def __init__(self, model_path=\"models/movenet_lightning.onnx\"):\n        super().__init__(\n            model_path=model_path,\n            input_topic=\"camera/raw\",\n            output_topic=\"poses\",\n            device=\"cpu\"\n        )\n        self.monitor = PerformanceMonitor(window_size=30)\n\n    def load_model(self):\n        import onnxruntime as ort\n        providers = ['CPUExecutionProvider']\n        self.session = ort.InferenceSession(self.model_path, providers=providers)\n        self.input_name = self.session.get_inputs()[0].name\n\n    def preprocess(self, image_data):\n        \"\"\"Resize and normalize for pose model\"\"\"\n        img = np.array(image_data).astype(np.float32)\n        img = (img / 127.5) - 1.0  # Normalize to [-1, 1]\n        img = np.transpose(img, (2, 0, 1))  # HWC -> CHW\n        return np.expand_dims(img, 0)  # Add batch dimension\n\n    def infer(self, preprocessed):\n        return self.session.run(None, {self.input_name: preprocessed})[0]\n\n    def postprocess(self, output):\n        \"\"\"Parse keypoints from model output\"\"\"\n        keypoints = []\n        for i in range(17):  # 17 body keypoints\n            y, x, conf = output[0, i, 0], output[0, i, 1], output[0, i, 2]\n            if conf > 0.3:\n                keypoints.append({'id': i, 'x': x, 'y': y, 'confidence': conf})\n        return keypoints",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:198:python",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 198,
      "lineEnd": 222,
      "language": "python",
      "code": "from horus import Hub, CmdVel, Node\n\n# Local shared memory (same machine)\nlocal_hub = Hub(CmdVel, topic=\"cmd_vel\")\n\n# Network UDP (cross-machine)\nnetwork_hub = Hub(CmdVel, endpoint=\"cmdvel@192.168.1.100:9000\")\n\n# Automatic transport selection\nauto_hub = Hub(CmdVel, endpoint=\"cmdvel@auto\")  # Uses optimal transport\n\nnode = Node(\"network_example\")\n\n# Send locally\nlocal_hub.send(CmdVel(1.0, 0.0), node)\n\n# Send over network\nnetwork_hub.send(CmdVel(1.0, 0.0), node)\n\n# Receive from network\nmsg = network_hub.try_recv(node)\nif msg:\n    print(f\"Received: {msg}\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:230:python",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 230,
      "lineEnd": 252,
      "language": "python",
      "code": "from horus import Hub, Node\nimport msgpack\n\n# Using GenericMessage for custom data\nhub = Hub(dict, topic=\"custom_data\")\nnode = Node(\"custom_node\")\n\n# Send Python dict (auto-serialized)\nhub.send({\n    \"robot_id\": 1,\n    \"position\": [1.0, 2.0, 3.0],\n    \"sensors\": {\n        \"lidar\": True,\n        \"camera\": True\n    }\n}, node)\n\n# Receive\ndata = hub.try_recv(node)\nif data:\n    print(f\"Robot {data['robot_id']} at {data['position']}\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/examples/index:258:bash",
      "file": "content/docs/python/examples/index.mdx",
      "lineStart": 258,
      "lineEnd": 266,
      "language": "bash",
      "code": "# Navigate to examples directory\ncd horus_py/examples\n\n# Run any example\npython simple_async.py\npython cross_language_example.py --help\npython pose_estimation.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:27:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 27,
      "lineEnd": 63,
      "language": "python",
      "code": "from horus.ml_utils import MLNodeBase\n\nclass MLNodeBase:\n    def __init__(self, model_path: str, input_topic: str, output_topic: str):\n        \"\"\"\n        Args:\n            model_path: Path to the model file\n            input_topic: Topic to subscribe to for inputs\n            output_topic: Topic to publish predictions to\n        \"\"\"\n        ...\n\n    def load_model(self):\n        \"\"\"Override to load your model\"\"\"\n        raise NotImplementedError()\n\n    def preprocess(self, data):\n        \"\"\"Override to preprocess input data\"\"\"\n        return data\n\n    def infer(self, data):\n        \"\"\"Override to run inference\"\"\"\n        raise NotImplementedError()\n\n    def postprocess(self, output):\n        \"\"\"Override to postprocess model output\"\"\"\n        return output\n\n    def run_inference(self, data) -> tuple[Any, float]:\n        \"\"\"Run full pipeline, returns (result, latency_ms)\"\"\"\n        ...\n\n    def get_stats(self) -> dict:\n        \"\"\"Get inference statistics\"\"\"\n        ...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/python/library/ml-utilities:69:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 69,
      "lineEnd": 102,
      "language": "python",
      "code": "from horus import Node, Hub\nfrom horus.ml_utils import PyTorchInferenceNode\n\nclass ObjectDetector(PyTorchInferenceNode):\n    def __init__(self):\n        super().__init__(\n            model_path=\"models/yolov8n.pt\",\n            input_topic=\"camera.raw\",\n            output_topic=\"detections\",\n            device=\"cuda:0\"  # or \"cpu\"\n        )\n\n    def load_model(self):\n        import torch\n        self.model = torch.jit.load(self.model_path, map_location=self.device)\n        self.model.eval()\n\n    def preprocess(self, image_data):\n        import torch\n        # Convert numpy to tensor, normalize\n        tensor = torch.from_numpy(image_data).float() / 255.0\n        tensor = tensor.permute(2, 0, 1).unsqueeze(0)  # HWC -> NCHW\n        return tensor.to(self.device)\n\n    def infer(self, tensor):\n        import torch\n        with torch.no_grad():\n            return self.model(tensor)\n\n    def postprocess(self, output):\n        # Convert detections to list\n        return output[0].cpu().numpy().tolist()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:106:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 106,
      "lineEnd": 130,
      "language": "python",
      "code": "from horus import Node, Hub, Scheduler\nfrom horus.ml_utils import PyTorchInferenceNode\n\nclass VisionNode(Node):\n    def __init__(self):\n        self.camera = Hub(\"camera.raw\")\n        self.detections = Hub(\"detections\")\n        self.detector = ObjectDetector()\n        self.detector.load_model()\n\n    def name(self) -> str:\n        return \"VisionNode\"\n\n    def tick(self):\n        if frame := self.camera.recv():\n            result, latency_ms = self.detector.run_inference(frame)\n            self.detections.send(result)\n            print(f\"Inference latency: {latency_ms:.2f}ms\")\n\n# Run\nscheduler = Scheduler()\nscheduler.add(VisionNode(), priority=0)\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:136:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 136,
      "lineEnd": 161,
      "language": "python",
      "code": "from horus.ml_utils import TensorFlowInferenceNode\n\nclass ImageClassifier(TensorFlowInferenceNode):\n    def __init__(self):\n        super().__init__(\n            model_path=\"models/mobilenet_v2\",\n            input_topic=\"camera.raw\",\n            output_topic=\"classification\",\n            use_gpu=True\n        )\n\n    def load_model(self):\n        import tensorflow as tf\n        # Handles both SavedModel and .h5 formats\n        if self.model_path.endswith(\".h5\"):\n            self.model = tf.keras.models.load_model(self.model_path)\n        else:\n            self.model = tf.saved_model.load(self.model_path)\n\n    def preprocess(self, image_data):\n        import tensorflow as tf\n        img = tf.image.resize(image_data, [224, 224])\n        img = img / 255.0\n        return tf.expand_dims(img, 0)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:169:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 169,
      "lineEnd": 201,
      "language": "python",
      "code": "from horus.ml_utils import ONNXInferenceNode\nimport numpy as np\n\nclass YOLODetector(ONNXInferenceNode):\n    def __init__(self):\n        super().__init__(\n            model_path=\"models/yolov8n.onnx\",\n            input_topic=\"camera.raw\",\n            output_topic=\"detections\",\n            use_gpu=True  # Uses CUDAExecutionProvider if available\n        )\n\n    def load_model(self):\n        import onnxruntime as ort\n        providers = (\n            [\"CUDAExecutionProvider\", \"CPUExecutionProvider\"]\n            if self.use_gpu else [\"CPUExecutionProvider\"]\n        )\n        self.session = ort.InferenceSession(self.model_path, providers=providers)\n        self.input_name = self.session.get_inputs()[0].name\n        self.output_names = [o.name for o in self.session.get_outputs()]\n\n    def preprocess(self, image_data):\n        # Resize to 640x640, normalize, NCHW format\n        img = np.array(image_data).astype(np.float32) / 255.0\n        img = np.transpose(img, (2, 0, 1))  # HWC -> CHW\n        return np.expand_dims(img, 0)\n\n    def infer(self, data):\n        outputs = self.session.run(self.output_names, {self.input_name: data})\n        return outputs[0] if len(outputs) == 1 else outputs",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:209:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 209,
      "lineEnd": 220,
      "language": "python",
      "code": "from horus.ml_utils import preprocess_image_imagenet\n\n# Standard ImageNet preprocessing for classification models\npreprocessed = preprocess_image_imagenet(\n    image,\n    target_size=(224, 224),\n    mean=[0.485, 0.456, 0.406],\n    std=[0.229, 0.224, 0.225]\n)\n# Returns (1, C, H, W) normalized tensor",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:224:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 224,
      "lineEnd": 233,
      "language": "python",
      "code": "from horus.ml_utils import preprocess_image_yolo\n\n# Letterbox preprocessing for YOLO models\npreprocessed, scale, pad_w, pad_h = preprocess_image_yolo(\n    image,\n    target_size=640\n)\n# Returns preprocessed image and transform params for postprocessing",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:237:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 237,
      "lineEnd": 246,
      "language": "python",
      "code": "from horus.ml_utils import nms\n\n# Filter overlapping detections\nkeep_indices = nms(\n    boxes,      # (N, 4) as [x, y, w, h]\n    scores,     # (N,) confidence scores\n    iou_threshold=0.45\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:252:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 252,
      "lineEnd": 270,
      "language": "python",
      "code": "from horus.ml_utils import PerformanceMonitor\n\nmonitor = PerformanceMonitor(window_size=100)\n\n# In your inference loop\nfor frame in frames:\n    result, latency_ms = model.run_inference(frame)\n    monitor.record(latency_ms)\n\n# Get statistics\nstats = monitor.get_stats()\nprint(f\"Avg latency: {stats['avg_latency_ms']:.2f}ms\")\nprint(f\"P95 latency: {stats['p95_latency_ms']:.2f}ms\")\nprint(f\"FPS: {stats['fps']:.1f}\")\n\n# Or print summary\nmonitor.print_stats()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:289:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 289,
      "lineEnd": 310,
      "language": "python",
      "code": "import horus\nimport numpy as np\nimport torch\n\n# Create tensor pool\npool = horus.TensorPool(pool_id=1, size_mb=1024)\n\n# Allocate tensor\ntensor = pool.alloc(shape=(1080, 1920, 3), dtype=\"float32\")\n\n# Zero-copy to numpy\nnp_array = tensor.numpy()  # No copy!\n\n# Zero-copy to PyTorch\ntorch_tensor = tensor.torch()  # No copy!\n\n# For GPU tensors\nif horus.cuda_is_available():\n    gpu_tensor = tensor.cuda(\"cuda:0\")\n    torch_gpu = gpu_tensor.torch()  # Zero-copy GPU access",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/ml-utilities:314:python",
      "file": "content/docs/python/library/ml-utilities.mdx",
      "lineStart": 314,
      "lineEnd": 362,
      "language": "python",
      "code": "from horus import Node, Hub, Scheduler\nfrom horus.ml_utils import PyTorchInferenceNode, PerformanceMonitor\nimport numpy as np\n\nclass CameraNode(Node):\n    def __init__(self):\n        self.output = Hub(\"camera.raw\")\n\n    def name(self):\n        return \"CameraNode\"\n\n    def tick(self):\n        # Simulate camera frame\n        frame = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)\n        self.output.send(frame)\n\n\nclass DetectorNode(Node):\n    def __init__(self):\n        self.camera = Hub(\"camera.raw\")\n        self.output = Hub(\"detections\")\n        self.detector = ObjectDetector()\n        self.detector.load_model()\n        self.monitor = PerformanceMonitor()\n\n    def name(self):\n        return \"DetectorNode\"\n\n    def tick(self):\n        if frame := self.camera.recv():\n            result, latency = self.detector.run_inference(frame)\n            self.monitor.record(latency)\n            self.output.send(result)\n\n            # Print stats every 100 frames\n            if self.monitor.get_stats()[\"samples\"] % 100 == 0:\n                self.monitor.print_stats()\n\n\ndef main():\n    scheduler = Scheduler()\n    scheduler.add(CameraNode(), priority=0)\n    scheduler.add(DetectorNode(), priority=1)\n    scheduler.run()\n\nif __name__ == \"__main__\":\n    main()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:35:bash",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 35,
      "lineEnd": 47,
      "language": "bash",
      "code": "# All hardware dependencies\npip install pyserial pygame pynput smbus2 pynmea2 opencv-python rplidar-roboticia\n\n# Or install individually\npip install pyserial          # SerialNode\npip install pygame            # JoystickNode\npip install pynput            # KeyboardNode\npip install smbus2            # ImuNode (I2C)\npip install pynmea2 pyserial  # GpsNode\npip install opencv-python     # CameraNode\npip install rplidar-roboticia # LidarNode",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:53:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 53,
      "lineEnd": 68,
      "language": "python",
      "code": "from horus import Scheduler\nfrom horus.nodes import SerialNode, ImuNode, CameraNode\n\n# Create nodes (simulation mode if hardware unavailable)\nserial = SerialNode(port=\"/dev/ttyUSB0\", baudrate=115200)\nimu = ImuNode(i2c_bus=1, i2c_address=0x68)\ncamera = CameraNode(device_id=0, width=640, height=480)\n\n# Run with scheduler\nscheduler = Scheduler()\nscheduler.add(serial, priority=0)\nscheduler.add(imu, priority=1)\nscheduler.add(camera, priority=2)\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:78:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 78,
      "lineEnd": 97,
      "language": "python",
      "code": "from horus.nodes import SerialNode, SerialData\n\n# Create serial node\nserial = SerialNode(\n    port=\"/dev/ttyUSB0\",\n    baudrate=115200,\n    topic_prefix=\"serial\",\n    timeout=0.1,\n    simulation=False,  # Set True for prototyping\n)\n\n# Topics:\n#   serial.rx - Incoming data (SerialData)\n#   serial.tx - Outgoing data (subscribe to send)\n\n# Direct API\nserial.write(b\"Hello Arduino!\\n\")\nresponse = serial.readline()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:114:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 114,
      "lineEnd": 120,
      "language": "python",
      "code": "@dataclass\nclass SerialData:\n    port: str           # Port name\n    data: bytes         # Raw bytes\n    timestamp: float    # Unix timestamp",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:130:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 130,
      "lineEnd": 144,
      "language": "python",
      "code": "from horus.nodes import JoystickNode, JoystickState\n\njoystick = JoystickNode(\n    device_id=0,\n    deadzone=0.1,\n    topic_prefix=\"joy\",\n    simulation=False,\n)\n\n# Topics:\n#   joy.state   - Full state (JoystickState)\n#   joy.axes    - List of axis values\n#   joy.buttons - List of button states",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:157:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 157,
      "lineEnd": 166,
      "language": "python",
      "code": "@dataclass\nclass JoystickState:\n    axes: List[float]           # Axis values (-1 to 1)\n    buttons: List[bool]         # Button states\n    hats: List[Tuple[int,int]]  # D-pad/hat values\n    device_id: int              # Device index\n    device_name: str            # Controller name\n    timestamp: float",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:170:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 170,
      "lineEnd": 195,
      "language": "python",
      "code": "from horus import Node, Scheduler\nfrom horus.nodes import JoystickNode\n\nclass TankDrive(Node):\n    def __init__(self):\n        super().__init__(\n            name=\"tank_drive\",\n            subs=[\"joy.state\"],\n            pubs=[\"cmd_vel\"],\n            tick=self.control,\n        )\n\n    def control(self, node):\n        if node.has_msg(\"joy.state\"):\n            state = node.get(\"joy.state\")\n            # Left stick Y = forward, Right stick X = turn\n            linear = -state.axes[1] * 0.5   # Max 0.5 m/s\n            angular = state.axes[2] * 1.0   # Max 1.0 rad/s\n            node.send(\"cmd_vel\", {\"linear\": linear, \"angular\": angular})\n\nscheduler = Scheduler()\nscheduler.add(JoystickNode(device_id=0))\nscheduler.add(TankDrive())\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:205:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 205,
      "lineEnd": 216,
      "language": "python",
      "code": "from horus.nodes import KeyboardNode, KeyboardState\n\nkeyboard = KeyboardNode(\n    topic_prefix=\"keyboard\",\n    simulation=False,\n)\n\n# Topics:\n#   keyboard.events  - Key events (KeyboardState)\n#   keyboard.pressed - Currently pressed keys (set)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:227:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 227,
      "lineEnd": 235,
      "language": "python",
      "code": "@dataclass\nclass KeyboardState:\n    key: str           # Key character (e.g., 'w', 'space')\n    keycode: int       # Virtual key code\n    pressed: bool      # True=press, False=release\n    modifiers: dict    # Shift, Ctrl, Alt states\n    timestamp: float",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:239:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 239,
      "lineEnd": 270,
      "language": "python",
      "code": "from horus import Node, Scheduler\nfrom horus.nodes import KeyboardNode\n\nclass WASDTeleop(Node):\n    def __init__(self):\n        super().__init__(\n            name=\"wasd_teleop\",\n            subs=[\"keyboard.pressed\"],\n            pubs=[\"cmd_vel\"],\n            tick=self.control,\n            rate=30,\n        )\n\n    def control(self, node):\n        pressed = node.get(\"keyboard.pressed\") or set()\n\n        linear = 0.0\n        angular = 0.0\n\n        if 'w' in pressed: linear = 0.5\n        if 's' in pressed: linear = -0.5\n        if 'a' in pressed: angular = 1.0\n        if 'd' in pressed: angular = -1.0\n\n        node.send(\"cmd_vel\", {\"linear\": linear, \"angular\": angular})\n\nscheduler = Scheduler()\nscheduler.add(KeyboardNode())\nscheduler.add(WASDTeleop())\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:280:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 280,
      "lineEnd": 293,
      "language": "python",
      "code": "from horus.nodes import ImuNode, ImuData\n\nimu = ImuNode(\n    i2c_bus=1,\n    i2c_address=0x68,\n    topic_prefix=\"imu\",\n    frame_id=\"imu_link\",\n    simulation=False,\n)\n\n# Topics:\n#   imu - IMU data (ImuData)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:309:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 309,
      "lineEnd": 321,
      "language": "python",
      "code": "@dataclass\nclass ImuData:\n    accel_x: float      # m/s²\n    accel_y: float\n    accel_z: float\n    gyro_x: float       # rad/s\n    gyro_y: float\n    gyro_z: float\n    temperature: float  # °C\n    frame_id: str\n    timestamp: float",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:338:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 338,
      "lineEnd": 350,
      "language": "python",
      "code": "from horus.nodes import GpsNode, GpsData\n\ngps = GpsNode(\n    port=\"/dev/ttyACM0\",\n    baudrate=9600,\n    topic_prefix=\"gps\",\n    simulation=False,\n)\n\n# Topics:\n#   gps.fix - GPS fix data (GpsData)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:364:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 364,
      "lineEnd": 380,
      "language": "python",
      "code": "@dataclass\nclass GpsData:\n    latitude: float     # Degrees\n    longitude: float    # Degrees\n    altitude: float     # Meters\n    fix_type: int       # 0=none, 1=2D, 2=3D\n    satellites: int     # Visible satellites\n    hdop: float         # Horizontal dilution\n    speed: float        # m/s\n    heading: float      # Degrees\n    frame_id: str\n    timestamp: float\n\n    def has_fix(self) -> bool:\n        return self.fix_type > 0 and self.satellites >= 4",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:397:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 397,
      "lineEnd": 412,
      "language": "python",
      "code": "from horus.nodes import CameraNode, ImageData\n\ncamera = CameraNode(\n    device_id=0,\n    width=640,\n    height=480,\n    fps=30.0,\n    topic_prefix=\"camera\",\n    simulation=False,\n)\n\n# Topics:\n#   camera.image     - ImageData message\n#   camera.image_raw - Raw numpy array (for CV processing)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:428:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 428,
      "lineEnd": 438,
      "language": "python",
      "code": "@dataclass\nclass ImageData:\n    data: bytes         # Raw pixel data\n    width: int\n    height: int\n    encoding: str       # \"bgr8\", \"rgb8\", \"mono8\"\n    step: int           # Row stride in bytes\n    frame_id: str\n    timestamp: float",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:442:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 442,
      "lineEnd": 469,
      "language": "python",
      "code": "from horus import Node, Scheduler\nfrom horus.nodes import CameraNode\nimport cv2\n\nclass ObjectDetector(Node):\n    def __init__(self):\n        super().__init__(\n            name=\"detector\",\n            subs=[\"camera.image_raw\"],\n            pubs=[\"detections\"],\n            tick=self.detect,\n            rate=10,\n        )\n        # Load your model here\n\n    def detect(self, node):\n        if node.has_msg(\"camera.image_raw\"):\n            frame = node.get(\"camera.image_raw\")\n            # Run detection on frame\n            # detections = self.model.predict(frame)\n            # node.send(\"detections\", detections)\n\nscheduler = Scheduler()\nscheduler.add(CameraNode(device_id=0, width=640, height=480))\nscheduler.add(ObjectDetector())\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:479:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 479,
      "lineEnd": 493,
      "language": "python",
      "code": "from horus.nodes import LidarNode, LaserScan\n\nlidar = LidarNode(\n    port=\"/dev/ttyUSB0\",\n    num_samples=360,\n    range_min=0.15,\n    range_max=12.0,\n    topic_prefix=\"scan\",\n    simulation=False,\n)\n\n# Topics:\n#   scan - LaserScan data",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:509:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 509,
      "lineEnd": 521,
      "language": "python",
      "code": "@dataclass\nclass LaserScan:\n    ranges: List[float]       # Range measurements (meters)\n    intensities: List[float]  # Signal intensities\n    angle_min: float          # Start angle (radians)\n    angle_max: float          # End angle (radians)\n    angle_increment: float    # Angular resolution\n    range_min: float          # Minimum valid range\n    range_max: float          # Maximum valid range\n    frame_id: str\n    timestamp: float",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:533:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 533,
      "lineEnd": 575,
      "language": "python",
      "code": "from horus import Node, Scheduler\nfrom horus.nodes import LidarNode\nimport math\n\nclass ObstacleAvoider(Node):\n    def __init__(self):\n        super().__init__(\n            name=\"avoider\",\n            subs=[\"scan\"],\n            pubs=[\"cmd_vel\"],\n            tick=self.avoid,\n            rate=10,\n        )\n\n    def avoid(self, node):\n        if not node.has_msg(\"scan\"):\n            return\n\n        scan = node.get(\"scan\")\n\n        # Check front sector (±30 degrees)\n        front_ranges = []\n        for i, r in enumerate(scan.ranges):\n            angle = scan.angle_min + i * scan.angle_increment\n            if abs(angle) < math.radians(30):\n                if scan.range_min < r < scan.range_max:\n                    front_ranges.append(r)\n\n        min_front = min(front_ranges) if front_ranges else float('inf')\n\n        if min_front < 0.5:  # Obstacle within 0.5m\n            cmd = {\"linear\": 0.0, \"angular\": 0.5}  # Turn\n        else:\n            cmd = {\"linear\": 0.3, \"angular\": 0.0}  # Forward\n\n        node.send(\"cmd_vel\", cmd)\n\nscheduler = Scheduler()\nscheduler.add(LidarNode(port=\"/dev/ttyUSB0\"))\nscheduler.add(ObstacleAvoider())\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:585:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 585,
      "lineEnd": 591,
      "language": "python",
      "code": "# Explicit simulation\nimu = ImuNode(simulation=True)\n\n# Auto-fallback (if hardware unavailable)\nimu = ImuNode()  # Falls back to simulation if I2C fails",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:613:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 613,
      "lineEnd": 622,
      "language": "python",
      "code": "from horus.nodes import ImuNode\n\n# Node will auto-fallback to simulation if hardware fails\nimu = ImuNode(i2c_bus=1)\n\n# Check if running in simulation\nif imu.simulation:\n    print(\"Warning: IMU running in simulation mode\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:626:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 626,
      "lineEnd": 633,
      "language": "python",
      "code": "# Multiple cameras\ncam_front = CameraNode(device_id=0, topic_prefix=\"camera.front\")\ncam_rear = CameraNode(device_id=1, topic_prefix=\"camera.rear\")\n\n# Subscribe to specific camera\nnode.subs = [\"camera.front.image\"]",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:637:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 637,
      "lineEnd": 663,
      "language": "python",
      "code": "from horus import Node, Scheduler\nfrom horus.nodes import ImuNode, GpsNode\n\nclass SensorFusion(Node):\n    def __init__(self):\n        super().__init__(\n            name=\"fusion\",\n            subs=[\"imu\", \"gps.fix\"],\n            pubs=[\"pose\"],\n            tick=self.fuse,\n            rate=100,\n        )\n\n    def fuse(self, node):\n        imu = node.get(\"imu\")\n        gps = node.get(\"gps.fix\")\n        # Kalman filter, etc.\n        pose = self.kalman.update(imu, gps)\n        node.send(\"pose\", pose)\n\nscheduler = Scheduler()\nscheduler.add(ImuNode())\nscheduler.add(GpsNode())\nscheduler.add(SensorFusion())\nscheduler.run()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:671:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 671,
      "lineEnd": 681,
      "language": "python",
      "code": "from horus.nodes import (\n    SerialData,\n    JoystickState,\n    KeyboardState,\n    ImuData,\n    GpsData,\n    ImageData,\n    LaserScan,\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:685:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 685,
      "lineEnd": 695,
      "language": "python",
      "code": "from horus.nodes import (\n    SerialNode,\n    JoystickNode,\n    KeyboardNode,\n    ImuNode,\n    GpsNode,\n    CameraNode,\n    LidarNode,\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-hardware-nodes:699:python",
      "file": "content/docs/python/library/python-hardware-nodes.mdx",
      "lineStart": 699,
      "lineEnd": 707,
      "language": "python",
      "code": "# All nodes available from main horus module\nfrom horus import (\n    SerialNode, JoystickNode, KeyboardNode,\n    ImuNode, GpsNode, CameraNode, LidarNode,\n    SerialData, JoystickState, KeyboardState,\n    ImuData, GpsData, ImageData, LaserScan,\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:13:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 13,
      "lineEnd": 19,
      "language": "python",
      "code": "# Option 1: Import everything (recommended)\nimport horus\n\n# Option 2: Import specific types\nfrom horus import Pose2D, Twist, CmdVel, LaserScan, Transform, Point3, Vector3, Quaternion",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:36:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 36,
      "lineEnd": 57,
      "language": "python",
      "code": "from horus import Pose2D\n\n# Create pose\npose = Pose2D(x=1.0, y=2.0, theta=0.5)\n\n# Static constructors\norigin = Pose2D.origin()  # Pose2D(0, 0, 0)\n\n# Properties (read/write)\npose.x = 1.5\npose.y = 2.5\npose.theta = 0.785\ntimestamp = pose.timestamp  # Microseconds since epoch (read-only)\n\n# Methods\ndistance = pose.distance_to(other_pose)  # Euclidean distance\npose.normalize_angle()  # Normalize theta to [-π, π]\nis_valid = pose.is_valid()  # Check if values are finite\n\nprint(pose)  # Pose2D(x=1.500, y=2.500, theta=0.785)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:66:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 66,
      "lineEnd": 72,
      "language": "python",
      "code": "from horus import Hub, Pose2D\n\nhub = Hub(Pose2D)  # Typed hub\nhub.send(Pose2D(x=1.0, y=2.0, theta=0.5))\npose = hub.recv()  # Returns Pose2D or None",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:80:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 80,
      "lineEnd": 104,
      "language": "python",
      "code": "from horus import Twist\n\n# Create 3D twist\ntwist = Twist(\n    linear=[1.0, 0.0, 0.0],   # [x, y, z] in m/s\n    angular=[0.0, 0.0, 0.5]    # [roll, pitch, yaw] in rad/s\n)\n\n# Create 2D twist (common for ground robots)\ntwist_2d = Twist.new_2d(linear_x=1.0, angular_z=0.5)\n\n# Stop command\nstop = Twist.stop()  # All zeros\n\n# Properties\ntwist.linear = [1.5, 0.0, 0.0]\ntwist.angular = [0.0, 0.0, 0.3]\ntimestamp = twist.timestamp\n\n# Validation\nis_valid = twist.is_valid()  # Check finite values\n\nprint(twist)  # Twist(linear=[1.50, 0.00, 0.00], angular=[0.00, 0.00, 0.30])",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:117:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 117,
      "lineEnd": 140,
      "language": "python",
      "code": "from horus import Transform, Pose2D\n\n# Create transform\ntf = Transform(\n    translation=[1.0, 2.0, 0.0],  # [x, y, z]\n    rotation=[0.0, 0.0, 0.0, 1.0]  # Quaternion [x, y, z, w]\n)\n\n# Static constructors\nidentity = Transform.identity()  # No translation or rotation\nfrom_pose = Transform.from_pose_2d(Pose2D(1.0, 2.0, 0.5))  # Convert from 2D pose\n\n# Properties\ntf.translation = [1.5, 2.5, 0.0]\ntf.rotation = [0.0, 0.0, 0.707, 0.707]  # 90° rotation around Z\ntimestamp = tf.timestamp\n\n# Methods\ntf.normalize_rotation()  # Ensure quaternion is normalized\nis_valid = tf.is_valid()  # Check finite values and normalized quaternion\n\nprint(tf)  # Transform(translation=[1.50, 2.50, 0.00], rotation=[...])",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/python/library/python-message-library:153:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 153,
      "lineEnd": 175,
      "language": "python",
      "code": "from horus import Point3, Vector3, Quaternion\n\n# Point3 - 3D position\npoint = Point3(x=1.0, y=2.0, z=3.0)\norigin = Point3.origin()  # (0, 0, 0)\ndist = point.distance_to(other_point)\n\n# Vector3 - 3D vector with operations\nvec = Vector3(x=1.0, y=0.0, z=0.0)\nzero = Vector3.zero()  # (0, 0, 0)\nmagnitude = vec.magnitude()\nvec.normalize()  # In-place normalization\ndot_product = vec.dot(other_vec)\ncross_product = vec.cross(other_vec)  # Returns new Vector3\n\n# Quaternion - 3D rotation\nquat = Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)\nidentity = Quaternion.identity()  # No rotation\nfrom_euler = Quaternion.from_euler(roll=0.0, pitch=0.0, yaw=1.57)  # From Euler angles\nquat.normalize()  # Ensure unit quaternion\nis_valid = quat.is_valid()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:185:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 185,
      "lineEnd": 200,
      "language": "python",
      "code": "from horus import CmdVel\n\n# Create velocity command\ncmd = CmdVel(linear=1.0, angular=0.5)\n\n# Stop command\nstop = CmdVel.zero()  # CmdVel(0.0, 0.0)\n\n# Properties\ncmd.linear = 1.5   # m/s\ncmd.angular = 0.3  # rad/s\ntimestamp = cmd.timestamp\n\nprint(cmd)  # CmdVel(linear=1.50, angular=0.30)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:208:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 208,
      "lineEnd": 214,
      "language": "python",
      "code": "from horus import Hub, CmdVel\n\nhub = Hub(CmdVel)  # Typed hub\nhub.send(CmdVel(linear=1.0, angular=0.5))\ncmd = hub.recv()  # Returns CmdVel or None",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:224:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 224,
      "lineEnd": 256,
      "language": "python",
      "code": "from horus import LaserScan\nimport numpy as np\n\n# Create laser scan\nscan = LaserScan()\n\n# Set ranges (must be exactly 360 elements)\nscan.ranges = [1.0] * 360  # List or NumPy array\nscan.ranges = np.random.uniform(0.1, 10.0, 360)  # NumPy works too\n\n# Set scan parameters\nscan.angle_min = -3.14159       # Start angle (radians)\nscan.angle_max = 3.14159        # End angle (radians)\nscan.range_min = 0.1            # Minimum valid range (meters)\nscan.range_max = 10.0           # Maximum valid range (meters)\nscan.angle_increment = 0.01745  # Angular resolution (radians)\n\n# Access ranges as NumPy array (zero-copy)\nranges_array = scan.ranges  # Returns np.ndarray\nscan.ranges[90] = 2.5  # Modify directly\n\n# Query methods\nangle = scan.angle_at(180)  # Get angle for specific index\nis_valid = scan.is_range_valid(180)  # Check if reading is valid\nvalid_count = scan.valid_count()  # Count valid readings\nmin_reading = scan.min_range()  # Minimum valid range (or None)\n\n# Length\nlength = len(scan)  # Always 360\n\nprint(scan)  # LaserScan(ranges=360, valid=342, min=0.15m)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:268:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 268,
      "lineEnd": 282,
      "language": "python",
      "code": "from horus import Hub, LaserScan\n\nhub = Hub(\"lidar\")  # Generic hub for LaserScan\n\n# Send\nscan = LaserScan()\nscan.ranges = read_lidar_hardware()  # Your driver\nhub.send(scan)\n\n# Receive\nscan = hub.recv()  # Returns LaserScan or None\nif scan:\n    print(f\"Got {scan.valid_count()} valid readings\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:310:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 310,
      "lineEnd": 316,
      "language": "python",
      "code": "# Python sender\nfrom horus import Hub, CmdVel\n\nhub = Hub(CmdVel)  # Typed hub\nhub.send(CmdVel(linear=1.0, angular=0.5))",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:318:rust",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 318,
      "lineEnd": 327,
      "language": "rust",
      "code": "// Rust receiver\nuse horus::prelude::*;\nuse horus::prelude::*; // Provides cmd_vel::CmdVel;\n\nlet hub = Hub::<CmdVel>::new(\"cmd_vel\")?;\nif let Some(cmd) = hub.recv(&mut None) {\n    println!(\"Received: linear={}, angular={}\", cmd.linear, cmd.angular);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/python/library/python-message-library:335:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 335,
      "lineEnd": 356,
      "language": "python",
      "code": "from horus import Node, run, Hub, CmdVel, LaserScan\n\n# Create hubs outside tick function\nscan_hub = Hub(\"lidar\")\ncmd_hub = Hub(CmdVel)\n\ndef controller_tick(node):\n    scan = scan_hub.recv()\n    if scan:\n        # Simple obstacle avoidance\n        min_dist = scan.min_range()\n        if min_dist and min_dist < 0.5:\n            # Too close - stop\n            cmd_hub.send(CmdVel.zero())\n        else:\n            # Safe - move forward\n            cmd_hub.send(CmdVel(linear=0.5, angular=0.0))\n\nnode = Node(name=\"controller\", tick=controller_tick, rate=10)\nrun(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:360:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 360,
      "lineEnd": 377,
      "language": "python",
      "code": "from horus import Hub, Pose2D\n\n# Track robot pose\npose_hub = Hub(Pose2D)\n\ncurrent_pose = Pose2D.origin()\n\ndef update_pose(delta_x, delta_y, delta_theta):\n    global current_pose\n    current_pose.x += delta_x\n    current_pose.y += delta_y\n    current_pose.theta += delta_theta\n    current_pose.normalize_angle()\n\n    if current_pose.is_valid():\n        pose_hub.send(current_pose)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:385:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 385,
      "lineEnd": 400,
      "language": "python",
      "code": "from horus import Imu\n\nimu = Imu()\n\n# Orientation as quaternion [x, y, z, w]\nimu.orientation = [0.0, 0.0, 0.0, 1.0]\n\n# Angular velocity [x, y, z] in rad/s\nimu.angular_velocity = [0.0, 0.0, 0.1]\n\n# Linear acceleration [x, y, z] in m/s²\nimu.linear_acceleration = [0.0, 0.0, 9.81]\n\nprint(imu)  # Imu(orientation=[0.00,0.00,0.00,1.00], angular_vel=[0.00,0.00,0.10])",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:408:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 408,
      "lineEnd": 427,
      "language": "python",
      "code": "from horus import Odometry\n\nodom = Odometry()\n\n# 2D pose access\nodom.x = 1.0       # meters\nodom.y = 2.0       # meters\nodom.theta = 0.5   # radians\n\n# 3D pose access\nodom.position = [1.0, 2.0, 0.0]      # [x, y, z]\nodom.orientation = [0.0, 0.0, 0.25, 0.97]  # quaternion [x, y, z, w]\n\n# Velocity\nodom.linear_velocity = [0.5, 0.0, 0.0]   # [vx, vy, vz] m/s\nodom.angular_velocity = [0.0, 0.0, 0.1]  # [wx, wy, wz] rad/s\n\nprint(odom)  # Odometry(pos=[1.00,2.00,0.50], vel=[0.50,0.00,0.00])",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:435:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 435,
      "lineEnd": 444,
      "language": "python",
      "code": "from horus import BatteryState\n\nbattery = BatteryState(voltage=12.6, percentage=85.0)\n\nbattery.voltage = 11.8       # Volts\nbattery.percentage = 75.0    # 0-100%\nbattery.current = 2.5        # Amps (positive = discharging)\nbattery.temperature = 25.0   # Celsius",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:452:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 452,
      "lineEnd": 460,
      "language": "python",
      "code": "from horus import NavSatFix\n\ngps = NavSatFix(latitude=37.7749, longitude=-122.4194, altitude=10.0)\n\ngps.latitude = 37.7749    # degrees\ngps.longitude = -122.4194 # degrees\ngps.altitude = 10.0       # meters above sea level",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:468:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 468,
      "lineEnd": 476,
      "language": "python",
      "code": "from horus import Range\n\nrange_sensor = Range()\nrange_sensor.range = 1.5       # meters\nrange_sensor.min_range = 0.02  # minimum valid range\nrange_sensor.max_range = 4.0   # maximum valid range\nrange_sensor.field_of_view = 0.26  # radians (~15°)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:486:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 486,
      "lineEnd": 494,
      "language": "python",
      "code": "from horus import MotorCommand\n\ncmd = MotorCommand()\ncmd.velocity = 100.0      # RPM or rad/s depending on mode\ncmd.position = 0.0        # Target position (radians)\ncmd.torque = 0.0          # Torque limit (Nm)\ncmd.mode = 0              # 0=velocity, 1=position, 2=torque",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:502:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 502,
      "lineEnd": 508,
      "language": "python",
      "code": "from horus import DifferentialDriveCommand\n\ncmd = DifferentialDriveCommand()\ncmd.left_velocity = 1.0   # Left wheel velocity (m/s or rad/s)\ncmd.right_velocity = 1.0  # Right wheel velocity",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:516:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 516,
      "lineEnd": 522,
      "language": "python",
      "code": "from horus import ServoCommand\n\ncmd = ServoCommand()\ncmd.angle = 90.0          # Target angle (degrees)\ncmd.speed = 100           # Movement speed (0-100%)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:530:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 530,
      "lineEnd": 537,
      "language": "python",
      "code": "from horus import PidConfig\n\npid = PidConfig()\npid.kp = 1.0   # Proportional gain\npid.ki = 0.1   # Integral gain\npid.kd = 0.05  # Derivative gain",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:547:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 547,
      "lineEnd": 564,
      "language": "python",
      "code": "from horus import Image, ImageEncoding\n\nimg = Image()\nimg.width = 640\nimg.height = 480\nimg.encoding = ImageEncoding.RGB8\nimg.data = bytes(640 * 480 * 3)  # Raw pixel data\n\n# Access encoding constants\nImageEncoding.RGB8      # 8-bit RGB\nImageEncoding.BGR8      # 8-bit BGR\nImageEncoding.RGBA8     # 8-bit RGBA\nImageEncoding.MONO8     # 8-bit grayscale\nImageEncoding.MONO16    # 16-bit grayscale\nImageEncoding.DEPTH16   # 16-bit depth\nImageEncoding.DEPTH32F  # 32-bit float depth",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:572:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 572,
      "lineEnd": 578,
      "language": "python",
      "code": "from horus import CompressedImage\n\nimg = CompressedImage()\nimg.format = \"jpeg\"           # \"jpeg\" or \"png\"\nimg.data = jpeg_bytes         # Compressed image data",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:586:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 586,
      "lineEnd": 596,
      "language": "python",
      "code": "from horus import CameraInfo\n\ninfo = CameraInfo()\ninfo.width = 640\ninfo.height = 480\ninfo.fx = 525.0   # Focal length X\ninfo.fy = 525.0   # Focal length Y\ninfo.cx = 320.0   # Principal point X\ninfo.cy = 240.0   # Principal point Y",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:604:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 604,
      "lineEnd": 615,
      "language": "python",
      "code": "from horus import Detection\n\ndet = Detection()\ndet.class_id = 0           # Class index\ndet.class_name = \"person\"  # Class label\ndet.confidence = 0.95      # Detection confidence (0-1)\ndet.x = 100                # Bounding box X\ndet.y = 50                 # Bounding box Y\ndet.width = 200            # Bounding box width\ndet.height = 400           # Bounding box height",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:623:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 623,
      "lineEnd": 632,
      "language": "python",
      "code": "from horus import DetectionArray, Detection\n\ndetections = DetectionArray()\ndetections.detections = [\n    Detection(),  # Add detection objects\n]\ndetections.source_width = 640\ndetections.source_height = 480",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:642:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 642,
      "lineEnd": 656,
      "language": "python",
      "code": "from horus import Goal, GoalStatus\n\ngoal = Goal()\ngoal.x = 10.0           # Target X position\ngoal.y = 5.0            # Target Y position\ngoal.theta = 0.0        # Target orientation\ngoal.tolerance = 0.1    # Position tolerance (meters)\n\n# Goal status values\nGoalStatus.PENDING    # Not yet started\nGoalStatus.ACTIVE     # Currently executing\nGoalStatus.SUCCEEDED  # Completed successfully\nGoalStatus.ABORTED    # Failed/cancelled",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:664:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 664,
      "lineEnd": 673,
      "language": "python",
      "code": "from horus import Path, Waypoint\n\npath = Path()\npath.waypoints = [\n    Waypoint(x=0.0, y=0.0, theta=0.0),\n    Waypoint(x=5.0, y=0.0, theta=0.0),\n    Waypoint(x=5.0, y=5.0, theta=1.57),\n]",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:681:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 681,
      "lineEnd": 691,
      "language": "python",
      "code": "from horus import OccupancyGrid\n\ngrid = OccupancyGrid()\ngrid.width = 100          # Grid width (cells)\ngrid.height = 100         # Grid height (cells)\ngrid.resolution = 0.05    # Meters per cell\ngrid.origin_x = -2.5      # Map origin X\ngrid.origin_y = -2.5      # Map origin Y\ngrid.data = bytes(100 * 100)  # 0=free, 100=occupied, -1=unknown",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:699:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 699,
      "lineEnd": 707,
      "language": "python",
      "code": "from horus import CostMap\n\ncostmap = CostMap()\ncostmap.width = 100\ncostmap.height = 100\ncostmap.resolution = 0.05\ncostmap.data = bytes(100 * 100)  # Cost values 0-255",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:717:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 717,
      "lineEnd": 734,
      "language": "python",
      "code": "from horus import PointCloud, PointField, PointFieldType\n\ncloud = PointCloud()\ncloud.width = 1000        # Number of points\ncloud.height = 1          # 1 for unorganized, >1 for organized\ncloud.point_step = 12     # Bytes per point\ncloud.row_step = 12000    # Bytes per row\n\n# Define point format (XYZ float32)\ncloud.fields = [\n    PointField(name=\"x\", offset=0, datatype=PointFieldType.FLOAT32, count=1),\n    PointField(name=\"y\", offset=4, datatype=PointFieldType.FLOAT32, count=1),\n    PointField(name=\"z\", offset=8, datatype=PointFieldType.FLOAT32, count=1),\n]\n\ncloud.data = point_data_bytes  # Raw point data",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:742:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 742,
      "lineEnd": 750,
      "language": "python",
      "code": "from horus import DepthImage\n\ndepth = DepthImage()\ndepth.width = 640\ndepth.height = 480\ndepth.encoding = \"32FC1\"  # 32-bit float, 1 channel\ndepth.data = depth_bytes  # Raw depth data",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:758:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 758,
      "lineEnd": 768,
      "language": "python",
      "code": "from horus import BoundingBox3D\n\nbox = BoundingBox3D()\nbox.center = [1.0, 2.0, 0.5]       # Center position [x, y, z]\nbox.size = [0.5, 0.5, 1.8]         # Dimensions [length, width, height]\nbox.orientation = [0.0, 0.0, 0.0, 1.0]  # Quaternion\nbox.class_id = 0\nbox.class_name = \"person\"\nbox.confidence = 0.92",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:778:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 778,
      "lineEnd": 784,
      "language": "python",
      "code": "from horus import WrenchStamped\n\nwrench = WrenchStamped()\nwrench.force = [10.0, 0.0, -9.81]   # Force [fx, fy, fz] in Newtons\nwrench.torque = [0.0, 0.5, 0.0]     # Torque [tx, ty, tz] in Nm",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:792:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 792,
      "lineEnd": 799,
      "language": "python",
      "code": "from horus import TactileArray\n\ntactile = TactileArray()\ntactile.rows = 4\ntactile.cols = 4\ntactile.data = [0.0] * 16  # Pressure values",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:807:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 807,
      "lineEnd": 813,
      "language": "python",
      "code": "from horus import ForceCommand\n\ncmd = ForceCommand()\ncmd.force = [0.0, 0.0, -10.0]   # Desired force [fx, fy, fz]\ncmd.torque = [0.0, 0.0, 0.0]    # Desired torque [tx, ty, tz]",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:823:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 823,
      "lineEnd": 840,
      "language": "python",
      "code": "from horus import RobotState, RobotType\n\nstate = RobotState()\nstate.robot_id = \"robot_01\"\nstate.robot_type = RobotType.GROUND\nstate.x = 5.0\nstate.y = 3.0\nstate.theta = 0.0\nstate.battery_level = 85.0\nstate.is_active = True\n\n# Robot types\nRobotType.GROUND     # Ground robot (UGV)\nRobotType.AERIAL     # Aerial robot (UAV)\nRobotType.MARINE     # Marine robot (USV/AUV)\nRobotType.ARM        # Robot arm/manipulator",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:848:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 848,
      "lineEnd": 858,
      "language": "python",
      "code": "from horus import FleetStatus, RobotState\n\nfleet = FleetStatus()\nfleet.fleet_id = \"warehouse_fleet\"\nfleet.robots = [\n    RobotState(),  # Add robot states\n]\nfleet.active_count = 5\nfleet.total_count = 8",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:866:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 866,
      "lineEnd": 891,
      "language": "python",
      "code": "from horus import TaskAssignment, TaskType, TaskStatus\n\ntask = TaskAssignment()\ntask.task_id = \"task_001\"\ntask.robot_id = \"robot_01\"\ntask.task_type = TaskType.NAVIGATION\ntask.status = TaskStatus.ACTIVE\ntask.priority = 5\ntask.goal_x = 10.0\ntask.goal_y = 5.0\n\n# Task types\nTaskType.NAVIGATION   # Move to location\nTaskType.PICKUP       # Pick up object\nTaskType.DELIVERY     # Deliver object\nTaskType.INSPECTION   # Inspect area\nTaskType.CHARGING     # Go to charger\n\n# Task status\nTaskStatus.PENDING    # Waiting to start\nTaskStatus.ACTIVE     # In progress\nTaskStatus.COMPLETED  # Successfully done\nTaskStatus.FAILED     # Failed\nTaskStatus.CANCELLED  # Cancelled",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/python/library/python-message-library:899:python",
      "file": "content/docs/python/library/python-message-library.mdx",
      "lineStart": 899,
      "lineEnd": 913,
      "language": "python",
      "code": "from horus import FormationControl, FormationType\n\nformation = FormationControl()\nformation.formation_type = FormationType.LINE\nformation.spacing = 2.0           # Distance between robots\nformation.leader_id = \"robot_01\"\n\n# Formation types\nFormationType.LINE       # Single file line\nFormationType.COLUMN     # Side-by-side column\nFormationType.WEDGE      # V-shaped wedge\nFormationType.CIRCLE     # Circular formation\nFormationType.CUSTOM     # Custom positions",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/control-messages:15:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 15,
      "lineEnd": 31,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::MotorCommand;\n\n// Velocity control\nlet vel_cmd = MotorCommand::velocity(0, 1.5);  // motor_id=0, 1.5 rad/s\n\n// Position control with max velocity\nlet pos_cmd = MotorCommand::position(0, 3.14, 2.0);  // motor_id=0, 3.14 rad, max 2 rad/s\n\n// Stop motor\nlet stop_cmd = MotorCommand::stop(0);\n\n// Check validity\nif vel_cmd.is_valid() {\n    println!(\"Target: {:.2}\", vel_cmd.target);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:59:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 59,
      "lineEnd": 77,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::DifferentialDriveCommand;\n\n// Direct wheel velocities\nlet cmd = DifferentialDriveCommand::new(1.0, 1.2);  // left=1.0, right=1.2 rad/s\n\n// From linear and angular velocities\nlet wheel_base = 0.5;   // 50cm between wheels\nlet wheel_radius = 0.1; // 10cm wheels\nlet cmd = DifferentialDriveCommand::from_twist(\n    0.5,  // 0.5 m/s forward\n    0.2,  // 0.2 rad/s rotation\n    wheel_base,\n    wheel_radius\n);\n\n// Stop\nlet stop = DifferentialDriveCommand::stop();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:93:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 93,
      "lineEnd": 107,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::ServoCommand;\n\n// Position command (radians)\nlet cmd = ServoCommand::new(0, 1.57);  // servo_id=0, 90 degrees\n\n// With specific speed (0-1)\nlet cmd = ServoCommand::with_speed(0, 1.57, 0.3);  // 30% speed\n\n// From degrees\nlet cmd = ServoCommand::from_degrees(0, 90.0);\n\n// Disable servo (release torque)\nlet disable = ServoCommand::disable(0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:123:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 123,
      "lineEnd": 145,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::PwmCommand;\n\n// Basic PWM command\nlet cmd = PwmCommand::new(0, 0.75);  // channel=0, 75% duty cycle\n\n// Forward/reverse\nlet forward = PwmCommand::forward(0, 0.8);   // 80% forward\nlet reverse = PwmCommand::reverse(0, 0.5);   // 50% reverse\n\n// Stop modes\nlet coast = PwmCommand::coast(0);  // Coast to stop\nlet brake = PwmCommand::brake(0);  // Active braking\n\n// With custom frequency\nlet cmd = PwmCommand::new(0, 0.5)\n    .with_frequency(20000)      // 20kHz PWM\n    .with_current_limit(2.5);   // 2.5A limit\n\n// Check properties\nprintln!(\"Speed: {:.1}%\", cmd.speed() * 100.0);\nprintln!(\"Direction: {}\", if cmd.is_forward() { \"forward\" } else { \"reverse\" });",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:163:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 163,
      "lineEnd": 186,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::StepperCommand;\n\n// Relative steps\nlet steps_cmd = StepperCommand::steps(0, 200);  // 200 steps forward\n\n// Absolute position\nlet pos_cmd = StepperCommand::position(0, 3.14, 1000.0);  // 3.14 rad, max 1000 steps/s\n\n// Continuous velocity\nlet vel_cmd = StepperCommand::velocity(0, 500.0);  // 500 steps/s\n\n// Homing\nlet home_cmd = StepperCommand::home(0, 100.0);  // Home at 100 steps/s\n\n// Disable (release holding torque)\nlet disable = StepperCommand::disable(0);\n\n// With options\nlet cmd = StepperCommand::position(0, 6.28, 2000.0)\n    .with_microsteps(16)        // 1/16 microstepping\n    .with_acceleration(5000.0)  // 5000 steps/s²\n    .with_current_limit(800);   // 800mA",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:215:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 215,
      "lineEnd": 238,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::PidConfig;\n\n// Full PID\nlet pid = PidConfig::new(1.0, 0.1, 0.05);  // Kp, Ki, Kd\n\n// P-only controller\nlet p_only = PidConfig::proportional(2.0);\n\n// PI controller\nlet pi = PidConfig::pi(1.5, 0.2);\n\n// PD controller\nlet pd = PidConfig::pd(1.0, 0.1);\n\n// With limits\nlet pid_limited = PidConfig::new(1.0, 0.1, 0.05)\n    .with_limits(10.0, 100.0);  // integral_limit, output_limit\n\n// Validation\nif pid.is_valid() {\n    println!(\"Kp={}, Ki={}, Kd={}\", pid.kp, pid.ki, pid.kd);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:257:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 257,
      "lineEnd": 269,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::TrajectoryPoint;\n\n// Simple 2D trajectory point\nlet point = TrajectoryPoint::new_2d(\n    1.0, 2.0,   // x, y position\n    0.5, 0.3,   // vx, vy velocity\n    1.5         // time from start (seconds)\n);\n\n// Stationary point\nlet waypoint = TrajectoryPoint::stationary(1.0, 2.0, 0.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:286:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 286,
      "lineEnd": 298,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides control::JointCommand;\n\nlet mut cmd = JointCommand::new();\n\n// Add position commands\ncmd.add_position(\"shoulder\", 0.5)?;\ncmd.add_position(\"elbow\", 1.0)?;\ncmd.add_position(\"wrist\", -0.3)?;\n\n// Add velocity commands\ncmd.add_velocity(\"gripper\", 0.2)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/control-messages:322:rust",
      "file": "content/docs/rust/api/control-messages.mdx",
      "lineStart": 322,
      "lineEnd": 359,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides control::{PwmCommand, DifferentialDriveCommand};\nuse horus::prelude::*; // Provides CmdVel;\n\nstruct MotorDriverNode {\n    cmd_sub: Hub<CmdVel>,\n    left_pwm_pub: Hub<PwmCommand>,\n    right_pwm_pub: Hub<PwmCommand>,\n    wheel_base: f64,\n    wheel_radius: f64,\n    max_speed: f64,\n}\n\nimpl Node for MotorDriverNode {\n    fn name(&self) -> &'static str { \"MotorDriver\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            // Convert CmdVel to differential drive\n            let diff = DifferentialDriveCommand::from_twist(\n                cmd.linear as f64,\n                cmd.angular as f64,\n                self.wheel_base,\n                self.wheel_radius\n            );\n\n            // Convert to PWM (-1 to 1)\n            let left_duty = (diff.left_velocity / self.max_speed).clamp(-1.0, 1.0) as f32;\n            let right_duty = (diff.right_velocity / self.max_speed).clamp(-1.0, 1.0) as f32;\n\n            // Send PWM commands\n            self.left_pwm_pub.send(PwmCommand::new(0, left_duty), &mut ctx).ok();\n            self.right_pwm_pub.send(PwmCommand::new(1, right_duty), &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/coordination-messages:15:rust",
      "file": "content/docs/rust/api/coordination-messages.mdx",
      "lineStart": 15,
      "lineEnd": 51,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides coordination::{RobotState, RobotType, RobotCapability};\nuse horus::prelude::*; // Provides geometry::{Pose2D, Twist};\n\n// Create robot state\nlet mut robot = RobotState::new(\"robot_01\", RobotType::Mobile);\n\n// Update motion state\nrobot.update_motion(\n    Pose2D::new(5.0, 3.0, 1.57),\n    Twist::linear(0.5, 0.0)\n);\n\n// Set capabilities\nrobot.set_capability(RobotCapability::Navigation, true);\nrobot.set_capability(RobotCapability::Transport, true);\nrobot.set_capability(RobotCapability::Vision, true);\n\n// Set battery and status\nrobot.battery_level = 85.0;\nrobot.load_factor = 0.3;  // 30% loaded\n\n// Check availability\nif robot.is_available() {\n    println!(\"{} is available for tasks\", robot.robot_id_str());\n}\n\n// Check if maintenance needed\nif robot.needs_maintenance() {\n    println!(\"{} needs maintenance\", robot.robot_id_str());\n}\n\n// Check capabilities\nif robot.has_capability(RobotCapability::Navigation) {\n    println!(\"Robot can navigate autonomously\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/coordination-messages:108:rust",
      "file": "content/docs/rust/api/coordination-messages.mdx",
      "lineStart": 108,
      "lineEnd": 143,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides coordination::{FleetStatus, RobotState, RobotType, CoordinationMode};\n\n// Create fleet\nlet mut fleet = FleetStatus::new(\"warehouse_fleet\");\nfleet.coordination_mode = CoordinationMode::Centralized;\n\n// Add robots\nlet robot1 = RobotState::new(\"robot_01\", RobotType::Transport);\nlet robot2 = RobotState::new(\"robot_02\", RobotType::Transport);\n\nfleet.update_robot(robot1)?;\nfleet.update_robot(robot2)?;\n\nprintln!(\"Fleet has {} robots\", fleet.robot_count);\nprintln!(\"Average battery: {:.1}%\", fleet.average_battery);\nprintln!(\"Communication health: {:.1}%\", fleet.comm_health * 100.0);\n\n// Get available robots\nlet available = fleet.available_robots();\nprintln!(\"{} robots available for tasks\", available.len());\n\n// Get robots needing maintenance\nlet maintenance = fleet.maintenance_needed();\nif !maintenance.is_empty() {\n    println!(\"{} robots need maintenance\", maintenance.len());\n}\n\n// Check emergency status\nif fleet.emergency_active {\n    println!(\"EMERGENCY: Fleet-wide emergency active!\");\n}\n\n// Remove robot\nfleet.remove_robot(\"robot_02\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/coordination-messages:174:rust",
      "file": "content/docs/rust/api/coordination-messages.mdx",
      "lineStart": 174,
      "lineEnd": 195,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides coordination::{TaskAssignment, TaskType, TaskStatus, RobotCapability};\n\n// Create navigation task\nlet task = TaskAssignment::new(1001, \"robot_01\", TaskType::Navigation)\n    .with_priority_deadline(0, 1704067200_000_000_000)  // High priority with deadline\n    .with_capabilities(RobotCapability::Navigation as u32);\n\nprintln!(\"Task {} assigned to {}\", task.task_id, task.robot_id_str());\n\n// Update task status\nlet mut task = task;\ntask.update_status(TaskStatus::InProgress);\n\n// Check if overdue\nif task.is_overdue() {\n    println!(\"Task {} is overdue!\", task.task_id);\n}\n\n// Mark completed\ntask.update_status(TaskStatus::Completed);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/coordination-messages:247:rust",
      "file": "content/docs/rust/api/coordination-messages.mdx",
      "lineStart": 247,
      "lineEnd": 269,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides coordination::{FormationControl, FormationType};\nuse horus::prelude::*; // Provides geometry::Twist;\n\n// Leader-follower formation\nlet follower = FormationControl::leader_follower(\"leader_robot\", [-1.0, 0.5]);\nprintln!(\"Following at offset ({:.1}, {:.1})\",\n    follower.relative_position[0], follower.relative_position[1]);\n\n// Circle formation (index 0 of 4 robots, 2m radius)\nlet circle_pos = FormationControl::circle(0, 4, 2.0);\n\n// Custom formation\nlet mut formation = FormationControl::default();\nformation.formation_type = FormationType::Grid;\nformation.spacing = 1.5;  // 1.5m spacing\nformation.scale = 1.0;\nformation.stiffness = 0.8;  // 80% stiffness\nformation.enabled = true;\n\n// Disable formation keeping\nformation.set_enabled(false);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/coordination-messages:304:rust",
      "file": "content/docs/rust/api/coordination-messages.mdx",
      "lineStart": 304,
      "lineEnd": 323,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides coordination::{AuctionBid, BidStatus};\n\n// Create bid for task\nlet mut bid = AuctionBid::new(1001, \"robot_02\", 15.5);  // task_id, robot_id, bid_value\nbid.estimated_time = 30.0;  // 30 seconds\nbid.capability_score = 0.9;  // 90% capability match\nbid.availability = 0.8;       // 80% available\n\n// Set expiration\nbid.expiration_time = bid.bid_time + 5_000_000_000;  // 5 second expiration\n\n// Check if valid\nif bid.is_valid() {\n    println!(\"Bid score: {:.2}\", bid.total_score());\n}\n\n// Update status after auction\nbid.status = BidStatus::Won;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/coordination-messages:352:rust",
      "file": "content/docs/rust/api/coordination-messages.mdx",
      "lineStart": 352,
      "lineEnd": 442,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides coordination::{\n    FleetStatus, RobotState, TaskAssignment, TaskType, TaskStatus,\n    AuctionBid, BidStatus, CoordinationMode\n};\n\nstruct FleetManagerNode {\n    fleet: FleetStatus,\n    robot_state_sub: Hub<RobotState>,\n    task_request_sub: Hub<TaskAssignment>,\n    bid_sub: Hub<AuctionBid>,\n    task_pub: Hub<TaskAssignment>,\n    fleet_pub: Hub<FleetStatus>,\n    pending_auctions: Vec<(u32, Vec<AuctionBid>)>,  // task_id -> bids\n}\n\nimpl Node for FleetManagerNode {\n    fn name(&self) -> &'static str { \"FleetManager\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update robot states\n        while let Some(state) = self.robot_state_sub.try_recv(&mut ctx) {\n            self.fleet.update_robot(state).ok();\n        }\n\n        // Process new task requests\n        while let Some(task) = self.task_request_sub.try_recv(&mut ctx) {\n            match self.fleet.coordination_mode {\n                CoordinationMode::Centralized => {\n                    // Assign to best available robot\n                    if let Some(robot) = self.find_best_robot(&task) {\n                        let mut assigned_task = task;\n                        let robot_id = robot.robot_id;\n                        assigned_task.robot_id = robot_id;\n                        assigned_task.update_status(TaskStatus::Assigned);\n                        self.task_pub.send(assigned_task, &mut ctx).ok();\n                    }\n                }\n                CoordinationMode::MarketBased => {\n                    // Start auction\n                    self.pending_auctions.push((task.task_id, Vec::new()));\n                }\n                _ => {}\n            }\n        }\n\n        // Process bids for market-based coordination\n        while let Some(bid) = self.bid_sub.try_recv(&mut ctx) {\n            for (task_id, bids) in &mut self.pending_auctions {\n                if *task_id == bid.task_id {\n                    bids.push(bid);\n                }\n            }\n        }\n\n        // Resolve auctions (select lowest bid score)\n        self.pending_auctions.retain(|(task_id, bids)| {\n            if bids.len() >= self.fleet.robot_count as usize {\n                if let Some(winner) = bids.iter()\n                    .filter(|b| b.is_valid())\n                    .min_by(|a, b| a.total_score().partial_cmp(&b.total_score()).unwrap())\n                {\n                    let task = TaskAssignment::new(*task_id, &winner.robot_id_str(), TaskType::Navigation);\n                    self.task_pub.send(task, &mut ctx).ok();\n                }\n                false  // Remove from pending\n            } else {\n                true   // Keep waiting for more bids\n            }\n        });\n\n        // Publish fleet status\n        self.fleet_pub.send(self.fleet.clone(), &mut ctx).ok();\n    }\n}\n\nimpl FleetManagerNode {\n    fn find_best_robot(&self, task: &TaskAssignment) -> Option<&RobotState> {\n        self.fleet.available_robots()\n            .into_iter()\n            .filter(|r| (r.capabilities & task.required_capabilities) == task.required_capabilities)\n            .min_by(|a, b| a.priority.cmp(&b.priority))\n    }\n\n    fn robot_id_str(robot_id: &[u8; 32]) -> String {\n        let end = robot_id.iter().position(|&b| b == 0).unwrap_or(32);\n        String::from_utf8_lossy(&robot_id[..end]).into_owned()\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/core:16:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 16,
      "lineEnd": 18,
      "language": "rust",
      "code": "use horus::prelude::*;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:26:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 26,
      "lineEnd": 38,
      "language": "rust",
      "code": "pub trait Node: Send {\n    fn name(&self) -> &'static str;\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>);\n\n    // Optional methods with defaults\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> { Ok(()) }\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> { Ok(()) }\n    fn on_error(&mut self, error: &str, ctx: &mut NodeInfo) { }\n    fn get_publishers(&self) -> Vec<TopicMetadata> { vec![] }\n    fn get_subscribers(&self) -> Vec<TopicMetadata> { vec![] }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:44:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 44,
      "lineEnd": 46,
      "language": "rust",
      "code": "fn name(&self) -> &'static str",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:53:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 53,
      "lineEnd": 57,
      "language": "rust",
      "code": "fn name(&self) -> &'static str {\n    \"my_sensor_node\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:63:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 63,
      "lineEnd": 65,
      "language": "rust",
      "code": "fn tick(&mut self, ctx: Option<&mut NodeInfo>)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:73:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 73,
      "lineEnd": 86,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Read sensor\n    let value = self.sensor.read();\n\n    // Publish data\n    self.publisher.send(value, &mut ctx).ok();\n\n    // Log (must unwrap Option)\n    if let Some(ref mut c) = ctx {\n        c.log_debug(&format!(\"Published: {}\", value));\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:94:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 94,
      "lineEnd": 96,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:111:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 111,
      "lineEnd": 113,
      "language": "rust",
      "code": "fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:128:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 128,
      "lineEnd": 130,
      "language": "rust",
      "code": "fn on_error(&mut self, error: &str, ctx: &mut NodeInfo)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:144:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 144,
      "lineEnd": 184,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct TemperatureSensor {\n    publisher: Hub<f32>,\n    sample_count: u64,\n}\n\nimpl TemperatureSensor {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            publisher: Hub::new(\"temperature\")?,\n            sample_count: 0,\n        })\n    }\n}\n\nimpl Node for TemperatureSensor {\n    fn name(&self) -> &'static str {\n        \"temperature_sensor\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Temperature sensor initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Simulate reading temperature\n        let temp = 20.0 + (self.sample_count as f32 * 0.1).sin() * 5.0;\n\n        self.publisher.send(temp, &mut ctx).ok();\n        self.sample_count += 1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(&format!(\"Sensor shutdown after {} samples\", self.sample_count));\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/core:192:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 192,
      "lineEnd": 194,
      "language": "rust",
      "code": "pub struct Hub<T> { /* fields omitted */ }",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:204:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 204,
      "lineEnd": 206,
      "language": "rust",
      "code": "pub fn new(topic_name: &str) -> Result<Self>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:216:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 216,
      "lineEnd": 218,
      "language": "rust",
      "code": "let hub: Hub<f32> = Hub::new(\"sensor.temperature\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/core:224:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 224,
      "lineEnd": 226,
      "language": "rust",
      "code": "pub fn new_with_capacity(topic_name: &str, capacity: usize) -> Result<Self>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:237:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 237,
      "lineEnd": 239,
      "language": "rust",
      "code": "let hub: Hub<Image> = Hub::new_with_capacity(\"camera.image\", 16)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/core:245:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 245,
      "lineEnd": 247,
      "language": "rust",
      "code": "pub fn from_config(hub_name: &str) -> Result<Self>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:257:toml",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 257,
      "lineEnd": 261,
      "language": "toml",
      "code": "[hubs.camera]\ntopic = \"camera.image\"\ncapacity = 16",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/core:263:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 263,
      "lineEnd": 265,
      "language": "rust",
      "code": "let hub: Hub<Image> = Hub::from_config(\"camera\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/core:273:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 273,
      "lineEnd": 275,
      "language": "rust",
      "code": "pub fn send(&self, msg: T, ctx: &mut Option<&mut NodeInfo>) -> Result<(), T>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:286:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 286,
      "lineEnd": 292,
      "language": "rust",
      "code": "// Inside tick()\nself.publisher.send(42.0, &mut ctx).ok();\n\n// Outside node context\nhub.send(data, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:298:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 298,
      "lineEnd": 300,
      "language": "rust",
      "code": "pub fn recv(&self, ctx: &mut Option<&mut NodeInfo>) -> Option<T>",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:310:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 310,
      "lineEnd": 314,
      "language": "rust",
      "code": "if let Some(value) = self.subscriber.recv(&mut ctx) {\n    // Process value\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:320:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 320,
      "lineEnd": 322,
      "language": "rust",
      "code": "pub fn get_topic_name(&self) -> &str",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:332:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 332,
      "lineEnd": 334,
      "language": "rust",
      "code": "pub fn get_metrics(&self) -> HubMetrics",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:344:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 344,
      "lineEnd": 346,
      "language": "rust",
      "code": "pub fn get_connection_state(&self) -> ConnectionState",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:358:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 358,
      "lineEnd": 368,
      "language": "rust",
      "code": "// Local shared memory (default, fastest)\nHub::new(\"topic\")?;\n\n// Direct TCP connection\nHub::new(\"topic@192.168.1.100\")?;\nHub::new(\"topic@192.168.1.100:9000\")?;\n\n// Multicast discovery\nHub::new(\"topic@*\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/core:376:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 376,
      "lineEnd": 378,
      "language": "rust",
      "code": "pub struct Link<T> { /* fields omitted */ }",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:388:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 388,
      "lineEnd": 393,
      "language": "rust",
      "code": "pub enum LinkRole {\n    Producer,\n    Consumer,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:397:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 397,
      "lineEnd": 404,
      "language": "rust",
      "code": "pub struct LinkMetrics {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub send_failures: u64,\n    pub recv_failures: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:412:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 412,
      "lineEnd": 414,
      "language": "rust",
      "code": "pub struct Scheduler { /* fields omitted */ }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:420:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 420,
      "lineEnd": 422,
      "language": "rust",
      "code": "pub fn new() -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:429:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 429,
      "lineEnd": 432,
      "language": "rust",
      "code": "// Default: deterministic, no learning phase\nlet scheduler = Scheduler::new();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:440:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 440,
      "lineEnd": 442,
      "language": "rust",
      "code": "pub fn with_name(self, name: &str) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:450:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 450,
      "lineEnd": 452,
      "language": "rust",
      "code": "pub fn with_capacity(self, capacity: usize) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:460:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 460,
      "lineEnd": 462,
      "language": "rust",
      "code": "pub fn with_config(self, config: SchedulerConfig) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:476:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 476,
      "lineEnd": 478,
      "language": "rust",
      "code": "pub fn enable_determinism(self) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:486:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 486,
      "lineEnd": 488,
      "language": "rust",
      "code": "pub fn enable_learning(self) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:495:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 495,
      "lineEnd": 499,
      "language": "rust",
      "code": "// Opt-in to non-deterministic learning\nlet scheduler = Scheduler::new()\n    .enable_learning();  // WARNING: Non-deterministic!",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:505:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 505,
      "lineEnd": 507,
      "language": "rust",
      "code": "pub fn with_safety_monitor(self, max_deadline_misses: u64) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:517:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 517,
      "lineEnd": 524,
      "language": "rust",
      "code": "pub fn add(\n    &mut self,\n    node: Box<dyn Node>,\n    priority: u32,\n    logging_enabled: Option<bool>,\n) -> &mut Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:536:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 536,
      "lineEnd": 541,
      "language": "rust",
      "code": "scheduler\n    .add(Box::new(SensorNode::new()?), 0, Some(true))\n    .add(Box::new(ControlNode::new()?), 1, Some(true))\n    .add(Box::new(LoggerNode::new()?), 100, None);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:547:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 547,
      "lineEnd": 554,
      "language": "rust",
      "code": "pub fn add_with_tier(\n    &mut self,\n    node: Box<dyn Node>,\n    priority: u32,\n    tier: NodeTier,\n) -> &mut Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:574:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 574,
      "lineEnd": 582,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nscheduler\n    .add_with_tier(Box::new(pid_controller), 0, NodeTier::Jit)\n    .add_with_tier(Box::new(sensor_reader), 1, NodeTier::Fast)\n    .add_with_tier(Box::new(cloud_sync), 5, NodeTier::AsyncIO)\n    .add_with_tier(Box::new(data_logger), 10, NodeTier::Background);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:588:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 588,
      "lineEnd": 596,
      "language": "rust",
      "code": "pub fn add_rt(\n    &mut self,\n    node: Box<dyn Node>,\n    priority: u32,\n    wcet_budget: Duration,\n    deadline: Duration,\n) -> &mut Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:610:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 610,
      "lineEnd": 612,
      "language": "rust",
      "code": "pub fn set_node_rate(&mut self, name: &str, rate_hz: f64) -> &mut Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:617:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 617,
      "lineEnd": 621,
      "language": "rust",
      "code": "scheduler\n    .set_node_rate(\"fast_sensor\", 1000.0)  // 1 kHz\n    .set_node_rate(\"slow_logger\", 1.0);    // 1 Hz",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:627:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 627,
      "lineEnd": 629,
      "language": "rust",
      "code": "pub fn set_node_logging(&mut self, name: &str, enabled: bool) -> &mut Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:639:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 639,
      "lineEnd": 641,
      "language": "rust",
      "code": "pub fn run(&mut self) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:651:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 651,
      "lineEnd": 653,
      "language": "rust",
      "code": "pub fn run_for(&mut self, duration: Duration) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:666:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 666,
      "lineEnd": 668,
      "language": "rust",
      "code": "pub fn tick(&mut self, node_names: &[&str]) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:676:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 676,
      "lineEnd": 678,
      "language": "rust",
      "code": "pub fn tick_for(&mut self, node_names: &[&str], duration: Duration) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:686:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 686,
      "lineEnd": 688,
      "language": "rust",
      "code": "pub fn stop(&self)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:696:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 696,
      "lineEnd": 698,
      "language": "rust",
      "code": "pub fn is_running(&self) -> bool",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:708:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 708,
      "lineEnd": 710,
      "language": "rust",
      "code": "pub fn set_realtime_priority(&self, priority: i32) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:718:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 718,
      "lineEnd": 720,
      "language": "rust",
      "code": "pub fn pin_to_cpu(&self, cpu_id: usize) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:728:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 728,
      "lineEnd": 730,
      "language": "rust",
      "code": "pub fn lock_memory(&self) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:738:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 738,
      "lineEnd": 764,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::time::Duration;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new()\n        .with_name(\"robot_controller\")\n        .with_capacity(10);\n\n    // Add nodes with priorities\n    scheduler\n        .add(Box::new(EmergencyStop::new()?), 0, Some(true))\n        .add(Box::new(MotorController::new()?), 1, Some(true))\n        .add(Box::new(SensorHub::new()?), 2, Some(true))\n        .add(Box::new(DataLogger::new()?), 100, Some(false));\n\n    // Configure rates\n    scheduler\n        .set_node_rate(\"motor_controller\", 1000.0)\n        .set_node_rate(\"data_logger\", 10.0);\n\n    // Run for 60 seconds\n    scheduler.run_for(Duration::from_secs(60))?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/core:772:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 772,
      "lineEnd": 774,
      "language": "rust",
      "code": "pub struct NodeInfo { /* fields omitted */ }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:780:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 780,
      "lineEnd": 782,
      "language": "rust",
      "code": "pub fn new(name: String, logging_enabled: bool) -> Self",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:792:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 792,
      "lineEnd": 794,
      "language": "rust",
      "code": "pub fn name(&self) -> &str",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:802:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 802,
      "lineEnd": 804,
      "language": "rust",
      "code": "pub fn state(&self) -> &NodeState",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:812:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 812,
      "lineEnd": 814,
      "language": "rust",
      "code": "pub fn metrics(&self) -> &NodeMetrics",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:822:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 822,
      "lineEnd": 824,
      "language": "rust",
      "code": "pub fn config(&self) -> &NodeConfig",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:834:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 834,
      "lineEnd": 836,
      "language": "rust",
      "code": "pub fn log_info(&mut self, msg: &str)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:844:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 844,
      "lineEnd": 846,
      "language": "rust",
      "code": "pub fn log_debug(&mut self, msg: &str)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:854:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 854,
      "lineEnd": 856,
      "language": "rust",
      "code": "pub fn log_warning(&mut self, msg: &str)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:864:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 864,
      "lineEnd": 866,
      "language": "rust",
      "code": "pub fn log_error(&mut self, msg: &str)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:876:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 876,
      "lineEnd": 878,
      "language": "rust",
      "code": "pub fn transition_to_error(&mut self, reason: String)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:886:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 886,
      "lineEnd": 888,
      "language": "rust",
      "code": "pub fn transition_to_crashed(&mut self, reason: String)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:896:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 896,
      "lineEnd": 898,
      "language": "rust",
      "code": "pub fn restart(&mut self) -> Result<()>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:906:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 906,
      "lineEnd": 916,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Pass ctx to Hub methods\n    self.publisher.send(data, &mut ctx).ok();\n\n    // Access NodeInfo (must unwrap Option)\n    if let Some(ref mut c) = ctx {\n        c.log_info(\"Processing complete\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:924:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 924,
      "lineEnd": 952,
      "language": "rust",
      "code": "use horus::prelude::*;  // Imports Error, Result\n\n// Error is an alias for HorusError\n#[derive(Debug, Error)]\npub enum Error {\n    Io(std::io::Error),\n    Config(String),\n    Backend { backend: String, message: String },\n    Communication(String),\n    Node { node: String, message: String },\n    Scheduling(String),\n    Memory(String),\n    SharedMemory(String),\n    Parameter(String),\n    Serialization(String),\n    Timeout(String),\n    NotFound(String),\n    PermissionDenied(String),\n    InvalidInput(String),\n    InitializationFailed(String),\n    AlreadyExists(String),\n    ParseError(String),\n    CommandFailed(String),\n    FeatureNotAvailable(String),\n    Internal(String),\n    Other(String),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:956:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 956,
      "lineEnd": 966,
      "language": "rust",
      "code": "impl Error {\n    pub fn config<S: Into<String>>(msg: S) -> Self;\n    pub fn backend<S, T>(backend: S, message: T) -> Self;\n    pub fn node<S, T>(node: S, message: T) -> Self;\n    pub fn communication<S: Into<String>>(msg: S) -> Self;\n    pub fn memory<S: Into<String>>(msg: S) -> Self;\n    pub fn not_found<S: Into<String>>(resource: S) -> Self;\n    pub fn invalid_input<S: Into<String>>(msg: S) -> Self;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:970:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 970,
      "lineEnd": 976,
      "language": "rust",
      "code": "impl Error {\n    pub fn is_not_found(&self) -> bool;\n    pub fn is_timeout(&self) -> bool;\n    pub fn is_permission_denied(&self) -> bool;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:984:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 984,
      "lineEnd": 992,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Result<T> is an alias for std::result::Result<T, Error>\npub type Result<T> = std::result::Result<T, Error>;\n\n// HorusResult<T> still works for backward compatibility\npub type HorusResult<T> = Result<T>;",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1000:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1000,
      "lineEnd": 1009,
      "language": "rust",
      "code": "pub enum NodeState {\n    Initializing,\n    Running,\n    Paused,\n    Error(String),\n    Crashed(String),\n    Stopped,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1013:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1013,
      "lineEnd": 1020,
      "language": "rust",
      "code": "pub enum HealthStatus {\n    Healthy,\n    Degraded,\n    Unhealthy,\n    Unknown,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1024:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1024,
      "lineEnd": 1032,
      "language": "rust",
      "code": "pub enum ConnectionState {\n    Disconnected,\n    Connecting,\n    Connected,\n    Reconnecting,\n    Failed,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1040:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1040,
      "lineEnd": 1048,
      "language": "rust",
      "code": "pub struct NodeMetrics {\n    pub total_ticks: u64,\n    pub errors_count: u64,\n    pub last_tick_duration_ns: u64,\n    pub avg_tick_duration_ns: u64,\n    pub max_tick_duration_ns: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1052:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1052,
      "lineEnd": 1058,
      "language": "rust",
      "code": "pub struct NodeConfig {\n    pub restart_on_failure: bool,\n    pub max_restart_attempts: u32,\n    pub tick_timeout_ms: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1062:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1062,
      "lineEnd": 1070,
      "language": "rust",
      "code": "pub struct HubMetrics {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub send_failures: u64,\n    pub recv_failures: u64,\n    pub last_activity: Option<Instant>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1074:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1074,
      "lineEnd": 1079,
      "language": "rust",
      "code": "pub struct TopicMetadata {\n    pub topic_name: String,\n    pub type_name: String,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1087:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1087,
      "lineEnd": 1092,
      "language": "rust",
      "code": "pub trait Channel<T>: Send + Sync {\n    fn send(&self, msg: T) -> Result<(), T>;\n    fn recv(&self) -> Option<T>;\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1096:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1096,
      "lineEnd": 1100,
      "language": "rust",
      "code": "pub trait Publisher<T>: Send + Sync {\n    fn publish(&self, msg: T) -> Result<(), T>;\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/core:1104:rust",
      "file": "content/docs/rust/api/core.mdx",
      "lineStart": 1104,
      "lineEnd": 1109,
      "language": "rust",
      "code": "pub trait Subscriber<T>: Send + Sync {\n    fn subscribe(&self) -> Option<T>;\n    fn try_recv(&self) -> Option<T>;\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:15:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 15,
      "lineEnd": 28,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::Heartbeat;\n\n// Create heartbeat\nlet mut heartbeat = Heartbeat::new(\"MotorController\", 1);\n\n// Update for each heartbeat cycle\nheartbeat.update(120.5);  // 120.5 seconds uptime\n\nprintln!(\"Node: {}\", heartbeat.name());\nprintln!(\"Sequence: {}\", heartbeat.sequence);\nprintln!(\"Uptime: {:.1}s\", heartbeat.uptime);\nprintln!(\"Alive: {}\", heartbeat.alive);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:45:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 45,
      "lineEnd": 65,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::{Status, StatusLevel};\n\n// Create status messages\nlet ok = Status::ok(\"System initialized successfully\");\n\nlet warning = Status::warn(1001, \"Battery level low\")\n    .with_component(\"PowerManager\");\n\nlet error = Status::error(2001, \"Sensor communication timeout\")\n    .with_component(\"SensorHub\");\n\nlet fatal = Status::fatal(9001, \"Motor driver fault - emergency stop\")\n    .with_component(\"MotorController\");\n\n// Access status info\nprintln!(\"[{:?}] {}: {}\",\n    error.level,\n    error.component_str(),\n    error.message_str());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:90:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 90,
      "lineEnd": 106,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::EmergencyStop;\n\n// Engage emergency stop\nlet estop = EmergencyStop::engage(\"Obstacle detected in safety zone\")\n    .with_source(\"SafetyController\");\n\nprintln!(\"E-STOP engaged: {}\", estop.engaged);\nprintln!(\"Reason: {}\", estop.reason_str());\n\n// Release emergency stop\nlet release = EmergencyStop::release();\n\n// Allow auto-reset\nlet mut estop_auto = EmergencyStop::engage(\"Soft limit exceeded\");\nestop_auto.auto_reset = true;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:122:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 122,
      "lineEnd": 147,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::ResourceUsage;\n\nlet mut usage = ResourceUsage::new();\nusage.cpu_percent = 45.5;\nusage.memory_bytes = 1024 * 1024 * 512;  // 512MB\nusage.memory_percent = 25.0;\nusage.temperature = 65.5;\nusage.thread_count = 12;\n\n// Check thresholds\nif usage.is_cpu_high(80.0) {\n    println!(\"Warning: High CPU usage\");\n}\n\nif usage.is_memory_high(90.0) {\n    println!(\"Warning: High memory usage\");\n}\n\nif usage.is_temperature_high(80.0) {\n    println!(\"Warning: High temperature\");\n}\n\nprintln!(\"CPU: {:.1}%, Memory: {:.1}%, Temp: {:.1}C\",\n    usage.cpu_percent, usage.memory_percent, usage.temperature);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:168:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 168,
      "lineEnd": 176,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::DiagnosticValue;\n\n// Create different value types\nlet string_val = DiagnosticValue::string(\"firmware_version\", \"1.2.3\");\nlet int_val = DiagnosticValue::int(\"error_count\", 42);\nlet float_val = DiagnosticValue::float(\"temperature\", 65.5);\nlet bool_val = DiagnosticValue::bool(\"calibrated\", true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:199:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 199,
      "lineEnd": 215,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::{DiagnosticReport, StatusLevel};\n\nlet mut report = DiagnosticReport::new(\"MotorController\");\n\n// Add diagnostic values\nreport.add_string(\"firmware\", \"2.1.0\")?;\nreport.add_int(\"tick_count\", 15000)?;\nreport.add_float(\"voltage\", 24.5)?;\nreport.add_bool(\"calibrated\", true)?;\n\n// Set overall status\nreport.set_level(StatusLevel::Ok);\n\nprintln!(\"Report for {} has {} values\",\n    report.component_str(), report.value_count);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:231:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 231,
      "lineEnd": 236,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::NodeState;\n\nlet state = NodeState::Running;\nprintln!(\"State: {}\", state.as_str());  // \"Running\"",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:253:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 253,
      "lineEnd": 265,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::HealthStatus;\n\nlet health = HealthStatus::Healthy;\nprintln!(\"Health: {} ({})\", health.as_str(), health.color());\n\n// Color codes for monitor display\n// Healthy -> \"green\"\n// Warning -> \"yellow\"\n// Error -> \"orange\"\n// Critical -> \"red\"\n// Unknown -> \"gray\"",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:281:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 281,
      "lineEnd": 307,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::{NodeHeartbeat, NodeState, HealthStatus};\n\n// Create heartbeat\nlet mut heartbeat = NodeHeartbeat::new(NodeState::Running, HealthStatus::Healthy);\nheartbeat.tick_count = 15000;\nheartbeat.target_rate_hz = 100;\nheartbeat.actual_rate_hz = 98;\nheartbeat.error_count = 0;\n\n// Update timestamp\nheartbeat.update_timestamp();\n\n// Check freshness (within last 5 seconds)\nif heartbeat.is_fresh(5) {\n    println!(\"Node is alive\");\n}\n\n// Serialize for file writing\nlet bytes = heartbeat.to_bytes();\n\n// Deserialize from file\nif let Some(hb) = NodeHeartbeat::from_bytes(&bytes) {\n    println!(\"Tick rate: {}/{} Hz\",\n        hb.actual_rate_hz, hb.target_rate_hz);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:326:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 326,
      "lineEnd": 354,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides diagnostics::SafetyStatus;\n\nlet mut safety = SafetyStatus::new();\nsafety.enabled = true;\nsafety.estop_engaged = false;\nsafety.watchdog_ok = true;\nsafety.limits_ok = true;\nsafety.comms_ok = true;\n\n// Check if safe to operate\nif safety.is_safe() {\n    println!(\"System is safe to operate\");\n} else {\n    println!(\"Safety interlock active - fault code: {}\", safety.fault_code);\n}\n\n// Set fault condition\nsafety.set_fault(1001);\nprintln!(\"Mode: {}\", match safety.mode {\n    SafetyStatus::MODE_NORMAL => \"Normal\",\n    SafetyStatus::MODE_REDUCED => \"Reduced\",\n    SafetyStatus::MODE_SAFE_STOP => \"Safe Stop\",\n    _ => \"Unknown\"\n});\n\n// Clear faults\nsafety.clear_faults();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/diagnostics-messages:379:rust",
      "file": "content/docs/rust/api/diagnostics-messages.mdx",
      "lineStart": 379,
      "lineEnd": 441,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides diagnostics::{\n    Status, StatusLevel, ResourceUsage, DiagnosticReport,\n    SafetyStatus, EmergencyStop\n};\n\nstruct DiagnosticsNode {\n    status_pub: Hub<Status>,\n    resource_pub: Hub<ResourceUsage>,\n    safety_sub: Hub<SafetyStatus>,\n    estop_pub: Hub<EmergencyStop>,\n    tick_count: u64,\n    start_time: std::time::Instant,\n}\n\nimpl Node for DiagnosticsNode {\n    fn name(&self) -> &'static str { \"Diagnostics\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.tick_count += 1;\n\n        // Check safety status\n        if let Some(safety) = self.safety_sub.recv(&mut ctx) {\n            if !safety.is_safe() {\n                // Trigger emergency stop\n                let estop = EmergencyStop::engage(&format!(\n                    \"Safety fault code: {}\", safety.fault_code\n                )).with_source(\"DiagnosticsNode\");\n                self.estop_pub.send(estop, &mut ctx).ok();\n\n                // Send error status\n                let status = Status::error(safety.fault_code, \"Safety system fault\")\n                    .with_component(\"SafetyMonitor\");\n                self.status_pub.send(status, &mut ctx).ok();\n            }\n        }\n\n        // Periodic resource reporting (every 100 ticks)\n        if self.tick_count % 100 == 0 {\n            let mut usage = ResourceUsage::new();\n            // ... populate with actual system metrics ...\n\n            // Check thresholds\n            if usage.is_cpu_high(90.0) {\n                let status = Status::warn(1001, \"CPU usage above 90%\")\n                    .with_component(\"ResourceMonitor\");\n                self.status_pub.send(status, &mut ctx).ok();\n            }\n\n            self.resource_pub.send(usage, &mut ctx).ok();\n        }\n\n        // Periodic OK status (every 1000 ticks)\n        if self.tick_count % 1000 == 0 {\n            let uptime = self.start_time.elapsed().as_secs_f64();\n            let status = Status::ok(&format!(\"System healthy, uptime: {:.0}s\", uptime))\n                .with_component(\"DiagnosticsNode\");\n            self.status_pub.send(status, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:15:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 15,
      "lineEnd": 42,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides force::WrenchStamped;\nuse horus::prelude::*; // Provides geometry::Vector3;\n\n// Create wrench measurement\nlet force = Vector3::new(10.0, 5.0, -2.0);   // Newtons\nlet torque = Vector3::new(0.1, 0.2, 0.05);   // Newton-meters\n\nlet wrench = WrenchStamped::new(force, torque)\n    .with_frame_id(\"tool0\");\n\n// Check magnitudes\nprintln!(\"Force magnitude: {:.2} N\", wrench.force_magnitude());\nprintln!(\"Torque magnitude: {:.3} Nm\", wrench.torque_magnitude());\n\n// Safety check\nlet max_force = 50.0;   // N\nlet max_torque = 5.0;   // Nm\nif wrench.exceeds_limits(max_force, max_torque) {\n    println!(\"Safety limits exceeded!\");\n}\n\n// Create from force only\nlet force_only = WrenchStamped::force_only(Vector3::new(0.0, 0.0, -10.0));\n\n// Create from torque only\nlet torque_only = WrenchStamped::torque_only(Vector3::new(0.0, 0.0, 0.5));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:56:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 56,
      "lineEnd": 60,
      "language": "rust",
      "code": "// Filter noisy sensor readings\nlet mut current = wrench;\ncurrent.filter(&previous_wrench, 0.1);  // alpha = 0.1 (heavy filtering)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:66:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 66,
      "lineEnd": 99,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides force::TactileArray;\n\n// Create 8x8 grid tactile array\nlet mut tactile = TactileArray::new(64, TactileArray::ARRANGEMENT_GRID);\ntactile.grid_width = 8;\ntactile.grid_height = 8;\ntactile.sensor_spacing = 2.0;  // 2mm between sensors\ntactile.sensitivity = 0.1;     // N per unit\n\n// Set sensor readings\ntactile.set_sensor(0, 1.5);\ntactile.set_sensor(1, 2.0);\n\n// Get active sensors\nlet readings = tactile.get_active_sensors();\n\n// Calculate total force\nlet total = tactile.total_force();\nprintln!(\"Total force: {:.2} N\", total);\n\n// Detect contact\nif tactile.detect_contact(0.5) {  // threshold\n    println!(\"Contact detected!\");\n}\n\n// Calculate center of pressure (grid arrangement only)\nif let Some((cx, cy)) = tactile.center_of_pressure() {\n    println!(\"Center of pressure: ({:.2}, {:.2})\", cx, cy);\n}\n\n// Get contact pattern\nlet pattern = tactile.contact_pattern(0.5);  // Returns Vec<bool>",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:127:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 127,
      "lineEnd": 151,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides force::ImpedanceParameters;\n\n// Default impedance (moderate compliance)\nlet mut impedance = ImpedanceParameters::new();\n\n// Compliant mode (low stiffness - for delicate tasks)\nlet compliant = ImpedanceParameters::compliant();\n// stiffness: [100, 100, 100, 10, 10, 10]\n// damping: [20, 20, 20, 2, 2, 2]\n\n// Stiff mode (high stiffness - for precision tasks)\nlet stiff = ImpedanceParameters::stiff();\n// stiffness: [5000, 5000, 5000, 500, 500, 500]\n// damping: [100, 100, 100, 10, 10, 10]\n\n// Enable/disable\nimpedance.enable();\nimpedance.disable();\n\n// Custom parameters\nimpedance.stiffness = [500.0, 500.0, 200.0, 50.0, 50.0, 50.0];  // [Kx, Ky, Kz, Krx, Kry, Krz]\nimpedance.damping = [30.0, 30.0, 20.0, 3.0, 3.0, 3.0];          // [Dx, Dy, Dz, Drx, Dry, Drz]\nimpedance.force_limits = [50.0, 50.0, 30.0, 5.0, 5.0, 5.0];     // Safety limits",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:168:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 168,
      "lineEnd": 190,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides force::ForceCommand;\nuse horus::prelude::*; // Provides geometry::Vector3;\n\n// Pure force command\nlet force_cmd = ForceCommand::force_only(Vector3::new(0.0, 0.0, -5.0));  // 5N downward\n\n// Hybrid force/position control\n// Force control on Z axis, position control on X/Y\nlet force_axes = [false, false, true, false, false, false];  // [fx, fy, fz, tx, ty, tz]\nlet target_force = Vector3::new(0.0, 0.0, -10.0);\nlet target_position = Vector3::new(0.5, 0.3, 0.0);\n\nlet hybrid_cmd = ForceCommand::hybrid(force_axes, target_force, target_position);\n\n// Surface contact following\nlet surface_normal = Vector3::new(0.0, 0.0, 1.0);  // Horizontal surface\nlet contact_force = 5.0;  // 5N contact force\nlet surface_cmd = ForceCommand::surface_contact(contact_force, surface_normal);\n\n// Set timeout\nlet cmd_with_timeout = force_cmd.with_timeout(5.0);  // 5 second timeout",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:211:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 211,
      "lineEnd": 223,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides force::{ContactInfo, ContactState};\nuse horus::prelude::*; // Provides geometry::Vector3;\n\n// Create contact info\nlet contact = ContactInfo::new(ContactState::StableContact, 15.0);  // 15N force\n\n// Check contact state\nif contact.is_in_contact() {\n    println!(\"Contact force: {:.1} N\", contact.contact_force);\n    println!(\"Duration: {:.2}s\", contact.contact_duration_seconds());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:240:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 240,
      "lineEnd": 263,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides force::HapticFeedback;\nuse horus::prelude::*; // Provides geometry::Vector3;\n\n// Vibration feedback\nlet vibration = HapticFeedback::vibration(\n    0.8,   // intensity (0-1)\n    250.0, // frequency (Hz)\n    0.5    // duration (seconds)\n);\n\n// Force feedback\nlet force = HapticFeedback::force(\n    Vector3::new(1.0, 0.0, 0.0),  // Force direction\n    1.0                           // Duration (seconds)\n);\n\n// Pulse pattern\nlet pulse = HapticFeedback::pulse(\n    0.6,   // intensity\n    100.0, // frequency\n    0.3    // duration\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/force-messages:275:rust",
      "file": "content/docs/rust/api/force-messages.mdx",
      "lineStart": 275,
      "lineEnd": 318,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides force::{WrenchStamped, ForceCommand, ImpedanceParameters};\nuse horus::prelude::*; // Provides geometry::Vector3;\n\nstruct ForceControlNode {\n    wrench_sub: Hub<WrenchStamped>,\n    cmd_pub: Hub<ForceCommand>,\n    impedance_pub: Hub<ImpedanceParameters>,\n    target_force: f64,\n    prev_wrench: Option<WrenchStamped>,\n}\n\nimpl Node for ForceControlNode {\n    fn name(&self) -> &'static str { \"ForceControl\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(mut wrench) = self.wrench_sub.recv(&mut ctx) {\n            // Apply low-pass filter\n            if let Some(prev) = &self.prev_wrench {\n                wrench.filter(prev, 0.2);\n            }\n            self.prev_wrench = Some(wrench.clone());\n\n            // Safety check\n            if wrench.exceeds_limits(100.0, 10.0) {\n                // Switch to compliant mode\n                let compliant = ImpedanceParameters::compliant();\n                self.impedance_pub.send(compliant, &mut ctx).ok();\n                return;\n            }\n\n            // Force control to maintain target contact force\n            let error = self.target_force - wrench.force.z;\n            let correction = error * 0.001;  // Simple P control\n\n            let cmd = ForceCommand::force_only(\n                Vector3::new(0.0, 0.0, self.target_force + correction)\n            );\n            self.cmd_pub.send(cmd, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/geometry-messages:19:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 19,
      "lineEnd": 39,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create 3D velocity command\nlet twist = Twist::new(\n    [1.0, 0.0, 0.0],    // linear: [x, y, z] in m/s\n    [0.0, 0.0, 0.5]     // angular: [roll, pitch, yaw] in rad/s\n);\n\n// For 2D robots (common case)\nlet cmd = Twist::new_2d(0.5, 0.3);  // 0.5 m/s forward, 0.3 rad/s rotation\nprintln!(\"Linear X: {}, Angular Z: {}\", cmd.linear[0], cmd.angular[2]);\n\n// Stop command (all zeros)\nlet stop = Twist::stop();\n\n// Validate the message\nif twist.is_valid() {\n    println!(\"Twist is valid\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:64:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 64,
      "lineEnd": 85,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create 2D pose\nlet pose = Pose2D::new(5.0, 3.0, 1.57);  // x, y, theta\nprintln!(\"Position: ({}, {}), Orientation: {} rad\", pose.x, pose.y, pose.theta);\n\n// Create pose at origin\nlet origin = Pose2D::origin();\n\n// Calculate distance between poses\nlet other = Pose2D::new(8.0, 7.0, 0.0);\nlet distance = pose.distance_to(&other);\nprintln!(\"Distance: {:.2} m\", distance);\n\n// Normalize angle to [-π, π]\nlet mut pose_copy = pose;\npose_copy.normalize_angle();\n\n// Check validity\nassert!(pose.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:112:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 112,
      "lineEnd": 136,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create transform with translation and quaternion rotation\nlet transform = Transform::new(\n    [1.0, 2.0, 0.5],           // translation [x, y, z]\n    [0.0, 0.0, 0.0, 1.0]       // rotation [x, y, z, w] quaternion\n);\n\n// Identity transform (no translation or rotation)\nlet identity = Transform::identity();\n\n// Create from 2D pose (z=0, only yaw rotation)\nlet pose = Pose2D::new(3.0, 4.0, 1.57);\nlet tf_from_pose = Transform::from_pose_2d(&pose);\n\n// Validate quaternion is normalized\nif transform.is_valid() {\n    println!(\"Transform is valid (quaternion normalized)\");\n}\n\n// Normalize quaternion if needed\nlet mut tf = Transform::new([0.0; 3], [1.0, 1.0, 1.0, 1.0]);\ntf.normalize_rotation();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:160:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 160,
      "lineEnd": 174,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create 3D point\nlet point = Point3::new(1.0, 2.0, 3.0);\nprintln!(\"Point: ({}, {}, {})\", point.x, point.y, point.z);\n\n// Create point at origin\nlet origin = Point3::origin();\n\n// Calculate distance between points\nlet other = Point3::new(4.0, 6.0, 3.0);\nlet distance = point.distance_to(&other);\nprintln!(\"Distance: {:.2} m\", distance);  // 5.0 m",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:196:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 196,
      "lineEnd": 226,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create 3D vector\nlet v = Vector3::new(3.0, 4.0, 0.0);\nprintln!(\"Vector: ({}, {}, {})\", v.x, v.y, v.z);\n\n// Zero vector\nlet zero = Vector3::zero();\n\n// Calculate magnitude\nlet mag = v.magnitude();\nprintln!(\"Magnitude: {:.2}\", mag);  // 5.0\n\n// Normalize vector\nlet mut unit = Vector3::new(3.0, 4.0, 0.0);\nunit.normalize();\nprintln!(\"Unit vector: ({:.2}, {:.2}, {})\", unit.x, unit.y, unit.z);  // (0.6, 0.8, 0)\n\n// Dot product\nlet v1 = Vector3::new(1.0, 2.0, 3.0);\nlet v2 = Vector3::new(4.0, 5.0, 6.0);\nlet dot = v1.dot(&v2);\nprintln!(\"Dot product: {}\", dot);  // 32.0\n\n// Cross product\nlet i = Vector3::new(1.0, 0.0, 0.0);\nlet j = Vector3::new(0.0, 1.0, 0.0);\nlet k = i.cross(&j);\nprintln!(\"i × j = ({}, {}, {})\", k.x, k.y, k.z);  // (0, 0, 1)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:253:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 253,
      "lineEnd": 276,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create quaternion directly\nlet q = Quaternion::new(0.0, 0.0, 0.0, 1.0);  // [x, y, z, w]\n\n// Identity quaternion (no rotation)\nlet identity = Quaternion::identity();\nassert_eq!(identity.w, 1.0);\n\n// Create from Euler angles (roll, pitch, yaw)\nlet q_from_euler = Quaternion::from_euler(\n    0.0,    // roll (rotation around X)\n    0.0,    // pitch (rotation around Y)\n    1.57    // yaw (rotation around Z) - 90 degrees\n);\n\n// Normalize quaternion\nlet mut q_unnorm = Quaternion::new(1.0, 1.0, 1.0, 1.0);\nq_unnorm.normalize();\n\n// Validate\nassert!(q.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:301:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 301,
      "lineEnd": 315,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Ultra-fast ~50ns transfer using PodLink\nlet twist_link: PodLink<Twist> = hub.create_pod_link(\"velocity_cmd\");\nlet pose_link: PodLink<Pose2D> = hub.create_pod_link(\"robot_pose\");\n\n// Send without serialization overhead\ntwist_link.send(Twist::new_2d(0.5, 0.1));\n\n// Receive with zero-copy\nif let Some(pose) = pose_link.recv() {\n    println!(\"Robot at ({:.2}, {:.2})\", pose.x, pose.y);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/geometry-messages:319:rust",
      "file": "content/docs/rust/api/geometry-messages.mdx",
      "lineStart": 319,
      "lineEnd": 365,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct DifferentialDriveController {\n    pose_sub: Hub<Pose2D>,\n    goal_sub: Hub<Pose2D>,\n    cmd_pub: Hub<Twist>,\n}\n\nimpl Node for DifferentialDriveController {\n    fn name(&self) -> &'static str { \"DiffDriveController\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Get current pose and goal\n        let pose = match self.pose_sub.try_recv(&mut ctx) {\n            Some(p) => p,\n            None => return,\n        };\n\n        let goal = match self.goal_sub.try_recv(&mut ctx) {\n            Some(g) => g,\n            None => return,\n        };\n\n        // Calculate distance and angle to goal\n        let dx = goal.x - pose.x;\n        let dy = goal.y - pose.y;\n        let distance = (dx * dx + dy * dy).sqrt();\n        let angle_to_goal = dy.atan2(dx);\n        let angle_error = angle_to_goal - pose.theta;\n\n        // Simple proportional controller\n        let cmd = if distance > 0.1 {\n            // Move towards goal\n            Twist::new_2d(\n                0.3 * distance.min(1.0),     // Linear velocity (capped)\n                1.0 * angle_error            // Angular velocity\n            )\n        } else {\n            // Goal reached\n            Twist::stop()\n        };\n\n        self.cmd_pub.send(cmd, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/hardware:16:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 16,
      "lineEnd": 21,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet discovery = HardwareDiscovery::new()?;\nlet report = discovery.scan_all();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:39:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 39,
      "lineEnd": 47,
      "language": "rust",
      "code": "let options = DiscoveryOptions::default()\n    .with_categories(CategoryFilter::only(&[\n        DeviceCategory::Camera,\n        DeviceCategory::Lidar,\n    ]))\n    .with_timeout(Duration::from_secs(5))\n    .with_i2c_probe(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:64:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 64,
      "lineEnd": 68,
      "language": "rust",
      "code": "let report = discovery.scan_all();\nprintln!(\"Found {} USB devices\", report.usb_devices.len());\nprintln!(\"{}\", report.summary());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:101:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 101,
      "lineEnd": 105,
      "language": "rust",
      "code": "let summary = report.summary();\nprintln!(\"USB: {}\", summary.usb_count);\nprintln!(\"I2C: {} devices on {} buses\", summary.i2c_device_count, summary.i2c_bus_count);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:129:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 129,
      "lineEnd": 139,
      "language": "rust",
      "code": "pub struct DiscoveredDevice {\n    pub name: String,\n    pub category: DeviceCategory,\n    pub path: Option<PathBuf>,\n    pub vendor_id: Option<u16>,\n    pub product_id: Option<u16>,\n    pub serial_number: Option<String>,\n    pub driver: Option<String>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:147:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 147,
      "lineEnd": 156,
      "language": "rust",
      "code": "// Only specific categories\nlet filter = CategoryFilter::only(&[DeviceCategory::Camera, DeviceCategory::Lidar]);\n\n// All except certain categories\nlet filter = CategoryFilter::except(&[DeviceCategory::Audio, DeviceCategory::Bluetooth]);\n\n// All categories (default)\nlet filter = CategoryFilter::all();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:166:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 166,
      "lineEnd": 180,
      "language": "rust",
      "code": "pub enum Platform {\n    RaspberryPi3,\n    RaspberryPi4,\n    RaspberryPi5,\n    JetsonNano,\n    JetsonXavier,\n    JetsonOrin,\n    BeagleBoneBlack,\n    BeagleBoneAI,\n    IntelNuc,\n    GenericLinux,\n    Unknown,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:197:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 197,
      "lineEnd": 210,
      "language": "rust",
      "code": "pub struct PlatformCapabilities {\n    pub has_gpio: bool,\n    pub has_i2c: bool,\n    pub has_spi: bool,\n    pub has_can: bool,\n    pub has_pwm: bool,\n    pub has_uart: bool,\n    pub cpu_cores: u8,\n    pub cpu_freq_mhz: Option<u32>,\n    pub memory_mb: Option<u32>,\n    pub gpu: Option<GpuType>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:218:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 218,
      "lineEnd": 230,
      "language": "rust",
      "code": "pub enum GpuType {\n    VideoCore4,      // Raspberry Pi 3\n    VideoCore6,      // Raspberry Pi 4\n    VideoCore7,      // Raspberry Pi 5\n    NvidiaTegra,     // Jetson Nano\n    NvidiaXavier,    // Jetson Xavier\n    NvidiaOrin,      // Jetson Orin\n    IntelIntegrated,\n    AmdIntegrated,\n    Unknown,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:240:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 240,
      "lineEnd": 247,
      "language": "rust",
      "code": "let db = DeviceDatabase::new();\nlet info = db.lookup_usb(0x10C4, 0xEA60); // Silicon Labs CP210x\n\nif let Some(info) = info {\n    println!(\"Device: {} ({:?})\", info.name, info.category);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:265:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 265,
      "lineEnd": 286,
      "language": "rust",
      "code": "pub enum DeviceCategory {\n    Microcontroller,\n    SerialAdapter,\n    MotorController,\n    ServoController,\n    Lidar,\n    DepthCamera,\n    Camera,\n    Imu,\n    Gps,\n    CanAdapter,\n    Joystick,\n    Bluetooth,\n    Audio,\n    Network,\n    Power,\n    Display,\n    Storage,\n    Other,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:300:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 300,
      "lineEnd": 308,
      "language": "rust",
      "code": "pub struct DeviceInfo {\n    pub name: String,\n    pub vendor: String,\n    pub category: DeviceCategory,\n    pub driver: Option<String>,\n    pub notes: Option<String>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:316:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 316,
      "lineEnd": 322,
      "language": "rust",
      "code": "pub struct DriverMatch {\n    pub driver_name: String,\n    pub confidence: MatchConfidence,\n    pub feature_flag: Option<String>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:330:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 330,
      "lineEnd": 337,
      "language": "rust",
      "code": "pub enum MatchConfidence {\n    Exact,     // Exact VID/PID match\n    High,      // Same vendor, similar device\n    Medium,    // Generic driver\n    Low,       // Best guess\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:347:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 347,
      "lineEnd": 360,
      "language": "rust",
      "code": "pub struct UsbDevice {\n    pub vendor_id: u16,\n    pub product_id: u16,\n    pub vendor: Option<String>,\n    pub product: Option<String>,\n    pub serial_number: Option<String>,\n    pub bus_number: u8,\n    pub device_address: u8,\n    pub device_class: u8,\n    pub device_subclass: u8,\n    pub serial_port: Option<String>,  // e.g., \"/dev/ttyUSB0\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:368:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 368,
      "lineEnd": 371,
      "language": "rust",
      "code": "let mut usb = UsbDiscovery::new();\nlet devices = usb.enumerate_devices();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:381:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 381,
      "lineEnd": 390,
      "language": "rust",
      "code": "pub struct SerialPort {\n    pub path: PathBuf,\n    pub port_type: SerialPortType,\n    pub vendor_id: Option<u16>,\n    pub product_id: Option<u16>,\n    pub product: Option<String>,\n    pub serial_number: Option<String>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:398:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 398,
      "lineEnd": 406,
      "language": "rust",
      "code": "pub enum SerialPortType {\n    UsbSerial,      // USB-to-serial adapter\n    PciSerial,      // PCI serial card\n    PlatformUart,   // Built-in UART (e.g., /dev/ttyAMA0)\n    Bluetooth,      // Bluetooth serial\n    Unknown,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:416:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 416,
      "lineEnd": 428,
      "language": "rust",
      "code": "pub struct I2cBus {\n    pub bus_number: u8,\n    pub path: PathBuf,\n    pub devices: Vec<I2cDevice>,\n}\n\npub struct I2cDevice {\n    pub address: u8,\n    pub name: Option<String>,\n    pub driver: Option<String>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:432:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 432,
      "lineEnd": 442,
      "language": "rust",
      "code": "pub struct SpiBus {\n    pub bus_number: u8,\n    pub chip_selects: Vec<SpiChipSelect>,\n}\n\npub struct SpiChipSelect {\n    pub chip_select: u8,\n    pub device_path: PathBuf,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:446:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 446,
      "lineEnd": 465,
      "language": "rust",
      "code": "pub struct CanInterface {\n    pub name: String,\n    pub interface_type: CanInterfaceType,\n    pub state: CanState,\n    pub bitrate: Option<u32>,\n}\n\npub enum CanInterfaceType {\n    SocketCan,\n    Slcan,\n    Virtual,\n}\n\npub enum CanState {\n    Up,\n    Down,\n    Error,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:469:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 469,
      "lineEnd": 484,
      "language": "rust",
      "code": "pub struct GpioChip {\n    pub name: String,\n    pub label: String,\n    pub num_lines: u32,\n    pub path: PathBuf,\n    pub lines: Vec<GpioLine>,\n}\n\npub struct GpioLine {\n    pub offset: u32,\n    pub name: String,\n    pub consumer: Option<String>,\n    pub direction: Option<String>,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:488:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 488,
      "lineEnd": 509,
      "language": "rust",
      "code": "pub struct PwmChip {\n    pub chip_number: u8,\n    pub num_channels: u8,\n    pub path: PathBuf,\n    pub channels: Vec<PwmChannel>,\n}\n\npub struct PwmChannel {\n    pub channel_number: u8,\n    pub enabled: bool,\n    pub period: Option<u64>,\n    pub duty_cycle: Option<u64>,\n    pub polarity: PwmPolarity,\n    pub frequency: Option<u32>,\n}\n\npub enum PwmPolarity {\n    Normal,\n    Inversed,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:513:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 513,
      "lineEnd": 535,
      "language": "rust",
      "code": "pub struct Camera {\n    pub name: String,\n    pub device_path: PathBuf,\n    pub camera_type: CameraType,\n    pub driver: Option<String>,\n    pub formats: Vec<VideoFormat>,\n}\n\npub enum CameraType {\n    Usb,\n    Csi,\n    Pci,\n    Virtual,\n}\n\npub struct VideoFormat {\n    pub pixel_format: String,\n    pub width: u32,\n    pub height: u32,\n    pub fps: u32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:539:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 539,
      "lineEnd": 555,
      "language": "rust",
      "code": "pub struct BluetoothAdapter {\n    pub name: String,\n    pub address: String,\n    pub adapter_type: BluetoothAdapterType,\n    pub state: BluetoothState,\n    pub devices: Vec<BluetoothDevice>,\n}\n\npub struct BluetoothDevice {\n    pub name: String,\n    pub address: String,\n    pub device_class: BluetoothDeviceClass,\n    pub connected: bool,\n    pub paired: bool,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:559:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 559,
      "lineEnd": 574,
      "language": "rust",
      "code": "pub struct NetworkInterface {\n    pub name: String,\n    pub interface_type: NetworkInterfaceType,\n    pub state: NetworkState,\n    pub mac_address: Option<String>,\n    pub ip_address: Option<String>,\n    pub wifi_info: Option<WifiInfo>,\n}\n\npub struct WifiInfo {\n    pub ssid: String,\n    pub signal_strength: i32,\n    pub frequency: u32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/hardware:578:rust",
      "file": "content/docs/rust/api/hardware.mdx",
      "lineStart": 578,
      "lineEnd": 601,
      "language": "rust",
      "code": "pub struct AudioCard {\n    pub card_number: u8,\n    pub card_id: String,\n    pub card_name: String,\n    pub device_type: AudioDeviceType,\n    pub driver: Option<String>,\n    pub devices: Vec<AudioDevice>,\n}\n\npub struct AudioDevice {\n    pub card_number: u8,\n    pub device_number: u8,\n    pub device_name: String,\n    pub direction: AudioDirection,\n    pub device_path: String,\n}\n\npub enum AudioDirection {\n    Playback,\n    Capture,\n    Duplex,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/index:66:rust",
      "file": "content/docs/rust/api/index.mdx",
      "lineStart": 66,
      "lineEnd": 68,
      "language": "rust",
      "code": "use horus::prelude::*;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/index:74:rust",
      "file": "content/docs/rust/api/index.mdx",
      "lineStart": 74,
      "lineEnd": 89,
      "language": "rust",
      "code": "use horus::{\n    // Core traits and types\n    Node, NodeInfo, NodeConfig, NodeMetrics, NodeState,\n    // Communication\n    Hub, Link, LinkMetrics,\n    // Scheduling\n    Scheduler,\n    // Errors (short aliases)\n    Error, Result,\n    // Traits\n    Channel, Publisher, Subscriber,\n    // Messages\n    Image, LaserScan, Imu, Twist, Pose, PointCloud,\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:15:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 15,
      "lineEnd": 45,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::DigitalIO;\n\nlet mut dio = DigitalIO::new(8);  // 8 pins\n\n// Set/get pin states\ndio.set_pin(0, true);   // Pin 0 high\ndio.set_pin(7, true);   // Pin 7 high\n\nif let Some(state) = dio.get_pin(0) {\n    println!(\"Pin 0: {}\", if state { \"HIGH\" } else { \"LOW\" });\n}\n\n// Set pin direction\ndio.set_pin_direction(0, true);   // Pin 0 as output\ndio.set_pin_direction(1, false);  // Pin 1 as input\n\n// Set pin label\ndio.set_pin_label(0, \"motor_enable\");\n\n// Count active pins\nprintln!(\"Active pins: {}\", dio.count_active());\n\n// Work with bitmask\nlet mask = dio.as_bitmask();  // 0b10000001 = 0x81\nprintln!(\"Bitmask: 0x{:02X}\", mask);\n\n// Set from bitmask\nlet mut dio2 = DigitalIO::new(8);\ndio2.from_bitmask(0xFF);  // All pins high",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:63:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 63,
      "lineEnd": 87,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::AnalogIO;\n\nlet mut aio = AnalogIO::new(4);  // 4 channels\n\n// Set channel values\naio.set_channel(0, 2.5);  // 2.5V\n\n// Configure channel\naio.set_channel_range(0, 0.0, 10.0);  // 0-10V range\naio.set_channel_info(0, \"temperature\", \"V\");\n\n// ADC conversion\naio.resolution_bits = 12;  // 12-bit ADC\n\n// Raw to engineering units\nif let Some(voltage) = aio.raw_to_engineering(0, 2048) {\n    println!(\"Voltage: {:.2}V\", voltage);  // ~5V for 12-bit\n}\n\n// Engineering units to raw\nif let Some(raw) = aio.engineering_to_raw(0, 5.0) {\n    println!(\"Raw value: {}\", raw);  // ~2048\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:107:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 107,
      "lineEnd": 129,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::SpiMessage;\n\n// Create SPI message\nlet tx_data = [0x9F];  // Read JEDEC ID command\nlet mut msg = SpiMessage::new(0, 0, &tx_data);  // bus=0, cs=0\n\n// With configuration\nlet msg = SpiMessage::with_config(\n    0,           // bus\n    0,           // chip select\n    &tx_data,\n    SpiMessage::MODE_0,  // SPI mode 0\n    1_000_000    // 1MHz clock\n);\n\n// Set mode\nmsg.set_mode(SpiMessage::MODE_3);  // CPOL=1, CPHA=1\n\n// Access data\nlet tx = msg.tx_data_slice();\nlet rx = msg.rx_data_slice();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:162:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 162,
      "lineEnd": 189,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::I2cMessage;\n\n// Read from device\nlet read_msg = I2cMessage::read(1, 0x68, 6);  // bus=1, addr=0x68, read 6 bytes\n\n// Write to device\nlet write_msg = I2cMessage::write(1, 0x68, &[0x6B, 0x00]);  // Wake up MPU6050\n\n// Read register\nlet reg_read = I2cMessage::read_register(\n    1,     // bus\n    0x68,  // device address\n    0x3B,  // register address (ACCEL_XOUT_H)\n    6      // read 6 bytes\n);\n\n// Write register\nlet reg_write = I2cMessage::write_register(\n    1,\n    0x68,\n    0x6B,      // PWR_MGMT_1 register\n    &[0x00]    // Wake up\n);\n\n// Access data\nlet data = reg_read.get_data();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:227:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 227,
      "lineEnd": 248,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::SerialData;\n\n// Create serial message\nlet mut serial = SerialData::new(\"/dev/ttyUSB0\");\nserial.baud_rate = 115200;\nserial.data_bits = 8;\nserial.stop_bits = 1;\nserial.parity = SerialData::PARITY_NONE;\n\n// Set data\nserial.set_data(&[0x01, 0x02, 0x03]);\n\n// Or from string\nserial.set_string(\"AT+GMR\\r\\n\");\n\n// Get data\nlet bytes = serial.get_data();\nif let Some(text) = serial.get_string() {\n    println!(\"Response: {}\", text);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:275:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 275,
      "lineEnd": 307,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::CanFrame;\n\n// Standard CAN frame\nlet frame = CanFrame::new(0x123, &[0x01, 0x02, 0x03, 0x04]);\n\n// Extended CAN frame (29-bit ID)\nlet ext_frame = CanFrame::new_extended(0x18FEF100, &[0x01, 0x02]);\n\n// Remote transmission request\nlet rtr = CanFrame::new_rtr(0x200, 8);  // Request 8 bytes\n\n// CAN-FD frame with bit rate switching\nlet fd_frame = CanFrame::new_fd(0x300, &[0u8; 64], true);\n\n// Set interface\nlet mut frame = CanFrame::new(0x100, &[0x01]);\nframe.set_interface(\"can0\");\n\n// Pack/unpack data\nlet mut frame = CanFrame::new(0x100, &[0u8; 8]);\nframe.pack_u16(0, 1234);   // Pack u16 at offset 0\nframe.pack_u32(2, 56789);  // Pack u32 at offset 2\n\nif let Some(val) = frame.unpack_u16(0) {\n    println!(\"Value: {}\", val);\n}\n\n// Validation\nif frame.is_valid() {\n    println!(\"ID: 0x{:03X}, DLC: {}\", frame.id, frame.dlc);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:338:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 338,
      "lineEnd": 369,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::ModbusMessage;\n\n// Read holding registers\nlet read_msg = ModbusMessage::read_holding_registers(\n    1,    // unit_id (slave address)\n    100,  // start address\n    10    // quantity\n);\n\n// Write single register\nlet write_msg = ModbusMessage::write_single_register(\n    1,     // unit_id\n    200,   // address\n    1234   // value\n);\n\n// Write multiple registers\nlet values = [100u16, 200, 300];\nlet write_multi = ModbusMessage::write_multiple_registers(1, 300, &values);\n\n// Create response\nlet response = read_msg.create_response(&[10, 20, 30, 40, 50]);\n\n// Create exception response\nlet exception = read_msg.create_exception(0x02);  // Illegal data address\n\n// Check for exception\nif response.is_exception() {\n    println!(\"Exception code: {}\", response.exception_code);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:403:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 403,
      "lineEnd": 415,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::NetworkStatus;\n\nlet mut status = NetworkStatus::new(\"eth0\");\nstatus.set_ip_from_string(\"192.168.1.100\")?;\nstatus.subnet_mask = 0xFFFFFF00;  // 255.255.255.0\nstatus.link_up = true;\nstatus.link_speed = 1000;  // 1Gbps\nstatus.full_duplex = true;\n\nprintln!(\"IP: {}\", status.ip_to_string());\nprintln!(\"Packet loss: {:.2}%\", status.packet_loss_percent());",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:421:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 421,
      "lineEnd": 434,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides io::SafetyRelayStatus;\n\nlet mut relay = SafetyRelayStatus::new(\"SR001\");\nrelay.safety_outputs[0] = true;\nrelay.safety_active = true;\n\nif relay.is_safe_state() {\n    println!(\"System is safe\");\n}\n\nprintln!(\"Active outputs: {}\", relay.active_output_count());\nprintln!(\"Active inputs: {}\", relay.active_input_count());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/io-messages:438:rust",
      "file": "content/docs/rust/api/io-messages.mdx",
      "lineStart": 438,
      "lineEnd": 467,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides io::{DigitalIO, AnalogIO, I2cMessage};\n\nstruct SensorNode {\n    dio_pub: Hub<DigitalIO>,\n    aio_pub: Hub<AnalogIO>,\n    i2c_pub: Hub<I2cMessage>,\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str { \"SensorNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read digital inputs (simulated)\n        let mut dio = DigitalIO::new(8);\n        // ... read GPIO pins ...\n        self.dio_pub.send(dio, &mut ctx).ok();\n\n        // Read analog channels (simulated)\n        let mut aio = AnalogIO::new(4);\n        // ... read ADC channels ...\n        self.aio_pub.send(aio, &mut ctx).ok();\n\n        // Read I2C sensor\n        let i2c_cmd = I2cMessage::read_register(1, 0x68, 0x3B, 14);\n        self.i2c_pub.send(i2c_cmd, &mut ctx).ok();\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:11:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 11,
      "lineEnd": 13,
      "language": "rust",
      "code": "use horus::prelude::*;  // Includes all macros",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:23:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 23,
      "lineEnd": 35,
      "language": "rust",
      "code": "node! {\n    NodeName {\n        pub { ... }         // Publishers (optional)\n        sub { ... }         // Subscribers (optional)\n        data { ... }        // Internal state (optional)\n        tick(ctx) { ... }   // Main loop (required)\n        init(ctx) { ... }   // Initialization (optional)\n        shutdown(ctx) { ... } // Cleanup (optional)\n        impl { ... }        // Custom methods (optional)\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:43:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 43,
      "lineEnd": 50,
      "language": "rust",
      "code": "pub {\n    // Syntax: name: Type -> \"topic_name\"\n    velocity: f32 -> \"robot.velocity\",\n    status: String -> \"robot.status\",\n    pose: Pose2D -> \"robot.pose\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:60:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 60,
      "lineEnd": 66,
      "language": "rust",
      "code": "sub {\n    // Syntax: name: Type -> \"topic_name\"\n    commands: String -> \"user.commands\",\n    sensors: f32 -> \"sensors.temperature\"\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:76:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 76,
      "lineEnd": 83,
      "language": "rust",
      "code": "data {\n    counter: u32 = 0,\n    buffer: Vec<f32> = Vec::new(),\n    last_time: Instant = Instant::now(),\n    config: MyConfig = MyConfig::default()\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:89:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 89,
      "lineEnd": 104,
      "language": "rust",
      "code": "tick(ctx) {\n    // ctx is Option<&mut NodeInfo>\n\n    // Read from subscribers\n    if let Some(cmd) = self.commands.recv(&mut ctx) {\n        // Process\n    }\n\n    // Write to publishers\n    self.velocity.send(1.0, &mut ctx).ok();\n\n    // Access internal state\n    self.counter += 1;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:110:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 110,
      "lineEnd": 116,
      "language": "rust",
      "code": "init(ctx) {\n    // ctx is &mut NodeInfo\n    ctx.log_info(\"Node starting\");\n    self.buffer.reserve(1000);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:122:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 122,
      "lineEnd": 128,
      "language": "rust",
      "code": "shutdown(ctx) {\n    // ctx is &mut NodeInfo\n    ctx.log_info(\"Node stopping\");\n    // Close files, save state, etc.\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:134:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 134,
      "lineEnd": 144,
      "language": "rust",
      "code": "impl {\n    fn calculate(&self, x: f32) -> f32 {\n        x * 2.0 + self.offset\n    }\n\n    fn reset(&mut self) {\n        self.counter = 0;\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:155:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 155,
      "lineEnd": 192,
      "language": "rust",
      "code": "// This macro call:\nnode! {\n    SensorNode {\n        pub { data: f32 -> \"sensor\" }\n        data { count: u32 = 0 }\n        tick(ctx) { self.count += 1; }\n    }\n}\n\n// Generates approximately:\nstruct SensorNode {\n    data: Hub<f32>,\n    count: u32,\n}\n\nimpl SensorNode {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            data: Hub::new(\"sensor\")?,\n            count: 0,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str { \"SensorNode\" }\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.count += 1;\n    }\n}\n\nimpl Default for SensorNode {\n    fn default() -> Self {\n        Self::new().expect(\"Failed to create SensorNode\")\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:198:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 198,
      "lineEnd": 206,
      "language": "rust",
      "code": "node! {\n    MinimalNode {\n        tick(ctx) {\n            // Called every tick\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:210:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 210,
      "lineEnd": 222,
      "language": "rust",
      "code": "node! {\n    HeartbeatNode {\n        pub { alive: bool -> \"system.heartbeat\" }\n        data { count: u64 = 0 }\n\n        tick(ctx) {\n            self.alive.send(true, &mut ctx).ok();\n            self.count += 1;\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:226:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 226,
      "lineEnd": 240,
      "language": "rust",
      "code": "node! {\n    LoggerNode {\n        sub { messages: String -> \"logs\" }\n\n        tick(ctx) {\n            while let Some(msg) = self.messages.recv(&mut ctx) {\n                if let Some(ref mut c) = ctx {\n                    c.log_info(&msg);\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:244:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 244,
      "lineEnd": 268,
      "language": "rust",
      "code": "node! {\n    ProcessorNode {\n        sub { input: f32 -> \"raw_data\" }\n        pub { output: f32 -> \"processed_data\" }\n        data {\n            scale: f32 = 2.0,\n            offset: f32 = 10.0\n        }\n\n        tick(ctx) {\n            if let Some(value) = self.input.recv(&mut ctx) {\n                let result = value * self.scale + self.offset;\n                self.output.send(result, &mut ctx).ok();\n            }\n        }\n\n        impl {\n            fn set_scale(&mut self, scale: f32) {\n                self.scale = scale;\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:272:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 272,
      "lineEnd": 297,
      "language": "rust",
      "code": "node! {\n    StatefulNode {\n        pub { status: String -> \"status\" }\n        data {\n            initialized: bool = false,\n            tick_count: u64 = 0\n        }\n\n        init(ctx) {\n            ctx.log_info(\"Initializing...\");\n            self.initialized = true;\n        }\n\n        tick(ctx) {\n            self.tick_count += 1;\n            let msg = format!(\"Tick {}\", self.tick_count);\n            self.status.send(msg, &mut ctx).ok();\n        }\n\n        shutdown(ctx) {\n            ctx.log_info(&format!(\"Total ticks: {}\", self.tick_count));\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:301:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 301,
      "lineEnd": 319,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nnode! {\n    MyNode {\n        pub { output: f32 -> \"data\" }\n        tick(ctx) {\n            self.output.send(42.0, &mut ctx).ok();\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(MyNode::new()?), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:329:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 329,
      "lineEnd": 337,
      "language": "rust",
      "code": "message! {\n    MessageName {\n        field1: Type,\n        field2: Type,\n        // ...\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:351:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 351,
      "lineEnd": 369,
      "language": "rust",
      "code": "message! {\n    RobotCommand {\n        linear_velocity: f32,\n        angular_velocity: f32,\n        timestamp: u64,\n    }\n}\n\n// Usage\nlet cmd = RobotCommand {\n    linear_velocity: 1.0,\n    angular_velocity: 0.5,\n    timestamp: 12345,\n};\n\nlet hub: Hub<RobotCommand> = Hub::new(\"commands\")?;\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:373:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 373,
      "lineEnd": 380,
      "language": "rust",
      "code": "message! {\n    SensorArray {\n        values: [f32; 8],\n        valid_count: u8,\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:384:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 384,
      "lineEnd": 395,
      "language": "rust",
      "code": "message! {\n    RobotState {\n        position: [f64; 3],\n        orientation: [f64; 4],  // quaternion\n        velocity: [f64; 6],     // linear + angular\n        status: u8,\n        battery_percent: f32,\n        timestamp: u64,\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:403:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 403,
      "lineEnd": 415,
      "language": "rust",
      "code": "// Good - non-blocking\ntick(ctx) {\n    if let Some(x) = self.input.recv(&mut ctx) {\n        self.output.send(x * 2.0, &mut ctx).ok();\n    }\n}\n\n// Bad - blocking operation\ntick(ctx) {\n    std::thread::sleep(Duration::from_secs(1));  // Blocks scheduler!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:419:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 419,
      "lineEnd": 427,
      "language": "rust",
      "code": "init(ctx) {\n    self.buffer.reserve(1000);  // Do once\n}\n\ntick(ctx) {\n    // Don't allocate here - runs every tick\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:431:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 431,
      "lineEnd": 437,
      "language": "rust",
      "code": "// Good\npub { motor_velocity: f32 -> \"motors.velocity\" }\n\n// Bad\npub { x: f32 -> \"data\" }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:441:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 441,
      "lineEnd": 453,
      "language": "rust",
      "code": "tick(ctx) {\n    // Use .ok() for non-critical sends\n    self.status.send(\"ok\".to_string(), &mut ctx).ok();\n\n    // Or handle errors explicitly\n    if let Err(msg) = self.critical.send(data, &mut ctx) {\n        if let Some(ref mut c) = ctx {\n            c.log_error(\"Failed to send critical data\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:463:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 463,
      "lineEnd": 473,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\nnode! {\n    MyNode {\n        pub { cmd: CmdVel -> \"cmd_vel\" }\n        tick(ctx) { }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/macros:479:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 479,
      "lineEnd": 485,
      "language": "rust",
      "code": "// Wrong\npub { cmd: f32 \"topic\" }\n\n// Correct\npub { cmd: f32 -> \"topic\" }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:489:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 489,
      "lineEnd": 495,
      "language": "rust",
      "code": "// Wrong\nnode! { my_node { ... } }\n\n// Correct\nnode! { MyNode { ... } }",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/api/macros:499:rust",
      "file": "content/docs/rust/api/macros.mdx",
      "lineStart": 499,
      "lineEnd": 511,
      "language": "rust",
      "code": "tick(ctx) {\n    // ctx is Option<&mut NodeInfo>\n\n    // Wrong - ctx is not NodeInfo directly\n    ctx.log_info(\"test\");\n\n    // Correct - unwrap the Option\n    if let Some(ref mut c) = ctx {\n        c.log_info(\"test\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:11:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 11,
      "lineEnd": 13,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides *;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:25:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 25,
      "lineEnd": 31,
      "language": "rust",
      "code": "pub struct Twist {\n    pub linear: [f64; 3],    // [x, y, z] in m/s\n    pub angular: [f64; 3],   // [roll, pitch, yaw] in rad/s\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:35:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 35,
      "lineEnd": 44,
      "language": "rust",
      "code": "// Full 3D velocity\nlet twist = Twist::new([1.0, 0.0, 0.0], [0.0, 0.0, 0.5]);\n\n// 2D velocity (forward + rotation)\nlet twist = Twist::new_2d(1.0, 0.5);  // 1 m/s forward, 0.5 rad/s rotation\n\n// Stop command\nlet twist = Twist::stop();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:58:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 58,
      "lineEnd": 65,
      "language": "rust",
      "code": "pub struct Pose2D {\n    pub x: f64,       // X position in meters\n    pub y: f64,       // Y position in meters\n    pub theta: f64,   // Orientation in radians\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:69:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 69,
      "lineEnd": 72,
      "language": "rust",
      "code": "let pose = Pose2D::new(1.0, 2.0, 0.5);  // x=1m, y=2m, theta=0.5rad\nlet pose = Pose2D::origin();             // (0, 0, 0)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:88:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 88,
      "lineEnd": 94,
      "language": "rust",
      "code": "pub struct Transform {\n    pub translation: [f64; 3],  // [x, y, z] in meters\n    pub rotation: [f64; 4],     // Quaternion [x, y, z, w]\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:98:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 98,
      "lineEnd": 102,
      "language": "rust",
      "code": "let tf = Transform::identity();\nlet tf = Transform::new([1.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0]);\nlet tf = Transform::from_pose_2d(&pose);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:117:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 117,
      "lineEnd": 123,
      "language": "rust",
      "code": "pub struct Point3 {\n    pub x: f64,\n    pub y: f64,\n    pub z: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:127:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 127,
      "lineEnd": 131,
      "language": "rust",
      "code": "let p1 = Point3::new(1.0, 2.0, 3.0);\nlet p2 = Point3::origin();\nlet dist = p1.distance_to(&p2);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:139:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 139,
      "lineEnd": 145,
      "language": "rust",
      "code": "pub struct Vector3 {\n    pub x: f64,\n    pub y: f64,\n    pub z: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:162:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 162,
      "lineEnd": 169,
      "language": "rust",
      "code": "pub struct Quaternion {\n    pub x: f64,\n    pub y: f64,\n    pub z: f64,\n    pub w: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:173:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 173,
      "lineEnd": 177,
      "language": "rust",
      "code": "let q = Quaternion::identity();\nlet q = Quaternion::new(0.0, 0.0, 0.0, 1.0);\nlet q = Quaternion::from_euler(roll, pitch, yaw);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:189:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 189,
      "lineEnd": 201,
      "language": "rust",
      "code": "pub struct LaserScan {\n    pub ranges: [f32; 360],      // Range measurements in meters\n    pub angle_min: f32,          // Start angle in radians\n    pub angle_max: f32,          // End angle in radians\n    pub range_min: f32,          // Minimum valid range\n    pub range_max: f32,          // Maximum valid range\n    pub angle_increment: f32,    // Angular resolution\n    pub time_increment: f32,     // Time between measurements\n    pub scan_time: f32,          // Full scan time\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:205:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 205,
      "lineEnd": 208,
      "language": "rust",
      "code": "let scan = LaserScan::new();\nlet scan = LaserScan::default();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:221:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 221,
      "lineEnd": 229,
      "language": "rust",
      "code": "if let Some(scan) = scan_sub.recv(&mut ctx) {\n    if let Some(min_dist) = scan.min_range() {\n        if min_dist < 0.5 {\n            // Obstacle detected!\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:237:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 237,
      "lineEnd": 247,
      "language": "rust",
      "code": "pub struct Imu {\n    pub orientation: [f64; 4],              // Quaternion [x, y, z, w]\n    pub orientation_covariance: [f64; 9],   // 3x3 covariance (-1 = no data)\n    pub angular_velocity: [f64; 3],         // [x, y, z] in rad/s\n    pub angular_velocity_covariance: [f64; 9],\n    pub linear_acceleration: [f64; 3],      // [x, y, z] in m/s²\n    pub linear_acceleration_covariance: [f64; 9],\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:251:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 251,
      "lineEnd": 253,
      "language": "rust",
      "code": "let imu = Imu::new();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:271:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 271,
      "lineEnd": 281,
      "language": "rust",
      "code": "pub struct Odometry {\n    pub pose: Pose2D,\n    pub twist: Twist,\n    pub pose_covariance: [f64; 36],    // 6x6 covariance\n    pub twist_covariance: [f64; 36],\n    pub frame_id: [u8; 32],            // e.g., \"odom\"\n    pub child_frame_id: [u8; 32],      // e.g., \"base_link\"\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:297:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 297,
      "lineEnd": 312,
      "language": "rust",
      "code": "pub struct NavSatFix {\n    pub latitude: f64,           // Degrees (+ North, - South)\n    pub longitude: f64,          // Degrees (+ East, - West)\n    pub altitude: f64,           // Meters above WGS84\n    pub position_covariance: [f64; 9],\n    pub position_covariance_type: u8,\n    pub status: u8,              // Fix status\n    pub satellites_visible: u16,\n    pub hdop: f32,\n    pub vdop: f32,\n    pub speed: f32,              // m/s\n    pub heading: f32,            // degrees\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:316:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 316,
      "lineEnd": 321,
      "language": "rust",
      "code": "NavSatFix::STATUS_NO_FIX    // 0\nNavSatFix::STATUS_FIX       // 1\nNavSatFix::STATUS_SBAS_FIX  // 2\nNavSatFix::STATUS_GBAS_FIX  // 3",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:339:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 339,
      "lineEnd": 352,
      "language": "rust",
      "code": "pub struct BatteryState {\n    pub voltage: f32,            // Volts\n    pub current: f32,            // Amperes (negative = discharging)\n    pub charge: f32,             // Amp-hours\n    pub capacity: f32,           // Amp-hours\n    pub percentage: f32,         // 0-100\n    pub power_supply_status: u8,\n    pub temperature: f32,        // Celsius\n    pub cell_voltages: [f32; 16],\n    pub cell_count: u8,\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:356:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 356,
      "lineEnd": 361,
      "language": "rust",
      "code": "BatteryState::STATUS_UNKNOWN     // 0\nBatteryState::STATUS_CHARGING    // 1\nBatteryState::STATUS_DISCHARGING // 2\nBatteryState::STATUS_FULL        // 3",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:378:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 378,
      "lineEnd": 387,
      "language": "rust",
      "code": "pub struct Range {\n    pub sensor_type: u8,     // 0=ultrasonic, 1=infrared\n    pub field_of_view: f32,  // radians\n    pub min_range: f32,      // meters\n    pub max_range: f32,      // meters\n    pub range: f32,          // meters\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:399:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 399,
      "lineEnd": 408,
      "language": "rust",
      "code": "pub struct Image {\n    pub width: u32,\n    pub height: u32,\n    pub encoding: ImageEncoding,\n    pub step: u32,           // Row size in bytes\n    pub data: Vec<u8>,\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:412:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 412,
      "lineEnd": 423,
      "language": "rust",
      "code": "pub enum ImageEncoding {\n    Rgb8,\n    Bgr8,\n    Rgba8,\n    Bgra8,\n    Mono8,\n    Mono16,\n    Depth16,\n    Depth32f,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:431:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 431,
      "lineEnd": 441,
      "language": "rust",
      "code": "pub struct CameraInfo {\n    pub width: u32,\n    pub height: u32,\n    pub distortion_model: [u8; 32],\n    pub d: [f64; 5],         // Distortion coefficients\n    pub k: [f64; 9],         // Intrinsic matrix\n    pub r: [f64; 9],         // Rectification matrix\n    pub p: [f64; 12],        // Projection matrix\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:449:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 449,
      "lineEnd": 456,
      "language": "rust",
      "code": "pub struct Detection {\n    pub class_id: u32,\n    pub class_name: [u8; 32],\n    pub confidence: f32,\n    pub bbox: [f32; 4],      // [x, y, width, height]\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:468:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 468,
      "lineEnd": 475,
      "language": "rust",
      "code": "pub struct MotorCommand {\n    pub motor_id: u8,\n    pub value: f32,          // -1.0 to 1.0 or actual units\n    pub mode: u8,            // 0=duty, 1=velocity, 2=position\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:483:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 483,
      "lineEnd": 490,
      "language": "rust",
      "code": "pub struct ServoCommand {\n    pub channel: u8,\n    pub angle: f32,          // degrees\n    pub speed: f32,          // degrees/second (0 = max)\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:498:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 498,
      "lineEnd": 509,
      "language": "rust",
      "code": "pub struct PidConfig {\n    pub kp: f32,\n    pub ki: f32,\n    pub kd: f32,\n    pub setpoint: f32,\n    pub output_min: f32,\n    pub output_max: f32,\n    pub integral_min: f32,\n    pub integral_max: f32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:517:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 517,
      "lineEnd": 522,
      "language": "rust",
      "code": "pub struct GenericMessage {\n    // Fixed-size buffer for shared memory safety\n    // Max payload: 4KB\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:526:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 526,
      "lineEnd": 535,
      "language": "rust",
      "code": "// From raw bytes\nlet msg = GenericMessage::new(data_vec)?;\n\n// From any serializable type\nlet msg = GenericMessage::from_value(&my_struct)?;\n\n// With metadata\nlet msg = GenericMessage::with_metadata(data, \"my_type\".to_string())?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/messages:547:rust",
      "file": "content/docs/rust/api/messages.mdx",
      "lineStart": 547,
      "lineEnd": 562,
      "language": "rust",
      "code": "use std::collections::HashMap;\n\n// Send\nlet mut data = HashMap::new();\ndata.insert(\"x\", 1.0);\ndata.insert(\"y\", 2.0);\nlet msg = GenericMessage::from_value(&data)?;\nhub.send(msg, &mut ctx)?;\n\n// Receive\nif let Some(msg) = hub.recv(&mut ctx) {\n    let data: HashMap<String, f64> = msg.to_value()?;\n    println!(\"x: {}\", data[\"x\"]);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:15:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 15,
      "lineEnd": 30,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{Tensor, DataType};\n\n// Create a 3x3 tensor\nlet data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];\nlet tensor = Tensor::new(data, vec![3, 3], DataType::Float32);\n\n// With name\nlet named_tensor = Tensor::new(data, vec![3, 3], DataType::Float32)\n    .with_name(\"input_features\".to_string());\n\n// Get properties\nprintln!(\"Shape: {:?}\", tensor.shape);\nprintln!(\"Elements: {}\", tensor.size());  // 9\nprintln!(\"Dimensions: {}\", tensor.ndim()); // 2",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:61:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 61,
      "lineEnd": 82,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Predictions;\nuse std::collections::HashMap;\n\nlet preds = Predictions {\n    class_ids: vec![0, 1, 2],\n    scores: vec![0.95, 0.88, 0.72],\n    class_names: Some(vec![\"person\".into(), \"car\".into(), \"dog\".into()]),\n    metadata: HashMap::new(),\n};\n\n// With metadata\nlet mut meta = HashMap::new();\nmeta.insert(\"model_version\".to_string(), \"1.0.0\".to_string());\n\nlet preds_with_meta = Predictions {\n    class_ids: vec![0],\n    scores: vec![0.99],\n    class_names: Some(vec![\"cat\".into()]),\n    metadata: meta,\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:97:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 97,
      "lineEnd": 112,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Detection;\n\nlet detection = Detection {\n    bbox: [100.0, 100.0, 200.0, 300.0],  // [x, y, width, height]\n    class_id: 0,\n    class_name: Some(\"person\".into()),\n    confidence: 0.95,\n    track_id: Some(42),  // For multi-object tracking\n};\n\nprintln!(\"Detected {} at ({}, {}) with {:.1}% confidence\",\n    detection.class_name.as_deref().unwrap_or(\"unknown\"),\n    detection.bbox[0], detection.bbox[1],\n    detection.confidence * 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:128:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 128,
      "lineEnd": 154,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{DetectionArray, Detection};\n\nlet detections = DetectionArray {\n    detections: vec![\n        Detection {\n            bbox: [100.0, 100.0, 200.0, 300.0],\n            class_id: 0,\n            class_name: Some(\"person\".into()),\n            confidence: 0.95,\n            track_id: None,\n        },\n        Detection {\n            bbox: [400.0, 200.0, 100.0, 80.0],\n            class_id: 2,\n            class_name: Some(\"car\".into()),\n            confidence: 0.88,\n            track_id: None,\n        },\n    ],\n    image_width: 640,\n    image_height: 480,\n    timestamp_ns: 0,\n};\n\nprintln!(\"Found {} objects\", detections.detections.len());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:169:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 169,
      "lineEnd": 189,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::SegmentationMask;\n\n// Create mask for 480x640 image with 21 classes (PASCAL VOC)\nlet mask = SegmentationMask {\n    mask: vec![0u8; 640 * 480],  // Class ID per pixel\n    width: 640,\n    height: 480,\n    num_classes: 21,\n    class_names: vec![\n        \"background\".into(), \"aeroplane\".into(), \"bicycle\".into(),\n        \"bird\".into(), \"boat\".into(), \"bottle\".into(),\n        // ... more classes\n    ],\n    timestamp_ns: 0,\n};\n\n// Get class at pixel\nlet pixel_class = mask.mask[(240 * 640 + 320) as usize];\nprintln!(\"Center pixel class: {}\", mask.class_names[pixel_class as usize]);",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:206:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 206,
      "lineEnd": 219,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Keypoint;\n\nlet nose = Keypoint {\n    x: 320.0,\n    y: 100.0,\n    z: Some(0.5),  // Optional depth\n    confidence: 0.98,\n    name: \"nose\".to_string(),\n};\n\nprintln!(\"{}: ({:.1}, {:.1}) conf={:.2}\",\n    nose.name, nose.x, nose.y, nose.confidence);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:235:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 235,
      "lineEnd": 256,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{Pose, Keypoint};\n\nlet pose = Pose {\n    keypoints: vec![\n        Keypoint { x: 320.0, y: 100.0, z: None, confidence: 0.98, name: \"nose\".into() },\n        Keypoint { x: 300.0, y: 200.0, z: None, confidence: 0.95, name: \"left_shoulder\".into() },\n        Keypoint { x: 340.0, y: 200.0, z: None, confidence: 0.96, name: \"right_shoulder\".into() },\n        // ... typically 17-33 keypoints\n    ],\n    confidence: 0.92,\n    person_id: 0,\n    bbox: Some([280.0, 80.0, 80.0, 200.0]),\n};\n\n// Check if key joints are detected\nlet high_conf_keypoints: Vec<_> = pose.keypoints.iter()\n    .filter(|kp| kp.confidence > 0.8)\n    .collect();\nprintln!(\"{}/{} keypoints detected with high confidence\",\n    high_conf_keypoints.len(), pose.keypoints.len());",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:271:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 271,
      "lineEnd": 282,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::PoseArray;\n\nlet poses = PoseArray {\n    poses: vec![/* multiple Pose instances */],\n    image_width: 640,\n    image_height: 480,\n    timestamp_ns: 0,\n};\n\nprintln!(\"Detected {} people\", poses.poses.len());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:297:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 297,
      "lineEnd": 310,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Classification;\n\nlet classification = Classification {\n    class_ids: vec![281, 282, 285],\n    class_names: vec![\"tabby\".into(), \"tiger_cat\".into(), \"Egyptian_cat\".into()],\n    probabilities: vec![0.75, 0.15, 0.08],  // Sum to ~1.0\n    timestamp_ns: 0,\n};\n\nprintln!(\"Top prediction: {} ({:.1}%)\",\n    classification.class_names[0],\n    classification.probabilities[0] * 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:325:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 325,
      "lineEnd": 341,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::FeatureVector;\n\nlet features = FeatureVector {\n    features: vec![0.1, 0.2, -0.3, /* ... 512 or 2048 dims */],\n    source: Some(\"image_001.jpg\".to_string()),\n    timestamp_ns: 0,\n};\n\n// Compute cosine similarity\nfn cosine_similarity(a: &[f32], b: &[f32]) -> f32 {\n    let dot: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n    let norm_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();\n    let norm_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();\n    dot / (norm_a * norm_b)\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:355:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 355,
      "lineEnd": 371,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{ModelInfo, ModelFormat};\n\nlet model_info = ModelInfo {\n    name: \"yolov8n\".to_string(),\n    version: \"8.0.0\".to_string(),\n    format: ModelFormat::ONNX,\n    input_shapes: vec![vec![1, 3, 640, 640]],\n    output_shapes: vec![vec![1, 84, 8400]],\n    input_names: vec![\"images\".to_string()],\n    output_names: vec![\"output0\".to_string()],\n    metadata: std::collections::HashMap::new(),\n};\n\nprintln!(\"Model: {} v{}\", model_info.name, model_info.version);\nprintln!(\"Input shape: {:?}\", model_info.input_shapes[0]);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:402:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 402,
      "lineEnd": 415,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::InferenceMetrics;\n\nlet metrics = InferenceMetrics {\n    latency_ms: 12.5,\n    throughput: 80.0,  // 80 fps\n    model_name: \"yolov8n\".to_string(),\n    batch_size: 1,\n    timestamp_ns: 0,\n};\n\nprintln!(\"{}: {:.1}ms latency, {:.0} fps\",\n    metrics.model_name, metrics.latency_ms, metrics.throughput);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:433:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 433,
      "lineEnd": 445,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::ChatMessage;\n\nlet system_msg = ChatMessage {\n    role: \"system\".to_string(),\n    content: \"You are a helpful robot assistant.\".to_string(),\n};\n\nlet user_msg = ChatMessage {\n    role: \"user\".to_string(),\n    content: \"What objects do you see?\".to_string(),\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:458:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 458,
      "lineEnd": 473,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{LLMRequest, ChatMessage};\n\nlet request = LLMRequest {\n    messages: vec![\n        ChatMessage {\n            role: \"system\".to_string(),\n            content: \"You are a robot navigation assistant.\".to_string(),\n        },\n        ChatMessage {\n            role: \"user\".to_string(),\n            content: \"Navigate to the kitchen.\".to_string(),\n        },\n    ],\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:485:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 485,
      "lineEnd": 499,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::LLMResponse;\n\nlet response = LLMResponse {\n    response: \"I'll navigate to the kitchen. Setting waypoint...\".to_string(),\n    tokens_used: 42,\n    latency_ms: 250,\n    model: \"llama-3-8b\".to_string(),\n    finish_reason: \"stop\".to_string(),\n    timestamp_ns: 0,\n};\n\nprintln!(\"Response: {}\", response.response);\nprintln!(\"Tokens: {}, Latency: {}ms\", response.tokens_used, response.latency_ms);",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:516:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 516,
      "lineEnd": 531,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::TrainingMetrics;\n\nlet metrics = TrainingMetrics {\n    epoch: 5,\n    step: 1000,\n    loss: 0.042,\n    accuracy: Some(0.95),\n    learning_rate: 0.0001,\n    timestamp_ns: 0,\n};\n\nprintln!(\"Epoch {}, Step {}: loss={:.4}, acc={:.2}%\",\n    metrics.epoch, metrics.step, metrics.loss,\n    metrics.accuracy.unwrap_or(0.0) * 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:548:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 548,
      "lineEnd": 558,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{TrajectoryPoint, Tensor, DataType};\n\nlet point = TrajectoryPoint {\n    observation: Tensor::new(vec![/* sensor data */], vec![128], DataType::Float32),\n    action: Tensor::new(vec![0.5, 0.0, 0.2], vec![3], DataType::Float32),\n    reward: Some(1.0),\n    done: false,\n    timestamp_ns: 0,\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:574:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 574,
      "lineEnd": 586,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{DeploymentConfig, ModelFormat};\n\nlet config = DeploymentConfig {\n    model_path: \"/models/yolov8n.onnx\".to_string(),\n    format: ModelFormat::ONNX,\n    execution_provider: \"cuda\".to_string(),\n    batch_size: 1,\n    use_fp16: true,\n    num_threads: None,\n    device_id: Some(0),\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/ml-messages:611:rust",
      "file": "content/docs/rust/api/ml-messages.mdx",
      "lineStart": 611,
      "lineEnd": 663,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides ml::{DetectionArray, Detection, InferenceMetrics};\nuse horus::prelude::*; // Provides Image;\n\nstruct ObjectDetectionNode {\n    image_sub: Hub<Image>,\n    detection_pub: Hub<DetectionArray>,\n    metrics_pub: Hub<InferenceMetrics>,\n    model_name: String,\n}\n\nimpl Node for ObjectDetectionNode {\n    fn name(&self) -> &'static str { \"ObjectDetection\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(image) = self.image_sub.recv(&mut ctx) {\n            let start = std::time::Instant::now();\n\n            // Run inference (placeholder)\n            let detections = self.run_inference(&image);\n\n            let elapsed = start.elapsed().as_secs_f32() * 1000.0;\n\n            // Publish detections\n            let detection_msg = DetectionArray {\n                detections,\n                image_width: image.width,\n                image_height: image.height,\n                timestamp_ns: image.timestamp,\n            };\n            self.detection_pub.send(detection_msg, &mut ctx).ok();\n\n            // Publish metrics\n            let metrics = InferenceMetrics {\n                latency_ms: elapsed,\n                throughput: 1000.0 / elapsed,\n                model_name: self.model_name.clone(),\n                batch_size: 1,\n                timestamp_ns: image.timestamp,\n            };\n            self.metrics_pub.send(metrics, &mut ctx).ok();\n        }\n    }\n}\n\nimpl ObjectDetectionNode {\n    fn run_inference(&self, _image: &Image) -> Vec<Detection> {\n        // Model inference implementation\n        vec![]\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:15:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 15,
      "lineEnd": 38,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::Goal;\nuse horus::prelude::*; // Provides geometry::Pose2D;\n\n// Create navigation goal\nlet target = Pose2D::new(5.0, 3.0, 1.57);  // x, y, theta\nlet goal = Goal::new(target, 0.1, 0.05);   // 10cm position, 0.05rad angle tolerance\n\n// With timeout and priority\nlet goal = Goal::new(target, 0.1, 0.05)\n    .with_timeout(30.0)  // 30 second timeout\n    .with_priority(0);   // Highest priority\n\n// Check if goal reached\nlet current_pose = Pose2D::new(5.05, 3.02, 1.55);\nif goal.is_reached(&current_pose) {\n    println!(\"Goal reached!\");\n}\n\n// Check position and orientation separately\nif goal.is_position_reached(&current_pose) {\n    println!(\"Position reached, adjusting orientation...\");\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:56:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 56,
      "lineEnd": 70,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::GoalStatus;\n\nlet status = GoalStatus::Active;\n\nmatch status {\n    GoalStatus::Pending => println!(\"Waiting to start\"),\n    GoalStatus::Active => println!(\"Moving to goal\"),\n    GoalStatus::Succeeded => println!(\"Goal reached!\"),\n    GoalStatus::Aborted => println!(\"Navigation failed\"),\n    GoalStatus::Cancelled => println!(\"Goal cancelled by user\"),\n    GoalStatus::Preempted => println!(\"Higher priority goal received\"),\n    GoalStatus::TimedOut => println!(\"Goal timed out\"),\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:88:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 88,
      "lineEnd": 107,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::{GoalResult, GoalStatus};\n\n// Create success result\nlet result = GoalResult::new(42, GoalStatus::Succeeded);\n\n// Create failure result with error\nlet error_result = GoalResult::new(42, GoalStatus::Aborted)\n    .with_error(\"Obstacle blocking path\");\n\n// Update progress\nlet mut in_progress = GoalResult::new(42, GoalStatus::Active);\nin_progress.distance_to_goal = 2.5;  // 2.5m remaining\nin_progress.eta_seconds = 5.0;       // 5s estimated\nin_progress.progress = 0.75;         // 75% complete\n\nprintln!(\"Goal {}: {:?}, {:.1}m to go, ETA {:.1}s\",\n    in_progress.goal_id, in_progress.status,\n    in_progress.distance_to_goal, in_progress.eta_seconds);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:125:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 125,
      "lineEnd": 144,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::Waypoint;\nuse horus::prelude::*; // Provides geometry::{Pose2D, Twist};\n\n// Simple waypoint\nlet wp = Waypoint::new(Pose2D::new(1.0, 2.0, 0.0));\n\n// Waypoint with velocity profile\nlet wp = Waypoint::new(Pose2D::new(1.0, 2.0, 0.0))\n    .with_velocity(Twist::linear(0.5, 0.0));  // 0.5 m/s forward\n\n// Waypoint requiring stop (e.g., for pickup)\nlet stop_wp = Waypoint::new(Pose2D::new(3.0, 4.0, 1.57))\n    .with_stop();\n\n// Access properties\nprintln!(\"Position: ({:.1}, {:.1})\", wp.pose.x, wp.pose.y);\nprintln!(\"Curvature: {:.3}\", wp.curvature);\nprintln!(\"Stop required: {}\", wp.stop_required);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:160:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 160,
      "lineEnd": 191,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::{Path, Waypoint};\nuse horus::prelude::*; // Provides geometry::Pose2D;\n\n// Create empty path\nlet mut path = Path::new();\n\n// Add waypoints\npath.add_waypoint(Waypoint::new(Pose2D::new(0.0, 0.0, 0.0)))?;\npath.add_waypoint(Waypoint::new(Pose2D::new(1.0, 0.0, 0.0)))?;\npath.add_waypoint(Waypoint::new(Pose2D::new(2.0, 1.0, 0.785)))?;\n\n// Set frame ID\nlet path = path.with_frame_id(\"map\");\n\n// Get path info\nprintln!(\"Waypoints: {}\", path.waypoint_count);\nprintln!(\"Total length: {:.2}m\", path.total_length);\n\n// Get valid waypoints slice\nlet waypoints = path.get_waypoints();\n\n// Find closest waypoint to current position\nlet current = Pose2D::new(1.2, 0.3, 0.0);\nif let Some(idx) = path.closest_waypoint_index(&current) {\n    println!(\"Closest waypoint: {}\", idx);\n}\n\n// Calculate progress along path\nlet progress = path.calculate_progress(&current);\nprintln!(\"Path progress: {:.0}%\", progress * 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:209:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 209,
      "lineEnd": 231,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::PathPlan;\n\n// Create path plan with waypoints\nlet waypoints = vec![\n    [0.0, 0.0, 0.0],      // [x, y, theta]\n    [1.0, 0.0, 0.0],\n    [2.0, 0.5, 0.5],\n    [3.0, 1.0, 0.785],\n];\nlet goal = [3.0, 1.0, 0.785];\n\nlet plan = PathPlan::with_waypoints(waypoints, goal);\n\n// Or build incrementally\nlet mut plan = PathPlan::new();\nplan.add_waypoint(0.0, 0.0, 0.0);\nplan.add_waypoint(1.0, 0.5, 0.2);\nplan.goal_pose = [1.0, 0.5, 0.2];\n\nprintln!(\"Path has {} waypoints\", plan.path_length);\nprintln!(\"Empty: {}\", plan.is_empty());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:246:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 246,
      "lineEnd": 288,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::OccupancyGrid;\nuse horus::prelude::*; // Provides geometry::Pose2D;\n\n// Create 10m x 10m map at 5cm resolution\nlet origin = Pose2D::origin();\nlet mut grid = OccupancyGrid::new(\n    200,   // width (200 * 0.05 = 10m)\n    200,   // height\n    0.05,  // resolution (5cm per cell)\n    origin\n);\n\n// Set occupancy (-1=unknown, 0=free, 100=occupied)\ngrid.set_occupancy(100, 100, 0);    // Free cell\ngrid.set_occupancy(150, 150, 100);  // Occupied cell (obstacle)\n\n// World to grid coordinate conversion\nif let Some((gx, gy)) = grid.world_to_grid(5.0, 5.0) {\n    println!(\"World (5.0, 5.0) -> Grid ({}, {})\", gx, gy);\n}\n\n// Grid to world coordinate conversion\nif let Some((x, y)) = grid.grid_to_world(100, 100) {\n    println!(\"Grid (100, 100) -> World ({:.2}, {:.2})\", x, y);\n}\n\n// Check cell status\nlet test_x = 7.5;\nlet test_y = 7.5;\nif grid.is_free(test_x, test_y) {\n    println!(\"({}, {}) is free\", test_x, test_y);\n} else if grid.is_occupied(test_x, test_y) {\n    println!(\"({}, {}) is occupied\", test_x, test_y);\n}\n\n// Get occupancy value\nif let Some((gx, gy)) = grid.world_to_grid(test_x, test_y) {\n    if let Some(value) = grid.get_occupancy(gx, gy) {\n        println!(\"Occupancy: {}\", value);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:317:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 317,
      "lineEnd": 340,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::{CostMap, OccupancyGrid};\nuse horus::prelude::*; // Provides geometry::Pose2D;\n\n// Create occupancy grid first\nlet grid = OccupancyGrid::new(200, 200, 0.05, Pose2D::origin());\n\n// Create costmap with inflation radius\nlet costmap = CostMap::from_occupancy_grid(grid, 0.55);  // 55cm inflation\n\n// Get cost at world coordinates (0-255, 253=lethal)\nif let Some(cost) = costmap.get_cost(5.0, 5.0) {\n    if cost >= costmap.lethal_cost {\n        println!(\"Position is in obstacle!\");\n    } else {\n        println!(\"Cost: {}\", cost);\n    }\n}\n\n// Access underlying grid\nprintln!(\"Map size: {}x{}\",\n    costmap.occupancy_grid.width,\n    costmap.occupancy_grid.height);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:365:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 365,
      "lineEnd": 380,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::VelocityObstacle;\n\nlet obstacle = VelocityObstacle {\n    position: [3.0, 2.0],        // [x, y]\n    velocity: [0.5, 0.0],        // Moving at 0.5 m/s in x\n    radius: 0.3,                  // 30cm radius\n    time_horizon: 5.0,            // 5 second prediction\n    obstacle_id: 1,\n};\n\nprintln!(\"Obstacle {} at ({:.1}, {:.1}) moving at ({:.1}, {:.1})\",\n    obstacle.obstacle_id,\n    obstacle.position[0], obstacle.position[1],\n    obstacle.velocity[0], obstacle.velocity[1]);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:396:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 396,
      "lineEnd": 410,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides navigation::{VelocityObstacles, VelocityObstacle};\n\nlet mut obstacles = VelocityObstacles::default();\nobstacles.obstacles[0] = VelocityObstacle {\n    position: [2.0, 1.0],\n    velocity: [0.3, 0.1],\n    radius: 0.25,\n    time_horizon: 3.0,\n    obstacle_id: 1,\n};\nobstacles.count = 1;\n\nprintln!(\"Tracking {} dynamic obstacles\", obstacles.count);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/navigation-messages:422:rust",
      "file": "content/docs/rust/api/navigation-messages.mdx",
      "lineStart": 422,
      "lineEnd": 483,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides navigation::{Goal, GoalResult, GoalStatus, Path, OccupancyGrid};\nuse horus::prelude::*; // Provides geometry::Pose2D;\nuse horus::prelude::*; // Provides Odometry;\n\nstruct NavigationNode {\n    goal_sub: Hub<Goal>,\n    odom_sub: Hub<Odometry>,\n    map_sub: Hub<OccupancyGrid>,\n    path_pub: Hub<Path>,\n    result_pub: Hub<GoalResult>,\n    current_goal: Option<Goal>,\n    current_path: Option<Path>,\n}\n\nimpl Node for NavigationNode {\n    fn name(&self) -> &'static str { \"Navigation\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check for new goals\n        if let Some(goal) = self.goal_sub.recv(&mut ctx) {\n            self.current_goal = Some(goal);\n            // Plan path to goal\n            if let Some(map) = self.map_sub.try_recv(&mut ctx) {\n                let path = self.plan_path(&goal, &map);\n                self.path_pub.send(path.clone(), &mut ctx).ok();\n                self.current_path = Some(path);\n            }\n        }\n\n        // Check goal progress\n        if let (Some(goal), Some(odom)) = (&self.current_goal, self.odom_sub.recv(&mut ctx)) {\n            let current_pose = Pose2D::new(\n                odom.pose.position.x,\n                odom.pose.position.y,\n                odom.pose.orientation.yaw()\n            );\n\n            if goal.is_reached(&current_pose) {\n                let result = GoalResult::new(goal.goal_id, GoalStatus::Succeeded);\n                self.result_pub.send(result, &mut ctx).ok();\n                self.current_goal = None;\n            } else {\n                let mut result = GoalResult::new(goal.goal_id, GoalStatus::Active);\n                result.distance_to_goal = goal.target_pose.distance_to(&current_pose);\n                if let Some(path) = &self.current_path {\n                    result.progress = path.calculate_progress(&current_pose);\n                }\n                self.result_pub.send(result, &mut ctx).ok();\n            }\n        }\n    }\n}\n\nimpl NavigationNode {\n    fn plan_path(&self, goal: &Goal, _map: &OccupancyGrid) -> Path {\n        // Path planning implementation (A*, RRT*, etc.)\n        Path::new()\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/perception-messages:15:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 15,
      "lineEnd": 42,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::{PointCloud, PointField, PointFieldType};\nuse horus::prelude::*; // Provides geometry::Point3;\n\n// Create XYZ point cloud from points\nlet points = vec![\n    Point3::new(1.0, 2.0, 3.0),\n    Point3::new(4.0, 5.0, 6.0),\n];\nlet cloud = PointCloud::xyz(&points);\n\n// Create XYZRGB point cloud with colors\nlet colored_points = vec![\n    (Point3::new(1.0, 2.0, 3.0), [255, 0, 0]),   // Red point\n    (Point3::new(4.0, 5.0, 6.0), [0, 255, 0]),   // Green point\n];\nlet cloud = PointCloud::xyzrgb(&colored_points);\n\n// Access point count\nprintln!(\"Points: {}\", cloud.point_count());\n\n// Extract XYZ coordinates back\nif let Some(points) = cloud.extract_xyz() {\n    for point in points {\n        println!(\"({:.2}, {:.2}, {:.2})\", point.x, point.y, point.z);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:63:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 63,
      "lineEnd": 69,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::{PointField, PointFieldType};\n\n// Create custom field\nlet intensity = PointField::new(\"intensity\", 12, PointFieldType::Float32, 1);\nprintln!(\"Field: {}, size: {} bytes\", intensity.name_str(), intensity.field_size());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:88:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 88,
      "lineEnd": 112,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::BoundingBox3D;\nuse horus::prelude::*; // Provides geometry::{Point3, Vector3};\n\n// Create bounding box\nlet center = Point3::new(1.0, 2.0, 0.5);\nlet size = Vector3::new(0.5, 0.3, 1.0);  // width, height, depth\n\nlet bbox = BoundingBox3D::new(center, size)\n    .with_label(\"person\");\n\n// Check properties\nprintln!(\"Label: {}\", bbox.label_str());\nprintln!(\"Volume: {:.2} m³\", bbox.volume());\nprintln!(\"Confidence: {:.2}\", bbox.confidence);\n\n// Check if point is inside\nlet test_point = Point3::new(1.1, 2.0, 0.6);\nif bbox.contains_point(&test_point) {\n    println!(\"Point is inside bounding box\");\n}\n\n// Get corner points\nlet corners = bbox.corners();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:130:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 130,
      "lineEnd": 149,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::{BoundingBoxArray3D, BoundingBox3D};\nuse horus::prelude::*; // Provides geometry::{Point3, Vector3};\n\nlet mut boxes = BoundingBoxArray3D::new();\n\n// Add bounding boxes\nlet bbox1 = BoundingBox3D::new(\n    Point3::new(1.0, 0.0, 0.5),\n    Vector3::new(0.5, 0.5, 1.8)\n).with_label(\"person\");\n\nboxes.add_box(bbox1)?;\n\n// Filter by confidence\nlet high_confidence = boxes.filter_by_confidence(0.8);\n\n// Filter by label\nlet people = boxes.filter_by_label(\"person\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:155:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 155,
      "lineEnd": 186,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::DepthImage;\n\n// Create depth image\nlet width = 640;\nlet height = 480;\nlet depths = vec![0u16; (width * height) as usize];  // Initialize with zeros\n\nlet mut depth_image = DepthImage::new(width, height, depths);\ndepth_image.min_depth = 200;   // 20cm minimum\ndepth_image.max_depth = 10000; // 10m maximum\ndepth_image.depth_scale = 1.0; // 1mm per unit\n\n// Access depth at pixel\nif let Some(depth) = depth_image.get_depth(320, 240) {\n    if depth_image.is_valid_depth(depth) {\n        println!(\"Depth at center: {}mm\", depth);\n    }\n}\n\n// Convert to point cloud using camera intrinsics\nlet fx = 525.0;  // Focal length x\nlet fy = 525.0;  // Focal length y\nlet cx = 320.0;  // Principal point x\nlet cy = 240.0;  // Principal point y\n\nlet point_cloud = depth_image.to_point_cloud(fx, fy, cx, cy);\n\n// Get statistics\nlet (min, max, mean) = depth_image.depth_statistics();\nprintln!(\"Depth range: {:.0}-{:.0}mm, mean: {:.0}mm\", min, max, mean);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:205:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 205,
      "lineEnd": 228,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::PlaneDetection;\nuse horus::prelude::*; // Provides geometry::{Point3, Vector3};\n\n// Create plane detection (floor plane)\nlet coefficients = [0.0, 0.0, 1.0, 0.0];  // ax + by + cz + d = 0 (horizontal plane at z=0)\nlet center = Point3::new(0.0, 0.0, 0.0);\nlet normal = Vector3::new(0.0, 0.0, 1.0);\n\nlet plane = PlaneDetection::new(coefficients, center, normal)\n    .with_type(\"floor\");\n\n// Check distance from point to plane\nlet test_point = Point3::new(1.0, 2.0, 0.1);\nlet distance = plane.distance_to_point(&test_point);\nprintln!(\"Distance to plane: {:.3}m\", distance);\n\n// Check if point is on plane (within tolerance)\nif plane.contains_point(&test_point, 0.05) {  // 5cm tolerance\n    println!(\"Point is on the plane\");\n}\n\nprintln!(\"Plane type: {}\", plane.plane_type_str());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:247:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 247,
      "lineEnd": 252,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides perception::PlaneArray;\n\nlet planes = PlaneArray::default();\nprintln!(\"Detected {} planes\", planes.count);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/perception-messages:256:rust",
      "file": "content/docs/rust/api/perception-messages.mdx",
      "lineStart": 256,
      "lineEnd": 280,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides perception::{PointCloud, DepthImage};\n\nstruct PerceptionNode {\n    depth_sub: Hub<DepthImage>,\n    cloud_pub: Hub<PointCloud>,\n    fx: f64,\n    fy: f64,\n    cx: f64,\n    cy: f64,\n}\n\nimpl Node for PerceptionNode {\n    fn name(&self) -> &'static str { \"PerceptionNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(depth) = self.depth_sub.recv(&mut ctx) {\n            // Convert depth to point cloud\n            let cloud = depth.to_point_cloud(self.fx, self.fy, self.cx, self.cy);\n            self.cloud_pub.send(cloud, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/sensor-messages:17:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 17,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a new laser scan\nlet mut scan = LaserScan::new();\n\n// Set scan parameters\nscan.angle_min = -std::f32::consts::PI;  // -180 degrees\nscan.angle_max = std::f32::consts::PI;   // +180 degrees\nscan.range_min = 0.1;                     // 10cm minimum\nscan.range_max = 30.0;                    // 30m maximum\n\n// Fill in range data (360 readings)\nfor i in 0..360 {\n    scan.ranges[i] = 2.5;  // 2.5m reading at all angles\n}\n\n// Get angle for a specific reading\nlet angle = scan.angle_at(90);  // 90th reading\nprintln!(\"Angle at index 90: {:.2} rad\", angle);\n\n// Check if a reading is valid\nif scan.is_range_valid(45) {\n    println!(\"Reading at 45 is valid: {:.2}m\", scan.ranges[45]);\n}\n\n// Get statistics\nlet valid = scan.valid_count();\nlet min_dist = scan.min_range();\nprintln!(\"Valid readings: {}, Min distance: {:?}\", valid, min_dist);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/sensor-messages:79:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 79,
      "lineEnd": 106,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create new IMU message\nlet mut imu = Imu::new();\n\n// Set orientation from Euler angles (roll, pitch, yaw)\nimu.set_orientation_from_euler(0.0, 0.05, 1.57);  // Slight pitch, 90° yaw\n\n// Set angular velocity [x, y, z] in rad/s\nimu.angular_velocity = [0.0, 0.0, 0.5];  // Rotating around Z-axis\n\n// Set linear acceleration [x, y, z] in m/s²\nimu.linear_acceleration = [0.0, 0.0, 9.81];  // Gravity pointing up\n\n// Check data availability\nif imu.has_orientation() {\n    println!(\"Orientation: {:?}\", imu.orientation);\n}\n\n// Get as Vector3 for calculations\nlet angular_vel = imu.angular_velocity_vec();\nlet linear_acc = imu.linear_acceleration_vec();\nprintln!(\"Angular velocity magnitude: {:.2} rad/s\", angular_vel.magnitude());\n\n// Validate data\nassert!(imu.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/sensor-messages:137:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 137,
      "lineEnd": 157,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create odometry message\nlet mut odom = Odometry::new();\n\n// Set coordinate frames\nodom.set_frames(\"odom\", \"base_link\");\n\n// Update with current pose and velocity\nlet pose = Pose2D::new(5.0, 3.0, 0.785);  // x, y, theta\nlet twist = Twist::new_2d(0.5, 0.1);       // linear, angular\nodom.update(pose, twist);\n\n// Access pose and velocity\nprintln!(\"Position: ({:.2}, {:.2})\", odom.pose.x, odom.pose.y);\nprintln!(\"Velocity: {:.2} m/s\", odom.twist.linear[0]);\n\n// Validate\nassert!(odom.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/sensor-messages:184:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 184,
      "lineEnd": 201,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create ultrasonic range reading\nlet ultrasonic = Range::new(Range::ULTRASONIC, 1.5);  // 1.5m reading\n\n// Create infrared range reading\nlet ir = Range::new(Range::INFRARED, 0.3);  // 30cm reading\n\n// Check if reading is valid (within sensor limits)\nif ultrasonic.is_valid() {\n    println!(\"Distance: {:.2}m\", ultrasonic.range);\n}\n\n// Access sensor parameters\nprintln!(\"FOV: {:.2} rad\", ultrasonic.field_of_view);\nprintln!(\"Range: {:.2} - {:.2}m\", ultrasonic.min_range, ultrasonic.max_range);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/sensor-messages:227:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 227,
      "lineEnd": 256,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create GPS fix from coordinates\nlet fix = NavSatFix::from_coordinates(\n    37.7749,    // Latitude (positive = North)\n    -122.4194,  // Longitude (positive = East)\n    10.5        // Altitude in meters\n);\n\n// Check fix status\nif fix.has_fix() {\n    println!(\"GPS Fix acquired!\");\n    println!(\"Position: {:.6}°N, {:.6}°E\", fix.latitude, fix.longitude);\n    println!(\"Altitude: {:.1}m\", fix.altitude);\n    println!(\"Satellites: {}\", fix.satellites_visible);\n}\n\n// Get accuracy estimate\nlet accuracy = fix.horizontal_accuracy();\nprintln!(\"Horizontal accuracy: ±{:.1}m\", accuracy);\n\n// Calculate distance to another position\nlet destination = NavSatFix::from_coordinates(37.8044, -122.2712, 0.0);\nlet distance = fix.distance_to(&destination);\nprintln!(\"Distance to destination: {:.0}m\", distance);\n\n// Validate coordinates\nassert!(fix.is_valid());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/sensor-messages:308:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 308,
      "lineEnd": 335,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create battery state\nlet mut battery = BatteryState::new(12.6, 85.0);  // 12.6V, 85%\n\n// Set additional fields\nbattery.current = -2.5;  // Discharging at 2.5A\nbattery.temperature = 28.0;\nbattery.power_supply_status = BatteryState::STATUS_DISCHARGING;\n\n// Check battery level\nif battery.is_low(20.0) {\n    println!(\"Battery low!\");\n}\nif battery.is_critical() {\n    println!(\"Battery critical (below 10%)!\");\n}\n\n// Estimate remaining time\nif let Some(remaining) = battery.time_remaining() {\n    println!(\"Estimated time remaining: {:.0} seconds\", remaining);\n}\n\nprintln!(\"Voltage: {:.2}V\", battery.voltage);\nprintln!(\"Charge: {:.0}%\", battery.percentage);\nprintln!(\"Temperature: {:.1}°C\", battery.temperature);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/sensor-messages:372:rust",
      "file": "content/docs/rust/api/sensor-messages.mdx",
      "lineStart": 372,
      "lineEnd": 440,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct SensorFusionNode {\n    imu_sub: Hub<Imu>,\n    odom_sub: Hub<Odometry>,\n    gps_sub: Hub<NavSatFix>,\n    fused_pose_pub: Hub<Pose2D>,\n    // Extended Kalman Filter state\n    ekf_state: [f64; 6],  // [x, y, theta, vx, vy, omega]\n}\n\nimpl Node for SensorFusionNode {\n    fn name(&self) -> &'static str { \"SensorFusion\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Process IMU at highest rate\n        if let Some(imu) = self.imu_sub.try_recv(&mut ctx) {\n            if imu.is_valid() {\n                // Use angular velocity for heading prediction\n                let omega = imu.angular_velocity[2];\n                self.predict_state(omega);\n            }\n        }\n\n        // Process odometry\n        if let Some(odom) = self.odom_sub.try_recv(&mut ctx) {\n            if odom.is_valid() {\n                // Update with wheel odometry\n                self.update_odometry(&odom);\n            }\n        }\n\n        // Process GPS (lower rate, absolute position)\n        if let Some(gps) = self.gps_sub.try_recv(&mut ctx) {\n            if gps.has_fix() && gps.is_valid() {\n                // Update with GPS (when available)\n                self.update_gps(&gps);\n            }\n        }\n\n        // Publish fused pose\n        let pose = Pose2D::new(\n            self.ekf_state[0],\n            self.ekf_state[1],\n            self.ekf_state[2]\n        );\n        self.fused_pose_pub.send(pose, &mut ctx).ok();\n    }\n}\n\nimpl SensorFusionNode {\n    fn predict_state(&mut self, omega: f64) {\n        // EKF prediction step using IMU\n        let dt = 0.01;  // 100Hz\n        self.ekf_state[2] += omega * dt;\n    }\n\n    fn update_odometry(&mut self, odom: &Odometry) {\n        // EKF update with odometry measurement\n        // ... implementation\n    }\n\n    fn update_gps(&mut self, gps: &NavSatFix) {\n        // EKF update with GPS measurement\n        // ... implementation\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-messages:15:rust",
      "file": "content/docs/rust/api/tensor-messages.mdx",
      "lineStart": 15,
      "lineEnd": 26,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides tensor::{HorusTensor, TensorDtype, TensorDevice};\n\n// Send tensor descriptor through Hub\nlet hub = Hub::<HorusTensor>::new(\"camera.frames\")?;\n\nif let Some(tensor) = hub.recv(ctx) {\n    println!(\"Shape: {:?}\", tensor.shape());\n    println!(\"Dtype: {:?}\", tensor.dtype);\n    println!(\"Device: {}\", tensor.device);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-messages:40:rust",
      "file": "content/docs/rust/api/tensor-messages.mdx",
      "lineStart": 40,
      "lineEnd": 44,
      "language": "rust",
      "code": "TensorDevice::Cpu     // Shared memory\nTensorDevice::Cuda0   // GPU 0\nTensorDevice::Cuda1   // GPU 1",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-messages:48:rust",
      "file": "content/docs/rust/api/tensor-messages.mdx",
      "lineStart": 48,
      "lineEnd": 59,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {TensorPool, TensorPoolConfig, TensorDtype, TensorDevice}\n\nlet pool = TensorPool::new(1, TensorPoolConfig::default())?;\nlet tensor = pool.alloc(&[1080, 1920, 3], TensorDtype::U8, TensorDevice::Cpu)?;\n\n// Write data\npool.data_slice_mut(&tensor)[0] = 255;\n\n// Share via Hub\nhub.send(tensor, &mut ctx)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-messages:63:python",
      "file": "content/docs/rust/api/tensor-messages.mdx",
      "lineStart": 63,
      "lineEnd": 67,
      "language": "python",
      "code": "hub = PyHub(\"camera.frames\")\ntensor = hub.recv_tensor(node)\narr = np.asarray(tensor)  # Zero-copy via __array_interface__",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/tensor-pool:24:rust",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 24,
      "lineEnd": 37,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default config (256 slots, 1GB max)\nlet pool = TensorPool::new(1, TensorPoolConfig::default())?;\n\n// Or customize\nlet config = TensorPoolConfig {\n    max_slots: 512,\n    max_total_size: 2 * 1024 * 1024 * 1024, // 2GB\n    ..Default::default()\n};\nlet pool = TensorPool::new(1, config)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-pool:41:rust",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 41,
      "lineEnd": 53,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Allocate a 1080p RGB image\nlet handle = TensorHandle::alloc(\n    pool.clone(),\n    &[1080, 1920, 3],\n    TensorDtype::U8,\n)?;\n\n// Access data\nlet data: &mut [u8] = handle.as_slice_mut();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-pool:74:toml",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 74,
      "lineEnd": 77,
      "language": "toml",
      "code": "[dependencies]\nhorus_core = { version = \"0.1\", features = [\"cuda\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/tensor-pool:81:rust",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 81,
      "lineEnd": 91,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nif cuda_available() {\n    // Create pool on device 0\n    let pool = CudaTensorPool::new(1, 0, CudaTensorPoolConfig::default())?;\n\n    // Or open existing pool (for consumer processes)\n    let pool = CudaTensorPool::open(1, 0)?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-pool:95:rust",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 95,
      "lineEnd": 109,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Allocate GPU tensor\nlet tensor = pool.alloc(&[1080, 1920, 3], TensorDtype::F32)?;\n\n// Get device pointer for CUDA kernels\nlet gpu_ptr = pool.device_ptr(&tensor);\n\n// Get IPC handle for cross-process sharing (64 bytes)\nlet ipc_handle = tensor.ipc_handle_bytes();\n\n// Release when done\npool.release(&tensor)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-pool:113:rust",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 113,
      "lineEnd": 126,
      "language": "rust",
      "code": "// Process A (producer): Create tensor and get IPC handle\nlet tensor = pool.alloc(&[1080, 1920, 3], TensorDtype::F32)?;\nlet ipc_handle = tensor.ipc_handle_bytes(); // 64 bytes\n// Send ipc_handle to Process B via Hub/Link...\n\n// Process B (consumer): Import GPU memory\nlet pool = CudaTensorPool::open(1, 0)?;\nlet (gpu_ptr, tensor) = pool.import_ipc(ipc_handle, &[1080, 1920, 3], TensorDtype::F32)?;\n// gpu_ptr points to SAME GPU memory - zero copy!\n\n// When done\npool.close_ipc(gpu_ptr)?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-pool:132:rust",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 132,
      "lineEnd": 146,
      "language": "rust",
      "code": "pub struct HorusTensor {\n    pub pool_id: u32,           // Which pool this tensor belongs to\n    pub slot_id: u32,           // Slot index within pool\n    pub generation: u32,        // ABA problem prevention\n    pub device_id: u8,          // 0 = CPU, 1+ = GPU device\n    pub dtype: TensorDtype,     // Data type\n    pub ndim: u8,               // Number of dimensions\n    pub shape: [u64; 8],        // Shape (up to 8 dimensions)\n    pub strides: [u64; 8],      // Strides for each dimension\n    pub numel: u64,             // Total number of elements\n    pub size: u64,              // Size in bytes\n    pub cuda_ipc_handle: [u8; 64], // CUDA IPC handle (GPU only)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/tensor-pool:150:python",
      "file": "content/docs/rust/api/tensor-pool.mdx",
      "lineStart": 150,
      "lineEnd": 172,
      "language": "python",
      "code": "import horus\n\n# Check CUDA availability\nif horus.cuda_is_available():\n    print(f\"CUDA devices: {horus.cuda_device_count()}\")\n\n# Create tensor pool\npool = horus.TensorPool(pool_id=1, size_mb=1024)\n\n# Allocate CPU tensor\ntensor = pool.alloc(shape=(1080, 1920, 3), dtype=\"float32\")\n\n# Transfer to GPU\ngpu_tensor = tensor.cuda(\"cuda:0\")\n\n# Get IPC handle for sharing\nipc_handle = gpu_tensor.get_cuda_ipc_handle()\n\n# Zero-copy PyTorch integration\nimport torch\ntorch_tensor = torch.as_tensor(gpu_tensor)  # Uses __cuda_array_interface__",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/timing-messages:17:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 17,
      "lineEnd": 40,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create time sync message for a master clock\nlet mut sync = TimeSync::new(\"master_clock\");\n\n// Set the message as received\nsync.update_receive_time();\n\n// Check synchronization quality\nif sync.is_valid() {\n    println!(\"Clock offset: {} ns\", sync.clock_offset);\n    println!(\"Network delay: {} ns\", sync.network_delay);\n    println!(\"Sync quality: {:?}\", sync.sync_quality);\n    println!(\"Confidence: {:.1}%\", sync.confidence * 100.0);\n}\n\n// Get synchronized time (local time + offset)\nlet synchronized = sync.synchronized_time();\nprintln!(\"Synchronized time: {} ns\", synchronized);\n\n// Get master clock identifier\nprintln!(\"Master: {}\", sync.master_id_str());",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/timing-messages:73:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 73,
      "lineEnd": 82,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet quality = SyncQuality::Good;\n\n// Quality levels are comparable\nif quality >= SyncQuality::Fair {\n    println!(\"Acceptable synchronization for most operations\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/timing-messages:99:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 99,
      "lineEnd": 137,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a one-time event\nlet start_time = 2_000_000_000; // 2 seconds from epoch\nlet event = ScheduledEvent::new(1, EventType::TaskStart, start_time)\n    .with_executor(\"robot_1\");\n\n// Create a repeating event (every 500ms)\nlet mut periodic = ScheduledEvent::repeating(\n    2,\n    EventType::DataCollection,\n    start_time,\n    500_000_000,  // 500ms interval\n);\nperiodic.max_repeats = 10;  // Run 10 times\n\n// Check if event is due\nlet current_time = 2_000_000_500;\nif event.is_due(current_time) {\n    println!(\"Event {} is ready to execute!\", event.event_id);\n}\n\n// Check if event was missed\nif event.is_missed(current_time) {\n    println!(\"Event {} missed its execution window\", event.event_id);\n}\n\n// Calculate time until execution\nif let Some(time_left) = event.time_until_execution(1_500_000_000) {\n    println!(\"Time until event: {} ns\", time_left);\n}\n\n// Update event status after execution\nlet mut executing_event = event;\nexecuting_event.update_status(EventStatus::Executing);\n// ... perform task ...\nexecuting_event.update_status(EventStatus::Completed);",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/timing-messages:214:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 214,
      "lineEnd": 247,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create a new timeline\nlet start_time = 1_000_000_000;\nlet mut timeline = Timeline::new(\"mission_timeline\", start_time);\n\n// Add events (they'll be sorted by time automatically)\nlet event1 = ScheduledEvent::new(1, EventType::TaskStart, 1_100_000_000);\nlet event2 = ScheduledEvent::new(2, EventType::DataCollection, 1_050_000_000);\nlet event3 = ScheduledEvent::new(3, EventType::TaskStop, 1_200_000_000);\n\ntimeline.add_event(event1).unwrap();\ntimeline.add_event(event2).unwrap();\ntimeline.add_event(event3).unwrap();\n\n// Start timeline execution\ntimeline.start();\nassert_eq!(timeline.status, TimelineStatus::Running);\n\n// Get events due for execution\nlet due_events = timeline.get_due_events(1_050_000_000);\nfor idx in due_events {\n    println!(\"Event {} is due\", timeline.events[idx].event_id);\n}\n\n// Update timeline with current time\ntimeline.update(1_100_000_000);\n\n// Control timeline execution\ntimeline.pause();\ntimeline.resume();\ntimeline.stop();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/timing-messages:297:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 297,
      "lineEnd": 321,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create clock statistics tracker\nlet mut stats = ClockStats::new(\"master_clock\");\n\n// Update with sync measurements\nstats.update_sync(-5000, SyncQuality::Good);  // -5μs offset\nstats.update_sync(-3000, SyncQuality::Good);  // -3μs offset\n\n// Check statistics\nprintln!(\"Current offset: {} ns\", stats.current_offset);\nprintln!(\"Average offset: {} ns\", stats.average_offset);\nprintln!(\"Sync count: {}\", stats.sync_count);\nprintln!(\"Success rate: {:.1}%\", stats.sync_success_rate() * 100.0);\n\n// Check health status\nif stats.is_sync_healthy() {\n    println!(\"Synchronization is healthy\");\n}\n\n// Get estimated accuracy\nlet accuracy = stats.estimated_accuracy();\nprintln!(\"Estimated accuracy: {} ns\", accuracy);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/timing-messages:352:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 352,
      "lineEnd": 422,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct SynchronizedRobot {\n    sync_sub: Hub<TimeSync>,\n    event_sub: Hub<ScheduledEvent>,\n    clock_stats_pub: Hub<ClockStats>,\n    stats: ClockStats,\n    timeline: Timeline,\n}\n\nimpl Node for SynchronizedRobot {\n    fn name(&self) -> &'static str { \"SynchronizedRobot\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Process time sync messages\n        if let Some(mut sync) = self.sync_sub.try_recv(&mut ctx) {\n            sync.update_receive_time();\n\n            if sync.is_valid() {\n                // Update clock statistics\n                self.stats.update_sync(sync.clock_offset, sync.sync_quality);\n\n                // Update timeline with synchronized time\n                let synced_time = sync.synchronized_time();\n                self.timeline.update(synced_time);\n\n                // Execute due events\n                for idx in self.timeline.get_due_events(synced_time) {\n                    self.execute_event(idx, &mut ctx);\n                }\n            }\n        }\n\n        // Process new scheduled events\n        if let Some(event) = self.event_sub.try_recv(&mut ctx) {\n            if let Err(e) = self.timeline.add_event(event) {\n                log::warn!(\"Failed to add event: {}\", e);\n            }\n        }\n\n        // Publish clock stats periodically\n        self.clock_stats_pub.send(self.stats, &mut ctx).ok();\n    }\n}\n\nimpl SynchronizedRobot {\n    fn execute_event(&mut self, idx: usize, ctx: &mut Option<&mut NodeInfo>) {\n        let event = &mut self.timeline.events[idx];\n        event.update_status(EventStatus::Executing);\n\n        match event.event_type {\n            EventType::TaskStart => {\n                log::info!(\"Starting task {}\", event.event_id);\n                // ... start task logic ...\n            }\n            EventType::DataCollection => {\n                log::info!(\"Collecting data\");\n                // ... data collection logic ...\n            }\n            EventType::SafetyCheck => {\n                log::info!(\"Performing safety check\");\n                // ... safety check logic ...\n            }\n            _ => {}\n        }\n\n        event.update_status(EventStatus::Completed);\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/api/timing-messages:426:rust",
      "file": "content/docs/rust/api/timing-messages.mdx",
      "lineStart": 426,
      "lineEnd": 455,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n/// Coordinate multiple robots in a formation with synchronized timing\nfn create_formation_timeline(robots: &[&str], start_time: u64) -> Timeline {\n    let mut timeline = Timeline::new(\"formation_1\", start_time);\n\n    // All robots start at the same synchronized time\n    for (i, robot) in robots.iter().enumerate() {\n        let event = ScheduledEvent::new(\n            i as u32,\n            EventType::FormationUpdate,\n            start_time,\n        ).with_executor(robot);\n\n        timeline.add_event(event).unwrap();\n    }\n\n    // Add periodic formation checks\n    let check_event = ScheduledEvent::repeating(\n        100,\n        EventType::SafetyCheck,\n        start_time + 1_000_000_000,  // 1 second after start\n        500_000_000,                  // Every 500ms\n    );\n    timeline.add_event(check_event).unwrap();\n\n    timeline\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:15:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 15,
      "lineEnd": 38,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::{Image, ImageEncoding};\n\n// Create RGB image\nlet pixels = vec![255, 0, 0, 0, 255, 0, 0, 0, 255]; // 3 RGB pixels\nlet image = Image::new(3, 1, ImageEncoding::Rgb8, pixels)\n    .with_frame_id(\"camera_front\");\n\n// Validate image\nif image.is_valid() {\n    println!(\"Image: {}x{}, {:?}\", image.width, image.height, image.encoding);\n    println!(\"Data size: {} bytes\", image.data.len());\n}\n\n// Access individual pixel\nif let Some(pixel) = image.get_pixel(0, 0) {\n    println!(\"Pixel[0,0]: R={}, G={}, B={}\", pixel[0], pixel[1], pixel[2]);\n}\n\n// Create region of interest (crop)\nif let Some(roi_image) = image.roi(0, 0, 2, 1) {\n    println!(\"ROI: {}x{}\", roi_image.width, roi_image.height);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:72:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 72,
      "lineEnd": 86,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::CompressedImage;\n\n// Create compressed image from JPEG data\nlet jpeg_data = std::fs::read(\"image.jpg\").unwrap();\nlet compressed = CompressedImage::new(\"jpeg\", jpeg_data);\n\nprintln!(\"Format: {}\", compressed.format_str());\nprintln!(\"Compressed size: {} bytes\", compressed.data.len());\n\n// Optional: set original dimensions if known\nlet mut img = compressed;\nimg.width = 640;\nimg.height = 480;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:111:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 111,
      "lineEnd": 137,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::CameraInfo;\n\n// Create camera info with intrinsics\nlet camera = CameraInfo::new(\n    640, 480,   // width, height\n    525.0, 525.0,  // fx, fy\n    320.0, 240.0   // cx, cy (principal point)\n).with_distortion_model(\"plumb_bob\");\n\n// Access intrinsics\nlet (fx, fy) = camera.focal_lengths();\nlet (cx, cy) = camera.principal_point();\n\nprintln!(\"Focal length: ({:.1}, {:.1})\", fx, fy);\nprintln!(\"Principal point: ({:.1}, {:.1})\", cx, cy);\n\n// Set distortion coefficients\nlet mut camera = camera;\ncamera.distortion_coefficients = [\n    -0.25,  // k1\n    0.12,   // k2\n    0.001,  // p1\n    -0.001, // p2\n    0.0, 0.0, 0.0, 0.0  // k3-k6\n];",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:140:text",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 140,
      "lineEnd": 144,
      "language": "text",
      "code": "[fx,  0,  cx]\n[ 0, fy,  cy]\n[ 0,  0,   1]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/vision-messages:147:text",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 147,
      "lineEnd": 151,
      "language": "text",
      "code": "[fx',  0, cx', Tx]\n[ 0,  fy', cy', Ty]\n[ 0,   0,   1,  0]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/api/vision-messages:171:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 171,
      "lineEnd": 188,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::RegionOfInterest;\n\n// Create ROI\nlet roi = RegionOfInterest::new(100, 50, 200, 150);\n\n// Check if point is inside ROI\nif roi.contains(150, 100) {\n    println!(\"Point is inside ROI\");\n}\n\n// Get area\nprintln!(\"ROI area: {} pixels\", roi.area());\n\n// Access properties\nprintln!(\"ROI: ({}, {}) -> {}x{}\",\n    roi.x_offset, roi.y_offset, roi.width, roi.height);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:204:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 204,
      "lineEnd": 215,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::{Detection, RegionOfInterest};\n\n// Create detection\nlet bbox = RegionOfInterest::new(100, 50, 200, 300);\nlet mut detection = Detection::new(\"person\", 0.95, bbox);\ndetection.track_id = 42;  // For multi-object tracking\n\nprintln!(\"Detected: {} ({:.1}% confidence)\",\n    detection.class_str(),\n    detection.confidence * 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:232:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 232,
      "lineEnd": 258,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::{DetectionArray, Detection, RegionOfInterest};\n\nlet mut detections = DetectionArray::new();\ndetections.image_width = 640;\ndetections.image_height = 480;\n\n// Add detections\nlet person = Detection::new(\"person\", 0.95, RegionOfInterest::new(100, 50, 200, 300));\nlet car = Detection::new(\"car\", 0.88, RegionOfInterest::new(400, 200, 150, 100));\n\ndetections.add_detection(person)?;\ndetections.add_detection(car)?;\n\nprintln!(\"Found {} objects\", detections.count);\n\n// Get valid detections\nfor detection in detections.get_detections() {\n    println!(\"  - {} ({:.1}%)\",\n        detection.class_str(),\n        detection.confidence * 100.0);\n}\n\n// Filter by confidence threshold\nlet high_conf = detections.filter_by_confidence(0.9);\nprintln!(\"High confidence: {} objects\", high_conf.len());",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:275:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 275,
      "lineEnd": 298,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides vision::{StereoInfo, CameraInfo};\n\n// Create stereo configuration\nlet left = CameraInfo::new(640, 480, 525.0, 525.0, 320.0, 240.0);\nlet right = CameraInfo::new(640, 480, 525.0, 525.0, 320.0, 240.0);\n\nlet stereo = StereoInfo {\n    left_camera: left,\n    right_camera: right,\n    baseline: 0.12,  // 12cm between cameras\n    depth_scale: 1.0,\n};\n\n// Calculate depth from disparity\nlet disparity = 64.0;  // pixels\nlet depth = stereo.depth_from_disparity(disparity);\nprintln!(\"Disparity {} -> depth {:.2}m\", disparity, depth);\n\n// Calculate disparity from depth\nlet depth = 2.0;  // meters\nlet disparity = stereo.disparity_from_depth(depth);\nprintln!(\"Depth {}m -> disparity {:.1}px\", depth, disparity);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/api/vision-messages:311:rust",
      "file": "content/docs/rust/api/vision-messages.mdx",
      "lineStart": 311,
      "lineEnd": 364,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides vision::{\n    Image, ImageEncoding, CameraInfo, DetectionArray, Detection, RegionOfInterest\n};\n\nstruct VisionNode {\n    image_sub: Hub<Image>,\n    camera_info_sub: Hub<CameraInfo>,\n    detection_pub: Hub<DetectionArray>,\n    camera_info: Option<CameraInfo>,\n}\n\nimpl Node for VisionNode {\n    fn name(&self) -> &'static str { \"VisionNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update camera calibration\n        if let Some(info) = self.camera_info_sub.try_recv(&mut ctx) {\n            self.camera_info = Some(info);\n        }\n\n        // Process images\n        if let Some(image) = self.image_sub.recv(&mut ctx) {\n            if !image.is_valid() {\n                return;\n            }\n\n            // Run detection (placeholder)\n            let detections = self.detect_objects(&image);\n\n            // Publish results\n            let mut detection_msg = DetectionArray::new();\n            detection_msg.image_width = image.width;\n            detection_msg.image_height = image.height;\n            detection_msg.frame_id = image.frame_id;\n\n            for detection in detections {\n                detection_msg.add_detection(detection).ok();\n            }\n\n            self.detection_pub.send(detection_msg, &mut ctx).ok();\n        }\n    }\n}\n\nimpl VisionNode {\n    fn detect_objects(&self, image: &Image) -> Vec<Detection> {\n        // Object detection implementation\n        // (e.g., using ML models)\n        vec![]\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:21:rust",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 21,
      "lineEnd": 133,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum RobotState {\n    Idle,\n    Moving,\n    ObstacleDetected,\n    Rotating,\n    Escaped,\n}\n\nstruct StateMachineNode {\n    state: RobotState,\n    obstacle_sub: Hub<bool>,\n    cmd_pub: Hub<CmdVel>,\n    rotation_counter: u32,\n}\n\nimpl StateMachineNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            state: RobotState::Idle,\n            obstacle_sub: Hub::new(\"obstacle_detected\")?,\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            rotation_counter: 0,\n        })\n    }\n}\n\nimpl Node for StateMachineNode {\n    fn name(&self) -> &'static str { \"StateMachineNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"State machine initialized - starting in IDLE state\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check for obstacles\n        let obstacle = self.obstacle_sub.recv(&mut ctx).unwrap_or(false);\n\n        // Store previous state for logging\n        let prev_state = self.state;\n\n        // State machine logic\n        self.state = match self.state {\n            RobotState::Idle => {\n                if !obstacle {\n                    RobotState::Moving\n                } else {\n                    RobotState::Idle\n                }\n            }\n\n            RobotState::Moving => {\n                if obstacle {\n                    self.cmd_pub.send(CmdVel::zero(), &mut ctx).ok();  // Stop\n                    RobotState::ObstacleDetected\n                } else {\n                    self.cmd_pub.send(CmdVel::new(1.0, 0.0), &mut ctx).ok();  // Forward\n                    RobotState::Moving\n                }\n            }\n\n            RobotState::ObstacleDetected => {\n                self.rotation_counter = 0;\n                RobotState::Rotating\n            }\n\n            RobotState::Rotating => {\n                self.cmd_pub.send(CmdVel::new(0.0, 0.5), &mut ctx).ok();  // Rotate\n                self.rotation_counter += 1;\n\n                if self.rotation_counter > 50 {\n                    RobotState::Escaped\n                } else {\n                    RobotState::Rotating\n                }\n            }\n\n            RobotState::Escaped => {\n                RobotState::Moving  // Resume moving\n            }\n        };\n\n        // Log state transitions\n        if self.state != prev_state {\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\n                    \"State transition: {:?} -> {:?}\",\n                    prev_state, self.state\n                ));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Ensure robot is stopped\n        self.cmd_pub.send(CmdVel::zero(), &mut None).ok();\n        ctx.log_info(\"State machine shutdown\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(StateMachineNode::new()?), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:136:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 136,
      "lineEnd": 138,
      "language": "bash",
      "code": "horus run state_machine.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:154:rust",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 154,
      "lineEnd": 366,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides {CmdVel, BatteryState};\n\n// CRITICAL PRIORITY: Emergency stop\nstruct EmergencyStopNode {\n    battery_sub: Hub<BatteryState>,\n    lidar_sub: Hub<f32>,  // Min obstacle distance\n    estop_pub: Hub<bool>,\n    estop_active: bool,\n}\n\nimpl EmergencyStopNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            battery_sub: Hub::new(\"battery_state\")?,\n            lidar_sub: Hub::new(\"min_distance\")?,\n            estop_pub: Hub::new(\"emergency_stop\")?,\n            estop_active: false,\n        })\n    }\n}\n\nimpl Node for EmergencyStopNode {\n    fn name(&self) -> &'static str { \"EmergencyStop\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\" Emergency stop system online - CRITICAL priority\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let mut should_stop = false;\n\n        // Check battery\n        if let Some(battery) = self.battery_sub.recv(&mut ctx) {\n            if battery.is_critical() {  // Below 10%\n                should_stop = true;\n                if let Some(ref mut c) = ctx {\n                    c.log_error(&format!(\n                        \" CRITICAL: Battery at {:.0}% - EMERGENCY STOP!\",\n                        battery.percentage\n                    ));\n                }\n            }\n        }\n\n        // Check obstacle distance\n        if let Some(min_dist) = self.lidar_sub.recv(&mut ctx) {\n            if min_dist < 0.2 {  // 20cm\n                should_stop = true;\n                if let Some(ref mut c) = ctx {\n                    c.log_error(&format!(\n                        \" CRITICAL: Obstacle at {:.2}m - EMERGENCY STOP!\",\n                        min_dist\n                    ));\n                }\n            }\n        }\n\n        // Publish estop state\n        if should_stop != self.estop_active {\n            self.estop_pub.send(should_stop, &mut ctx).ok();\n            self.estop_active = should_stop;\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Always activate estop on shutdown\n        self.estop_pub.send(true, &mut None).ok();\n        ctx.log_warning(\"Emergency stop system offline\");\n        Ok(())\n    }\n}\n\n// HIGH PRIORITY: Motor controller\nstruct MotorController {\n    estop_sub: Hub<bool>,\n    cmd_sub: Hub<CmdVel>,\n    motor_pub: Hub<CmdVel>,\n    estop_active: bool,\n}\n\nimpl MotorController {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            estop_sub: Hub::new(\"emergency_stop\")?,\n            cmd_sub: Hub::new(\"cmd_vel_request\")?,\n            motor_pub: Hub::new(\"cmd_vel_actual\")?,\n            estop_active: false,\n        })\n    }\n}\n\nimpl Node for MotorController {\n    fn name(&self) -> &'static str { \"MotorController\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Motor controller online - HIGH priority\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Check emergency stop FIRST\n        if let Some(estop) = self.estop_sub.recv(&mut ctx) {\n            if estop != self.estop_active {\n                self.estop_active = estop;\n                if let Some(ctx) = ctx {\n                    if estop {\n                        ctx.log_warning(\"Motors DISABLED - emergency stop active\");\n                    } else {\n                        ctx.log_info(\"Motors ENABLED - emergency stop cleared\");\n                    }\n                }\n            }\n        }\n\n        // Don't move if estop active\n        if self.estop_active {\n            self.motor_pub.send(CmdVel::zero(), &mut ctx).ok();\n            return;\n        }\n\n        // Process normal commands\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            self.motor_pub.send(cmd, &mut ctx).ok();\n\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"Motors: linear={:.2}, angular={:.2}\",\n                    cmd.linear, cmd.angular\n                ));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Stop motors\n        self.motor_pub.send(CmdVel::zero(), &mut None).ok();\n        ctx.log_info(\"Motor controller stopped\");\n        Ok(())\n    }\n}\n\n// BACKGROUND PRIORITY: Data logging\nstruct LoggerNode {\n    cmd_sub: Hub<CmdVel>,\n    battery_sub: Hub<BatteryState>,\n}\n\nimpl LoggerNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_sub: Hub::new(\"cmd_vel_actual\")?,\n            battery_sub: Hub::new(\"battery_state\")?,\n        })\n    }\n}\n\nimpl Node for LoggerNode {\n    fn name(&self) -> &'static str { \"Logger\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\" Logger online - BACKGROUND priority\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Log velocity commands\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"LOG: cmd_vel({:.2}, {:.2})\",\n                    cmd.linear, cmd.angular\n                ));\n            }\n        }\n\n        // Log battery state\n        if let Some(battery) = self.battery_sub.recv(&mut ctx) {\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"LOG: battery({:.1}V, {:.0}%)\",\n                    battery.voltage, battery.percentage\n                ));\n            }\n        }\n\n        // In production: write to file, database, etc.\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Logger stopped\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // PRIORITY 0 (Critical): Safety runs FIRST\n    scheduler.add(Box::new(EmergencyStopNode::new()?), 0, Some(true));\n\n    // PRIORITY 1 (High): Control runs SECOND\n    scheduler.add(Box::new(MotorController::new()?), 1, Some(true));\n\n    // PRIORITY 4 (Background): Logging runs LAST\n    scheduler.add(Box::new(LoggerNode::new()?), 4, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:369:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 369,
      "lineEnd": 371,
      "language": "bash",
      "code": "horus run safety_system.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:388:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 388,
      "lineEnd": 392,
      "language": "bash",
      "code": "mkdir multi_node_system\ncd multi_node_system\nmkdir nodes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:397:python",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 397,
      "lineEnd": 420,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport time\nimport random\n\ndef sensor_tick(node):\n    \"\"\"Simulate temperature sensor readings\"\"\"\n    # Generate realistic temperature with noise\n    temperature = 20.0 + random.random() * 10.0\n\n    node.send(\"temperature\", temperature)\n    print(f\"Sensor: {temperature:.1f}°C\")\n\nnode = horus.Node(\n    name=\"SensorNode\",\n    pubs={\"temperature\": float},\n    tick=sensor_tick,\n    rate=2  # 2 Hz\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:425:python",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 425,
      "lineEnd": 454,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\n\ndef controller_tick(node):\n    \"\"\"Control cooling fan based on temperature\"\"\"\n    temp = node.recv(\"temperature\")\n\n    if temp is not None:\n        if temp > 25.0:\n            # Temperature too high - activate fan\n            fan_speed = min(100, int((temp - 20) * 10))\n            node.send(\"fan_control\", fan_speed)\n            print(f\"Controller: Fan at {fan_speed}%\")\n        else:\n            # Temperature OK - fan off\n            node.send(\"fan_control\", 0)\n            print(f\"Controller: Temperature normal, fan off\")\n\nnode = horus.Node(\n    name=\"ControllerNode\",\n    subs={\"temperature\": float},\n    pubs={\"fan_control\": int},\n    tick=controller_tick,\n    rate=2\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:459:python",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 459,
      "lineEnd": 483,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport datetime\n\ndef logger_tick(node):\n    \"\"\"Log system status\"\"\"\n    temp = node.recv(\"temperature\")\n    fan = node.recv(\"fan_control\")\n\n    if temp is not None and fan is not None:\n        timestamp = datetime.datetime.now().strftime(\"%H:%M:%S\")\n        status = \"COOLING\" if fan > 0 else \"NORMAL\"\n        print(f\"Logger [{timestamp}]: {temp:.1f}°C | Fan {fan}% | {status}\")\n\nnode = horus.Node(\n    name=\"LoggerNode\",\n    subs={\"temperature\": float, \"fan_control\": int},\n    tick=logger_tick,\n    rate=1  # 1 Hz\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:487:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 487,
      "lineEnd": 493,
      "language": "bash",
      "code": "# Make scripts executable\nchmod +x nodes/*.py\n\n# Run all nodes as separate processes\nhorus run \"nodes/*.py\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:496:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 496,
      "lineEnd": 517,
      "language": "bash",
      "code": "Executing 3 files concurrently:\n  1. nodes/controller.py (python)\n  2. nodes/logger.py (python)\n  3. nodes/sensor.py (python)\n\nPhase 1: Building all files...\nPhase 2: Starting all processes...\n  Started [controller]\n  Started [logger]\n  Started [sensor]\n\nAll processes running. Press Ctrl+C to stop.\n\n[sensor] Sensor: 23.4°C\n[controller] Controller: Fan at 34%\n[logger] Logger [15:30:45]: 23.4°C | Fan 34% | COOLING\n[sensor] Sensor: 26.8°C\n[controller] Controller: Fan at 68%\n[sensor] Sensor: 21.2°C\n[logger] Logger [15:30:46]: 21.2°C | Fan 12% | COOLING",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:535:rust",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 535,
      "lineEnd": 583,
      "language": "rust",
      "code": "use horus::prelude::*;\n\npub struct TempSensor {\n    temp_pub: Hub<f32>,\n    counter: f32,\n}\n\nimpl TempSensor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            temp_pub: Hub::new(\"temperature\")?,\n            counter: 0.0,\n        })\n    }\n}\n\nimpl Node for TempSensor {\n    fn name(&self) -> &'static str { \"RustTempSensor\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Rust sensor online - high performance mode\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Fast sensor simulation\n        let temp = 20.0 + (self.counter.sin() * 5.0);\n        self.temp_pub.send(temp, &mut ctx).ok();\n\n        if let Some(ref mut c) = ctx {\n            c.log_debug(&format!(\"Rust: {:.2}°C\", temp));\n        }\n\n        self.counter += 0.1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Rust sensor offline\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(TempSensor::new()?), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:588:python",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 588,
      "lineEnd": 614,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\n\ndef controller_tick(node):\n    \"\"\"Python controller receives from Rust sensor\"\"\"\n    temp = node.recv(\"temperature\")\n\n    if temp is not None:\n        status = \"HOT\" if temp > 22.0 else \"NORMAL\"\n        print(f\"Python controller: {temp:.2f}°C - {status}\")\n\n        # Send command back to Rust actuator\n        command = 1.0 if temp > 22.0 else 0.0\n        node.send(\"actuator_cmd\", command)\n\nnode = horus.Node(\n    name=\"PyController\",\n    subs={\"temperature\": float},\n    pubs={\"actuator_cmd\": float},\n    tick=controller_tick,\n    rate=10\n)\n\nif __name__ == \"__main__\":\n    horus.run(node)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:619:rust",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 619,
      "lineEnd": 651,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct Actuator {\n    cmd_sub: Hub<f32>,\n}\n\nimpl Node for Actuator {\n    fn name(&self) -> &'static str { \"RustActuator\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            if let Some(ctx) = ctx {\n                let action = if cmd > 0.5 { \"COOLING\" } else { \"IDLE\" };\n                ctx.log_info(&format!(\"Actuator: {}\", action));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Actuator stopped\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(Actuator {\n        cmd_sub: Hub::new(\"actuator_cmd\")?,\n    }), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:655:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 655,
      "lineEnd": 657,
      "language": "bash",
      "code": "horus run \"nodes/*\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:676:python",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 676,
      "lineEnd": 754,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport time\n\ndef high_freq_sensor(node):\n    \"\"\"100Hz IMU sensor\"\"\"\n    imu = {\n        \"accel_x\": 1.0,\n        \"accel_y\": 0.0,\n        \"accel_z\": 9.8,\n        \"timestamp\": time.time()\n    }\n    node.send(\"imu_data\", imu)\n\ndef control_loop(node):\n    \"\"\"50Hz controller with staleness detection\"\"\"\n    if node.has_msg(\"imu_data\"):\n        # Check message age\n        imu, timestamp = node.get_with_timestamp(\"imu_data\")\n\n        # Skip stale data (older than 100ms)\n        age = time.time() - timestamp\n        if age > 0.1:\n            node.log_warning(f\"Skipping stale IMU data (age: {age*1000:.1f}ms)\")\n            return\n\n        # Process fresh data\n        accel_magnitude = (\n            imu[\"accel_x\"]**2 +\n            imu[\"accel_y\"]**2 +\n            imu[\"accel_z\"]**2\n        ) ** 0.5\n\n        print(f\"Control: IMU magnitude = {accel_magnitude:.2f} m/s²\")\n\n        # Send command\n        cmd = {\"linear\": 1.0, \"angular\": 0.5}\n        node.send(\"cmd_vel\", cmd)\n\ndef logger(node):\n    \"\"\"10Hz logger with latency measurement\"\"\"\n    if node.has_msg(\"cmd_vel\"):\n        msg, timestamp = node.get_with_timestamp(\"cmd_vel\")\n        latency = (time.time() - timestamp) * 1000  # ms\n\n        print(f\"Logger: Command latency = {latency:.1f}ms\")\n\n        # Log to file in production\n        # with open(\"log.txt\", \"a\") as f:\n        #     f.write(f\"{timestamp},{msg},{latency}\\n\")\n\n# Create nodes with different rates\nsensor_node = horus.Node(\n    name=\"HighFreqSensor\",\n    pubs={\"imu_data\": dict},\n    tick=high_freq_sensor,\n    rate=100.0  # 100 Hz\n)\n\ncontrol_node = horus.Node(\n    name=\"Controller\",\n    subs={\"imu_data\": dict},\n    pubs={\"cmd_vel\": dict},\n    tick=control_loop,\n    rate=50.0  # 50 Hz\n)\n\nlogger_node = horus.Node(\n    name=\"Logger\",\n    subs={\"cmd_vel\": dict},\n    tick=logger,\n    rate=10.0  # 10 Hz\n)\n\n# Run all nodes\nif __name__ == \"__main__\":\n    horus.run(sensor_node, control_node, logger_node, duration=5.0)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:757:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 757,
      "lineEnd": 759,
      "language": "bash",
      "code": "horus run advanced_python.py",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:782:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 782,
      "lineEnd": 786,
      "language": "bash",
      "code": "horus run \"nodes/*.rs\"\nhorus run \"nodes/*.py\"\nhorus run \"nodes/*\"  # Mix Rust and Python!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:798:bash",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 798,
      "lineEnd": 800,
      "language": "bash",
      "code": "horus run main.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/advanced-examples:824:python",
      "file": "content/docs/rust/examples/advanced-examples.mdx",
      "lineStart": 824,
      "lineEnd": 863,
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport horus\nimport time\n\ndef test_sensor_controller_integration():\n    \"\"\"Integration test for sensor + controller\"\"\"\n\n    # Mock sensor\n    def mock_sensor(node):\n        node.send(\"temperature\", 30.0)  # Hot!\n\n    # Test controller\n    fan_commands = []\n\n    def test_controller(node):\n        temp = node.recv(\"temperature\")\n        if temp is not None and temp > 25.0:\n            fan_speed = min(100, int((temp - 20) * 10))\n            fan_commands.append(fan_speed)\n            node.send(\"fan_control\", fan_speed)\n\n    # Run test\n    sensor = horus.Node(\"sensor\", pubs={\"temperature\": float}, tick=mock_sensor)\n    controller = horus.Node(\"controller\",\n                           subs={\"temperature\": float},\n                           pubs={\"fan_control\": int},\n                           tick=test_controller)\n\n    horus.run(sensor, controller, duration=0.1)\n\n    # Verify\n    assert len(fan_commands) > 0, \"Controller should have sent fan commands\"\n    assert fan_commands[0] == 100, f\"Expected fan at 100%, got {fan_commands[0]}%\"\n\n    print(\" Test passed!\")\n\nif __name__ == \"__main__\":\n    test_sensor_controller_integration()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:29:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 29,
      "lineEnd": 82,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Define publisher node\nstruct SensorNode {\n    data_pub: Hub<f32>,\n    counter: f32,\n}\n\nimpl SensorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            data_pub: Hub::new(\"sensor_data\")?,\n            counter: 0.0,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str {\n        \"SensorNode\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Simulate sensor reading\n        let reading = self.counter.sin() * 10.0;\n\n        // Publish data\n        self.data_pub.send(reading, &mut ctx).ok();\n        if let Some(ref mut c) = ctx {\n            c.log_debug(&format!(\"Published: {:.2}\", reading));\n        }\n\n        self.counter += 0.1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor shutdown\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:85:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 85,
      "lineEnd": 87,
      "language": "bash",
      "code": "horus run publisher.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:93:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 93,
      "lineEnd": 140,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct ProcessorNode {\n    data_sub: Hub<f32>,\n}\n\nimpl ProcessorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            data_sub: Hub::new(\"sensor_data\")?,\n        })\n    }\n}\n\nimpl Node for ProcessorNode {\n    fn name(&self) -> &'static str {\n        \"ProcessorNode\"\n    }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Processor initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_sub.recv(&mut ctx) {\n            // Process received data\n            let processed = data * 2.0;\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\"Processed: {:.2}\", processed));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Processor shutdown\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(ProcessorNode::new()?), 0, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:146:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 146,
      "lineEnd": 152,
      "language": "bash",
      "code": "# Terminal 1\nhorus run publisher.rs\n\n# Terminal 2 (automatically connects!)\nhorus run subscriber.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:160:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 160,
      "lineEnd": 234,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Publisher\nstruct SensorNode {\n    data_pub: Hub<f32>,\n    counter: f32,\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str { \"SensorNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor online\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let reading = self.counter.sin() * 10.0;\n        self.data_pub.send(reading, &mut ctx).ok();\n        self.counter += 0.1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor offline\");\n        Ok(())\n    }\n}\n\n// Subscriber\nstruct ProcessorNode {\n    data_sub: Hub<f32>,\n}\n\nimpl Node for ProcessorNode {\n    fn name(&self) -> &'static str { \"ProcessorNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Processor online\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(data) = self.data_sub.recv(&mut ctx) {\n            let processed = data * 2.0;\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\"Received: {:.2} -> {:.2}\", data, processed));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Processor offline\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Add both nodes\n    scheduler.add(Box::new(SensorNode {\n        data_pub: Hub::new(\"sensor_data\")?,\n        counter: 0.0,\n    }), 0, Some(true));\n\n    scheduler.add(Box::new(ProcessorNode {\n        data_sub: Hub::new(\"sensor_data\")?,\n    }), 1, Some(true));\n\n    // Run both nodes together\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:237:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 237,
      "lineEnd": 239,
      "language": "bash",
      "code": "horus run pubsub.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:255:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 255,
      "lineEnd": 351,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\n\n// Keyboard input  velocity commands\nstruct TeleopNode {\n    cmd_pub: Hub<CmdVel>,\n}\n\nimpl TeleopNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n        })\n    }\n}\n\nimpl Node for TeleopNode {\n    fn name(&self) -> &'static str { \"TeleopNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Teleop ready - sending movement commands\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Simulate keyboard input (w/a/s/d)\n        // In real code, read from device::Input\n        let cmd = CmdVel::new(1.0, 0.5);  // Forward + turn right\n        self.cmd_pub.send(cmd, &mut ctx).ok();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        // Send stop command on shutdown\n        let stop = CmdVel::zero();\n        self.cmd_pub.send(stop, &mut None).ok();\n        ctx.log_info(\"Teleop stopped\");\n        Ok(())\n    }\n}\n\n// Velocity commands  motor control\nstruct MotorDriverNode {\n    cmd_sub: Hub<CmdVel>,\n}\n\nimpl MotorDriverNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_sub: Hub::new(\"cmd_vel\")?,\n        })\n    }\n}\n\nimpl Node for MotorDriverNode {\n    fn name(&self) -> &'static str { \"MotorDriverNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Motor driver initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            // Convert to differential drive (left/right wheel speeds)\n            let left_speed = cmd.linear - cmd.angular;\n            let right_speed = cmd.linear + cmd.angular;\n\n            // Send to motors\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\n                    \"Motors: L={:.2} m/s, R={:.2} m/s\",\n                    left_speed, right_speed\n                ));\n            }\n\n            // In real code: send to hardware\n            // motor_driver.set_speeds(left_speed, right_speed)?;\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Motors stopped\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    scheduler.add(Box::new(TeleopNode::new()?), 0, Some(true));\n    scheduler.add(Box::new(MotorDriverNode::new()?), 1, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:354:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 354,
      "lineEnd": 356,
      "language": "bash",
      "code": "horus run robot_controller.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:372:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 372,
      "lineEnd": 490,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides {LaserScan, CmdVel};\n\n// Lidar  Scan data\nstruct LidarNode {\n    scan_pub: Hub<LaserScan>,\n    angle: f32,\n}\n\nimpl LidarNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            scan_pub: Hub::new(\"scan\")?,\n            angle: 0.0,\n        })\n    }\n}\n\nimpl Node for LidarNode {\n    fn name(&self) -> &'static str { \"LidarNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Lidar initialized\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let mut scan = LaserScan::new();\n\n        // Simulate lidar readings (sine wave for demo)\n        for i in 0..360 {\n            scan.ranges[i] = 5.0 + (self.angle + i as f32 * 0.01).sin() * 2.0;\n        }\n\n        // Add one close obstacle in front\n        scan.ranges[0] = 0.3;  // 30cm directly ahead!\n\n        self.scan_pub.send(scan, &mut ctx).ok();\n        self.angle += 0.1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Lidar offline\");\n        Ok(())\n    }\n}\n\n// Scan data  Obstacle detection  Stop command\nstruct ObstacleDetector {\n    scan_sub: Hub<LaserScan>,\n    cmd_pub: Hub<CmdVel>,\n    safety_distance: f32,\n}\n\nimpl ObstacleDetector {\n    fn new(safety_distance: f32) -> Result<Self> {\n        Ok(Self {\n            scan_sub: Hub::new(\"scan\")?,\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            safety_distance,\n        })\n    }\n}\n\nimpl Node for ObstacleDetector {\n    fn name(&self) -> &'static str { \"ObstacleDetector\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(&format!(\n            \"Obstacle detector active - safety distance: {:.2}m\",\n            self.safety_distance\n        ));\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            // Find minimum distance\n            if let Some(min_dist) = scan.min_range() {\n                if min_dist < self.safety_distance {\n                    // Emergency stop!\n                    let stop = CmdVel::zero();\n                    self.cmd_pub.send(stop, &mut ctx).ok();\n\n                    if let Some(ref mut c) = ctx {\n                        c.log_warning(&format!(\n                            \"[WARNING] Obstacle detected at {:.2}m - STOPPING!\",\n                            min_dist\n                        ));\n                    }\n                } else {\n                    // Safe to move\n                    if let Some(ref mut c) = ctx {\n                        c.log_debug(&format!(\"Safe - closest obstacle: {:.2}m\", min_dist));\n                    }\n                }\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Obstacle detector offline\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    scheduler.add(Box::new(LidarNode::new()?), 0, Some(true));\n\n    // Obstacle detector runs with HIGH priority (1)\n    scheduler.add(Box::new(ObstacleDetector::new(0.5)?), 1, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:493:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 493,
      "lineEnd": 495,
      "language": "bash",
      "code": "horus run obstacle_detector.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:511:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 511,
      "lineEnd": 663,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct PIDController {\n    setpoint_sub: Hub<f32>,    // Desired position\n    feedback_sub: Hub<f32>,    // Current position\n    output_pub: Hub<f32>,      // Control output\n\n    kp: f32,  // Proportional gain\n    ki: f32,  // Integral gain\n    kd: f32,  // Derivative gain\n\n    integral: f32,\n    last_error: f32,\n}\n\nimpl PIDController {\n    fn new(kp: f32, ki: f32, kd: f32) -> Result<Self> {\n        Ok(Self {\n            setpoint_sub: Hub::new(\"setpoint\")?,\n            feedback_sub: Hub::new(\"feedback\")?,\n            output_pub: Hub::new(\"control_output\")?,\n            kp, ki, kd,\n            integral: 0.0,\n            last_error: 0.0,\n        })\n    }\n}\n\nimpl Node for PIDController {\n    fn name(&self) -> &'static str { \"PIDController\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(&format!(\n            \"PID initialized - Kp: {}, Ki: {}, Kd: {}\",\n            self.kp, self.ki, self.kd\n        ));\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Get setpoint and current position\n        let setpoint = self.setpoint_sub.recv(&mut ctx).unwrap_or(0.0);\n        let feedback = self.feedback_sub.recv(&mut ctx).unwrap_or(0.0);\n\n        // Calculate error\n        let error = setpoint - feedback;\n\n        // Integral term (accumulated error)\n        self.integral += error;\n\n        // Derivative term (rate of change)\n        let derivative = error - self.last_error;\n\n        // PID output\n        let output = self.kp * error\n                   + self.ki * self.integral\n                   + self.kd * derivative;\n\n        // Publish control output\n        self.output_pub.send(output, &mut ctx).ok();\n\n        if let Some(ref mut c) = ctx {\n            c.log_debug(&format!(\n                \"PID: setpoint={:.2}, feedback={:.2}, error={:.2}, output={:.2}\",\n                setpoint, feedback, error, output\n            ));\n        }\n\n        // Update state\n        self.last_error = error;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"PID controller stopped\");\n        Ok(())\n    }\n}\n\n// Simple test system node\nstruct TestSystem {\n    output_sub: Hub<f32>,\n    feedback_pub: Hub<f32>,\n    position: f32,\n}\n\nimpl TestSystem {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            output_sub: Hub::new(\"control_output\")?,\n            feedback_pub: Hub::new(\"feedback\")?,\n            position: 0.0,\n        })\n    }\n}\n\nimpl Node for TestSystem {\n    fn name(&self) -> &'static str { \"TestSystem\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Apply control output to position\n        if let Some(output) = self.output_sub.recv(&mut ctx) {\n            self.position += output * 0.01;  // Simple integration\n        }\n\n        // Publish current position\n        self.feedback_pub.send(self.position, &mut ctx).ok();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Test system stopped\");\n        Ok(())\n    }\n}\n\n// Setpoint generator\nstruct SetpointNode {\n    setpoint_pub: Hub<f32>,\n}\n\nimpl Node for SetpointNode {\n    fn name(&self) -> &'static str { \"SetpointNode\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Target position\n        let setpoint = 10.0;\n        self.setpoint_pub.send(setpoint, &mut ctx).ok();\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Setpoint generator stopped\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Setpoint generator\n    scheduler.add(Box::new(SetpointNode {\n        setpoint_pub: Hub::new(\"setpoint\")?,\n    }), 0, Some(true));\n\n    // Test system (simulates plant)\n    scheduler.add(Box::new(TestSystem::new()?), 1, Some(true));\n\n    // PID controller (Kp=0.5, Ki=0.01, Kd=0.1)\n    scheduler.add(Box::new(PIDController::new(0.5, 0.01, 0.1)?), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:666:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 666,
      "lineEnd": 668,
      "language": "bash",
      "code": "horus run pid_controller.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:685:rust",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 685,
      "lineEnd": 832,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Stage 1: Data acquisition\nstruct SensorNode {\n    raw_pub: Hub<f32>,\n    counter: f32,\n}\n\nimpl SensorNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            raw_pub: Hub::new(\"raw_data\")?,\n            counter: 0.0,\n        })\n    }\n}\n\nimpl Node for SensorNode {\n    fn name(&self) -> &'static str { \"SensorNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Stage 1: Sensor online\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Simulate noisy sensor\n        let raw_data = 50.0 + (self.counter * 0.5).sin() * 20.0;\n        self.raw_pub.send(raw_data, &mut ctx).ok();\n\n        if let Some(ref mut c) = ctx {\n            c.log_debug(&format!(\"Raw: {:.2}\", raw_data));\n        }\n\n        self.counter += 0.1;\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Sensor offline\");\n        Ok(())\n    }\n}\n\n// Stage 2: Filtering\nstruct FilterNode {\n    raw_sub: Hub<f32>,\n    filtered_pub: Hub<f32>,\n    alpha: f32,  // Low-pass filter coefficient\n    filtered_value: f32,\n}\n\nimpl FilterNode {\n    fn new(alpha: f32) -> Result<Self> {\n        Ok(Self {\n            raw_sub: Hub::new(\"raw_data\")?,\n            filtered_pub: Hub::new(\"filtered_data\")?,\n            alpha,\n            filtered_value: 0.0,\n        })\n    }\n}\n\nimpl Node for FilterNode {\n    fn name(&self) -> &'static str { \"FilterNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Stage 2: Filter online\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(raw) = self.raw_sub.recv(&mut ctx) {\n            // Exponential moving average\n            self.filtered_value = self.alpha * raw\n                                + (1.0 - self.alpha) * self.filtered_value;\n\n            self.filtered_pub.send(self.filtered_value, &mut ctx).ok();\n\n            if let Some(ref mut c) = ctx {\n                c.log_debug(&format!(\"Filtered: {:.2}\", self.filtered_value));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Filter offline\");\n        Ok(())\n    }\n}\n\n// Stage 3: Decision making\nstruct ControllerNode {\n    filtered_sub: Hub<f32>,\n    cmd_pub: Hub<f32>,\n    threshold: f32,\n}\n\nimpl ControllerNode {\n    fn new(threshold: f32) -> Result<Self> {\n        Ok(Self {\n            filtered_sub: Hub::new(\"filtered_data\")?,\n            cmd_pub: Hub::new(\"commands\")?,\n            threshold,\n        })\n    }\n}\n\nimpl Node for ControllerNode {\n    fn name(&self) -> &'static str { \"ControllerNode\" }\n\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Stage 3: Controller online\");\n        Ok(())\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(value) = self.filtered_sub.recv(&mut ctx) {\n            let command = if value > self.threshold { 1.0 } else { 0.0 };\n            self.cmd_pub.send(command, &mut ctx).ok();\n\n            if let Some(ref mut c) = ctx {\n                c.log_info(&format!(\n                    \"Value: {:.2}, Threshold: {:.2}, Command: {:.0}\",\n                    value, self.threshold, command\n                ));\n            }\n        }\n    }\n\n    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        ctx.log_info(\"Controller offline\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Add pipeline stages in priority order\n    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));\n    scheduler.add(Box::new(FilterNode::new(0.2)?), 1, Some(true));\n    scheduler.add(Box::new(ControllerNode::new(50.0)?), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/examples/basic-examples:835:bash",
      "file": "content/docs/rust/examples/basic-examples.mdx",
      "lineStart": 835,
      "lineEnd": 837,
      "language": "bash",
      "code": "horus run pipeline.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:24:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 24,
      "lineEnd": 50,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides AABB\n\nfn main() {\n    // Create two boxes\n    let robot = AABB::new(0.0, 0.0, 2.0, 2.0);\n    let obstacle = AABB::new(1.5, 1.5, 3.0, 3.0);\n\n    // Check collision\n    if robot.intersects(&obstacle) {\n        println!(\"Collision detected!\");\n    }\n\n    // Check if point is inside\n    if robot.contains_point(1.0, 1.0) {\n        println!(\"Point is inside robot bounds\");\n    }\n\n    // Ray intersection\n    let origin = (0.0, 0.0);\n    let direction = (1.0, 0.0);  // Pointing right\n\n    if let Some(distance) = obstacle.ray_intersect(origin, direction) {\n        println!(\"Ray hits obstacle at distance {:.2}\", distance);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:56:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 56,
      "lineEnd": 62,
      "language": "rust",
      "code": "// From min/max coordinates\nlet box1 = AABB::new(min_x: f64, min_y: f64, max_x: f64, max_y: f64);\n\n// From center and size\nlet box2 = AABB::from_center(center_x: f64, center_y: f64, width: f64, height: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:91:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 91,
      "lineEnd": 98,
      "language": "rust",
      "code": "pub struct AABB {\n    pub min_x: f64,\n    pub min_y: f64,\n    pub max_x: f64,\n    pub max_y: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:102:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 102,
      "lineEnd": 145,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides AABB\n\nstruct Robot {\n    position: (f64, f64),\n    size: (f64, f64),\n}\n\nimpl Robot {\n    fn get_bounds(&self) -> AABB {\n        AABB::from_center(\n            self.position.0,\n            self.position.1,\n            self.size.0,\n            self.size.1,\n        )\n    }\n\n    fn would_collide(&self, new_pos: (f64, f64), obstacles: &[AABB]) -> bool {\n        let future_bounds = AABB::from_center(\n            new_pos.0,\n            new_pos.1,\n            self.size.0,\n            self.size.1,\n        );\n\n        obstacles.iter().any(|obs| future_bounds.intersects(obs))\n    }\n\n    fn move_if_safe(&mut self, delta: (f64, f64), obstacles: &[AABB]) -> bool {\n        let new_pos = (\n            self.position.0 + delta.0,\n            self.position.1 + delta.1,\n        );\n\n        if !self.would_collide(new_pos, obstacles) {\n            self.position = new_pos;\n            true\n        } else {\n            false\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:151:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 151,
      "lineEnd": 193,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides AABB\n\nstruct CollisionSystem {\n    objects: Vec<(AABB, usize)>,  // (bounds, object_id)\n}\n\nimpl CollisionSystem {\n    fn new() -> Self {\n        Self { objects: Vec::new() }\n    }\n\n    fn add_object(&mut self, bounds: AABB, id: usize) {\n        self.objects.push((bounds, id));\n    }\n\n    /// Get pairs that might be colliding (broad phase)\n    fn get_potential_collisions(&self) -> Vec<(usize, usize)> {\n        let mut pairs = Vec::new();\n\n        for i in 0..self.objects.len() {\n            for j in (i + 1)..self.objects.len() {\n                if self.objects[i].0.intersects(&self.objects[j].0) {\n                    pairs.push((self.objects[i].1, self.objects[j].1));\n                }\n            }\n        }\n\n        pairs\n    }\n\n    /// Optimized: Only check objects near a point\n    fn get_objects_near(&self, point: (f64, f64), radius: f64) -> Vec<usize> {\n        let query_box = AABB::from_center(point.0, point.1, radius * 2.0, radius * 2.0);\n\n        self.objects\n            .iter()\n            .filter(|(bounds, _)| bounds.intersects(&query_box))\n            .map(|(_, id)| *id)\n            .collect()\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:197:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 197,
      "lineEnd": 236,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides AABB\n\nstruct Sensor {\n    position: (f64, f64),\n    range: f64,\n    field_of_view: AABB,\n}\n\nimpl Sensor {\n    fn new(position: (f64, f64), range: f64) -> Self {\n        // Sensor can see in a box around it\n        let fov = AABB::from_center(position.0, position.1, range * 2.0, range * 2.0);\n\n        Self {\n            position,\n            range,\n            field_of_view: fov,\n        }\n    }\n\n    fn can_potentially_see(&self, target: &AABB) -> bool {\n        self.field_of_view.intersects(target)\n    }\n\n    fn ray_to_target(&self, target_center: (f64, f64)) -> Option<f64> {\n        let dx = target_center.0 - self.position.0;\n        let dy = target_center.1 - self.position.1;\n        let len = (dx * dx + dy * dy).sqrt();\n\n        if len > 0.0 {\n            let direction = (dx / len, dy / len);\n            // Check if ray is blocked\n            Some(len)\n        } else {\n            Some(0.0)\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:240:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 240,
      "lineEnd": 277,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides AABB\n\nstruct SafetyZone {\n    robot_bounds: AABB,\n    warning_zone: AABB,\n    danger_zone: AABB,\n}\n\nimpl SafetyZone {\n    fn new(robot: AABB, warning_margin: f64, danger_margin: f64) -> Self {\n        Self {\n            robot_bounds: robot,\n            warning_zone: robot.expand(warning_margin),\n            danger_zone: robot.expand(danger_margin),\n        }\n    }\n\n    fn check_obstacle(&self, obstacle: &AABB) -> SafetyLevel {\n        if self.robot_bounds.intersects(obstacle) {\n            SafetyLevel::Collision\n        } else if self.danger_zone.intersects(obstacle) {\n            SafetyLevel::Danger\n        } else if self.warning_zone.intersects(obstacle) {\n            SafetyLevel::Warning\n        } else {\n            SafetyLevel::Safe\n        }\n    }\n}\n\nenum SafetyLevel {\n    Safe,\n    Warning,\n    Danger,\n    Collision,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:281:rust",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 281,
      "lineEnd": 312,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides AABB\n\nfn simulate_lidar(\n    origin: (f64, f64),\n    obstacles: &[AABB],\n    num_rays: usize,\n    max_range: f64,\n) -> Vec<f64> {\n    let mut ranges = Vec::with_capacity(num_rays);\n\n    for i in 0..num_rays {\n        let angle = (i as f64 / num_rays as f64) * 2.0 * std::f64::consts::PI;\n        let direction = (angle.cos(), angle.sin());\n\n        // Find closest intersection\n        let mut min_distance = max_range;\n\n        for obstacle in obstacles {\n            if let Some(dist) = obstacle.ray_intersect(origin, direction) {\n                if dist > 0.0 && dist < min_distance {\n                    min_distance = dist;\n                }\n            }\n        }\n\n        ranges.push(min_distance);\n    }\n\n    ranges\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/aabb:335:text",
      "file": "content/docs/rust/library/algorithms/aabb.mdx",
      "lineStart": 335,
      "lineEnd": 346,
      "language": "text",
      "code": "      ┌─────────────────┐\n      │    AABB         │\n      │  ┌─────────┐    │  ← Wasted space\n      │ /           \\   │\n      │/             \\  │\n      │\\             /  │\n      │ \\           /   │\n      │  └─────────┘    │\n      │                 │\n      └─────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:24:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 24,
      "lineEnd": 54,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes AStar\n\nfn main() {\n    // Create 100x100 grid planner\n    let mut astar = AStar::new(100, 100);\n\n    // Set start and goal positions\n    astar.set_start(10, 10);\n    astar.set_goal(90, 90);\n\n    // Add obstacles\n    astar.set_obstacle(50, 50);\n    astar.set_obstacle(51, 50);\n    astar.set_obstacle(52, 50);\n\n    // Find path\n    if let Some(path) = astar.plan() {\n        println!(\"Found path with {} waypoints\", path.len());\n        for (x, y) in &path {\n            println!(\"  ({}, {})\", x, y);\n        }\n\n        // Calculate path length\n        let length = AStar::path_length(&path);\n        println!(\"Path length: {:.2} units\", length);\n    } else {\n        println!(\"No path found!\");\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:60:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 60,
      "lineEnd": 62,
      "language": "rust",
      "code": "let astar = AStar::new(width: usize, height: usize);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:82:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 82,
      "lineEnd": 84,
      "language": "rust",
      "code": "let path: Option<Vec<(i32, i32)>> = astar.plan();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:90:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 90,
      "lineEnd": 92,
      "language": "rust",
      "code": "let length: f64 = AStar::path_length(&path);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:100:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 100,
      "lineEnd": 111,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides Heuristic\n\n// Best for 8-directional movement (default)\nastar.set_heuristic(Heuristic::Euclidean);\n\n// Best for 4-directional movement\nastar.set_heuristic(Heuristic::Manhattan);\n\n// Good balance for grid-based movement\nastar.set_heuristic(Heuristic::Diagonal);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:123:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 123,
      "lineEnd": 132,
      "language": "rust",
      "code": "// Optimal path (slower)\nastar.set_heuristic_weight(1.0);\n\n// Faster search, possibly suboptimal\nastar.set_heuristic_weight(1.5);\n\n// Much faster, less optimal\nastar.set_heuristic_weight(2.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:139:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 139,
      "lineEnd": 145,
      "language": "rust",
      "code": "// Allow diagonal movement (default)\nastar.set_allow_diagonal(true);\n\n// 4-directional only (up, down, left, right)\nastar.set_allow_diagonal(false);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:153:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 153,
      "lineEnd": 172,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {AStar, OccupancyGrid}\n\nfn plan_on_map(grid: &OccupancyGrid, start: (i32, i32), goal: (i32, i32)) -> Option<Vec<(i32, i32)>> {\n    let mut astar = AStar::new(grid.width(), grid.height());\n    astar.set_start(start.0, start.1);\n    astar.set_goal(goal.0, goal.1);\n\n    // Copy obstacles from occupancy grid\n    for y in 0..grid.height() {\n        for x in 0..grid.width() {\n            if grid.is_occupied(x, y) {\n                astar.set_obstacle(x as i32, y as i32);\n            }\n        }\n    }\n\n    astar.plan()\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:178:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 178,
      "lineEnd": 195,
      "language": "rust",
      "code": "fn grid_to_world(\n    path: &[(i32, i32)],\n    resolution: f64,  // meters per cell\n    origin: (f64, f64),  // world origin of grid\n) -> Vec<(f64, f64)> {\n    path.iter()\n        .map(|(gx, gy)| {\n            let wx = origin.0 + (*gx as f64 + 0.5) * resolution;\n            let wy = origin.1 + (*gy as f64 + 0.5) * resolution;\n            (wx, wy)\n        })\n        .collect()\n}\n\n// Example: 10cm resolution, origin at (0, 0)\nlet world_path = grid_to_world(&path, 0.1, (0.0, 0.0));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/astar:212:rust",
      "file": "content/docs/rust/library/algorithms/astar.mdx",
      "lineStart": 212,
      "lineEnd": 246,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes AStar\n\nstruct DynamicPlanner {\n    astar: AStar,\n    current_path: Option<Vec<(i32, i32)>>,\n}\n\nimpl DynamicPlanner {\n    fn new(width: usize, height: usize) -> Self {\n        Self {\n            astar: AStar::new(width, height),\n            current_path: None,\n        }\n    }\n\n    fn set_goal(&mut self, goal: (i32, i32)) {\n        self.astar.set_goal(goal.0, goal.1);\n    }\n\n    fn replan(&mut self, robot_pos: (i32, i32)) -> Option<&Vec<(i32, i32)>> {\n        self.astar.set_start(robot_pos.0, robot_pos.1);\n        self.current_path = self.astar.plan();\n        self.current_path.as_ref()\n    }\n\n    fn add_obstacle(&mut self, x: i32, y: i32) {\n        self.astar.set_obstacle(x, y);\n    }\n\n    fn remove_obstacle(&mut self, x: i32, y: i32) {\n        self.astar.clear_obstacle(x, y);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:24:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 24,
      "lineEnd": 44,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides DifferentialDrive\n\nfn main() {\n    // Create kinematics model\n    // wheel_base: distance between wheels (0.5m)\n    // wheel_radius: wheel radius (0.1m)\n    let dd = DifferentialDrive::new(0.5, 0.1);\n\n    // Inverse kinematics: velocity command → wheel speeds\n    let linear_vel = 0.5;   // m/s forward\n    let angular_vel = 0.2;  // rad/s counter-clockwise\n\n    let (left_speed, right_speed) = dd.inverse_kinematics(linear_vel, angular_vel);\n    println!(\"Wheel speeds: L={:.2} m/s, R={:.2} m/s\", left_speed, right_speed);\n\n    // Forward kinematics: wheel speeds → robot velocity\n    let (v, omega) = dd.forward_kinematics(left_speed, right_speed);\n    println!(\"Robot velocity: v={:.2} m/s, ω={:.2} rad/s\", v, omega);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:50:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 50,
      "lineEnd": 52,
      "language": "rust",
      "code": "let dd = DifferentialDrive::new(wheel_base: f64, wheel_radius: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:61:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 61,
      "lineEnd": 67,
      "language": "rust",
      "code": "// Velocity command → wheel speeds (m/s)\nlet (left, right) = dd.inverse_kinematics(linear: f64, angular: f64);\n\n// Wheel speeds → velocity command\nlet (linear, angular) = dd.forward_kinematics(left_speed: f64, right_speed: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:71:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 71,
      "lineEnd": 77,
      "language": "rust",
      "code": "// Angular velocity (rad/s) → linear velocity (m/s)\nlet linear = dd.wheel_angular_to_linear(angular_speed: f64);\n\n// Linear velocity (m/s) → angular velocity (rad/s)\nlet angular = dd.wheel_linear_to_angular(linear_speed: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:81:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 81,
      "lineEnd": 88,
      "language": "rust",
      "code": "let new_pose = dd.update_odometry(\n    pose: (f64, f64, f64),      // Current (x, y, theta)\n    left_speed: f64,            // Left wheel speed (m/s)\n    right_speed: f64,           // Right wheel speed (m/s)\n    dt: f64,                    // Time step (seconds)\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:96:text",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 96,
      "lineEnd": 99,
      "language": "text",
      "code": "v_left  = v - (ω × L / 2)\nv_right = v + (ω × L / 2)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:110:text",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 110,
      "lineEnd": 113,
      "language": "text",
      "code": "v = (v_left + v_right) / 2\nω = (v_right - v_left) / L",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:119:text",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 119,
      "lineEnd": 123,
      "language": "text",
      "code": "x_new = x + v × cos(θ) × dt\ny_new = y + v × sin(θ) × dt\nθ_new = θ + ω × dt",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:127:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 127,
      "lineEnd": 157,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides DifferentialDrive\n\nstruct MotorController {\n    dd: DifferentialDrive,\n    max_wheel_speed: f64,\n}\n\nimpl MotorController {\n    fn new(wheel_base: f64, wheel_radius: f64, max_speed: f64) -> Self {\n        Self {\n            dd: DifferentialDrive::new(wheel_base, wheel_radius),\n            max_wheel_speed: max_speed,\n        }\n    }\n\n    fn compute_motor_commands(&self, linear: f64, angular: f64) -> (f64, f64) {\n        let (left, right) = self.dd.inverse_kinematics(linear, angular);\n\n        // Clamp to max speed\n        let left = left.clamp(-self.max_wheel_speed, self.max_wheel_speed);\n        let right = right.clamp(-self.max_wheel_speed, self.max_wheel_speed);\n\n        // Convert to motor units (e.g., RPM or PWM)\n        let left_rpm = self.dd.wheel_linear_to_angular(left) * 60.0 / (2.0 * std::f64::consts::PI);\n        let right_rpm = self.dd.wheel_linear_to_angular(right) * 60.0 / (2.0 * std::f64::consts::PI);\n\n        (left_rpm, right_rpm)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:161:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 161,
      "lineEnd": 227,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {DifferentialDrive, Odometry, Pose2D, Twist}\n\nstruct OdometryNode {\n    dd: DifferentialDrive,\n    pose: (f64, f64, f64),\n    last_time: Option<u64>,\n    left_speed: f64,\n    right_speed: f64,\n    odom_pub: Hub<Odometry>,\n}\n\nimpl OdometryNode {\n    fn new(wheel_base: f64, wheel_radius: f64) -> Result<Self> {\n        Ok(Self {\n            dd: DifferentialDrive::new(wheel_base, wheel_radius),\n            pose: (0.0, 0.0, 0.0),\n            last_time: None,\n            left_speed: 0.0,\n            right_speed: 0.0,\n            odom_pub: Hub::new(\"odom\")?,\n        })\n    }\n\n    fn update_wheel_speed(&mut self, left: f64, right: f64) {\n        self.left_speed = left;\n        self.right_speed = right;\n    }\n}\n\nimpl Node for OdometryNode {\n    fn name(&self) -> &'static str { \"Odometry\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let now = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_micros() as u64;\n\n        if let Some(last) = self.last_time {\n            let dt = (now - last) as f64 / 1_000_000.0;\n\n            // Update pose\n            self.pose = self.dd.update_odometry(\n                self.pose,\n                self.left_speed,\n                self.right_speed,\n                dt,\n            );\n\n            // Compute velocity\n            let (linear, angular) = self.dd.forward_kinematics(\n                self.left_speed,\n                self.right_speed,\n            );\n\n            // Publish odometry\n            let mut odom = Odometry::default();\n            odom.pose = Pose2D::new(self.pose.0, self.pose.1, self.pose.2);\n            odom.twist = Twist::new_2d(linear, angular);\n            self.odom_pub.send(odom, &mut ctx).ok();\n        }\n\n        self.last_time = Some(now);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:243:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 243,
      "lineEnd": 247,
      "language": "rust",
      "code": "// Forward at 0.5 m/s\nlet (l, r) = dd.inverse_kinematics(0.5, 0.0);\n// l == r == 0.5",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:251:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 251,
      "lineEnd": 255,
      "language": "rust",
      "code": "// Rotate at 1 rad/s\nlet (l, r) = dd.inverse_kinematics(0.0, 1.0);\n// l = -0.25, r = 0.25 (for wheel_base = 0.5)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:259:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 259,
      "lineEnd": 263,
      "language": "rust",
      "code": "// Move in arc: forward + turn\nlet (l, r) = dd.inverse_kinematics(0.3, 0.5);\n// Different speeds create curved path",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/differential-drive:269:rust",
      "file": "content/docs/rust/library/algorithms/differential-drive.mdx",
      "lineStart": 269,
      "lineEnd": 280,
      "language": "rust",
      "code": "fn max_velocities(dd: &DifferentialDrive, max_wheel_speed: f64) -> (f64, f64) {\n    // Max linear (both wheels forward at max)\n    let max_linear = max_wheel_speed;\n\n    // Max angular (wheels spinning opposite)\n    let wheel_base = 0.5;  // Get from dd configuration\n    let max_angular = 2.0 * max_wheel_speed / wheel_base;\n\n    (max_linear, max_angular)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:37:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 37,
      "lineEnd": 68,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes EKF\n\nfn main() {\n    let mut ekf = EKF::new();\n\n    // Set initial state: stationary at origin\n    ekf.set_state([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);\n\n    // Simulate motion\n    ekf.set_state([0.0, 0.0, 0.0, 1.0, 0.0, 0.0]);  // Moving at 1 m/s in X\n\n    // Control loop\n    let dt = 0.01;  // 100 Hz\n    for i in 0..100 {\n        // Prediction step (time update)\n        ekf.predict(dt);\n\n        // Measurement update (when available)\n        if i % 10 == 0 {\n            // Simulated odometry measurement\n            let (x, y, theta) = ekf.get_pose();\n            ekf.update_odometry([x + 0.01, y, theta]);  // Noisy measurement\n        }\n\n        let (x, y, theta) = ekf.get_pose();\n        let uncertainty = ekf.get_position_uncertainty();\n        println!(\"Pose: ({:.3}, {:.3}, {:.3}), Uncertainty: {:.4}\",\n                 x, y, theta, uncertainty);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:74:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 74,
      "lineEnd": 76,
      "language": "rust",
      "code": "let ekf = EKF::new();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:116:text",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 116,
      "lineEnd": 120,
      "language": "text",
      "code": "x(k+1) = x(k) + vx(k) * dt\ny(k+1) = y(k) + vy(k) * dt\ntheta(k+1) = theta(k) + omega(k) * dt",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:130:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 130,
      "lineEnd": 140,
      "language": "rust",
      "code": "let mut q = [[0.0; 6]; 6];\nq[0][0] = 0.1;   // x position variance\nq[1][1] = 0.1;   // y position variance\nq[2][2] = 0.05;  // theta variance\nq[3][3] = 0.2;   // vx variance (velocity changes)\nq[4][4] = 0.2;   // vy variance\nq[5][5] = 0.1;   // omega variance\n\nekf.set_process_noise(q);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:152:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 152,
      "lineEnd": 159,
      "language": "rust",
      "code": "let mut r = [[0.0; 3]; 3];\nr[0][0] = 0.05;  // x measurement variance\nr[1][1] = 0.05;  // y measurement variance\nr[2][2] = 0.02;  // theta measurement variance\n\nekf.set_odometry_noise(r);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:169:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 169,
      "lineEnd": 241,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes EKF\n\nstruct LocalizationFilter {\n    ekf: EKF,\n    last_odom_update: f64,\n    last_gps_update: f64,\n}\n\nimpl LocalizationFilter {\n    fn new() -> Self {\n        let mut ekf = EKF::new();\n\n        // Set process noise for mobile robot\n        let mut q = [[0.0; 6]; 6];\n        q[0][0] = 0.1;\n        q[1][1] = 0.1;\n        q[2][2] = 0.05;\n        q[3][3] = 0.5;  // Velocity can change quickly\n        q[4][4] = 0.5;\n        q[5][5] = 0.3;\n        ekf.set_process_noise(q);\n\n        // Odometry is relatively accurate\n        let mut r_odom = [[0.0; 3]; 3];\n        r_odom[0][0] = 0.01;\n        r_odom[1][1] = 0.01;\n        r_odom[2][2] = 0.005;\n        ekf.set_odometry_noise(r_odom);\n\n        Self {\n            ekf,\n            last_odom_update: 0.0,\n            last_gps_update: 0.0,\n        }\n    }\n\n    fn predict(&mut self, dt: f64) {\n        self.ekf.predict(dt);\n    }\n\n    fn update_odometry(&mut self, odom: [f64; 3], timestamp: f64) {\n        // Only update if new data\n        if timestamp > self.last_odom_update {\n            self.ekf.update_odometry(odom);\n            self.last_odom_update = timestamp;\n        }\n    }\n\n    fn update_gps(&mut self, x: f64, y: f64, accuracy: f64) {\n        // GPS provides position only, with variable accuracy\n        // Temporarily increase measurement noise based on accuracy\n        let mut r = [[0.0; 3]; 3];\n        r[0][0] = accuracy * accuracy;\n        r[1][1] = accuracy * accuracy;\n        r[2][2] = 1.0;  // GPS doesn't provide heading, ignore\n\n        self.ekf.set_odometry_noise(r);\n\n        // Get current heading from state\n        let (_, _, theta) = self.ekf.get_pose();\n        self.ekf.update_odometry([x, y, theta]);\n    }\n\n    fn get_pose(&self) -> (f64, f64, f64) {\n        self.ekf.get_pose()\n    }\n\n    fn get_uncertainty(&self) -> f64 {\n        self.ekf.get_position_uncertainty()\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:245:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 245,
      "lineEnd": 303,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Includes EKF\nuse horus::prelude::*; // Provides {Odometry, Pose2D};\n\nstruct LocalizationNode {\n    ekf: EKF,\n    odom_sub: Hub<Odometry>,\n    pose_pub: Hub<Pose2D>,\n    last_time: Option<u64>,\n}\n\nimpl LocalizationNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            ekf: EKF::new(),\n            odom_sub: Hub::new(\"odom\")?,\n            pose_pub: Hub::new(\"pose\")?,\n            last_time: None,\n        })\n    }\n}\n\nimpl Node for LocalizationNode {\n    fn name(&self) -> &'static str { \"Localization\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Calculate dt\n        let current_time = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_micros() as u64;\n\n        let dt = if let Some(last) = self.last_time {\n            (current_time - last) as f64 / 1_000_000.0\n        } else {\n            0.01\n        };\n        self.last_time = Some(current_time);\n\n        // Prediction step every tick\n        self.ekf.predict(dt);\n\n        // Update step when odometry available\n        if let Some(odom) = self.odom_sub.recv(&mut ctx) {\n            self.ekf.update_odometry([\n                odom.pose.x,\n                odom.pose.y,\n                odom.pose.theta,\n            ]);\n        }\n\n        // Publish filtered pose\n        let (x, y, theta) = self.ekf.get_pose();\n        let pose = Pose2D::new(x, y, theta);\n        self.pose_pub.send(pose, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/ekf:309:rust",
      "file": "content/docs/rust/library/algorithms/ekf.mdx",
      "lineStart": 309,
      "lineEnd": 320,
      "language": "rust",
      "code": "let mut ekf = EKF::new();\n\nprintln!(\"Initial uncertainty: {:.4}\", ekf.get_position_uncertainty());\n\n// Predict without measurements\nfor i in 0..100 {\n    ekf.predict(0.1);\n    println!(\"After {:.1}s: {:.4}\", (i + 1) as f64 * 0.1,\n             ekf.get_position_uncertainty());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/index:37:rust",
      "file": "content/docs/rust/library/algorithms/index.mdx",
      "lineStart": 37,
      "lineEnd": 39,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides all algorithms: AStar, EKF, PID, PurePursuit, RRT, SensorFusion, DifferentialDrive, OccupancyGrid, etc.",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/index:45:rust",
      "file": "content/docs/rust/library/algorithms/index.mdx",
      "lineStart": 45,
      "lineEnd": 73,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {AStar, PurePursuit}\n\nfn main() {\n    // Step 1: Plan a path with A*\n    let mut planner = AStar::new(100, 100);\n    planner.set_start(10, 10);\n    planner.set_goal(90, 90);\n    planner.set_obstacle(50, 50);\n\n    let path = planner.plan().expect(\"No path found\");\n\n    // Step 2: Follow the path with Pure Pursuit\n    let mut pursuit = PurePursuit::new(0.5);  // 0.5m look-ahead\n\n    // Convert grid coordinates to world coordinates\n    let world_path: Vec<(f64, f64)> = path\n        .iter()\n        .map(|(x, y)| (*x as f64 * 0.1, *y as f64 * 0.1))\n        .collect();\n    pursuit.set_path(world_path);\n\n    // Control loop\n    let current_pose = (1.0, 1.0, 0.0);  // x, y, theta\n    let (linear, angular) = pursuit.compute_velocity(current_pose, 0.5);\n\n    println!(\"Command: linear={:.2} m/s, angular={:.2} rad/s\", linear, angular);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/index:79:rust",
      "file": "content/docs/rust/library/algorithms/index.mdx",
      "lineStart": 79,
      "lineEnd": 108,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {EKF, SensorFusion}\n\nfn main() {\n    // EKF for pose estimation\n    let mut ekf = EKF::new();\n    ekf.set_state([0.0, 0.0, 0.0, 1.0, 0.0, 0.0]);  // x, y, theta, vx, vy, omega\n\n    // Sensor fusion for position\n    let mut fusion = SensorFusion::new();\n\n    // Simulate sensor readings\n    fusion.add_measurement(\"odometry\", 1.5, 0.1);   // High confidence\n    fusion.add_measurement(\"gps\", 1.6, 0.5);        // Lower confidence\n    fusion.add_measurement(\"visual\", 1.55, 0.2);   // Medium confidence\n\n    // Get fused position estimate\n    let fused_x = fusion.fuse().unwrap();\n    let fused_variance = fusion.fused_variance().unwrap();\n\n    println!(\"Fused position: {:.3}m (variance: {:.4})\", fused_x, fused_variance);\n\n    // Update EKF with fused measurement\n    ekf.predict(0.01);\n    ekf.update_odometry([fused_x, 0.0, 0.0]);\n\n    let (x, y, theta) = ekf.get_pose();\n    println!(\"EKF pose: ({:.2}, {:.2}, {:.2})\", x, y, theta);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/index:157:rust",
      "file": "content/docs/rust/library/algorithms/index.mdx",
      "lineStart": 157,
      "lineEnd": 185,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {PID, MotorCommand, Odometry}\n\nstruct MotorController {\n    pid: PID,\n    cmd_pub: Hub<MotorCommand>,\n    odom_sub: Hub<Odometry>,\n    target_velocity: f64,\n}\n\nimpl Node for MotorController {\n    fn name(&self) -> &'static str { \"MotorController\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(odom) = self.odom_sub.recv(&mut ctx) {\n            let current_vel = odom.twist.linear[0];\n            let output = self.pid.compute(self.target_velocity, current_vel, 0.01);\n\n            let cmd = MotorCommand {\n                motor_id: 0,\n                value: output as f32,\n                mode: 1,  // velocity mode\n                timestamp: 0,\n            };\n            self.cmd_pub.send(cmd, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:33:rust",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 33,
      "lineEnd": 70,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides KalmanFilter\n\nfn main() {\n    // 1D position-velocity tracker: 2 states, 1 measurement\n    let mut kf = KalmanFilter::new(2, 1);\n\n    // Set initial state [position, velocity]\n    kf.set_state(vec![0.0, 1.0]);  // At origin, moving at 1 m/s\n\n    // Configure constant-velocity model\n    // x' = x + v*dt, v' = v\n    let dt = 0.1;\n    kf.set_state_transition(vec![\n        vec![1.0, dt],   // position = position + velocity * dt\n        vec![0.0, 1.0],  // velocity stays constant\n    ]);\n\n    // Measure position only\n    kf.set_measurement_matrix(vec![\n        vec![1.0, 0.0],  // Measure position, not velocity\n    ]);\n\n    // Simulation loop\n    for _ in 0..10 {\n        // Prediction step\n        kf.predict();\n\n        // Update with noisy measurement\n        let true_position = kf.get_state()[0];\n        let noisy_measurement = true_position + 0.1;  // Add noise\n        kf.update(vec![noisy_measurement]);\n\n        println!(\"Estimated: pos={:.2}, vel={:.2}\",\n                 kf.get_state()[0], kf.get_state()[1]);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:76:rust",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 76,
      "lineEnd": 78,
      "language": "rust",
      "code": "let kf = KalmanFilter::new(n_states: usize, n_measurements: usize);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:112:text",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 112,
      "lineEnd": 115,
      "language": "text",
      "code": "x̂⁻ = F × x̂        (State prediction)\nP⁻ = F × P × Fᵀ + Q   (Covariance prediction)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:119:text",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 119,
      "lineEnd": 125,
      "language": "text",
      "code": "y = z - H × x̂⁻         (Innovation)\nS = H × P⁻ × Hᵀ + R     (Innovation covariance)\nK = P⁻ × Hᵀ × S⁻¹       (Kalman gain)\nx̂ = x̂⁻ + K × y         (State update)\nP = (I - K × H) × P⁻    (Covariance update)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:131:rust",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 131,
      "lineEnd": 198,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides KalmanFilter\n\nstruct PositionTracker {\n    kf: KalmanFilter,\n    dt: f64,\n}\n\nimpl PositionTracker {\n    fn new(dt: f64) -> Self {\n        let mut kf = KalmanFilter::new(2, 1);\n\n        // Constant velocity model\n        kf.set_state_transition(vec![\n            vec![1.0, dt],\n            vec![0.0, 1.0],\n        ]);\n\n        // Measure position only\n        kf.set_measurement_matrix(vec![\n            vec![1.0, 0.0],\n        ]);\n\n        // Tune noise parameters\n        kf.set_process_noise(vec![\n            vec![0.01, 0.0],\n            vec![0.0, 0.1],  // Velocity can change\n        ]);\n\n        kf.set_measurement_noise(vec![\n            vec![0.5],  // Position measurement noise\n        ]);\n\n        Self { kf, dt }\n    }\n\n    fn predict(&mut self) {\n        self.kf.predict();\n    }\n\n    fn update(&mut self, measured_position: f64) {\n        self.kf.update(vec![measured_position]);\n    }\n\n    fn get_position(&self) -> f64 {\n        self.kf.get_state()[0]\n    }\n\n    fn get_velocity(&self) -> f64 {\n        self.kf.get_state()[1]\n    }\n}\n\nfn main() {\n    let mut tracker = PositionTracker::new(0.1);\n\n    // Simulate noisy position measurements\n    let measurements = [0.1, 0.3, 0.4, 0.6, 0.85, 1.05, 1.2];\n\n    for measurement in measurements {\n        tracker.predict();\n        tracker.update(measurement);\n\n        println!(\"Measured: {:.2}, Estimated pos: {:.2}, vel: {:.2}\",\n                 measurement, tracker.get_position(), tracker.get_velocity());\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:204:rust",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 204,
      "lineEnd": 229,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides KalmanFilter\n\nfn filter_signal(noisy_data: &[f64]) -> Vec<f64> {\n    // Simple 1-state filter for signal smoothing\n    let mut kf = KalmanFilter::new(1, 1);\n\n    // Identity matrices (signal doesn't change much)\n    kf.set_state_transition(vec![vec![1.0]]);\n    kf.set_measurement_matrix(vec![vec![1.0]]);\n\n    // Tune for smoothing\n    kf.set_process_noise(vec![vec![0.01]]);      // Low = smooth output\n    kf.set_measurement_noise(vec![vec![0.5]]);   // High = trust model more\n\n    let mut filtered = Vec::new();\n\n    for &value in noisy_data {\n        kf.predict();\n        kf.update(vec![value]);\n        filtered.push(kf.get_state()[0]);\n    }\n\n    filtered\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:255:rust",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 255,
      "lineEnd": 261,
      "language": "rust",
      "code": "// Set initial state to first measurement\nkf.set_state(vec![first_measurement, 0.0]);\n\n// Set high initial covariance if uncertain\n// This is done automatically by default",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/kalman-filter:267:rust",
      "file": "content/docs/rust/library/algorithms/kalman-filter.mdx",
      "lineStart": 267,
      "lineEnd": 306,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides KalmanFilter\n\nfn main() {\n    // 4 states: [x, y, vx, vy], 2 measurements: [x, y]\n    let mut kf = KalmanFilter::new(4, 2);\n\n    let dt = 0.1;\n\n    // State transition for constant velocity in 2D\n    kf.set_state_transition(vec![\n        vec![1.0, 0.0, dt,  0.0],   // x = x + vx*dt\n        vec![0.0, 1.0, 0.0, dt ],   // y = y + vy*dt\n        vec![0.0, 0.0, 1.0, 0.0],   // vx = vx\n        vec![0.0, 0.0, 0.0, 1.0],   // vy = vy\n    ]);\n\n    // Measure position only\n    kf.set_measurement_matrix(vec![\n        vec![1.0, 0.0, 0.0, 0.0],   // Measure x\n        vec![0.0, 1.0, 0.0, 0.0],   // Measure y\n    ]);\n\n    // Initial state: at (1, 2) moving at (0.5, 0.3) m/s\n    kf.set_state(vec![1.0, 2.0, 0.5, 0.3]);\n\n    // Run filter\n    for _ in 0..20 {\n        kf.predict();\n\n        // Simulated measurement (add noise in real application)\n        let state = kf.get_state();\n        kf.update(vec![state[0] + 0.1, state[1] + 0.1]);\n    }\n\n    let final_state = kf.get_state();\n    println!(\"Final position: ({:.2}, {:.2})\", final_state[0], final_state[1]);\n    println!(\"Final velocity: ({:.2}, {:.2})\", final_state[2], final_state[3]);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:24:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 24,
      "lineEnd": 43,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides OccupancyGrid\n\nfn main() {\n    // Create 10m × 10m grid at 0.1m resolution (100×100 cells)\n    let mut grid = OccupancyGrid::new(100, 100, 0.1);\n\n    // Add obstacle\n    grid.set_occupied(50, 50);\n\n    // Check if path is clear\n    if grid.is_free(60, 60) {\n        println!(\"Cell is free for navigation\");\n    }\n\n    // Convert world coordinates to grid\n    let (gx, gy) = grid.world_to_grid(5.0, 5.0);\n    println!(\"World (5.0, 5.0) = Grid ({}, {})\", gx, gy);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:49:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 49,
      "lineEnd": 55,
      "language": "rust",
      "code": "let grid = OccupancyGrid::new(\n    width: usize,      // Grid width in cells\n    height: usize,     // Grid height in cells\n    resolution: f64,   // Cell size in meters\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:92:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 92,
      "lineEnd": 98,
      "language": "rust",
      "code": "grid.ray_trace(\n    start: (f64, f64),   // World start point\n    end: (f64, f64),     // World end point\n    mark_free: bool,     // Mark intermediate cells as free\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:102:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 102,
      "lineEnd": 156,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides OccupancyGrid\n\nstruct GridMapper {\n    grid: OccupancyGrid,\n}\n\nimpl GridMapper {\n    fn new(width_m: f64, height_m: f64, resolution: f64) -> Self {\n        let width = (width_m / resolution) as usize;\n        let height = (height_m / resolution) as usize;\n\n        let mut grid = OccupancyGrid::new(width, height, resolution);\n\n        // Center the grid origin\n        grid.set_origin(-width_m / 2.0, -height_m / 2.0);\n\n        Self { grid }\n    }\n\n    fn process_lidar_scan(&mut self, robot_pos: (f64, f64), scan: &[(f64, f64)]) {\n        for &(angle, distance) in scan {\n            // Calculate endpoint\n            let end_x = robot_pos.0 + distance * angle.cos();\n            let end_y = robot_pos.1 + distance * angle.sin();\n\n            // Ray trace: mark path as free, endpoint as occupied\n            self.grid.ray_trace(robot_pos, (end_x, end_y), true);\n        }\n    }\n\n    fn is_path_clear(&self, from: (f64, f64), to: (f64, f64)) -> bool {\n        let (x0, y0) = self.grid.world_to_grid(from.0, from.1);\n        let (x1, y1) = self.grid.world_to_grid(to.0, to.1);\n\n        // Simple line check\n        let steps = ((x1 - x0).abs().max((y1 - y0).abs())) as usize;\n        if steps == 0 {\n            return true;\n        }\n\n        for i in 0..=steps {\n            let t = i as f64 / steps as f64;\n            let x = (x0 as f64 + t * (x1 - x0) as f64) as usize;\n            let y = (y0 as f64 + t * (y1 - y0) as f64) as usize;\n\n            if self.grid.is_occupied(x, y) {\n                return false;\n            }\n        }\n\n        true\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:160:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 160,
      "lineEnd": 212,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {OccupancyGrid, AStar}\n\nstruct GridPlanner {\n    grid: OccupancyGrid,\n    planner: AStar,\n    resolution: f64,\n}\n\nimpl GridPlanner {\n    fn new(width: usize, height: usize, resolution: f64) -> Self {\n        let mut planner = AStar::new(width, height);\n\n        Self {\n            grid: OccupancyGrid::new(width, height, resolution),\n            planner,\n            resolution,\n        }\n    }\n\n    fn update_obstacles(&mut self) {\n        // Sync occupancy grid to A* obstacle map\n        let (w, h) = self.grid.get_dimensions();\n\n        for y in 0..h {\n            for x in 0..w {\n                if self.grid.is_occupied(x, y) {\n                    self.planner.set_obstacle(x as i32, y as i32);\n                } else {\n                    self.planner.clear_obstacle(x as i32, y as i32);\n                }\n            }\n        }\n    }\n\n    fn plan_path(&mut self, start: (f64, f64), goal: (f64, f64)) -> Option<Vec<(f64, f64)>> {\n        // Convert to grid coordinates\n        let (sx, sy) = self.grid.world_to_grid(start.0, start.1);\n        let (gx, gy) = self.grid.world_to_grid(goal.0, goal.1);\n\n        self.planner.set_start(sx, sy);\n        self.planner.set_goal(gx, gy);\n\n        // Plan on grid\n        let grid_path = self.planner.plan()?;\n\n        // Convert back to world coordinates\n        Some(grid_path.iter().map(|(x, y)| {\n            self.grid.grid_to_world(*x, *y)\n        }).collect())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:218:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 218,
      "lineEnd": 257,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides OccupancyGrid\n\nfn update_cell_probability(\n    grid: &mut OccupancyGrid,\n    x: usize,\n    y: usize,\n    measurement_prob: f64,  // Probability cell is occupied from sensor\n) {\n    let prior = grid.get_probability(x, y);\n\n    // Bayes update (simplified)\n    let posterior = (measurement_prob * prior)\n        / (measurement_prob * prior + (1.0 - measurement_prob) * (1.0 - prior));\n\n    grid.set_probability(x, y, posterior);\n}\n\nfn main() {\n    let mut grid = OccupancyGrid::new(100, 100, 0.1);\n\n    // Start with unknown (0.5)\n    for y in 0..100 {\n        for x in 0..100 {\n            grid.set_probability(x, y, 0.5);\n        }\n    }\n\n    // Update with sensor readings\n    // High probability = likely obstacle\n    update_cell_probability(&mut grid, 50, 50, 0.9);\n    update_cell_probability(&mut grid, 50, 50, 0.85);  // More confident\n\n    // Low probability = likely free\n    update_cell_probability(&mut grid, 60, 60, 0.1);\n\n    println!(\"Cell (50,50) probability: {:.2}\", grid.get_probability(50, 50));\n    println!(\"Cell (60,60) probability: {:.2}\", grid.get_probability(60, 60));\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/occupancy-grid:261:rust",
      "file": "content/docs/rust/library/algorithms/occupancy-grid.mdx",
      "lineStart": 261,
      "lineEnd": 311,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {OccupancyGrid, LaserScan, Odometry}\n\nstruct MappingNode {\n    grid: OccupancyGrid,\n    laser_sub: Hub<LaserScan>,\n    odom_sub: Hub<Odometry>,\n    robot_pose: (f64, f64, f64),\n}\n\nimpl MappingNode {\n    fn new() -> Result<Self> {\n        let mut grid = OccupancyGrid::new(200, 200, 0.05);  // 10m × 10m at 5cm\n        grid.set_origin(-5.0, -5.0);  // Center at robot start\n\n        Ok(Self {\n            grid,\n            laser_sub: Hub::new(\"scan\")?,\n            odom_sub: Hub::new(\"odom\")?,\n            robot_pose: (0.0, 0.0, 0.0),\n        })\n    }\n}\n\nimpl Node for MappingNode {\n    fn name(&self) -> &'static str { \"Mapping\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update robot pose\n        if let Some(odom) = self.odom_sub.recv(&mut ctx) {\n            self.robot_pose = (odom.pose.x, odom.pose.y, odom.pose.theta);\n        }\n\n        // Process laser scan\n        if let Some(scan) = self.laser_sub.recv(&mut ctx) {\n            let (rx, ry, rtheta) = self.robot_pose;\n\n            for (i, range) in scan.ranges.iter().enumerate() {\n                if *range > scan.range_min && *range < scan.range_max {\n                    let angle = scan.angle_min + i as f64 * scan.angle_increment + rtheta;\n\n                    let end_x = rx + range * angle.cos();\n                    let end_y = ry + range * angle.sin();\n\n                    self.grid.ray_trace((rx, ry), (end_x, end_y), true);\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:24:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 24,
      "lineEnd": 48,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes PID\n\nfn main() {\n    // Create PID controller with gains\n    let mut pid = PID::new(2.0, 0.5, 0.1);  // Kp, Ki, Kd\n\n    // Set output limits (e.g., motor PWM range)\n    pid.set_output_limits(-255.0, 255.0);\n\n    // Control loop\n    let setpoint = 100.0;  // Target value\n    let dt = 0.01;         // 10ms control period\n\n    // Simulate control loop\n    let mut feedback = 0.0;\n    for _ in 0..100 {\n        let output = pid.compute(setpoint, feedback, dt);\n        println!(\"Output: {:.2}, Error: {:.2}\", output, pid.get_error());\n\n        // Simulate plant response (simplified)\n        feedback += output * 0.01;\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:54:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 54,
      "lineEnd": 56,
      "language": "rust",
      "code": "let pid = PID::new(kp: f64, ki: f64, kd: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:76:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 76,
      "lineEnd": 78,
      "language": "rust",
      "code": "let output = pid.compute(setpoint: f64, feedback: f64, dt: f64) -> f64;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:144:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 144,
      "lineEnd": 152,
      "language": "rust",
      "code": "let mut pid = PID::new(2.0, 0.5, 0.1);\n\n// Method 1: Limit output (also prevents windup indirectly)\npid.set_output_limits(-100.0, 100.0);\n\n// Method 2: Directly limit integral accumulation\npid.set_integral_limits(-50.0, 50.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:163:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 163,
      "lineEnd": 172,
      "language": "rust",
      "code": "let mut pid = PID::new(2.0, 0.5, 0.1);\n\n// Ignore errors smaller than 1.0\npid.set_deadband(1.0);\n\n// Error within deadband → treated as zero\npid.compute(100.0, 99.5, 0.01);  // Returns 0\npid.compute(100.0, 95.0, 0.01);  // Returns non-zero",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:181:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 181,
      "lineEnd": 209,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes PID\n\nstruct MotorController {\n    pid: PID,\n    target_rpm: f64,\n}\n\nimpl MotorController {\n    fn new(target_rpm: f64) -> Self {\n        let mut pid = PID::new(1.5, 0.2, 0.05);\n        pid.set_output_limits(-255.0, 255.0);  // PWM range\n        pid.set_integral_limits(-100.0, 100.0);\n\n        Self { pid, target_rpm }\n    }\n\n    fn update(&mut self, current_rpm: f64, dt: f64) -> i32 {\n        let pwm = self.pid.compute(self.target_rpm, current_rpm, dt);\n        pwm as i32\n    }\n\n    fn set_target(&mut self, rpm: f64) {\n        self.target_rpm = rpm;\n        // Optionally reset integral when target changes significantly\n        // self.pid.reset();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:213:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 213,
      "lineEnd": 237,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes PID\n\nstruct PositionController {\n    pid: PID,\n}\n\nimpl PositionController {\n    fn new() -> Self {\n        let mut pid = PID::new(10.0, 1.0, 0.5);\n        pid.set_output_limits(-1.0, 1.0);  // Velocity limits\n        pid.set_deadband(0.01);  // 1cm deadband\n\n        Self { pid }\n    }\n\n    fn compute_velocity(&mut self, target_pos: f64, current_pos: f64, dt: f64) -> f64 {\n        self.pid.compute(target_pos, current_pos, dt)\n    }\n\n    fn is_at_target(&self) -> bool {\n        self.pid.get_error().abs() < 0.01\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:243:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 243,
      "lineEnd": 276,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes PID\n\nstruct CascadedController {\n    position_pid: PID,\n    velocity_pid: PID,\n}\n\nimpl CascadedController {\n    fn new() -> Self {\n        let mut position_pid = PID::new(5.0, 0.0, 0.0);\n        position_pid.set_output_limits(-10.0, 10.0);  // Max velocity\n\n        let mut velocity_pid = PID::new(2.0, 0.5, 0.1);\n        velocity_pid.set_output_limits(-255.0, 255.0);  // PWM\n\n        Self { position_pid, velocity_pid }\n    }\n\n    fn compute(\n        &mut self,\n        target_pos: f64,\n        current_pos: f64,\n        current_vel: f64,\n        dt: f64,\n    ) -> f64 {\n        // Outer loop: position → velocity setpoint\n        let velocity_setpoint = self.position_pid.compute(target_pos, current_pos, dt);\n\n        // Inner loop: velocity → torque/PWM\n        self.velocity_pid.compute(velocity_setpoint, current_vel, dt)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pid:280:rust",
      "file": "content/docs/rust/library/algorithms/pid.mdx",
      "lineStart": 280,
      "lineEnd": 322,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Includes PID\nuse horus::prelude::*; // Provides {MotorCommand, Odometry};\n\nnode! {\n    name: \"VelocityController\",\n    state: {\n        pid: PID,\n        target_velocity: f64,\n    },\n    publishers: {\n        cmd_pub: Hub<MotorCommand> = \"motor.cmd\",\n    },\n    subscribers: {\n        odom_sub: Hub<Odometry> = \"odom\",\n    },\n    init: |_params| {\n        let mut pid = PID::new(2.0, 0.5, 0.1);\n        pid.set_output_limits(-1.0, 1.0);\n        Ok(Self {\n            pid,\n            target_velocity: 0.5,\n            cmd_pub,\n            odom_sub,\n        })\n    },\n    tick: |self, ctx| {\n        if let Some(odom) = self.odom_sub.recv(ctx) {\n            let current = odom.twist.linear[0];\n            let output = self.pid.compute(self.target_velocity, current, 0.01);\n\n            let cmd = MotorCommand {\n                motor_id: 0,\n                value: output as f32,\n                mode: 1,\n                timestamp: 0,\n            };\n            self.cmd_pub.send(cmd, ctx).ok();\n        }\n    },\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:24:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 24,
      "lineEnd": 58,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides PurePursuit\n\nfn main() {\n    // Create controller with 0.5m look-ahead\n    let mut pursuit = PurePursuit::new(0.5);\n\n    // Set path to follow\n    let path = vec![\n        (0.0, 0.0),\n        (1.0, 0.0),\n        (2.0, 0.5),\n        (3.0, 1.0),\n        (4.0, 1.0),\n    ];\n    pursuit.set_path(path);\n\n    // Control loop\n    let mut pose = (0.0, 0.0, 0.0);  // x, y, theta\n    let desired_speed = 0.5;  // m/s\n\n    while !pursuit.is_goal_reached(pose) {\n        let (linear, angular) = pursuit.compute_velocity(pose, desired_speed);\n        println!(\"Command: v={:.2} m/s, ω={:.2} rad/s\", linear, angular);\n\n        // Simulate robot motion (simplified)\n        let dt = 0.1;\n        pose.0 += linear * pose.2.cos() * dt;\n        pose.1 += linear * pose.2.sin() * dt;\n        pose.2 += angular * dt;\n    }\n\n    println!(\"Goal reached!\");\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:64:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 64,
      "lineEnd": 66,
      "language": "rust",
      "code": "let pursuit = PurePursuit::new(look_ahead_distance: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:82:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 82,
      "lineEnd": 87,
      "language": "rust",
      "code": "let (linear, angular) = pursuit.compute_velocity(\n    current_pose: (f64, f64, f64),  // (x, y, theta)\n    desired_linear_velocity: f64,\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:103:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 103,
      "lineEnd": 112,
      "language": "rust",
      "code": "// Short look-ahead: Follows path closely, may oscillate\npursuit.set_look_ahead_distance(0.3);\n\n// Medium look-ahead: Good balance (recommended)\npursuit.set_look_ahead_distance(0.5);\n\n// Long look-ahead: Smooth but cuts corners\npursuit.set_look_ahead_distance(1.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:128:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 128,
      "lineEnd": 136,
      "language": "rust",
      "code": "fn adaptive_look_ahead(speed: f64, curvature: f64) -> f64 {\n    let base = 0.5;\n    let speed_factor = speed * 0.5;  // Increase with speed\n    let curve_factor = -curvature.abs() * 0.3;  // Decrease on curves\n\n    (base + speed_factor + curve_factor).clamp(0.2, 1.5)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:142:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 142,
      "lineEnd": 198,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {AStar, PurePursuit}\n\nstruct Navigator {\n    planner: AStar,\n    controller: PurePursuit,\n    resolution: f64,  // Grid resolution in meters\n}\n\nimpl Navigator {\n    fn new(width: usize, height: usize, resolution: f64) -> Self {\n        Self {\n            planner: AStar::new(width, height),\n            controller: PurePursuit::new(0.5),\n            resolution,\n        }\n    }\n\n    fn plan_to(&mut self, goal: (f64, f64), robot_pose: (f64, f64, f64)) {\n        // Convert world to grid coordinates\n        let start_grid = (\n            (robot_pose.0 / self.resolution) as i32,\n            (robot_pose.1 / self.resolution) as i32,\n        );\n        let goal_grid = (\n            (goal.0 / self.resolution) as i32,\n            (goal.1 / self.resolution) as i32,\n        );\n\n        self.planner.set_start(start_grid.0, start_grid.1);\n        self.planner.set_goal(goal_grid.0, goal_grid.1);\n\n        if let Some(grid_path) = self.planner.plan() {\n            // Convert grid path to world coordinates\n            let world_path: Vec<(f64, f64)> = grid_path\n                .iter()\n                .map(|(gx, gy)| {\n                    (\n                        (*gx as f64 + 0.5) * self.resolution,\n                        (*gy as f64 + 0.5) * self.resolution,\n                    )\n                })\n                .collect();\n\n            self.controller.set_path(world_path);\n        }\n    }\n\n    fn compute_command(&mut self, pose: (f64, f64, f64), speed: f64) -> (f64, f64) {\n        self.controller.compute_velocity(pose, speed)\n    }\n\n    fn is_goal_reached(&self, pose: (f64, f64, f64)) -> bool {\n        self.controller.is_goal_reached(pose)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:202:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 202,
      "lineEnd": 257,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {PurePursuit, Path, Odometry, Twist}\n\nstruct PathFollower {\n    pursuit: PurePursuit,\n    path_sub: Hub<Path>,\n    odom_sub: Hub<Odometry>,\n    cmd_pub: Hub<Twist>,\n    desired_speed: f64,\n}\n\nimpl PathFollower {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            pursuit: PurePursuit::new(0.5),\n            path_sub: Hub::new(\"path\")?,\n            odom_sub: Hub::new(\"odom\")?,\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            desired_speed: 0.3,\n        })\n    }\n}\n\nimpl Node for PathFollower {\n    fn name(&self) -> &'static str { \"PathFollower\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update path if new one received\n        if let Some(path_msg) = self.path_sub.recv(&mut ctx) {\n            let path: Vec<(f64, f64)> = path_msg.waypoints\n                .iter()\n                .map(|w| (w.x, w.y))\n                .collect();\n            self.pursuit.set_path(path);\n        }\n\n        // Compute control from odometry\n        if let Some(odom) = self.odom_sub.recv(&mut ctx) {\n            let pose = (odom.pose.x, odom.pose.y, odom.pose.theta);\n\n            if !self.pursuit.is_goal_reached(pose) {\n                let (linear, angular) = self.pursuit.compute_velocity(\n                    pose,\n                    self.desired_speed,\n                );\n\n                let cmd = Twist::new_2d(linear, angular);\n                self.cmd_pub.send(cmd, &mut ctx).ok();\n            } else {\n                // Stop at goal\n                self.cmd_pub.send(Twist::stop(), &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/pure-pursuit:263:rust",
      "file": "content/docs/rust/library/algorithms/pure-pursuit.mdx",
      "lineStart": 263,
      "lineEnd": 268,
      "language": "rust",
      "code": "let mut pursuit = PurePursuit::new(0.5);\n// No path set\nlet (v, w) = pursuit.compute_velocity((0.0, 0.0, 0.0), 1.0);\n// Returns (0.0, 0.0) - safe stop",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:34:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 34,
      "lineEnd": 70,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes RRT\n\nfn main() {\n    // Create RRT planner\n    let mut rrt = RRT::new(\n        (0.0, 0.0),     // start\n        (10.0, 10.0),   // goal\n        (-5.0, -5.0),   // bounds min\n        (15.0, 15.0),   // bounds max\n    );\n\n    // Add circular obstacles\n    rrt.add_obstacle((5.0, 5.0), 2.0);  // center, radius\n    rrt.add_obstacle((7.0, 3.0), 1.0);\n\n    // Configure planning parameters\n    rrt.set_max_iterations(2000);\n    rrt.set_step_size(0.5);\n    rrt.set_goal_tolerance(0.3);\n    rrt.set_goal_bias(0.1);\n\n    // Plan path\n    if let Some(path) = rrt.plan() {\n        println!(\"Found path with {} waypoints\", path.len());\n\n        let cost = RRT::path_cost(&path);\n        println!(\"Path length: {:.2} meters\", cost);\n\n        for (x, y) in &path {\n            println!(\"  ({:.2}, {:.2})\", x, y);\n        }\n    } else {\n        println!(\"No path found within {} iterations\", 2000);\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:76:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 76,
      "lineEnd": 83,
      "language": "rust",
      "code": "let rrt = RRT::new(\n    start: (f64, f64),       // Start position\n    goal: (f64, f64),        // Goal position\n    bounds_min: (f64, f64),  // Sampling space minimum\n    bounds_max: (f64, f64),  // Sampling space maximum\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:103:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 103,
      "lineEnd": 105,
      "language": "rust",
      "code": "let path: Option<Vec<(f64, f64)>> = rrt.plan();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:123:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 123,
      "lineEnd": 129,
      "language": "rust",
      "code": "// Small steps: More precise, slower, better in cluttered spaces\nrrt.set_step_size(0.2);\n\n// Large steps: Faster exploration, may miss narrow passages\nrrt.set_step_size(1.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:140:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 140,
      "lineEnd": 146,
      "language": "rust",
      "code": "// Low bias: More exploration, finds alternative paths\nrrt.set_goal_bias(0.05);\n\n// High bias: Faster convergence to goal, may miss better paths\nrrt.set_goal_bias(0.3);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:155:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 155,
      "lineEnd": 161,
      "language": "rust",
      "code": "// Complex environments need more iterations\nrrt.set_max_iterations(5000);\n\n// Simple environments\nrrt.set_max_iterations(500);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:167:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 167,
      "lineEnd": 173,
      "language": "rust",
      "code": "// Precise goal reaching\nrrt.set_goal_tolerance(0.1);\n\n// Approximate goal area\nrrt.set_goal_tolerance(0.5);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:177:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 177,
      "lineEnd": 228,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes RRT\n\nstruct DynamicPlanner {\n    start: (f64, f64),\n    goal: (f64, f64),\n    bounds: ((f64, f64), (f64, f64)),\n    obstacles: Vec<((f64, f64), f64)>,\n}\n\nimpl DynamicPlanner {\n    fn new(\n        start: (f64, f64),\n        goal: (f64, f64),\n        bounds_min: (f64, f64),\n        bounds_max: (f64, f64),\n    ) -> Self {\n        Self {\n            start,\n            goal,\n            bounds: (bounds_min, bounds_max),\n            obstacles: Vec::new(),\n        }\n    }\n\n    fn add_obstacle(&mut self, center: (f64, f64), radius: f64) {\n        self.obstacles.push((center, radius));\n    }\n\n    fn update_robot_position(&mut self, pos: (f64, f64)) {\n        self.start = pos;\n    }\n\n    fn replan(&self) -> Option<Vec<(f64, f64)>> {\n        let mut rrt = RRT::new(\n            self.start,\n            self.goal,\n            self.bounds.0,\n            self.bounds.1,\n        );\n\n        for (center, radius) in &self.obstacles {\n            rrt.add_obstacle(*center, *radius);\n        }\n\n        rrt.set_max_iterations(1000);\n        rrt.set_goal_bias(0.15);\n\n        rrt.plan()\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:234:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 234,
      "lineEnd": 301,
      "language": "rust",
      "code": "fn smooth_path(path: &[(f64, f64)], obstacles: &[((f64, f64), f64)]) -> Vec<(f64, f64)> {\n    if path.len() <= 2 {\n        return path.to_vec();\n    }\n\n    let mut smoothed = vec![path[0]];\n    let mut i = 0;\n\n    while i < path.len() - 1 {\n        // Try to skip intermediate points\n        let mut j = path.len() - 1;\n\n        while j > i + 1 {\n            if is_collision_free(path[i], path[j], obstacles) {\n                break;\n            }\n            j -= 1;\n        }\n\n        smoothed.push(path[j]);\n        i = j;\n    }\n\n    smoothed\n}\n\nfn is_collision_free(\n    p1: (f64, f64),\n    p2: (f64, f64),\n    obstacles: &[((f64, f64), f64)],\n) -> bool {\n    // Check line segment against all obstacles\n    for (center, radius) in obstacles {\n        if line_circle_intersects(p1, p2, *center, *radius) {\n            return false;\n        }\n    }\n    true\n}\n\nfn line_circle_intersects(\n    p1: (f64, f64),\n    p2: (f64, f64),\n    center: (f64, f64),\n    radius: f64,\n) -> bool {\n    let dx = p2.0 - p1.0;\n    let dy = p2.1 - p1.1;\n    let fx = p1.0 - center.0;\n    let fy = p1.1 - center.1;\n\n    let a = dx * dx + dy * dy;\n    let b = 2.0 * (fx * dx + fy * dy);\n    let c = fx * fx + fy * fy - radius * radius;\n\n    let discriminant = b * b - 4.0 * a * c;\n\n    if discriminant < 0.0 {\n        return false;\n    }\n\n    let t1 = (-b - discriminant.sqrt()) / (2.0 * a);\n    let t2 = (-b + discriminant.sqrt()) / (2.0 * a);\n\n    (0.0..=1.0).contains(&t1) || (0.0..=1.0).contains(&t2)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:307:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 307,
      "lineEnd": 341,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes RRT\n\nfn plan_to_nearest_goal(\n    start: (f64, f64),\n    goals: &[(f64, f64)],\n    obstacles: &[((f64, f64), f64)],\n    bounds: ((f64, f64), (f64, f64)),\n) -> Option<(Vec<(f64, f64)>, usize)> {\n    let mut best_path: Option<Vec<(f64, f64)>> = None;\n    let mut best_cost = f64::INFINITY;\n    let mut best_goal_idx = 0;\n\n    for (i, goal) in goals.iter().enumerate() {\n        let mut rrt = RRT::new(start, *goal, bounds.0, bounds.1);\n\n        for (center, radius) in obstacles {\n            rrt.add_obstacle(*center, *radius);\n        }\n\n        rrt.set_max_iterations(1000);\n\n        if let Some(path) = rrt.plan() {\n            let cost = RRT::path_cost(&path);\n            if cost < best_cost {\n                best_cost = cost;\n                best_path = Some(path);\n                best_goal_idx = i;\n            }\n        }\n    }\n\n    best_path.map(|p| (p, best_goal_idx))\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/rrt:362:rust",
      "file": "content/docs/rust/library/algorithms/rrt.mdx",
      "lineStart": 362,
      "lineEnd": 379,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {AStar, RRT}\n\n// A*: Grid-based, optimal\nlet mut astar = AStar::new(100, 100);\nastar.set_start(10, 10);\nastar.set_goal(90, 90);\nlet grid_path = astar.plan();  // Optimal on grid\n\n// RRT: Continuous, probabilistically complete\nlet mut rrt = RRT::new(\n    (1.0, 1.0),\n    (9.0, 9.0),\n    (0.0, 0.0),\n    (10.0, 10.0),\n);\nlet continuous_path = rrt.plan();  // Works in continuous space",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:26:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 26,
      "lineEnd": 61,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SafetyLayer, SafetyStatus}\n\nfn main() {\n    let mut safety = SafetyLayer::new();\n\n    // Configure limits\n    safety.set_max_velocity(2.0);         // m/s\n    safety.set_min_obstacle_distance(0.5); // meters\n    safety.set_min_battery(15.0);          // percent\n    safety.set_max_temperature(75.0);      // °C\n\n    // Check individual conditions\n    if !safety.check_velocity(2.5) {\n        println!(\"Velocity exceeds safe limit!\");\n    }\n\n    // Comprehensive check\n    let status = safety.check_all(\n        1.5,   // velocity\n        0.8,   // obstacle distance\n        50.0,  // battery %\n        60.0,  // temperature °C\n    );\n\n    match status {\n        SafetyStatus::Safe => println!(\"All systems nominal\"),\n        SafetyStatus::Warning => println!(\"Approaching limits\"),\n        SafetyStatus::Critical => println!(\"STOP - Safety violation!\"),\n    }\n\n    // Limit velocity to safe range\n    let safe_vel = safety.limit_velocity(3.0);\n    println!(\"Limited velocity: {} m/s\", safe_vel);  // 2.0\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:67:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 67,
      "lineEnd": 71,
      "language": "rust",
      "code": "let safety = SafetyLayer::new();\n// Or using Default trait\nlet safety = SafetyLayer::default();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:108:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 108,
      "lineEnd": 115,
      "language": "rust",
      "code": "let status: SafetyStatus = safety.check_all(\n    velocity: f64,\n    obstacle_distance: f64,\n    battery_percent: f64,\n    temperature: f64,\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:124:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 124,
      "lineEnd": 126,
      "language": "rust",
      "code": "let safe_velocity = safety.limit_velocity(requested_velocity);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:141:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 141,
      "lineEnd": 180,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SafetyLayer, SafetyStatus}\n\nstruct SafeMotionController {\n    safety: SafetyLayer,\n    current_velocity: f64,\n}\n\nimpl SafeMotionController {\n    fn new() -> Self {\n        let mut safety = SafetyLayer::new();\n        safety.set_max_velocity(1.5);\n        safety.set_min_obstacle_distance(0.5);\n\n        Self {\n            safety,\n            current_velocity: 0.0,\n        }\n    }\n\n    fn set_velocity(&mut self, requested: f64, obstacle_dist: f64) -> f64 {\n        // First, limit to max velocity\n        let limited = self.safety.limit_velocity(requested);\n\n        // Then check obstacle distance\n        if !self.safety.check_obstacle_distance(obstacle_dist) {\n            // Too close to obstacle - emergency stop\n            self.current_velocity = 0.0;\n        } else if obstacle_dist < 1.0 {\n            // Getting close - reduce speed proportionally\n            let factor = (obstacle_dist - 0.5) / 0.5;  // 0 at 0.5m, 1 at 1m\n            self.current_velocity = limited * factor.clamp(0.0, 1.0);\n        } else {\n            self.current_velocity = limited;\n        }\n\n        self.current_velocity\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:184:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 184,
      "lineEnd": 230,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SafetyLayer, SafetyStatus}\n\nstruct BatteryAwareRobot {\n    safety: SafetyLayer,\n    home_position: (f64, f64),\n    current_position: (f64, f64),\n}\n\nimpl BatteryAwareRobot {\n    fn new(home: (f64, f64)) -> Self {\n        let mut safety = SafetyLayer::new();\n        safety.set_min_battery(20.0);  // Return home at 20%\n\n        Self {\n            safety,\n            home_position: home,\n            current_position: home,\n        }\n    }\n\n    fn should_return_home(&self, battery_percent: f64) -> bool {\n        !self.safety.check_battery(battery_percent)\n    }\n\n    fn get_max_range(&self, battery_percent: f64) -> f64 {\n        // Estimate based on battery\n        // Need enough to return home\n        let distance_home = self.distance_to(self.home_position);\n        let usable_battery = battery_percent - 20.0;  // Reserve 20%\n\n        if usable_battery <= 0.0 {\n            0.0\n        } else {\n            // Assume 1% battery = 10m range\n            let max_one_way = usable_battery * 10.0 / 2.0;\n            max_one_way - distance_home\n        }\n    }\n\n    fn distance_to(&self, target: (f64, f64)) -> f64 {\n        let dx = target.0 - self.current_position.0;\n        let dy = target.1 - self.current_position.1;\n        (dx * dx + dy * dy).sqrt()\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:234:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 234,
      "lineEnd": 317,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SafetyLayer, SafetyStatus, Twist, LaserScan, BatteryState}\n\nstruct SafetyNode {\n    safety: SafetyLayer,\n    cmd_sub: Hub<Twist>,\n    cmd_pub: Hub<Twist>,\n    scan_sub: Hub<LaserScan>,\n    battery_sub: Hub<BatteryState>,\n    min_obstacle_dist: f64,\n    battery_percent: f64,\n}\n\nimpl SafetyNode {\n    fn new() -> Result<Self> {\n        let mut safety = SafetyLayer::new();\n        safety.set_max_velocity(1.0);\n        safety.set_min_obstacle_distance(0.3);\n        safety.set_min_battery(15.0);\n\n        Ok(Self {\n            safety,\n            cmd_sub: Hub::new(\"cmd_vel_raw\")?,\n            cmd_pub: Hub::new(\"cmd_vel\")?,\n            scan_sub: Hub::new(\"scan\")?,\n            battery_sub: Hub::new(\"battery\")?,\n            min_obstacle_dist: f64::MAX,\n            battery_percent: 100.0,\n        })\n    }\n}\n\nimpl Node for SafetyNode {\n    fn name(&self) -> &'static str { \"Safety\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Update obstacle distance from LIDAR\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            self.min_obstacle_dist = scan.ranges\n                .iter()\n                .filter(|r| **r > scan.range_min && **r < scan.range_max)\n                .fold(f64::MAX, |min, r| min.min(*r));\n        }\n\n        // Update battery level\n        if let Some(battery) = self.battery_sub.recv(&mut ctx) {\n            self.battery_percent = battery.percentage;\n        }\n\n        // Filter velocity commands\n        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {\n            let status = self.safety.check_all(\n                cmd.linear.x,\n                self.min_obstacle_dist,\n                self.battery_percent,\n                50.0,  // Temperature not monitored in this example\n            );\n\n            let safe_cmd = match status {\n                SafetyStatus::Critical => {\n                    // Emergency stop\n                    Twist::stop()\n                }\n                SafetyStatus::Warning => {\n                    // Reduce speed\n                    Twist::new_2d(\n                        self.safety.limit_velocity(cmd.linear.x) * 0.5,\n                        cmd.angular.z * 0.5,\n                    )\n                }\n                SafetyStatus::Safe => {\n                    // Pass through with velocity limiting\n                    Twist::new_2d(\n                        self.safety.limit_velocity(cmd.linear.x),\n                        cmd.angular.z,\n                    )\n                }\n            };\n\n            self.cmd_pub.send(safe_cmd, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/safety-layer:321:rust",
      "file": "content/docs/rust/library/algorithms/safety-layer.mdx",
      "lineStart": 321,
      "lineEnd": 360,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SafetyLayer\n\nenum SafetyProfile {\n    Indoor,\n    Outdoor,\n    HighSpeed,\n    LowBattery,\n}\n\nfn configure_safety(profile: SafetyProfile) -> SafetyLayer {\n    let mut safety = SafetyLayer::new();\n\n    match profile {\n        SafetyProfile::Indoor => {\n            safety.set_max_velocity(0.5);\n            safety.set_min_obstacle_distance(0.3);\n            safety.set_min_battery(10.0);\n        }\n        SafetyProfile::Outdoor => {\n            safety.set_max_velocity(2.0);\n            safety.set_min_obstacle_distance(1.0);\n            safety.set_min_battery(15.0);\n        }\n        SafetyProfile::HighSpeed => {\n            safety.set_max_velocity(5.0);\n            safety.set_min_obstacle_distance(2.0);\n            safety.set_min_battery(20.0);\n        }\n        SafetyProfile::LowBattery => {\n            safety.set_max_velocity(0.3);\n            safety.set_min_obstacle_distance(0.5);\n            safety.set_min_battery(5.0);  // Allow lower before stopping\n            safety.enable_temperature_check(false);  // Conserve processing\n        }\n    }\n\n    safety\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:24:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 24,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SensorFusion\n\nfn main() {\n    let mut fusion = SensorFusion::new();\n\n    // Add measurements with variance (uncertainty)\n    fusion.add_measurement(\"odometry\", 1.50, 0.01);   // Low variance = high confidence\n    fusion.add_measurement(\"gps\", 1.55, 0.10);        // Higher variance = lower confidence\n    fusion.add_measurement(\"visual\", 1.48, 0.05);     // Medium confidence\n\n    // Get fused estimate\n    if let Some(fused_value) = fusion.fuse() {\n        println!(\"Fused position: {:.3} m\", fused_value);\n    }\n\n    // Get combined uncertainty\n    if let Some(variance) = fusion.fused_variance() {\n        println!(\"Fused uncertainty: {:.4} m²\", variance);\n        println!(\"Standard deviation: {:.3} m\", variance.sqrt());\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:52:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 52,
      "lineEnd": 54,
      "language": "rust",
      "code": "let fusion = SensorFusion::new();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:58:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 58,
      "lineEnd": 64,
      "language": "rust",
      "code": "// Basic measurement\nfusion.add_measurement(sensor_id: &str, value: f64, variance: f64);\n\n// With timestamp\nfusion.add_measurement_with_time(sensor_id: &str, value: f64, variance: f64, timestamp: f64);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:95:text",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 95,
      "lineEnd": 98,
      "language": "text",
      "code": "weight_i = 1 / variance_i\nfused = Σ(weight_i × value_i) / Σ(weight_i)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:104:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 104,
      "lineEnd": 126,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SensorFusion\n\nfn main() {\n    let mut fusion = SensorFusion::new();\n\n    // GPS: accurate but noisy\n    fusion.add_measurement(\"gps_x\", 10.5, 2.0);\n\n    // Odometry: drifts but smooth\n    fusion.add_measurement(\"odom_x\", 10.2, 0.5);\n\n    // Wheel encoders: very accurate short-term\n    fusion.add_measurement(\"encoder_x\", 10.3, 0.1);\n\n    let fused = fusion.fuse().unwrap();\n    println!(\"Fused X: {:.3} m\", fused);  // Closer to encoder value\n\n    // Combined variance is lower than any individual\n    let var = fusion.fused_variance().unwrap();\n    println!(\"Fused variance: {:.4}\", var);  // < 0.1\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:132:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 132,
      "lineEnd": 151,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SensorFusion\n\nfn main() {\n    let mut fusion = SensorFusion::new();\n    fusion.set_max_age(1.0);  // Ignore measurements older than 1 second\n\n    // Old GPS measurement\n    fusion.add_measurement_with_time(\"gps\", 10.0, 0.5, 0.0);\n\n    // Recent odometry\n    fusion.add_measurement_with_time(\"odom\", 10.5, 0.5, 0.8);\n\n    // Fuse at current time\n    let current_time = 1.0;\n    if let Some(fused) = fusion.fuse_with_time(current_time) {\n        println!(\"Fused: {:.3}\", fused);  // Weighted toward recent odom\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:154:text",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 154,
      "lineEnd": 156,
      "language": "text",
      "code": "time_weight = exp(-age / max_age)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:162:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 162,
      "lineEnd": 178,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SensorFusion\n\nfn main() {\n    // Gyroscope integration (high frequency, drifts)\n    let gyro_angle = 45.2;\n\n    // Accelerometer angle (low frequency, noisy)\n    let accel_angle = 44.8;\n\n    // Alpha: trust gyro for short-term, accel for long-term\n    let alpha = 0.98;  // 98% gyro, 2% accelerometer\n\n    let fused = SensorFusion::complementary_filter(gyro_angle, accel_angle, alpha);\n    println!(\"Fused angle: {:.2}°\", fused);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:193:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 193,
      "lineEnd": 234,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SensorFusion\n\nstruct Position3D {\n    x: SensorFusion,\n    y: SensorFusion,\n    z: SensorFusion,\n}\n\nimpl Position3D {\n    fn new() -> Self {\n        Self {\n            x: SensorFusion::new(),\n            y: SensorFusion::new(),\n            z: SensorFusion::new(),\n        }\n    }\n\n    fn add_gps(&mut self, x: f64, y: f64, z: f64, hdop: f64, vdop: f64) {\n        let h_var = (hdop * 2.5).powi(2);  // Convert HDOP to variance\n        let v_var = (vdop * 2.5).powi(2);\n\n        self.x.add_measurement(\"gps\", x, h_var);\n        self.y.add_measurement(\"gps\", y, h_var);\n        self.z.add_measurement(\"gps\", z, v_var);\n    }\n\n    fn add_odometry(&mut self, x: f64, y: f64, variance: f64) {\n        self.x.add_measurement(\"odom\", x, variance);\n        self.y.add_measurement(\"odom\", y, variance);\n        // Odometry doesn't measure Z\n    }\n\n    fn fuse(&self) -> Option<(f64, f64, f64)> {\n        Some((\n            self.x.fuse()?,\n            self.y.fuse()?,\n            self.z.fuse()?,\n        ))\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/algorithms/sensor-fusion:238:rust",
      "file": "content/docs/rust/library/algorithms/sensor-fusion.mdx",
      "lineStart": 238,
      "lineEnd": 287,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {SensorFusion, NavSatFix, Odometry, Pose2D}\n\nstruct PositionFusionNode {\n    fusion_x: SensorFusion,\n    fusion_y: SensorFusion,\n    gps_sub: Hub<NavSatFix>,\n    odom_sub: Hub<Odometry>,\n    pose_pub: Hub<Pose2D>,\n}\n\nimpl Node for PositionFusionNode {\n    fn name(&self) -> &'static str { \"PositionFusion\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        let current_time = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs_f64();\n\n        // Update from GPS\n        if let Some(gps) = self.gps_sub.recv(&mut ctx) {\n            if gps.has_fix() {\n                let variance = gps.horizontal_accuracy().powi(2);\n                // Convert lat/lon to local coordinates (simplified)\n                let x = gps.longitude * 111000.0;  // Rough conversion\n                let y = gps.latitude * 111000.0;\n\n                self.fusion_x.add_measurement_with_time(\"gps\", x, variance, current_time);\n                self.fusion_y.add_measurement_with_time(\"gps\", y, variance, current_time);\n            }\n        }\n\n        // Update from odometry\n        if let Some(odom) = self.odom_sub.recv(&mut ctx) {\n            self.fusion_x.add_measurement_with_time(\"odom\", odom.pose.x, 0.01, current_time);\n            self.fusion_y.add_measurement_with_time(\"odom\", odom.pose.y, 0.01, current_time);\n        }\n\n        // Publish fused position\n        if let (Some(x), Some(y)) = (\n            self.fusion_x.fuse_with_time(current_time),\n            self.fusion_y.fuse_with_time(current_time),\n        ) {\n            let pose = Pose2D::new(x, y, 0.0);\n            self.pose_pub.send(pose, &mut ctx).ok();\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:30:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 30,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create battery monitor\n    let mut battery = BatteryMonitorNode::new()?;\n    battery.set_sensor_type(SensorType::INA219);\n    battery.set_i2c_address(0x40);  // Default address\n    battery.set_battery_capacity(5000);  // 5000 mAh\n\n    scheduler.add(Box::new(battery), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:131:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 131,
      "lineEnd": 136,
      "language": "rust",
      "code": "battery.set_sensor_type(SensorType::INA219);  // INA219 or INA226\nbattery.set_i2c_bus(1);                       // I2C bus number\nbattery.set_i2c_address(0x40);                // I2C address (0x40-0x4F)\nbattery.set_shunt_resistance(0.1);            // Shunt resistor value (Ω)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:139:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 139,
      "lineEnd": 144,
      "language": "rust",
      "code": "battery.set_battery_capacity(5000);           // Capacity in mAh\nbattery.set_battery_chemistry(Chemistry::LiPo); // Chemistry type\nbattery.set_cell_count(4);                    // Number of cells (S)\nbattery.set_nominal_voltage(3.7);             // Per-cell nominal voltage",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:147:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 147,
      "lineEnd": 151,
      "language": "rust",
      "code": "battery.set_sample_rate(10);                  // Samples per second\nbattery.set_averaging(16);                    // INA226: averaging samples\nbattery.set_voltage_range(VoltageRange::V32); // INA226: range selection",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:154:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 154,
      "lineEnd": 159,
      "language": "rust",
      "code": "battery.set_low_voltage_threshold(10.5);      // Low battery warning (V)\nbattery.set_critical_voltage_threshold(9.9);  // Critical shutdown (V)\nbattery.set_high_current_threshold(5.0);      // Overcurrent alert (A)\nbattery.set_low_soc_threshold(20);            // Low SOC warning (%)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:162:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 162,
      "lineEnd": 169,
      "language": "rust",
      "code": "// Quick presets for common batteries\nbattery.configure_3s_lipo(5000.0);   // 3S LiPo, 5000mAh\nbattery.configure_4s_lipo(5000.0);   // 4S LiPo, 5000mAh\nbattery.configure_6s_lipo(5000.0);   // 6S LiPo, 5000mAh\nbattery.configure_12v_lead_acid(7000.0); // 12V Lead-acid\nbattery.configure_lifepo4(4, 3000.0);     // 4S LiFePO4",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:174:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 174,
      "lineEnd": 195,
      "language": "rust",
      "code": "struct PredictiveBatteryMonitor {\n    inner: BatteryMonitorNode,\n    kalman_filter: KalmanFilter,\n    degradation_model: DegradationModel,\n}\n\nimpl Node for PredictiveBatteryMonitor {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Hardware monitoring\n        self.inner.tick(&mut ctx);\n\n        // Custom prediction\n        let state = self.inner.get_state();\n        let prediction = self.kalman_filter.predict(state);\n        let remaining_life = self.degradation_model.estimate(state);\n\n        // Publish custom metrics\n        // ...\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:203:bash",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 203,
      "lineEnd": 212,
      "language": "bash",
      "code": "# Install I2C tools\nsudo apt install i2c-tools\n\n# Enable I2C\nsudo raspi-config  # Interface Options -> I2C\n\n# Verify I2C device\ni2cdetect -y 1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:216:text",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 216,
      "lineEnd": 225,
      "language": "text",
      "code": "Raspberry Pi    INA219      Battery/Load\nGPIO 2 (SDA) --> SDA\nGPIO 3 (SCL) --> SCL\n3.3V         --> VCC\nGND          --- GND\n                VIN+ --> Battery +\n                VIN- --> Load +\n                       Load - --> Battery -",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:229:text",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 229,
      "lineEnd": 238,
      "language": "text",
      "code": "Raspberry Pi    INA226      Battery/Load\nGPIO 2 (SDA) --> SDA\nGPIO 3 (SCL) --> SCL\n3.3V         --> VCC\nGND          --- GND\n                VIN+ --> Battery +\n                VIN- --> Load +\n                       Load - --> Battery -",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:250:bash",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 250,
      "lineEnd": 253,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: i2c-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:259:yaml",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 259,
      "lineEnd": 264,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - i2c-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:270:toml",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 270,
      "lineEnd": 273,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"i2c-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:279:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 279,
      "lineEnd": 287,
      "language": "rust",
      "code": "// Features:\n// - Voltage: 0-26V (bus voltage)\n// - Current: ±3.2A (with 0.1Ω shunt)\n// - Resolution: 12-bit (configurable)\n// - Sample rate: Up to 2kHz\n// - I2C addresses: 0x40-0x4F (16 addresses)\n// - Use for: Small robots, drones, low-power systems",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:291:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 291,
      "lineEnd": 301,
      "language": "rust",
      "code": "// Features:\n// - Voltage: 0-36V\n// - Current: ±20A (with appropriate shunt)\n// - Resolution: 16-bit\n// - Sample rate: Up to 8kHz\n// - Averaging: 1-1024 samples\n// - Alert pin support\n// - I2C addresses: 0x40-0x4F (16 addresses)\n// - Use for: High-power systems, current sensing",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:307:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 307,
      "lineEnd": 317,
      "language": "rust",
      "code": "let mut battery = BatteryMonitorNode::new()?;\n\n// Select sensor type\nbattery.set_sensor_type(SensorType::INA219);\nbattery.set_sensor_type(SensorType::INA226);\n\n// Set I2C bus and address\nbattery.set_i2c_bus(1);           // /dev/i2c-1\nbattery.set_i2c_address(0x40);    // Default address",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:321:text",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 321,
      "lineEnd": 328,
      "language": "text",
      "code": "Address pins (A0, A1):\n0x40: GND, GND (default)\n0x41: GND, VS+\n0x44: GND, SDA\n0x45: GND, SCL\n... up to 0x4F (16 combinations)",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:332:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 332,
      "lineEnd": 342,
      "language": "rust",
      "code": "// Set shunt resistance (Ohms)\nbattery.set_shunt_resistance(0.1);   // 0.1Ω (INA219 default)\nbattery.set_shunt_resistance(0.01);  // 0.01Ω (for higher current)\n\n// Shunt selection guide:\n// 0.1Ω: Up to 3.2A (INA219)\n// 0.01Ω: Up to 32A\n// 0.002Ω: Up to 160A\n// Lower resistance = higher current capacity, lower resolution",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:346:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 346,
      "lineEnd": 359,
      "language": "rust",
      "code": "// Set battery capacity (mAh)\nbattery.set_battery_capacity(5000);  // 5000 mAh (5 Ah)\n\n// Set battery chemistry (for SOC curve)\nbattery.set_battery_chemistry(BatteryChemistry::LiPo);\nbattery.set_battery_chemistry(BatteryChemistry::LiFePO4);\nbattery.set_battery_chemistry(BatteryChemistry::NiMH);\nbattery.set_battery_chemistry(BatteryChemistry::LeadAcid);\n\n// Set cell count\nbattery.set_cell_count(3);  // 3S LiPo (11.1V nominal)\nbattery.set_cell_count(4);  // 4S LiPo (14.8V nominal)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:363:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 363,
      "lineEnd": 373,
      "language": "rust",
      "code": "// Sample rate (Hz)\nbattery.set_sample_rate(10);  // 10 samples/sec\n\n// Averaging (INA226 only)\nbattery.set_averaging(4);  // Average 4 samples\nbattery.set_averaging(16);  // More averaging = less noise\n\n// Calibration\nbattery.calibrate()?;  // Auto-calibrate based on shunt",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:377:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 377,
      "lineEnd": 390,
      "language": "rust",
      "code": "// Low voltage warning (V)\nbattery.set_low_voltage_threshold(10.5);  // 3.5V per cell (3S)\n\n// Critical voltage (V)\nbattery.set_critical_voltage_threshold(9.9);  // 3.3V per cell\n\n// High current warning (A)\nbattery.set_high_current_threshold(5.0);\n\n// Low SOC warning (%)\nbattery.set_low_soc_threshold(20);  // 20%\nbattery.set_critical_soc_threshold(5);  // 5%",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:396:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 396,
      "lineEnd": 409,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Subscribe to battery data\nlet hub = Hub::<BatteryData>::new(\"battery.data\")?;\n\nif let Some(data) = hub.recv(&mut None) {\n    println!(\"Voltage: {:.2}V\", data.voltage);\n    println!(\"Current: {:.2}A\", data.current);\n    println!(\"Power: {:.2}W\", data.power);\n    println!(\"SOC: {}%\", data.soc);\n    println!(\"Runtime: {} min\", data.remaining_minutes);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:413:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 413,
      "lineEnd": 434,
      "language": "rust",
      "code": "// Subscribe to alerts\nlet alert_hub = Hub::<BatteryAlert>::new(\"battery.alert\")?;\n\nif let Some(alert) = alert_hub.recv(&mut None) {\n    match alert.alert_type {\n        AlertType::LOW_VOLTAGE => {\n            println!(\"WARNING: Low voltage {:.2}V\", alert.voltage);\n        }\n        AlertType::CRITICAL_VOLTAGE => {\n            println!(\"CRITICAL: Battery critically low!\");\n            // Initiate emergency landing/shutdown\n        }\n        AlertType::HIGH_CURRENT => {\n            println!(\"WARNING: High current draw {:.2}A\", alert.current);\n        }\n        AlertType::LOW_SOC => {\n            println!(\"WARNING: Battery low ({}%)\", alert.soc);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:438:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 438,
      "lineEnd": 450,
      "language": "rust",
      "code": "let hub = Hub::<BatteryData>::new(\"battery.data\")?;\n\nlet mut total_energy = 0.0;  // Wh\n\nwhile let Some(data) = hub.recv(&mut None) {\n    // Integrate power over time\n    let dt = 0.1;  // Sample period (seconds)\n    total_energy += data.power * (dt / 3600.0);  // Convert to Wh\n\n    println!(\"Energy consumed: {:.2} Wh\", total_energy);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:454:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 454,
      "lineEnd": 527,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure battery monitor\n    let mut battery = BatteryMonitorNode::new()?;\n    battery.set_sensor_type(SensorType::INA219);\n    battery.set_i2c_address(0x40);\n    battery.set_shunt_resistance(0.1);\n    battery.set_battery_capacity(5000);  // 5 Ah\n    battery.set_battery_chemistry(BatteryChemistry::LiPo);\n    battery.set_cell_count(3);  // 3S\n\n    // Set alerts\n    battery.set_low_voltage_threshold(10.5);\n    battery.set_critical_voltage_threshold(9.9);\n    battery.set_low_soc_threshold(20);\n    battery.set_high_current_threshold(5.0);\n\n    scheduler.add(Box::new(battery), 1, Some(true));\n\n    // Monitor node\n    let monitor_node = node! {\n        name: \"battery_monitor\",\n        tick: |ctx| {\n            let data_hub = Hub::<BatteryData>::new(\"battery.data\")?;\n            let alert_hub = Hub::<BatteryAlert>::new(\"battery.alert\")?;\n\n            // Display battery status\n            if let Some(data) = data_hub.recv(&mut None) {\n                ctx.log_info(&format!(\n                    \"Battery: {:.2}V, {:.2}A, {:.2}W | SOC: {}% | Runtime: {}min\",\n                    data.voltage, data.current, data.power,\n                    data.soc, data.remaining_minutes\n                ));\n            }\n\n            // Handle alerts\n            while let Some(alert) = alert_hub.recv(&mut None) {\n                match alert.alert_type {\n                    AlertType::LOW_VOLTAGE => {\n                        ctx.log_warning(&format!(\n                            \"Low battery voltage: {:.2}V\", alert.voltage\n                        ));\n                    }\n                    AlertType::CRITICAL_VOLTAGE => {\n                        ctx.log_error(\"CRITICAL: Battery voltage too low!\");\n                        // Trigger emergency shutdown\n                        // ...\n                    }\n                    AlertType::HIGH_CURRENT => {\n                        ctx.log_warning(&format!(\n                            \"High current draw: {:.2}A\", alert.current\n                        ));\n                    }\n                    AlertType::LOW_SOC => {\n                        ctx.log_warning(&format!(\n                            \"Low battery SOC: {}%\", alert.soc\n                        ));\n                    }\n                }\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(monitor_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:533:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 533,
      "lineEnd": 544,
      "language": "rust",
      "code": "pub struct BatteryData {\n    pub voltage: f32,             // Battery voltage (V)\n    pub current: f32,             // Current draw (A)\n    pub power: f32,               // Power consumption (W)\n    pub soc: u8,                  // State of charge (0-100%)\n    pub capacity_remaining: u32,  // Remaining capacity (mAh)\n    pub remaining_minutes: u16,   // Estimated runtime (min)\n    pub energy_consumed: f32,     // Total energy used (Wh)\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:548:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 548,
      "lineEnd": 556,
      "language": "rust",
      "code": "pub struct BatteryAlert {\n    pub alert_type: u8,\n    pub voltage: f32,\n    pub current: f32,\n    pub soc: u8,\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:560:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 560,
      "lineEnd": 566,
      "language": "rust",
      "code": "pub const ALERT_LOW_VOLTAGE: u8 = 0;\npub const ALERT_CRITICAL_VOLTAGE: u8 = 1;\npub const ALERT_HIGH_CURRENT: u8 = 2;\npub const ALERT_LOW_SOC: u8 = 3;\npub const ALERT_CRITICAL_SOC: u8 = 4;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:572:text",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 572,
      "lineEnd": 580,
      "language": "text",
      "code": "Voltage (per cell) | SOC\n4.2V               | 100%\n4.0V               | 90%\n3.85V              | 70%\n3.7V               | 30%\n3.5V               | 10%\n3.3V               | 0% (critical)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:584:text",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 584,
      "lineEnd": 591,
      "language": "text",
      "code": "Voltage (per cell) | SOC\n3.65V              | 100%\n3.4V               | 90%\n3.3V               | 50%\n3.0V               | 10%\n2.5V               | 0% (critical)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/battery-monitor:677:rust",
      "file": "content/docs/rust/library/built-in-nodes/battery-monitor.mdx",
      "lineStart": 677,
      "lineEnd": 688,
      "language": "rust",
      "code": "// Monitor multiple batteries\nlet mut battery1 = BatteryMonitorNode::new()?;\nbattery1.set_i2c_address(0x40);\nbattery1.set_battery_id(0);\n\nlet mut battery2 = BatteryMonitorNode::new()?;\nbattery2.set_i2c_address(0x41);\nbattery2.set_battery_id(1);\n\n// Each publishes to \"battery.data\" with different battery_id",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 29,
      "lineEnd": 49,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create BLDC node\n    let mut bldc = BldcMotorNode::new()?;\n    bldc.set_num_motors(4);\n    bldc.set_protocol(BldcProtocol::DShot600);\n\n    // Configure motor 0\n    bldc.set_gpio_pin(0, 18);  // GPIO pin for motor 0\n    bldc.set_min_throttle(0, 1000);\n    bldc.set_max_throttle(0, 2000);\n\n    scheduler.add(Box::new(bldc), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:55:bash",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 55,
      "lineEnd": 61,
      "language": "bash",
      "code": "# Install GPIO library\nsudo apt install libraspberrypi-dev\n\n# Enable GPIO and PWM\nsudo raspi-config  # Interface Options",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:65:text",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 65,
      "lineEnd": 73,
      "language": "text",
      "code": "Raspberry Pi    ESC         Motor\nGPIO 18   -->   Signal  --> Motor 0\nGPIO 19   -->   Signal  --> Motor 1\nGPIO 20   -->   Signal  --> Motor 2\nGPIO 21   -->   Signal  --> Motor 3\n5V        -->   BEC (optional for ESC power)\nGND       ---   GND (common ground REQUIRED)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:88:bash",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 88,
      "lineEnd": 91,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:97:yaml",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 97,
      "lineEnd": 102,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:108:toml",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 108,
      "lineEnd": 111,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:117:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 117,
      "lineEnd": 123,
      "language": "rust",
      "code": "bldc.set_protocol(BldcProtocol::PWM);\n// Frequency: 50 Hz\n// Pulse width: 1000-2000 μs\n// Pros: Universal compatibility\n// Cons: Slow update rate (~50Hz)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:127:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 127,
      "lineEnd": 133,
      "language": "rust",
      "code": "bldc.set_protocol(BldcProtocol::OneShot125);\n// Pulse width: 125-250 μs\n// Update rate: Up to 4 kHz\n// Pros: 8x faster than PWM\n// Cons: Requires ESC support",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:137:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 137,
      "lineEnd": 141,
      "language": "rust",
      "code": "bldc.set_protocol(BldcProtocol::OneShot42);\n// Pulse width: 42-84 μs\n// Update rate: Up to 12 kHz",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:145:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 145,
      "lineEnd": 150,
      "language": "rust",
      "code": "bldc.set_protocol(BldcProtocol::MultiShot);\n// Pulse width: 5-25 μs\n// Update rate: Up to 32 kHz\n// Pros: Very fast response",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:154:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 154,
      "lineEnd": 169,
      "language": "rust",
      "code": "// DShot150 (150 kbit/s) - reliable, slower\nbldc.set_protocol(BldcProtocol::DShot150);\n\n// DShot300 (300 kbit/s) - balanced\nbldc.set_protocol(BldcProtocol::DShot300);\n\n// DShot600 (600 kbit/s) - fast, recommended\nbldc.set_protocol(BldcProtocol::DShot600);\n\n// DShot1200 (1200 kbit/s) - fastest\nbldc.set_protocol(BldcProtocol::DShot1200);\n\n// Pros: Digital (no calibration), telemetry, CRC\n// Cons: Requires compatible ESC",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:173:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 173,
      "lineEnd": 177,
      "language": "rust",
      "code": "bldc.set_protocol(BldcProtocol::KISS);\n// Serial protocol for KISS ESCs\n// Pros: Telemetry, configuration",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:181:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 181,
      "lineEnd": 185,
      "language": "rust",
      "code": "bldc.set_protocol(BldcProtocol::CAN);\n// Requires CAN bus setup\n// Pros: Reliable, telemetry, long distances",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:191:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 191,
      "lineEnd": 206,
      "language": "rust",
      "code": "let mut bldc = BldcMotorNode::new()?;\n\n// Number of motors (1-8)\nbldc.set_num_motors(4);\n\n// Select protocol\nbldc.set_protocol(BldcProtocol::DShot600);\n\n// Configure each motor\nfor motor_id in 0..4 {\n    bldc.set_gpio_pin(motor_id, 18 + motor_id as u8);\n    bldc.set_min_throttle(motor_id, 1000);\n    bldc.set_max_throttle(motor_id, 2000);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:210:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 210,
      "lineEnd": 217,
      "language": "rust",
      "code": "// Set throttle range for motor 0\nbldc.set_min_throttle(0, 1000); // Microseconds (PWM) or value (DShot)\nbldc.set_max_throttle(0, 2000);\n\n// For DShot: 0-2000 maps to 0-2000 throttle value\n// For PWM: 1000-2000 microseconds",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:221:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 221,
      "lineEnd": 228,
      "language": "rust",
      "code": "// Reverse motor direction\nbldc.set_direction_reversed(0, true);\n\n// Useful for:\n// - Correcting motor spin direction\n// - Quad/hex copter motor layout",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:232:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 232,
      "lineEnd": 238,
      "language": "rust",
      "code": "// Enable arming requirement (safety)\nbldc.set_arming_required(true);\n\n// Set arming timeout (seconds)\nbldc.set_arming_timeout(5.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:242:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 242,
      "lineEnd": 248,
      "language": "rust",
      "code": "// Set failsafe throttle (used if signal lost)\nbldc.set_failsafe_throttle(1000); // Idle/off\n\n// Failsafe timeout (milliseconds)\nbldc.set_failsafe_timeout(500);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:252:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 252,
      "lineEnd": 261,
      "language": "rust",
      "code": "// Enable 3D mode (forward and reverse thrust)\nbldc.enable_3d_mode(true);\nbldc.set_3d_deadband(50); // Deadband around center\n\n// Throttle range in 3D mode:\n// 1000-1500: Reverse thrust\n// 1500: Neutral (deadband)\n// 1500-2000: Forward thrust",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:267:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 267,
      "lineEnd": 279,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create throttle command\nlet cmd = BldcCommand {\n    motor_id: 0,\n    throttle: 1500,  // Mid throttle\n};\n\n// Send command\nlet hub = Hub::<BldcCommand>::new(\"bldc.command\")?;\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:283:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 283,
      "lineEnd": 305,
      "language": "rust",
      "code": "// 1. Ensure all throttles at minimum\nfor motor_id in 0..4 {\n    let cmd = BldcCommand {\n        motor_id,\n        throttle: 1000,\n    };\n    hub.send(cmd, &mut None).ok();\n}\n\n// 2. Send arm command\nlet arm_cmd = BldcCommand {\n    motor_id: 0xFF,  // Broadcast to all\n    command_type: BldcCommand::CMD_ARM,\n    ..Default::default()\n};\nhub.send(arm_cmd, &mut None).ok();\n\n// 3. Wait for confirmation\nstd::thread::sleep(Duration::from_millis(100));\n\n// 4. Now safe to send throttle commands",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:309:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 309,
      "lineEnd": 324,
      "language": "rust",
      "code": "// Enable bidirectional DShot\nbldc.enable_telemetry(true);\n\n// Subscribe to telemetry topic\nlet telem_hub = Hub::<BldcTelemetry>::new(\"bldc.telemetry\")?;\n\nif let Some(telem) = telem_hub.recv(&mut None) {\n    println!(\"Motor {}: {} RPM, {}°C, {} A\",\n        telem.motor_id,\n        telem.rpm,\n        telem.temperature,\n        telem.current\n    );\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:328:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 328,
      "lineEnd": 343,
      "language": "rust",
      "code": "// Calibrate ESC throttle range\nlet calibrate_cmd = BldcCommand {\n    motor_id: 0,\n    command_type: BldcCommand::CMD_CALIBRATE,\n    ..Default::default()\n};\nhub.send(calibrate_cmd, &mut None).ok();\n\n// Process:\n// 1. Send max throttle (2000)\n// 2. Power on ESC\n// 3. Wait for confirmation beep\n// 4. Send min throttle (1000)\n// 5. Wait for confirmation beep",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:347:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 347,
      "lineEnd": 437,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure 4 motors for quadcopter\n    let mut bldc = BldcMotorNode::new()?;\n    bldc.set_num_motors(4);\n    bldc.set_protocol(BldcProtocol::DShot600);\n    bldc.set_arming_required(true);\n    bldc.enable_telemetry(true);\n\n    // Motor layout:\n    //   0   1\n    //    \\ /\n    //     X\n    //    / \\\n    //   2   3\n\n    for motor_id in 0..4 {\n        bldc.set_gpio_pin(motor_id, 18 + motor_id as u8);\n        bldc.set_min_throttle(motor_id, 1000);\n        bldc.set_max_throttle(motor_id, 2000);\n        bldc.set_failsafe_throttle(motor_id, 1000);\n    }\n\n    // Reverse motors 1 and 3 for proper rotation\n    bldc.set_direction_reversed(1, true);\n    bldc.set_direction_reversed(3, true);\n\n    scheduler.add(Box::new(bldc), 1, Some(true));\n\n    // Motor control node\n    let motor_node = node! {\n        name: \"motor_control\",\n        init: |ctx| {\n            // Arm motors on startup\n            let hub = Hub::<BldcCommand>::new(\"bldc.command\")?;\n\n            // Set all to idle\n            for motor_id in 0..4 {\n                hub.send(BldcCommand {\n                    motor_id,\n                    throttle: 1000,\n                }, None)?;\n            }\n\n            // Arm\n            hub.send(BldcCommand {\n                motor_id: 0xFF,\n                command_type: BldcCommand::CMD_ARM,\n                ..Default::default()\n            }, None)?;\n\n            ctx.log_info(\"Motors armed\");\n            Ok(())\n        },\n        tick: |ctx| {\n            let hub = Hub::<BldcCommand>::new(\"bldc.command\")?;\n\n            // Example: Spin all motors at 25% throttle\n            let throttle = 1000 + (1000.0 * 0.25) as u16;\n\n            for motor_id in 0..4 {\n                hub.send(BldcCommand {\n                    motor_id,\n                    throttle,\n                }, None)?;\n            }\n\n            // Monitor telemetry\n            let telem_hub = Hub::<BldcTelemetry>::new(\"bldc.telemetry\")?;\n            while let Some(telem) = telem_hub.recv(&mut None) {\n                if telem.temperature > 80.0 {\n                    ctx.log_warning(&format!(\n                        \"Motor {} overheating: {}°C\",\n                        telem.motor_id, telem.temperature\n                    ));\n                }\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(motor_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:443:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 443,
      "lineEnd": 449,
      "language": "rust",
      "code": "pub struct BldcCommand {\n    pub motor_id: u8,         // Motor ID (0-7, 0xFF for all)\n    pub command_type: u8,     // Command type\n    pub throttle: u16,        // Throttle value (1000-2000)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:453:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 453,
      "lineEnd": 461,
      "language": "rust",
      "code": "pub const CMD_THROTTLE: u8 = 0;         // Set throttle\npub const CMD_ARM: u8 = 1;              // Arm motors\npub const CMD_DISARM: u8 = 2;           // Disarm motors\npub const CMD_CALIBRATE: u8 = 3;        // Calibrate ESC\npub const CMD_REVERSE: u8 = 4;          // Set direction\npub const CMD_3D_MODE: u8 = 5;          // Enable 3D mode\npub const CMD_BEEP: u8 = 6;             // ESC beep (DShot)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:465:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 465,
      "lineEnd": 475,
      "language": "rust",
      "code": "pub struct BldcTelemetry {\n    pub motor_id: u8,         // Motor ID\n    pub rpm: u32,             // Revolutions per minute\n    pub voltage: f32,         // Voltage (V)\n    pub current: f32,         // Current (A)\n    pub temperature: f32,     // Temperature (°C)\n    pub consumption: u32,     // Energy consumption (mAh)\n    pub timestamp: u64,       // Telemetry time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/bldc-motor:540:rust",
      "file": "content/docs/rust/library/built-in-nodes/bldc-motor.mdx",
      "lineStart": 540,
      "lineEnd": 562,
      "language": "rust",
      "code": "// 1. Disconnect motor power\n// 2. Set max throttle\nlet cmd = BldcCommand {\n    motor_id: 0,\n    throttle: 2000,\n};\nhub.send(cmd, &mut None).ok();\n\n// 3. Connect motor power (you'll hear beeps)\n// 4. Wait 3 seconds\nstd::thread::sleep(Duration::from_secs(3));\n\n// 5. Set min throttle\nlet cmd = BldcCommand {\n    motor_id: 0,\n    throttle: 1000,\n};\nhub.send(cmd, &mut None).ok();\n\n// 6. ESC will beep to confirm calibration\n// 7. Repeat for all motors",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 29,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Basic camera setup\n    let mut camera = CameraNode::new()?;\n    camera.set_device_id(0);           // Default camera\n    camera.set_resolution(640, 480);   // VGA resolution\n    camera.set_fps(30.0);              // 30 frames per second\n    camera.set_encoding(ImageEncoding::Bgr8);\n\n    scheduler.add(Box::new(camera), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:64:bash",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 64,
      "lineEnd": 67,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: opencv-backend)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:73:yaml",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 73,
      "lineEnd": 78,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - opencv-backend",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:84:toml",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 84,
      "lineEnd": 87,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"opencv-backend\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:93:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 93,
      "lineEnd": 102,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topic \"camera.image\"\nlet mut camera = CameraNode::new()?;\n\n// Create with custom topic prefix\nlet mut left_camera = CameraNode::new_with_topic(\"camera.left\")?;\n// Publishes to \"camera.left.image\" and \"camera.left.camera_info\"",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:106:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 106,
      "lineEnd": 124,
      "language": "rust",
      "code": "// Set camera device (0 = default, 1+ = additional cameras)\ncamera.set_device_id(0);\n\n// Set image resolution\ncamera.set_resolution(1920, 1080);\n\n// Set capture framerate (clamped to 1.0 - 120.0 Hz)\ncamera.set_fps(60.0);\n\n// Set image encoding format\ncamera.set_encoding(ImageEncoding::Rgb8);\n\n// Enable compression (useful for network transmission)\ncamera.set_compression(true, 85);  // 85% quality\n\n// Disable compression (raw images)\ncamera.set_compression(false, 90);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:128:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 128,
      "lineEnd": 136,
      "language": "rust",
      "code": "// Get current actual framerate\nlet fps = camera.get_actual_fps();\neprintln!(\"Camera running at {:.1} fps\", fps);\n\n// Get total frames captured since initialization\nlet frames = camera.get_frame_count();\neprintln!(\"Captured {} frames\", frames);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:165:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 165,
      "lineEnd": 183,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create and configure camera\n    let mut camera = CameraNode::new()?;\n    camera.set_device_id(0);\n    camera.set_resolution(640, 480);\n    camera.set_fps(30.0);\n    camera.set_encoding(ImageEncoding::Bgr8);\n\n    scheduler.add(Box::new(camera), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:187:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 187,
      "lineEnd": 213,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Left camera\n    let mut left_camera = CameraNode::new_with_topic(\"camera.left\")?;\n    left_camera.set_device_id(0);\n    left_camera.set_resolution(1280, 720);\n    left_camera.set_fps(30.0);\n    left_camera.set_encoding(ImageEncoding::Mono8);  // Grayscale for stereo\n\n    // Right camera\n    let mut right_camera = CameraNode::new_with_topic(\"camera.right\")?;\n    right_camera.set_device_id(1);\n    right_camera.set_resolution(1280, 720);\n    right_camera.set_fps(30.0);\n    right_camera.set_encoding(ImageEncoding::Mono8);\n\n    scheduler.add(Box::new(left_camera), 50, Some(true));\n    scheduler.add(Box::new(right_camera), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:217:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 217,
      "lineEnd": 236,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Low resolution, high framerate for real-time control\n    let mut camera = CameraNode::new()?;\n    camera.set_device_id(0);\n    camera.set_resolution(320, 240);    // Small resolution\n    camera.set_fps(120.0);              // High framerate\n    camera.set_encoding(ImageEncoding::Mono8);  // Fastest encoding\n    camera.set_compression(false, 0);   // No compression overhead\n\n    scheduler.add(Box::new(camera), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:240:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 240,
      "lineEnd": 292,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Example image subscriber node\nstruct ImageProcessor {\n    subscriber: Hub<Image>,\n}\n\nimpl ImageProcessor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            subscriber: Hub::new(\"camera.image\")?,\n        })\n    }\n}\n\nimpl Node for ImageProcessor {\n    fn name(&self) -> &'static str {\n        \"ImageProcessor\"\n    }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Receive images from camera\n        if let Some(image) = self.subscriber.recv(&mut ctx) {\n            if let Some(ctx) = ctx.as_mut() {\n                ctx.log_debug(&format!(\"Received {}x{} image with {} bytes\",\n                         image.width, image.height, image.data.len()));\n            }\n\n            // Process image data here\n            // - Apply filters (blur, edge detection)\n            // - Color space conversion\n            // - Feature extraction\n        }\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    let mut camera = CameraNode::new()?;\n    camera.set_resolution(640, 480);\n    camera.set_encoding(ImageEncoding::Bgr8);\n\n    let processor = ImageProcessor::new()?;\n\n    scheduler.add(Box::new(camera), 50, Some(true));\n    scheduler.add(Box::new(processor), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:300:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 300,
      "lineEnd": 310,
      "language": "rust",
      "code": "pub struct Image {\n    pub width: u32,              // Image width in pixels\n    pub height: u32,             // Image height in pixels\n    pub encoding: ImageEncoding, // Pixel encoding format\n    pub step: u32,               // Bytes per row (may include padding)\n    pub data: Vec<u8>,           // Image data (row-major order)\n    pub frame_id: [u8; 32],      // Camera identifier\n    pub timestamp: u64,          // Nanoseconds since epoch\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:316:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 316,
      "lineEnd": 330,
      "language": "rust",
      "code": "pub enum ImageEncoding {\n    Mono8,       // 8-bit grayscale (1 byte/pixel)\n    Mono16,      // 16-bit grayscale (2 bytes/pixel)\n    Rgb8,        // 8-bit RGB (3 bytes/pixel)\n    Bgr8,        // 8-bit BGR - OpenCV format (3 bytes/pixel)\n    Rgba8,       // 8-bit RGBA with alpha (4 bytes/pixel)\n    Bgra8,       // 8-bit BGRA with alpha (4 bytes/pixel)\n    Yuv422,      // YUV 4:2:2 format (2 bytes/pixel)\n    Mono32F,     // 32-bit float grayscale (4 bytes/pixel)\n    Rgb32F,      // 32-bit float RGB (12 bytes/pixel)\n    BayerRggb8,  // Bayer pattern raw sensor data (1 byte/pixel)\n    Depth16,     // 16-bit depth in millimeters (2 bytes/pixel)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:336:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 336,
      "lineEnd": 348,
      "language": "rust",
      "code": "pub struct CameraInfo {\n    pub width: u32,                          // Image width\n    pub height: u32,                         // Image height\n    pub distortion_model: [u8; 16],          // \"plumb_bob\", \"rational_polynomial\"\n    pub distortion_coefficients: [f64; 8],   // [k1, k2, p1, p2, k3, k4, k5, k6]\n    pub camera_matrix: [f64; 9],             // 3x3 intrinsic matrix [fx, 0, cx, 0, fy, cy, 0, 0, 1]\n    pub rectification_matrix: [f64; 9],      // 3x3 rectification matrix\n    pub projection_matrix: [f64; 12],        // 3x4 projection matrix\n    pub frame_id: [u8; 32],                  // Camera identifier\n    pub timestamp: u64,                      // Nanoseconds since epoch\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:404:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 404,
      "lineEnd": 413,
      "language": "rust",
      "code": "// Use grayscale for algorithms that don't need color\ncamera.set_encoding(ImageEncoding::Mono8);\n\n// Match resolution to actual needs (don't over-sample)\ncamera.set_resolution(640, 480);  // Instead of 1920x1080\n\n// Use compression only when transmitting over network\ncamera.set_compression(false, 0);  // Disable for local processing",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:433:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 433,
      "lineEnd": 437,
      "language": "rust",
      "code": "// Try different device IDs\ncamera.set_device_id(0);  // Usually default camera\ncamera.set_device_id(1);  // Secondary camera",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:439:bash",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 439,
      "lineEnd": 445,
      "language": "bash",
      "code": "# Check available cameras on Linux\nv4l2-ctl --list-devices\n\n# Kill processes using camera\nlsof /dev/video0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:454:bash",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 454,
      "lineEnd": 462,
      "language": "bash",
      "code": "# Add user to video group\nsudo usermod -a -G video $USER\n\n# Or change device permissions (temporary)\nsudo chmod 666 /dev/video0\n\n# Then logout and login again",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:471:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 471,
      "lineEnd": 484,
      "language": "rust",
      "code": "// Reduce resolution\ncamera.set_resolution(320, 240);\n\n// Lower framerate\ncamera.set_fps(15.0);\n\n// Use grayscale instead of color\ncamera.set_encoding(ImageEncoding::Mono8);\n\n// Check actual FPS\nlet actual_fps = camera.get_actual_fps();\neprintln!(\"Running at {:.1} FPS\", actual_fps);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:495:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 495,
      "lineEnd": 500,
      "language": "rust",
      "code": "// If colors are swapped, change encoding\ncamera.set_encoding(ImageEncoding::Bgr8);  // OpenCV default\n// or\ncamera.set_encoding(ImageEncoding::Rgb8);  // Standard RGB",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:509:bash",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 509,
      "lineEnd": 512,
      "language": "bash",
      "code": "# Check supported formats (Linux)\nv4l2-ctl --device=/dev/video0 --list-formats-ext",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:514:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 514,
      "lineEnd": 518,
      "language": "rust",
      "code": "// Use standard resolutions\ncamera.set_resolution(640, 480);   // VGA - widely supported\ncamera.set_resolution(1280, 720);  // HD - common on webcams",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/camera:524:rust",
      "file": "content/docs/rust/library/built-in-nodes/camera.mdx",
      "lineStart": 524,
      "lineEnd": 539,
      "language": "rust",
      "code": "// CameraInfo is published every 30 frames\n// Contains:\n// - camera_matrix: [fx, 0, cx, 0, fy, cy, 0, 0, 1]\n//   - fx, fy: focal lengths in pixels\n//   - cx, cy: principal point (image center)\n// - distortion_coefficients: [k1, k2, p1, p2, k3, ...]\n//   - Radial and tangential distortion parameters\n// - projection_matrix: For stereo rectification\n\n// Default values (uncalibrated):\n// fx = fy = 800.0\n// cx = width / 2\n// cy = height / 2\n// No distortion",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 29,
      "lineEnd": 43,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create CAN node on can0 interface\n    let mut can = CanBusNode::new(\"can0\")?;\n    can.set_bitrate(500_000); // 500 kbit/s\n\n    scheduler.add(Box::new(can), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:49:bash",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 49,
      "lineEnd": 57,
      "language": "bash",
      "code": "# Install CAN utilities\nsudo apt install can-utils\n\n# Load SocketCAN kernel module\nsudo modprobe can\nsudo modprobe can_raw\nsudo modprobe vcan  # Virtual CAN for testing",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:61:bash",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 61,
      "lineEnd": 68,
      "language": "bash",
      "code": "# Create virtual CAN interface\nsudo ip link add dev can0 type vcan\nsudo ip link set up can0\n\n# Verify\nip link show can0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:72:bash",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 72,
      "lineEnd": 80,
      "language": "bash",
      "code": "# For physical CAN interfaces (e.g., MCP2515)\nsudo ip link set can0 type can bitrate 500000\nsudo ip link set up can0\n\n# Verify\nip link show can0\ncandump can0  # Monitor CAN traffic",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:90:bash",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 90,
      "lineEnd": 93,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: can-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:99:yaml",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 99,
      "lineEnd": 104,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - can-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:110:toml",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 110,
      "lineEnd": 113,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"can-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:119:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 119,
      "lineEnd": 133,
      "language": "rust",
      "code": "let mut can = CanBusNode::new(\"can0\")?;\n\n// Standard bitrates\ncan.set_bitrate(125_000);   // 125 kbit/s\ncan.set_bitrate(250_000);   // 250 kbit/s\ncan.set_bitrate(500_000);   // 500 kbit/s\ncan.set_bitrate(1_000_000); // 1 Mbit/s\n\n// Or use presets\ncan.configure_125k();\ncan.configure_250k();\ncan.configure_500k();\ncan.configure_1m();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:137:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 137,
      "lineEnd": 141,
      "language": "rust",
      "code": "// Enable CAN-FD with higher data phase bitrate\ncan.enable_can_fd(true);\ncan.set_fd_bitrate(2_000_000); // 2 Mbit/s data phase",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:145:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 145,
      "lineEnd": 154,
      "language": "rust",
      "code": "// Listen-only mode (passive monitoring, no ACK)\ncan.enable_listen_only(true);\n\n// Loopback mode (for testing without hardware)\ncan.enable_loopback(true);\n\n// Automatic bus-off recovery\ncan.enable_auto_restart(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:158:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 158,
      "lineEnd": 168,
      "language": "rust",
      "code": "// Add single ID filter\ncan.add_filter(0x123, 0x7FF); // ID, mask\n\n// Add range filter\ncan.add_range_filter(0x100, 0x1FF); // Start, end\n\n// Set filter mode\ncan.set_whitelist_mode(); // Only accept filtered IDs\ncan.set_blacklist_mode(); // Block filtered IDs",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:174:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 174,
      "lineEnd": 186,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create standard CAN frame\nlet mut frame = CanFrame::new(0x123, false); // ID, extended\nframe.data[0] = 0x01;\nframe.data[1] = 0x02;\nframe.dlc = 2;\n\n// Publish to TX topic\nlet tx_hub = Hub::<CanFrame>::new(\"can.can0.tx\")?;\ntx_hub.send(frame, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:190:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 190,
      "lineEnd": 198,
      "language": "rust",
      "code": "// Subscribe to RX topic\nlet rx_hub = Hub::<CanFrame>::new(\"can.can0.rx\")?;\n\nif let Some(frame) = rx_hub.recv(&mut None) {\n    println!(\"Received CAN ID 0x{:03X}: {:?}\",\n        frame.id, &frame.data[..frame.dlc as usize]);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:202:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 202,
      "lineEnd": 214,
      "language": "rust",
      "code": "// Subscribe to error topic\nlet error_hub = Hub::<CanError>::new(\"can.can0.error\")?;\n\nif let Some(error) = error_hub.recv(&mut None) {\n    match error.error_type {\n        CanError::ERROR_TX_TIMEOUT => println!(\"TX timeout\"),\n        CanError::ERROR_BUS_OFF => println!(\"Bus off\"),\n        CanError::ERROR_ACK => println!(\"No ACK received\"),\n        _ => println!(\"Error: {}\", error.error_type),\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:220:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 220,
      "lineEnd": 223,
      "language": "rust",
      "code": "can.configure_j1939();\n// Sets: 250 kbit/s, 29-bit extended IDs",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:226:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 226,
      "lineEnd": 231,
      "language": "rust",
      "code": "let mut frame = CanFrame::new(0x18FEF100, true); // PGN 65265, SA 0\nframe.data[0] = 0xFF; // Engine speed LSB\nframe.data[1] = 0xFF; // Engine speed MSB\nframe.dlc = 8;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:235:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 235,
      "lineEnd": 238,
      "language": "rust",
      "code": "can.configure_canopen(1_000_000); // 1 Mbit/s\n// Uses 11-bit IDs",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:241:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 241,
      "lineEnd": 247,
      "language": "rust",
      "code": "// NMT: Start node 5\nlet mut frame = CanFrame::new(0x000, false);\nframe.data[0] = 0x01; // Start command\nframe.data[1] = 0x05; // Node ID\nframe.dlc = 2;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:251:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 251,
      "lineEnd": 253,
      "language": "rust",
      "code": "can.configure_devicenet(125_000); // 125 kbit/s or 250k, 500k",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:259:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 259,
      "lineEnd": 270,
      "language": "rust",
      "code": "pub struct CanFrame {\n    pub id: u32,              // CAN identifier (11 or 29 bit)\n    pub is_extended: bool,    // Extended frame format\n    pub is_remote: bool,      // Remote transmission request\n    pub is_error: bool,       // Error frame\n    pub is_fd: bool,          // CAN-FD frame\n    pub data: [u8; 64],       // Data (8 bytes standard, 64 CAN-FD)\n    pub dlc: u8,              // Data length code\n    pub timestamp: u64,       // Reception time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:274:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 274,
      "lineEnd": 281,
      "language": "rust",
      "code": "pub struct CanError {\n    pub error_type: u8,       // Error type code\n    pub tx_errors: u8,        // TX error counter\n    pub rx_errors: u8,        // RX error counter\n    pub timestamp: u64,       // Error time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:285:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 285,
      "lineEnd": 295,
      "language": "rust",
      "code": "pub const ERROR_TX_TIMEOUT: u8 = 1;  // TX timeout\npub const ERROR_LOST_ARB: u8 = 2;    // Lost arbitration\npub const ERROR_CONTROLLER: u8 = 3;  // Controller problem\npub const ERROR_PROTOCOL: u8 = 4;    // Protocol violation\npub const ERROR_TRANSCEIVER: u8 = 5; // Transceiver status\npub const ERROR_NO_ACK: u8 = 6;      // No ACK\npub const ERROR_BUS_OFF: u8 = 7;     // Bus off\npub const ERROR_BUS_ERROR: u8 = 8;   // Bus error\npub const ERROR_RESTARTED: u8 = 9;   // Controller restarted",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:299:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 299,
      "lineEnd": 353,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure CAN bus\n    let mut can = CanBusNode::new(\"can0\")?;\n    can.set_bitrate(500_000);\n    can.add_filter(0x100, 0x700); // Accept 0x100-0x1FF\n    can.set_whitelist_mode();\n\n    scheduler.add(Box::new(can), 1, Some(true));\n\n    // TX node\n    let tx_node = node! {\n        name: \"can_tx\",\n        init: |ctx| {\n            ctx.log_info(\"CAN TX node initialized\");\n            Ok(())\n        },\n        tick: |ctx| {\n            // Send periodic message\n            let mut frame = CanFrame::new(0x123, false);\n            frame.data[0] = 0xAA;\n            frame.data[1] = 0xBB;\n            frame.dlc = 2;\n\n            let hub = Hub::<CanFrame>::new(\"can.can0.tx\")?;\n            hub.send(frame, &mut None).ok();\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(tx_node), 2, Some(true));\n\n    // RX node\n    let rx_node = node! {\n        name: \"can_rx\",\n        tick: |ctx| {\n            let hub = Hub::<CanFrame>::new(\"can.can0.rx\")?;\n            while let Some(frame) = hub.recv(&mut None) {\n                ctx.log_info(&format!(\n                    \"RX: ID=0x{:03X} Data={:02X?}\",\n                    frame.id, &frame.data[..frame.dlc as usize]\n                ));\n            }\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(rx_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:357:bash",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 357,
      "lineEnd": 369,
      "language": "bash",
      "code": "# Send test frame\ncansend can0 123#AABBCCDD\n\n# Monitor bus\ncandump can0\n\n# Generate random traffic\ncangen can0 -v\n\n# Replay captured traffic\ncanplayer -I captured.log",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:373:rust",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 373,
      "lineEnd": 386,
      "language": "rust",
      "code": "// Get bus statistics\nlet stats = can.get_statistics();\nprintln!(\"TX: {}, RX: {}, Errors: {}, Bus-off: {}\",\n    stats.tx_count, stats.rx_count, stats.error_count, stats.bus_off_count);\n\n// Get error counters\nlet (tx_errors, rx_errors) = can.get_error_counters();\nprintln!(\"TX errors: {}, RX errors: {}\", tx_errors, rx_errors);\n\n// Get bus load\nlet load = can.get_bus_load();\nprintln!(\"Bus load: {:.1}%\", load);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/can-bus:392:text",
      "file": "content/docs/rust/library/built-in-nodes/can-bus.mdx",
      "lineStart": 392,
      "lineEnd": 404,
      "language": "text",
      "code": "[WARN] CanBusNode: Hardware unavailable - using SIMULATION mode\n[WARN]   Tried: can0\n[WARN]   Error: No such device\n[WARN]   Fix:\n[WARN]     1. Install: sudo apt install can-utils\n[WARN]     2. Load kernel module: sudo modprobe vcan\n[WARN]     3. Create interface: sudo ip link add dev can0 type vcan\n[WARN]     4. Bring up interface: sudo ip link set up can0\n[WARN]     5. For real CAN hardware, use socketcan_interface drivers\n[WARN]     6. If using cargo: cargo build --features=\"can-hardware\"\n[WARN]        (horus run auto-detects features)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:29:yaml",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 29,
      "lineEnd": 34,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - ml-inference",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:38:bash",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 38,
      "lineEnd": 44,
      "language": "bash",
      "code": "# For OpenAI\nexport OPENAI_API_KEY=\"sk-...\"\n\n# For Anthropic\nexport ANTHROPIC_API_KEY=\"sk-ant-...\"",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:48:rust",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 48,
      "lineEnd": 64,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let llm_node = CloudLLMNode::new(\n        \"user.prompts\",\n        \"robot.responses\",\n        LLMConfig::openai_gpt4(),\n    )?;\n\n    scheduler.add(Box::new(llm_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:84:rust",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 84,
      "lineEnd": 96,
      "language": "rust",
      "code": "// OpenAI GPT-4 (most capable)\nlet config = LLMConfig::openai_gpt4();\n\n// OpenAI GPT-3.5-Turbo (faster, cheaper)\nlet config = LLMConfig::openai_gpt35_turbo();\n\n// Anthropic Claude 3.5 Sonnet\nlet config = LLMConfig::anthropic_claude_sonnet();\n\n// Anthropic Claude 3 Haiku (fastest)\nlet config = LLMConfig::anthropic_claude_haiku();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:119:rust",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 119,
      "lineEnd": 150,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::{LLMRequest, LLMResponse};\n\nstruct VoiceCommandNode {\n    prompt_pub: Hub<LLMRequest>,\n    response_sub: Hub<LLMResponse>,\n    cmd_pub: Hub<RobotCommand>,\n}\n\nimpl Node for VoiceCommandNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Send voice transcription to LLM\n        let request = LLMRequest {\n            prompt: \"User said: 'move forward two meters'\".to_string(),\n            system_prompt: Some(\n                \"You are a robot command parser. Extract the action and parameters. \\\n                 Respond with JSON: {\\\"action\\\": \\\"move\\\", \\\"distance\\\": 2.0}\".to_string()\n            ),\n            ..Default::default()\n        };\n        self.prompt_pub.send(request, &mut ctx).ok();\n\n        // Process LLM response\n        if let Some(response) = self.response_sub.recv(&mut ctx) {\n            // Parse JSON and execute command\n            if let Ok(cmd) = serde_json::from_str::<RobotCommand>(&response.content) {\n                self.cmd_pub.send(cmd, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:154:rust",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 154,
      "lineEnd": 167,
      "language": "rust",
      "code": "let config = LLMConfig {\n    model: \"gpt-4\".to_string(),\n    temperature: 0.9,  // More creative responses\n    max_history: 20,   // Remember more context\n    ..LLMConfig::openai_gpt4()\n};\n\nlet conversation_node = CloudLLMNode::new(\n    \"user.speech\",\n    \"robot.reply\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:171:rust",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 171,
      "lineEnd": 190,
      "language": "rust",
      "code": "struct TaskPlannerNode {\n    llm_pub: Hub<LLMRequest>,\n    llm_sub: Hub<LLMResponse>,\n}\n\nimpl TaskPlannerNode {\n    fn plan_task(&mut self, task: &str, ctx: &mut Option<&mut NodeInfo>) {\n        let request = LLMRequest {\n            prompt: format!(\"Plan steps to accomplish: {}\", task),\n            system_prompt: Some(\n                \"You are a robot task planner. Break down tasks into executable steps. \\\n                 Each step should be a simple action the robot can perform.\".to_string()\n            ),\n            ..Default::default()\n        };\n        self.llm_pub.send(request, ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/cloud-llm:194:rust",
      "file": "content/docs/rust/library/built-in-nodes/cloud-llm.mdx",
      "lineStart": 194,
      "lineEnd": 207,
      "language": "rust",
      "code": "let config = LLMConfig {\n    stream: true,  // Enable streaming\n    ..LLMConfig::openai_gpt4()\n};\n\n// Subscribe to streaming chunks\nlet stream_sub = Hub::<String>::new(\"robot.responses.stream\")?;\n\n// Process chunks as they arrive\nif let Some(chunk) = stream_sub.recv(&mut None) {\n    print!(\"{}\", chunk);  // Real-time output\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/collision-detector:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/collision-detector.mdx",
      "lineStart": 28,
      "lineEnd": 42,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut collision = CollisionDetectorNode::new()?;\n    collision.set_safe_distance(0.5);  // 0.5m safety margin\n    collision.enable_auto_stop(true);\n\n    scheduler.add(Box::new(collision), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/collision-detector:46:rust",
      "file": "content/docs/rust/library/built-in-nodes/collision-detector.mdx",
      "lineStart": 46,
      "lineEnd": 57,
      "language": "rust",
      "code": "let hub = Hub::<CollisionWarning>::new(\"collision.warning\")?;\n\nif let Some(warning) = hub.recv(&mut None) {\n    println!(\"Collision risk: {:?} at {:.2}m, angle {}°\",\n        warning.level, warning.distance, warning.angle);\n\n    if warning.level == WarningLevel::Critical {\n        // Emergency stop already triggered\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 28,
      "lineEnd": 45,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create DC motor node\n    let mut dc = DcMotorNode::new()?;\n    dc.set_num_motors(2);\n\n    // Configure motor 0 (L298N driver)\n    dc.set_motor_pins(0, 18, 23, 24);  // PWM, IN1, IN2\n\n    scheduler.add(Box::new(dc), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:51:bash",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 51,
      "lineEnd": 57,
      "language": "bash",
      "code": "# Install GPIO library\nsudo apt install libraspberrypi-dev\n\n# Enable GPIO and PWM\nsudo raspi-config  # Interface Options",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:61:text",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 61,
      "lineEnd": 69,
      "language": "text",
      "code": "Raspberry Pi    L298N       Motor\nGPIO 18 (PWM) --> ENA\nGPIO 23       --> IN1       Motor A+\nGPIO 24       --> IN2       Motor A-\n5V            --> +5V\nGND           --- GND\n                +12V  -->   Motor Power",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:73:text",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 73,
      "lineEnd": 84,
      "language": "text",
      "code": "Raspberry Pi    TB6612      Motors\nGPIO 18 (PWM) --> PWMA\nGPIO 23       --> AIN1      Motor A\nGPIO 24       --> AIN2\nGPIO 19 (PWM) --> PWMB\nGPIO 25       --> BIN1      Motor B\nGPIO 26       --> BIN2\n3.3V          --> VCC\nGND           --- GND\n                VM    -->   Motor Power (12V)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:94:bash",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 94,
      "lineEnd": 97,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:103:yaml",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 103,
      "lineEnd": 108,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:114:toml",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 114,
      "lineEnd": 117,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:123:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 123,
      "lineEnd": 129,
      "language": "rust",
      "code": "dc.set_driver_type(0, DriverType::L298N);\n// Dual H-bridge\n// Max current: 2A per channel\n// Logic voltage: 5V\n// Motor voltage: 5V-35V",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:133:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 133,
      "lineEnd": 140,
      "language": "rust",
      "code": "dc.set_driver_type(0, DriverType::TB6612);\n// Dual H-bridge\n// Max current: 1.2A per channel (3.2A peak)\n// Logic voltage: 3.3V/5V\n// Motor voltage: 4.5V-13.5V\n// More efficient than L298N",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:144:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 144,
      "lineEnd": 150,
      "language": "rust",
      "code": "dc.set_driver_type(0, DriverType::DRV8833);\n// Dual H-bridge\n// Max current: 1.5A per channel (2A peak)\n// Logic voltage: 3.3V/5V\n// Motor voltage: 2.7V-10.8V",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:154:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 154,
      "lineEnd": 157,
      "language": "rust",
      "code": "dc.set_driver_type(0, DriverType::Generic);\n// For other H-bridge drivers",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:163:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 163,
      "lineEnd": 176,
      "language": "rust",
      "code": "let mut dc = DcMotorNode::new()?;\n\n// Number of motors (1-8)\ndc.set_num_motors(2);\n\n// Configure each motor\ndc.set_motor_pins(\n    0,      // Motor ID\n    18,     // PWM pin\n    23,     // Direction pin 1 (IN1/AIN1)\n    24      // Direction pin 2 (IN2/AIN2)\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:180:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 180,
      "lineEnd": 188,
      "language": "rust",
      "code": "// Set PWM frequency (Hz)\ndc.set_pwm_frequency(1000);   // 1 kHz (audible)\ndc.set_pwm_frequency(20000);  // 20 kHz (ultrasonic, preferred)\n\n// Set PWM resolution\ndc.set_pwm_resolution(8);     // 8-bit (0-255)\ndc.set_pwm_resolution(10);    // 10-bit (0-1023)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:192:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 192,
      "lineEnd": 197,
      "language": "rust",
      "code": "// Invert motor direction\ndc.invert_direction(0, true);\n\n// Useful if motor wired backwards",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:201:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 201,
      "lineEnd": 207,
      "language": "rust",
      "code": "// Set minimum speed (dead zone)\ndc.set_min_speed(0, 20);  // 20% minimum\n\n// Set maximum speed\ndc.set_max_speed(0, 80);  // 80% maximum (protects motor)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:211:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 211,
      "lineEnd": 220,
      "language": "rust",
      "code": "// Enable soft start\ndc.enable_acceleration(0, true);\n\n// Set acceleration rate (% per second)\ndc.set_acceleration_rate(0, 100.0);  // Reach full speed in 1 sec\n\n// Set deceleration rate\ndc.set_deceleration_rate(0, 200.0);  // Stop in 0.5 sec",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:226:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 226,
      "lineEnd": 246,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Set motor speed (-100 to +100)\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_SPEED,\n    speed: 75,  // 75% forward\n};\n\nlet hub = Hub::<DcMotorCommand>::new(\"dc_motor.command\")?;\nhub.send(cmd, &mut None).ok();\n\n// Negative speed = reverse\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_SPEED,\n    speed: -50,  // 50% reverse\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:250:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 250,
      "lineEnd": 264,
      "language": "rust",
      "code": "// Forward\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_FORWARD,\n    speed: 60,\n};\n\n// Reverse\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_REVERSE,\n    speed: 60,\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:268:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 268,
      "lineEnd": 284,
      "language": "rust",
      "code": "// Brake (active braking, both motor leads LOW or HIGH)\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_BRAKE,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();\n\n// Coast (free-spinning, both motor leads floating)\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_COAST,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:288:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 288,
      "lineEnd": 296,
      "language": "rust",
      "code": "// Stop (gradual deceleration if acceleration enabled)\nlet cmd = DcMotorCommand {\n    motor_id: 0,\n    command_type: DcMotorCommand::CMD_STOP,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:302:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 302,
      "lineEnd": 347,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure single motor\n    let mut dc = DcMotorNode::new()?;\n    dc.set_num_motors(1);\n    dc.set_motor_pins(0, 18, 23, 24);\n    dc.set_pwm_frequency(20000);\n\n    scheduler.add(Box::new(dc), 1, Some(true));\n\n    // Control node\n    let control_node = node! {\n        name: \"motor_control\",\n        tick: |ctx| {\n            let hub = Hub::<DcMotorCommand>::new(\"dc_motor.command\")?;\n\n            // Run motor at 70% forward\n            hub.send(DcMotorCommand {\n                motor_id: 0,\n                command_type: DcMotorCommand::CMD_SPEED,\n                speed: 70,\n            }, None)?;\n\n            // Wait 2 seconds\n            std::thread::sleep(Duration::from_secs(2));\n\n            // Reverse at 50%\n            hub.send(DcMotorCommand {\n                motor_id: 0,\n                command_type: DcMotorCommand::CMD_SPEED,\n                speed: -50,\n            }, None)?;\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(control_node), 2, Some(false));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:351:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 351,
      "lineEnd": 364,
      "language": "rust",
      "code": "// Configure left and right motors\ndc.set_motor_pins(0, 18, 23, 24);  // Left motor\ndc.set_motor_pins(1, 19, 25, 26);  // Right motor\ndc.invert_direction(1, true);       // Mirror right motor\n\n// Drive forward\nhub.send(DcMotorCommand { motor_id: 0, speed: 70, ..Default::default() }, None)?;\nhub.send(DcMotorCommand { motor_id: 1, speed: 70, ..Default::default() }, None)?;\n\n// Turn right (left motor faster)\nhub.send(DcMotorCommand { motor_id: 0, speed: 80, ..Default::default() }, None)?;\nhub.send(DcMotorCommand { motor_id: 1, speed: 40, ..Default::default() }, None)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:368:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 368,
      "lineEnd": 439,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure tank drive (2 motors)\n    let mut dc = DcMotorNode::new()?;\n    dc.set_num_motors(2);\n\n    // Left motor\n    dc.set_motor_pins(0, 18, 23, 24);\n    dc.set_driver_type(0, DriverType::L298N);\n    dc.enable_acceleration(0, true);\n    dc.set_acceleration_rate(0, 150.0);\n\n    // Right motor (mirrored)\n    dc.set_motor_pins(1, 19, 25, 26);\n    dc.set_driver_type(1, DriverType::L298N);\n    dc.invert_direction(1, true);\n    dc.enable_acceleration(1, true);\n    dc.set_acceleration_rate(1, 150.0);\n\n    scheduler.add(Box::new(dc), 1, Some(true));\n\n    // Drive control node\n    let drive_node = node! {\n        name: \"tank_drive\",\n        tick: |ctx| {\n            let hub = Hub::<DcMotorCommand>::new(\"dc_motor.command\")?;\n\n            // Simple autonomous pattern\n            // Forward\n            ctx.log_info(\"Forward\");\n            hub.send(DcMotorCommand { motor_id: 0, speed: 60, ..Default::default() }, None)?;\n            hub.send(DcMotorCommand { motor_id: 1, speed: 60, ..Default::default() }, None)?;\n            std::thread::sleep(Duration::from_secs(2));\n\n            // Turn left\n            ctx.log_info(\"Turn left\");\n            hub.send(DcMotorCommand { motor_id: 0, speed: 30, ..Default::default() }, None)?;\n            hub.send(DcMotorCommand { motor_id: 1, speed: 60, ..Default::default() }, None)?;\n            std::thread::sleep(Duration::from_secs(1));\n\n            // Reverse\n            ctx.log_info(\"Reverse\");\n            hub.send(DcMotorCommand { motor_id: 0, speed: -40, ..Default::default() }, None)?;\n            hub.send(DcMotorCommand { motor_id: 1, speed: -40, ..Default::default() }, None)?;\n            std::thread::sleep(Duration::from_secs(1));\n\n            // Stop\n            ctx.log_info(\"Stop\");\n            hub.send(DcMotorCommand {\n                motor_id: 0,\n                command_type: DcMotorCommand::CMD_BRAKE,\n                ..Default::default()\n            }, None)?;\n            hub.send(DcMotorCommand {\n                motor_id: 1,\n                command_type: DcMotorCommand::CMD_BRAKE,\n                ..Default::default()\n            }, None)?;\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(drive_node), 2, Some(false));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:445:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 445,
      "lineEnd": 451,
      "language": "rust",
      "code": "pub struct DcMotorCommand {\n    pub motor_id: u8,         // Motor ID (0-7)\n    pub command_type: u8,     // Command type\n    pub speed: i8,            // Speed (-100 to +100)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:455:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 455,
      "lineEnd": 462,
      "language": "rust",
      "code": "pub const CMD_SPEED: u8 = 0;      // Set speed (signed)\npub const CMD_FORWARD: u8 = 1;    // Forward direction\npub const CMD_REVERSE: u8 = 2;    // Reverse direction\npub const CMD_BRAKE: u8 = 3;      // Active brake\npub const CMD_COAST: u8 = 4;      // Free coast\npub const CMD_STOP: u8 = 5;       // Gradual stop",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:583:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 583,
      "lineEnd": 591,
      "language": "rust",
      "code": "// This happens automatically on Ctrl+C\nfn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"DcMotorNode shutting down - stopping all motors\");\n    self.emergency_stop();  // Sets all motors to 0\n    ctx.log_info(\"All DC motors stopped safely\");\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:597:rust",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 597,
      "lineEnd": 606,
      "language": "rust",
      "code": "// In your control node\nif danger_detected {\n    hub.send(DcMotorCommand {\n        motor_id: 0,\n        command_type: DcMotorCommand::CMD_BRAKE,\n        ..Default::default()\n    }, None)?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dc-motor:612:text",
      "file": "content/docs/rust/library/built-in-nodes/dc-motor.mdx",
      "lineStart": 612,
      "lineEnd": 615,
      "language": "text",
      "code": "[12:34:56.789] [INFO] DcMotorNode shutting down - stopping all motors\n[12:34:56.790] [INFO] All DC motors stopped safely",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:30:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 30,
      "lineEnd": 63,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Option 1: Simple setup with camera model preset\n    let camera = DepthCameraNode::new(CameraModel::RealSenseD435)?;\n\n    // Option 2: Builder pattern with custom configuration\n    let camera = DepthCameraNode::builder()\n        .model(CameraModel::RealSenseD435)\n        .resolution(640, 480)\n        .frame_rate(30)\n        .enable_point_cloud(true)\n        .build()?;\n\n    scheduler.add(Box::new(camera), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n// Subscribe to depth data in another node:\nlet depth_hub = Hub::<DepthImage>::new(\"depth_camera.depth.image\")?;\nif let Some(depth) = depth_hub.recv(&mut ctx) {\n    println!(\"Depth image: {}x{}\", depth.width, depth.height);\n}\n\n// Subscribe to point cloud:\nlet pc_hub = Hub::<PointCloud>::new(\"depth_camera.pointcloud\")?;\nif let Some(pc) = pc_hub.recv(&mut ctx) {\n    println!(\"Point cloud: {} points\", pc.points.len());\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:83:bash",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 83,
      "lineEnd": 92,
      "language": "bash",
      "code": "# Install librealsense2\nsudo apt install librealsense2-dkms librealsense2-utils\n\n# Verify camera connection\nrealsense-viewer\n\n# Check USB permissions\nsudo usermod -a -G video $USER",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:102:bash",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 102,
      "lineEnd": 105,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: realsense)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:111:yaml",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 111,
      "lineEnd": 116,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - realsense  # or zed for Stereolabs cameras",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:122:toml",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 122,
      "lineEnd": 125,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"realsense\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:131:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 131,
      "lineEnd": 144,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with specific camera model\nlet mut camera = DepthCameraNode::new(CameraModel::RealSenseD435)?;\n\n// Use builder for advanced configuration\nlet camera = DepthCameraNode::builder()\n    .model(CameraModel::RealSenseD435)\n    .resolution(1280, 720)\n    .frame_rate(30)\n    .enable_point_cloud(true)\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:148:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 148,
      "lineEnd": 167,
      "language": "rust",
      "code": "// Set resolution\ncamera.set_resolution(1280, 720);\ncamera.set_depth_resolution(640, 480);\n\n// Set frame rate\ncamera.set_frame_rate(30);\n\n// Set depth range (meters)\ncamera.set_depth_range(0.3, 10.0);\n\n// Enable features\ncamera.enable_point_cloud(true);\ncamera.enable_depth_alignment(true);\n\n// Post-processing filters\ncamera.set_spatial_filter(true);\ncamera.set_temporal_filter(true);\ncamera.set_hole_filling(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:196:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 196,
      "lineEnd": 211,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create depth camera node\n    let mut camera = DepthCameraNode::new(CameraModel::RealSenseD435)?;\n    camera.set_resolution(640, 480);\n    camera.set_frame_rate(30);\n\n    scheduler.add(Box::new(camera), 30, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:215:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 215,
      "lineEnd": 254,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct ObstacleDetector {\n    depth_sub: Hub<DepthImage>,\n    min_distance: f32,\n}\n\nimpl ObstacleDetector {\n    fn new(min_distance: f32) -> Result<Self, Box<dyn std::error::Error>> {\n        Ok(Self {\n            depth_sub: Hub::new(\"depth_camera.depth.image\")?,\n            min_distance,\n        })\n    }\n}\n\nimpl Node for ObstacleDetector {\n    fn name(&self) -> &'static str { \"ObstacleDetector\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(depth) = self.depth_sub.recv(&mut ctx) {\n            // Check center region for obstacles\n            let center_x = depth.width / 2;\n            let center_y = depth.height / 2;\n\n            // Get depth at center (implementation depends on encoding)\n            let center_depth = get_depth_at(&depth, center_x, center_y);\n\n            if center_depth < self.min_distance && center_depth > 0.0 {\n                if let Some(ctx) = ctx.as_mut() {\n                    ctx.log_warning(&format!(\n                        \"Obstacle detected at {:.2}m!\", center_depth\n                    ));\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:258:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 258,
      "lineEnd": 276,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Enable point cloud generation\n    let camera = DepthCameraNode::builder()\n        .model(CameraModel::RealSenseD435)\n        .resolution(640, 480)\n        .frame_rate(15)  // Lower rate for point cloud processing\n        .enable_point_cloud(true)\n        .build()?;\n\n    scheduler.add(Box::new(camera), 15, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:280:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 280,
      "lineEnd": 289,
      "language": "rust",
      "code": "let camera = DepthCameraNode::builder()\n    .model(CameraModel::RealSenseD435)\n    .with_closure(|mut depth: DepthImage| {\n        // Filter out far distances\n        depth.max_depth = 5.0;  // Limit to 5 meters\n        depth\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:295:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 295,
      "lineEnd": 305,
      "language": "rust",
      "code": "pub struct DepthImage {\n    pub width: u32,\n    pub height: u32,\n    pub encoding: u8,        // Depth encoding (16UC1, 32FC1)\n    pub data: Vec<u8>,       // Raw depth data\n    pub min_depth: f32,      // Minimum valid depth (meters)\n    pub max_depth: f32,      // Maximum valid depth (meters)\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:309:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 309,
      "lineEnd": 317,
      "language": "rust",
      "code": "pub struct PointCloud {\n    pub width: u32,\n    pub height: u32,\n    pub points: Vec<Point3D>,  // XYZ positions\n    pub colors: Vec<[u8; 3]>,  // RGB colors (optional)\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:323:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 323,
      "lineEnd": 327,
      "language": "rust",
      "code": "// Best for: Indoor navigation, manipulation\nlet mut camera = DepthCameraNode::new(CameraModel::RealSenseD435)?;\n// Defaults: 1280x720 @ 30fps, 0.3-10m range",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:331:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 331,
      "lineEnd": 335,
      "language": "rust",
      "code": "// Best for: High-precision scanning, small object detection\nlet mut camera = DepthCameraNode::new(CameraModel::RealSenseL515)?;\n// Defaults: 1024x768 @ 30fps, LiDAR-based, +/-5mm accuracy",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:339:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 339,
      "lineEnd": 343,
      "language": "rust",
      "code": "// Best for: Body tracking, large FOV applications\nlet mut camera = DepthCameraNode::new(CameraModel::AzureKinect)?;\n// Defaults: 1024x1024 @ 30fps, ToF, 0.25-5.46m range",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:361:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 361,
      "lineEnd": 370,
      "language": "rust",
      "code": "// Reduce resolution\ncamera.set_resolution(640, 480);\n\n// Disable point cloud if not needed\ncamera.enable_point_cloud(false);\n\n// Use depth-only mode\ncamera.enable_rgb(false);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:375:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 375,
      "lineEnd": 380,
      "language": "rust",
      "code": "// Enable post-processing filters\ncamera.set_spatial_filter(true);\ncamera.set_temporal_filter(true);\ncamera.set_hole_filling(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-camera:399:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-camera.mdx",
      "lineStart": 399,
      "lineEnd": 405,
      "language": "rust",
      "code": "// Force simulation mode\nlet mut camera = DepthCameraNode::new_with_backend(\n    CameraModel::RealSenseD435,\n    DepthBackend::Simulation\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:29:yaml",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 29,
      "lineEnd": 34,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:38:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 38,
      "lineEnd": 55,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let depth_node = DepthEstimationNode::new(\n        \"models/midas_v21_384.onnx\",\n        \"camera.raw\",        // Input image topic\n        \"vision.depth\",      // Output depth topic\n        DepthConfig::midas_v21(),\n    )?;\n\n    scheduler.add(Box::new(depth_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:80:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 80,
      "lineEnd": 94,
      "language": "rust",
      "code": "let config = DepthConfig {\n    model_type: DepthModelType::MiDaSLarge,\n    input_size: [384, 384],\n    use_gpu: true,\n    device_id: 0,\n    num_threads: 4,\n    metric_depth: false,      // Relative (0-1) vs metric (meters)\n    depth_scale: 1.0,\n    min_depth: 0.1,           // Minimum depth (meters)\n    max_depth: 100.0,         // Maximum depth (meters)\n    enable_visualization: true,\n    invert_depth: true,       // MiDaS outputs inverse depth\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:130:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 130,
      "lineEnd": 145,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides DepthImage;\n\nlet depth_hub = Hub::<DepthImage>::new(\"vision.depth\")?;\n\nif let Some(depth) = depth_hub.recv(&mut None) {\n    println!(\"Depth map: {}x{}\", depth.width, depth.height);\n\n    // Access depth at pixel (x, y)\n    let x = 320;\n    let y = 240;\n    let idx = y as usize * depth.width as usize + x as usize;\n    let depth_mm = depth.depths[idx];\n    println!(\"Depth at ({}, {}): {} mm\", x, y, depth_mm);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:149:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 149,
      "lineEnd": 161,
      "language": "rust",
      "code": "// Use depth for simple obstacle detection\nfn check_obstacles(depth: &DepthImage, threshold_mm: u16) -> bool {\n    let center_region = get_center_region(depth, 0.3); // Center 30%\n\n    for &d in &center_region {\n        if d < threshold_mm && d > 0 {\n            return true; // Obstacle detected\n        }\n    }\n    false\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:165:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 165,
      "lineEnd": 176,
      "language": "rust",
      "code": "// Configure for navigation (metric depth)\nlet config = DepthConfig::depth_anything_small()\n    .metric_depth = true;\n\nlet depth_node = DepthEstimationNode::new(\n    \"models/depth_anything_small.onnx\",\n    \"camera.front\",\n    \"navigation.depth\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:180:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 180,
      "lineEnd": 193,
      "language": "rust",
      "code": "let config = DepthConfig {\n    use_gpu: true,\n    device_id: 0,\n    ..DepthConfig::midas_v21()\n};\n\nlet depth_node = DepthEstimationNode::new(\n    \"models/midas_v21_384.onnx\",\n    \"camera.raw\",\n    \"vision.depth\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:199:bash",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 199,
      "lineEnd": 211,
      "language": "bash",
      "code": "# MiDaS v2.1 Small (fast)\nwget https://github.com/isl-org/MiDaS/releases/download/v2_1/midas_v21_small_256.onnx\n\n# MiDaS v2.1 (balanced)\nwget https://github.com/isl-org/MiDaS/releases/download/v2_1/midas_v21_384.onnx\n\n# MiDaS DPT-Large (highest quality)\nwget https://github.com/isl-org/MiDaS/releases/download/v3_1/dpt_large_384.onnx\n\n# Depth Anything (convert from PyTorch)\n# See: https://github.com/LiheYoung/Depth-Anything",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:235:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 235,
      "lineEnd": 244,
      "language": "rust",
      "code": "// Combine depth with camera intrinsics for 3D point cloud\nlet depth_sub = Hub::<DepthImage>::new(\"vision.depth\")?;\nlet pointcloud_pub = Hub::<PointCloud2>::new(\"vision.pointcloud\")?;\n\nif let Some(depth) = depth_sub.recv(&mut ctx) {\n    let cloud = depth_to_pointcloud(&depth, &camera_intrinsics);\n    pointcloud_pub.send(cloud, &mut ctx).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/depth-estimation:248:rust",
      "file": "content/docs/rust/library/built-in-nodes/depth-estimation.mdx",
      "lineStart": 248,
      "lineEnd": 262,
      "language": "rust",
      "code": "// Use with SafetyMonitorNode for collision avoidance\nlet depth_node = DepthEstimationNode::new(\n    \"models/midas_small.onnx\",\n    \"camera.front\",\n    \"safety.depth\",\n    DepthConfig::midas_small(),\n)?;\n\nlet safety = SafetyMonitorNode::new(\n    SafetyConfig::default()\n        .with_depth_topic(\"safety.depth\")\n        .with_min_clearance(0.5),  // 50cm minimum\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:26:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 26,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    let mut diff_drive = DifferentialDriveNode::new()?;\n    diff_drive.set_wheel_base(0.3);           // 0.3m between wheels\n    diff_drive.set_wheel_radius(0.05);        // 0.05m wheel radius\n    diff_drive.set_velocity_limits(1.0, 2.0); // 1 m/s linear, 2 rad/s angular\n\n    scheduler.add(Box::new(diff_drive), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n// Send velocity commands in another node:\nlet cmd_hub = Hub::<Twist>::new(\"cmd_vel\")?;\n\n// Drive forward at 0.5 m/s\ncmd_hub.send(Twist::new([0.5, 0.0, 0.0], [0.0, 0.0, 0.0]), None)?;",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:56:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 56,
      "lineEnd": 68,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topics (\"cmd_vel\", \"drive_command\", \"odom\")\nlet mut diff_drive = DifferentialDriveNode::new()?;\n\n// Create with custom topics\nlet mut diff_drive = DifferentialDriveNode::new_with_topics(\n    \"robot.cmd_vel\",      // Command input topic\n    \"robot.drive\",        // Drive output topic\n    \"robot.odom\"          // Odometry output topic\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:72:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 72,
      "lineEnd": 85,
      "language": "rust",
      "code": "// Physical dimensions\ndiff_drive.set_wheel_base(0.25);         // Distance between wheels (m)\ndiff_drive.set_wheel_radius(0.04);       // Wheel radius (m)\n\n// Velocity limits (combined method)\ndiff_drive.set_velocity_limits(1.5, 2.0); // Max linear (m/s), max angular (rad/s)\n\n// Reset odometry to origin\ndiff_drive.reset_odometry();\n\n// Get current position (x, y, orientation)\nlet (x, y, theta) = diff_drive.get_position();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:115:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 115,
      "lineEnd": 131,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nlet hub = Hub::<Twist>::new(\"cmd_vel\")?;\n\n// Drive forward at 0.5 m/s\nhub.send(Twist::new([0.5, 0.0, 0.0], [0.0, 0.0, 0.0]), None)?;\n\n// Turn in place (rotate left at 1 rad/s)\nhub.send(Twist::new([0.0, 0.0, 0.0], [0.0, 0.0, 1.0]), None)?;\n\n// Arc turn (forward + rotate)\nhub.send(Twist::new([0.3, 0.0, 0.0], [0.0, 0.0, 0.5]), None)?;\n\n// Stop\nhub.send(Twist::default(), None)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:135:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 135,
      "lineEnd": 161,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Differential drive controller\n    let mut diff_drive = DifferentialDriveNode::new()?;\n    diff_drive.set_wheel_base(0.25);\n    diff_drive.set_wheel_radius(0.04);\n    diff_drive.set_velocity_limits(1.0, 2.0);\n\n    // Encoders for feedback\n    let mut left_encoder = EncoderNode::new_with_topic(\"left_encoder\")?;\n    left_encoder.set_encoder_config(1024.0, 0.04, 1.0);\n\n    let mut right_encoder = EncoderNode::new_with_topic(\"right_encoder\")?;\n    right_encoder.set_encoder_config(1024.0, 0.04, 1.0);\n\n    scheduler.add(Box::new(diff_drive), 50, Some(true));\n    scheduler.add(Box::new(left_encoder), 50, Some(true));\n    scheduler.add(Box::new(right_encoder), 50, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:165:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 165,
      "lineEnd": 190,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct JoystickToDrive {\n    joy_sub: Hub<JoystickEvent>,\n    cmd_pub: Hub<Twist>,\n    max_linear: f64,\n    max_angular: f64,\n}\n\nimpl Node for JoystickToDrive {\n    fn name(&self) -> &'static str { \"JoystickToDrive\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(joy) = self.joy_sub.recv(&mut ctx) {\n            // Left stick Y = forward/backward\n            // Right stick X = turn\n            let linear = joy.axes[1] * self.max_linear;\n            let angular = -joy.axes[2] * self.max_angular;\n\n            let cmd = Twist::new([linear, 0.0, 0.0], [0.0, 0.0, angular]);\n            let _ = self.cmd_pub.send(cmd, None);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:196:text",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 196,
      "lineEnd": 199,
      "language": "text",
      "code": "v_left  = linear_x - (angular_z * wheel_base / 2)\nv_right = linear_x + (angular_z * wheel_base / 2)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:203:text",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 203,
      "lineEnd": 206,
      "language": "text",
      "code": "linear_x  = (v_left + v_right) / 2\nangular_z = (v_right - v_left) / wheel_base",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:212:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 212,
      "lineEnd": 218,
      "language": "rust",
      "code": "pub struct Twist {\n    pub linear: [f64; 3],   // [x, y, z] velocity in m/s\n    pub angular: [f64; 3],  // [roll, pitch, yaw] velocity in rad/s\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/differential-drive:230:rust",
      "file": "content/docs/rust/library/built-in-nodes/differential-drive.mdx",
      "lineStart": 230,
      "lineEnd": 239,
      "language": "rust",
      "code": "// This happens automatically on Ctrl+C\nfn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    ctx.log_info(\"DifferentialDriveNode shutting down - stopping drive motors\");\n    // Publish stop command to motors\n    self.publish_drive_command(0.0, 0.0);\n    ctx.log_info(\"Differential drive motors stopped safely\");\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/digital-io:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/digital-io.mdx",
      "lineStart": 28,
      "lineEnd": 42,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut gpio = DigitalIONode::new()?;\n    gpio.configure_input(17, PullMode::PullUp);   // Button\n    gpio.configure_output(27);                     // LED\n\n    scheduler.add(Box::new(gpio), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/digital-io:54:bash",
      "file": "content/docs/rust/library/built-in-nodes/digital-io.mdx",
      "lineStart": 54,
      "lineEnd": 57,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/digital-io:63:yaml",
      "file": "content/docs/rust/library/built-in-nodes/digital-io.mdx",
      "lineStart": 63,
      "lineEnd": 68,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/digital-io:74:toml",
      "file": "content/docs/rust/library/built-in-nodes/digital-io.mdx",
      "lineStart": 74,
      "lineEnd": 77,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/digital-io:81:rust",
      "file": "content/docs/rust/library/built-in-nodes/digital-io.mdx",
      "lineStart": 81,
      "lineEnd": 88,
      "language": "rust",
      "code": "// Configure input with pull-up\ngpio.configure_input(17, PullMode::PullUp);\ngpio.enable_debounce(17, 50);  // 50ms debounce\n\n// Configure output\ngpio.configure_output(27);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/digital-io:92:rust",
      "file": "content/docs/rust/library/built-in-nodes/digital-io.mdx",
      "lineStart": 92,
      "lineEnd": 107,
      "language": "rust",
      "code": "// Read input\nlet input_hub = Hub::<GpioInput>::new(\"gpio.input\")?;\nif let Some(input) = input_hub.recv(&mut None) {\n    if input.pin == 17 && input.value == false {\n        println!(\"Button pressed!\");\n    }\n}\n\n// Set output\nlet output_hub = Hub::<GpioOutput>::new(\"gpio.output\")?;\noutput_hub.send(GpioOutput {\n    pin: 27,\n    value: true,  // LED on\n}, None)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:30:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 30,
      "lineEnd": 48,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create Dynamixel node\n    let mut dxl = DynamixelNode::new(\"/dev/ttyUSB0\")?;\n    dxl.set_baud_rate(1_000_000);  // 1 Mbps\n    dxl.set_protocol_version(2.0);  // Protocol 2.0\n\n    // Add servo ID 1 (XM430-W350)\n    dxl.add_servo(1, DynamixelModel::XM430_W350);\n\n    scheduler.add(Box::new(dxl), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:54:bash",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 54,
      "lineEnd": 63,
      "language": "bash",
      "code": "# Install USB-serial drivers\nsudo apt install setserial\n\n# Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# Verify port\nls -l /dev/ttyUSB*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:67:text",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 67,
      "lineEnd": 72,
      "language": "text",
      "code": "USB2Dynamixel    Servo 1    Servo 2    Servo 3\n    DATA   -->   DATA  -->  DATA  -->  DATA\n    VDD    -->   VDD   -->  VDD   -->  VDD\n    GND    -->   GND   -->  GND   -->  GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:82:text",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 82,
      "lineEnd": 84,
      "language": "text",
      "code": "Computer USB  -->  U2D2  -->  Dynamixel Bus",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:94:bash",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 94,
      "lineEnd": 97,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: serial-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:103:yaml",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 103,
      "lineEnd": 108,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - serial-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:114:toml",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 114,
      "lineEnd": 117,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"serial-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:123:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 123,
      "lineEnd": 129,
      "language": "rust",
      "code": "DynamixelModel::AX12A      // Entry-level (0-300°)\nDynamixelModel::AX18A      // Higher torque\nDynamixelModel::MX28       // Mid-range (0-360° or continuous)\nDynamixelModel::MX64       // High torque\nDynamixelModel::MX106      // Very high torque",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:133:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 133,
      "lineEnd": 159,
      "language": "rust",
      "code": "// XL Series (Budget)\nDynamixelModel::XL320      // Tiny (9V max)\nDynamixelModel::XL430      // Compact\n\n// XM Series (Performance)\nDynamixelModel::XM430_W210 // 4.1 Nm\nDynamixelModel::XM430_W350 // 4.2 Nm\nDynamixelModel::XM540_W270 // 10.6 Nm\n\n// XH Series (High-Performance)\nDynamixelModel::XH430_V210 // Position feedback\nDynamixelModel::XH430_W350\nDynamixelModel::XH540_W270\n\n// XC/XW Series (Industrial)\nDynamixelModel::XC430_W150 // Compact\nDynamixelModel::XW540_T260 // High torque\n\n// P Series (Modular)\nDynamixelModel::PH42_020   // 42mm frame\nDynamixelModel::PH54_100   // 54mm frame\n\n// PRO Series (Industrial)\nDynamixelModel::PRO_M42\nDynamixelModel::PRO_M54",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:165:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 165,
      "lineEnd": 176,
      "language": "rust",
      "code": "let mut dxl = DynamixelNode::new(\"/dev/ttyUSB0\")?;\n\n// Set communication parameters\ndxl.set_baud_rate(1_000_000);    // 1 Mbps (standard)\ndxl.set_baud_rate(3_000_000);    // 3 Mbps (fast)\ndxl.set_baud_rate(4_500_000);    // 4.5 Mbps (maximum)\n\n// Set protocol version\ndxl.set_protocol_version(1.0);   // Legacy servos\ndxl.set_protocol_version(2.0);   // Modern servos",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:180:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 180,
      "lineEnd": 191,
      "language": "rust",
      "code": "// Add servos by ID and model\ndxl.add_servo(1, DynamixelModel::XM430_W350);\ndxl.add_servo(2, DynamixelModel::XM430_W350);\ndxl.add_servo(3, DynamixelModel::XM540_W270);\n\n// Scan for servos\nlet found_servos = dxl.scan_servos()?;\nfor servo in found_servos {\n    println!(\"Found servo ID {} (model: {})\", servo.id, servo.model);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:195:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 195,
      "lineEnd": 210,
      "language": "rust",
      "code": "// Position control mode (default)\ndxl.set_operating_mode(1, OperatingMode::Position);\n\n// Extended position mode (multi-turn)\ndxl.set_operating_mode(1, OperatingMode::ExtendedPosition);\n\n// Velocity control mode\ndxl.set_operating_mode(1, OperatingMode::Velocity);\n\n// Current control mode (torque)\ndxl.set_operating_mode(1, OperatingMode::Current);\n\n// PWM control mode (voltage)\ndxl.set_operating_mode(1, OperatingMode::PWM);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:214:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 214,
      "lineEnd": 223,
      "language": "rust",
      "code": "// Set position PID gains\ndxl.set_position_p_gain(1, 800);\ndxl.set_position_i_gain(1, 0);\ndxl.set_position_d_gain(1, 0);\n\n// Set velocity PI gains\ndxl.set_velocity_p_gain(1, 100);\ndxl.set_velocity_i_gain(1, 1920);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:227:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 227,
      "lineEnd": 240,
      "language": "rust",
      "code": "// Set position limits (encoder units)\ndxl.set_min_position(1, 0);\ndxl.set_max_position(1, 4095);  // AX/MX: 0-4095\n\n// Set velocity limit\ndxl.set_velocity_limit(1, 50);  // Rev/min\n\n// Set current limit (torque)\ndxl.set_current_limit(1, 1193);  // mA\n\n// Temperature limit\ndxl.set_temperature_limit(1, 80);  // °C",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:246:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 246,
      "lineEnd": 268,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create position command\nlet cmd = DynamixelCommand {\n    servo_id: 1,\n    command_type: DynamixelCommand::CMD_POSITION,\n    goal_position: 2048,  // Center position\n    profile_velocity: 50,\n    profile_acceleration: 10,\n};\n\n// Send command\nlet hub = Hub::<DynamixelCommand>::new(\"dynamixel.command\")?;\nhub.send(cmd, &mut None).ok();\n\n// Read status\nlet status_hub = Hub::<DynamixelStatus>::new(\"dynamixel.status\")?;\nif let Some(status) = status_hub.recv(&mut None) {\n    println!(\"Servo {}: position = {}, load = {}%\",\n        status.servo_id, status.present_position, status.present_load);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:272:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 272,
      "lineEnd": 281,
      "language": "rust",
      "code": "// Set velocity (rev/min)\nlet cmd = DynamixelCommand {\n    servo_id: 1,\n    command_type: DynamixelCommand::CMD_VELOCITY,\n    goal_velocity: 50,  // 50 RPM\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:285:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 285,
      "lineEnd": 294,
      "language": "rust",
      "code": "// Set current (mA)\nlet cmd = DynamixelCommand {\n    servo_id: 1,\n    command_type: DynamixelCommand::CMD_CURRENT,\n    goal_current: 500,  // 500 mA\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:298:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 298,
      "lineEnd": 308,
      "language": "rust",
      "code": "// Move multiple servos simultaneously\nlet sync_cmd = DynamixelSyncWrite {\n    servo_ids: vec![1, 2, 3, 4],\n    positions: vec![1024, 2048, 3072, 2048],\n    velocities: vec![50, 50, 50, 50],\n};\n\nlet hub = Hub::<DynamixelSyncWrite>::new(\"dynamixel.sync_write\")?;\nhub.send(sync_cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:312:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 312,
      "lineEnd": 330,
      "language": "rust",
      "code": "// Read multiple servo states efficiently\nlet bulk_read = DynamixelBulkRead {\n    servo_ids: vec![1, 2, 3, 4],\n};\n\nlet hub = Hub::<DynamixelBulkRead>::new(\"dynamixel.bulk_read\")?;\nhub.send(bulk_read, &mut None).ok();\n\n// Receive results\nlet result_hub = Hub::<DynamixelBulkReadResult>::new(\"dynamixel.bulk_result\")?;\nif let Some(result) = result_hub.recv(&mut None) {\n    for status in result.statuses {\n        println!(\"Servo {}: pos={}, vel={}, current={}\",\n            status.servo_id, status.present_position,\n            status.present_velocity, status.present_current);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:334:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 334,
      "lineEnd": 424,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure 5-DOF arm\n    let mut dxl = DynamixelNode::new(\"/dev/ttyUSB0\")?;\n    dxl.set_baud_rate(1_000_000);\n    dxl.set_protocol_version(2.0);\n\n    // Add servos\n    dxl.add_servo(1, DynamixelModel::XM540_W270); // Base\n    dxl.add_servo(2, DynamixelModel::XM430_W350); // Shoulder\n    dxl.add_servo(3, DynamixelModel::XM430_W350); // Elbow\n    dxl.add_servo(4, DynamixelModel::XM430_W210); // Wrist1\n    dxl.add_servo(5, DynamixelModel::XM430_W210); // Wrist2\n\n    // Configure all servos\n    for id in 1..=5 {\n        dxl.set_operating_mode(id, OperatingMode::ExtendedPosition);\n        dxl.set_velocity_limit(id, 50);\n        dxl.set_current_limit(id, 1000);\n        dxl.set_temperature_limit(id, 75);\n    }\n\n    scheduler.add(Box::new(dxl), 1, Some(true));\n\n    // Arm control node\n    let arm_node = node! {\n        name: \"arm_control\",\n        init: |ctx| {\n            // Enable torque on all servos\n            let hub = Hub::<DynamixelCommand>::new(\"dynamixel.command\")?;\n\n            for id in 1..=5 {\n                hub.send(DynamixelCommand {\n                    servo_id: id,\n                    command_type: DynamixelCommand::CMD_TORQUE_ENABLE,\n                    ..Default::default()\n                }, None)?;\n            }\n\n            ctx.log_info(\"Arm initialized\");\n            Ok(())\n        },\n        tick: |ctx| {\n            let hub = Hub::<DynamixelCommand>::new(\"dynamixel.command\")?;\n\n            // Move to home position\n            let home_positions = vec![2048, 1024, 2048, 2048, 2048];\n\n            for (idx, &pos) in home_positions.iter().enumerate() {\n                hub.send(DynamixelCommand {\n                    servo_id: (idx + 1) as u8,\n                    command_type: DynamixelCommand::CMD_POSITION,\n                    goal_position: pos,\n                    profile_velocity: 30,\n                    profile_acceleration: 10,\n                }, None)?;\n            }\n\n            // Monitor servo status\n            let status_hub = Hub::<DynamixelStatus>::new(\"dynamixel.status\")?;\n            while let Some(status) = status_hub.recv(&mut None) {\n                // Check for errors\n                if status.hardware_error != 0 {\n                    ctx.log_error(&format!(\n                        \"Servo {} error: 0x{:02X}\",\n                        status.servo_id, status.hardware_error\n                    ));\n                }\n\n                // Check temperature\n                if status.present_temperature > 70 {\n                    ctx.log_warning(&format!(\n                        \"Servo {} hot: {}°C\",\n                        status.servo_id, status.present_temperature\n                    ));\n                }\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(arm_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:430:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 430,
      "lineEnd": 440,
      "language": "rust",
      "code": "pub struct DynamixelCommand {\n    pub servo_id: u8,           // Servo ID (1-253)\n    pub command_type: u8,       // Command type\n    pub goal_position: i32,     // Target position\n    pub goal_velocity: i32,     // Target velocity\n    pub goal_current: i16,      // Target current\n    pub profile_velocity: u32,  // Motion profile velocity\n    pub profile_acceleration: u32, // Motion profile acceleration\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:444:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 444,
      "lineEnd": 454,
      "language": "rust",
      "code": "pub const CMD_POSITION: u8 = 0;\npub const CMD_VELOCITY: u8 = 1;\npub const CMD_CURRENT: u8 = 2;\npub const CMD_PWM: u8 = 3;\npub const CMD_TORQUE_ENABLE: u8 = 4;\npub const CMD_TORQUE_DISABLE: u8 = 5;\npub const CMD_LED_ON: u8 = 6;\npub const CMD_LED_OFF: u8 = 7;\npub const CMD_REBOOT: u8 = 8;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:458:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 458,
      "lineEnd": 471,
      "language": "rust",
      "code": "pub struct DynamixelStatus {\n    pub servo_id: u8,\n    pub present_position: i32,\n    pub present_velocity: i32,\n    pub present_current: i16,\n    pub present_voltage: f32,      // Volts\n    pub present_temperature: u8,   // °C\n    pub present_load: i16,         // %\n    pub moving: bool,\n    pub hardware_error: u8,\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:475:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 475,
      "lineEnd": 481,
      "language": "rust",
      "code": "pub const ERROR_INPUT_VOLTAGE: u8 = 0x01;\npub const ERROR_OVERHEATING: u8 = 0x04;\npub const ERROR_MOTOR_ENCODER: u8 = 0x08;\npub const ERROR_ELECTRICAL_SHOCK: u8 = 0x10;\npub const ERROR_OVERLOAD: u8 = 0x20;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:487:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 487,
      "lineEnd": 496,
      "language": "rust",
      "code": "// Set compliance (stiffness) for AX/MX series\ndxl.set_cw_compliance_margin(1, 1);\ndxl.set_ccw_compliance_margin(1, 1);\ndxl.set_cw_compliance_slope(1, 32);\ndxl.set_ccw_compliance_slope(1, 32);\n\n// Lower slope = stiffer\n// Higher slope = more compliant",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:500:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 500,
      "lineEnd": 506,
      "language": "rust",
      "code": "// Trapezoidal velocity profile\ndxl.set_profile_velocity(1, 50);      // Max velocity\ndxl.set_profile_acceleration(1, 10);  // Acceleration rate\n\n// Motion will smoothly accelerate and decelerate",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:510:rust",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 510,
      "lineEnd": 514,
      "language": "rust",
      "code": "// Create custom register layouts for efficient bulk operations\ndxl.setup_indirect_address(1, 0, ADDR_GOAL_POSITION);\ndxl.setup_indirect_address(1, 1, ADDR_GOAL_VELOCITY);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/dynamixel:525:bash",
      "file": "content/docs/rust/library/built-in-nodes/dynamixel.mdx",
      "lineStart": 525,
      "lineEnd": 528,
      "language": "bash",
      "code": "# Available from ROBOTIS website\n# Runs on Windows/Linux/Mac",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:37:yaml",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 37,
      "lineEnd": 42,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:46:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 46,
      "lineEnd": 63,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let embedding_node = EmbeddingNode::new(\n        \"models/clip_vit_b32_visual.onnx\",\n        \"camera.raw\",           // Input image topic\n        \"vision.embeddings\",    // Output embeddings topic\n        EmbeddingConfig::clip_vit_b32(),\n    )?;\n\n    scheduler.add(Box::new(embedding_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:94:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 94,
      "lineEnd": 106,
      "language": "rust",
      "code": "let config = EmbeddingConfig {\n    model_type: EmbeddingModelType::ClipVitB32,\n    input_size: [224, 224],\n    embedding_dim: 512,\n    use_gpu: true,\n    device_id: 0,\n    num_threads: 4,\n    normalize: true,  // L2 normalization\n    normalize_mean: [0.48145466, 0.4578275, 0.40821073],\n    normalize_std: [0.26862954, 0.26130258, 0.27577711],\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:139:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 139,
      "lineEnd": 149,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::EmbeddingVector;\n\nlet embedding_hub = Hub::<EmbeddingVector>::new(\"vision.embeddings\")?;\n\nif let Some(emb) = embedding_hub.recv(&mut None) {\n    println!(\"Embedding: {} dimensions\", emb.data.len());\n    println!(\"Model: {}\", emb.model_name);\n    println!(\"Normalized: {}\", emb.normalized);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:153:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 153,
      "lineEnd": 182,
      "language": "rust",
      "code": "// Store reference embeddings\nlet mut database: Vec<(String, Vec<f32>)> = Vec::new();\n\n// Add reference images\ndatabase.push((\"kitchen\".to_string(), kitchen_embedding));\ndatabase.push((\"hallway\".to_string(), hallway_embedding));\n\n// Find most similar\nfn find_similar(query: &[f32], database: &[(String, Vec<f32>)]) -> &str {\n    let mut best_score = -1.0;\n    let mut best_match = \"\";\n\n    for (name, db_emb) in database {\n        let similarity = cosine_similarity(query, db_emb);\n        if similarity > best_score {\n            best_score = similarity;\n            best_match = name;\n        }\n    }\n    best_match\n}\n\nfn cosine_similarity(a: &[f32], b: &[f32]) -> f32 {\n    let dot: f32 = a.iter().zip(b).map(|(x, y)| x * y).sum();\n    let norm_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();\n    let norm_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();\n    dot / (norm_a * norm_b)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:186:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 186,
      "lineEnd": 205,
      "language": "rust",
      "code": "// Use embeddings for loop closure detection in SLAM\nstruct PlaceRecognition {\n    embedding_sub: Hub<EmbeddingVector>,\n    keyframes: Vec<(u64, Vec<f32>)>,  // (timestamp, embedding)\n    threshold: f32,\n}\n\nimpl PlaceRecognition {\n    fn check_loop_closure(&mut self, current: &EmbeddingVector) -> Option<u64> {\n        for (timestamp, keyframe_emb) in &self.keyframes {\n            let similarity = cosine_similarity(&current.data, keyframe_emb);\n            if similarity > self.threshold {\n                return Some(*timestamp);  // Loop closure detected!\n            }\n        }\n        None\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:209:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 209,
      "lineEnd": 233,
      "language": "rust",
      "code": "// CLIP enables zero-shot classification by comparing\n// image embeddings with text embeddings\n\n// Pre-compute text embeddings for classes\nlet class_embeddings = vec![\n    (\"person\", person_text_embedding),\n    (\"robot\", robot_text_embedding),\n    (\"obstacle\", obstacle_text_embedding),\n];\n\nfn classify(image_emb: &[f32], classes: &[(&str, Vec<f32>)]) -> &str {\n    let mut best_score = -1.0;\n    let mut best_class = \"\";\n\n    for (class_name, class_emb) in classes {\n        let score = cosine_similarity(image_emb, class_emb);\n        if score > best_score {\n            best_score = score;\n            best_class = class_name;\n        }\n    }\n    best_class\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:237:rust",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 237,
      "lineEnd": 250,
      "language": "rust",
      "code": "let config = EmbeddingConfig {\n    use_gpu: true,\n    device_id: 0,\n    ..EmbeddingConfig::clip_vit_b32()\n};\n\nlet embedding_node = EmbeddingNode::new(\n    \"models/clip_vit_b32_visual.onnx\",\n    \"camera.raw\",\n    \"vision.embeddings\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:256:bash",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 256,
      "lineEnd": 271,
      "language": "bash",
      "code": "# Export CLIP visual encoder to ONNX\npython -c \"\nimport torch\nimport clip\n\nmodel, _ = clip.load('ViT-B/32')\nvisual = model.visual\n\ndummy = torch.randn(1, 3, 224, 224)\ntorch.onnx.export(visual, dummy, 'clip_vit_b32_visual.onnx',\n    input_names=['image'],\n    output_names=['embedding'],\n    dynamic_axes={'image': {0: 'batch'}, 'embedding': {0: 'batch'}})\n\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/embedding:275:bash",
      "file": "content/docs/rust/library/built-in-nodes/embedding.mdx",
      "lineStart": 275,
      "lineEnd": 288,
      "language": "bash",
      "code": "# Export DINOv2 to ONNX\npython -c \"\nimport torch\n\nmodel = torch.hub.load('facebookresearch/dinov2', 'dinov2_vits14')\nmodel.eval()\n\ndummy = torch.randn(1, 3, 224, 224)\ntorch.onnx.export(model, dummy, 'dinov2_small.onnx',\n    input_names=['image'],\n    output_names=['embedding'])\n\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/emergency-stop:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/emergency-stop.mdx",
      "lineStart": 29,
      "lineEnd": 43,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut estop = EmergencyStopNode::new()?;\n    estop.set_button_pin(17);  // GPIO 17 for e-stop button\n    estop.set_mode(EstopMode::Latching);  // Requires manual reset\n\n    scheduler.add(Box::new(estop), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/emergency-stop:47:rust",
      "file": "content/docs/rust/library/built-in-nodes/emergency-stop.mdx",
      "lineStart": 47,
      "lineEnd": 58,
      "language": "rust",
      "code": "// Set e-stop button GPIO pin\nestop.set_button_pin(17);\n\n// Set mode\nestop.set_mode(EstopMode::Latching);      // Manual reset required\nestop.set_mode(EstopMode::NonLatching);   // Auto-reset when clear\n\n// Enable watchdog\nestop.enable_watchdog(true);\nestop.set_watchdog_timeout(1000);  // 1 second timeout",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/emergency-stop:62:rust",
      "file": "content/docs/rust/library/built-in-nodes/emergency-stop.mdx",
      "lineStart": 62,
      "lineEnd": 79,
      "language": "rust",
      "code": "// Monitor e-stop state\nlet hub = Hub::<EstopState>::new(\"estop.state\")?;\n\nif let Some(state) = hub.recv(&mut None) {\n    if state.triggered {\n        println!(\"E-STOP TRIGGERED! Reason: {:?}\", state.reason);\n        // All motors stopped\n    }\n}\n\n// Software e-stop trigger\nlet cmd_hub = Hub::<EstopCommand>::new(\"estop.command\")?;\ncmd_hub.send(EstopCommand::Trigger, &mut None).ok();\n\n// Reset e-stop\ncmd_hub.send(EstopCommand::Reset, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 27,
      "lineEnd": 53,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create encoder node\n    let mut encoder = EncoderNode::new()?;\n\n    // Configure encoder (resolution, wheel_radius, gear_ratio)\n    encoder.set_encoder_config(4096.0, 0.05, 1.0);\n\n    // Configure GPIO pins for quadrature encoder (pin A, pin B)\n    encoder.set_gpio_pins(17, 27);\n\n    scheduler.add(Box::new(encoder), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n// Subscribe to odometry in another node:\nlet odom_hub = Hub::<Odometry>::new(\"odom\")?;\nif let Some(odom) = odom_hub.recv(&mut ctx) {\n    println!(\"Position: ({:.2}, {:.2}), Heading: {:.2}deg\",\n             odom.pose.x, odom.pose.y, odom.pose.theta.to_degrees());\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:67:bash",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 67,
      "lineEnd": 70,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:76:yaml",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 76,
      "lineEnd": 81,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:87:toml",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 87,
      "lineEnd": 90,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:96:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 96,
      "lineEnd": 104,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topic \"odom\"\nlet mut encoder = EncoderNode::new()?;\n\n// Create with custom topic\nlet mut encoder = EncoderNode::new_with_topic(\"wheel_encoder\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:108:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 108,
      "lineEnd": 127,
      "language": "rust",
      "code": "// Set encoder configuration\nencoder.set_encoder_config(\n    1024.0,  // encoder_resolution (PPR)\n    0.05,    // wheel_radius (meters)\n    1.0      // gear_ratio\n);\n\n// Set coordinate frame IDs\nencoder.set_frame_ids(\"odom\", \"base_link\");\n\n// Reset encoder position and distance\nencoder.reset();\n\n// Set simulation velocity (for testing without hardware)\nencoder.set_simulation_velocity(\n    0.5,   // linear velocity (m/s)\n    0.1    // angular velocity (rad/s)\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:131:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 131,
      "lineEnd": 137,
      "language": "rust",
      "code": "// Get current velocity (m/s)\nlet velocity = encoder.get_velocity();\n\n// Get total distance traveled (meters)\nlet distance = encoder.get_total_distance();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:160:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 160,
      "lineEnd": 183,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create encoder node for motor feedback\n    let mut encoder = EncoderNode::new_with_topic(\"motor_encoder\")?;\n\n    // Configure for a 1024 PPR encoder on 6cm wheel\n    encoder.set_encoder_config(\n        1024.0,  // 1024 pulses per revolution\n        0.06,    // 6cm wheel radius\n        1.0      // direct drive (no gearing)\n    );\n\n    encoder.set_frame_ids(\"odom\", \"base_link\");\n\n    scheduler.add(Box::new(encoder), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:187:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 187,
      "lineEnd": 217,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Left wheel encoder\n    let mut left_encoder = EncoderNode::new_with_topic(\"left_wheel_odom\")?;\n    left_encoder.set_encoder_config(\n        2048.0,  // High-resolution encoder\n        0.075,   // 7.5cm wheel radius\n        1.0      // Direct drive\n    );\n    left_encoder.set_frame_ids(\"odom\", \"left_wheel\");\n\n    // Right wheel encoder\n    let mut right_encoder = EncoderNode::new_with_topic(\"right_wheel_odom\")?;\n    right_encoder.set_encoder_config(\n        2048.0,  // High-resolution encoder\n        0.075,   // 7.5cm wheel radius\n        1.0      // Direct drive\n    );\n    right_encoder.set_frame_ids(\"odom\", \"right_wheel\");\n\n    scheduler.add(Box::new(left_encoder), 50, Some(true));\n    scheduler.add(Box::new(right_encoder), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:221:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 221,
      "lineEnd": 230,
      "language": "rust",
      "code": "// Encoder on motor shaft with 10:1 gearbox\nlet mut encoder = EncoderNode::new_with_topic(\"geared_motor\")?;\n\nencoder.set_encoder_config(\n    512.0,   // 512 PPR encoder on motor shaft\n    0.05,    // 5cm output wheel\n    10.0     // 10:1 gear reduction (motor spins 10x faster)\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:234:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 234,
      "lineEnd": 259,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Encoder provides feedback\n    let mut encoder = EncoderNode::new_with_topic(\"encoder.velocity\")?;\n    encoder.set_encoder_config(1024.0, 0.05, 1.0);\n\n    // PID controller uses encoder feedback\n    let mut pid = PidControllerNode::new_with_topics(\n        \"target.velocity\",\n        \"encoder.velocity\",  // Subscribe to encoder output\n        \"motor.command\",\n        \"pid_config\"\n    )?;\n    pid.set_gains(1.5, 0.2, 0.05);\n\n    scheduler.add(Box::new(encoder), 50, Some(true));\n    scheduler.add(Box::new(pid), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:265:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 265,
      "lineEnd": 275,
      "language": "rust",
      "code": "pub struct Odometry {\n    pub pose: Pose2D,              // Current pose estimate\n    pub twist: Twist,              // Current velocity estimate\n    pub pose_covariance: [f64; 36],   // 6x6 pose covariance matrix\n    pub twist_covariance: [f64; 36],  // 6x6 twist covariance matrix\n    pub frame_id: [u8; 32],        // Reference frame (\"odom\")\n    pub child_frame_id: [u8; 32],  // Child frame (\"base_link\")\n    pub timestamp: u64,            // Nanoseconds since epoch\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:279:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 279,
      "lineEnd": 285,
      "language": "rust",
      "code": "pub struct Pose2D {\n    pub x: f64,        // X position in meters\n    pub y: f64,        // Y position in meters\n    pub theta: f64,    // Orientation in radians\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:289:rust",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 289,
      "lineEnd": 294,
      "language": "rust",
      "code": "pub struct Twist {\n    pub linear: [f64; 3],   // [x, y, z] linear velocity (m/s)\n    pub angular: [f64; 3],  // [roll, pitch, yaw] angular velocity (rad/s)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:307:text",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 307,
      "lineEnd": 310,
      "language": "text",
      "code": "Effective PPR = Nominal PPR x 4 (with quadrature decoding)\nExample: 256 PPR encoder = 1024 counts per revolution",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:324:text",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 324,
      "lineEnd": 326,
      "language": "text",
      "code": "velocity = (current_position - last_position) / dt",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:330:text",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 330,
      "lineEnd": 332,
      "language": "text",
      "code": "distance = (pulse_count / encoder_resolution) x (2 x PI x wheel_radius) / gear_ratio",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/encoder:418:text",
      "file": "content/docs/rust/library/built-in-nodes/encoder.mdx",
      "lineStart": 418,
      "lineEnd": 420,
      "language": "text",
      "code": "actual_radius = (measured_distance / 10.0) x nominal_radius",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/force-torque:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/force-torque.mdx",
      "lineStart": 27,
      "lineEnd": 41,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut ft_sensor = ForceTorqueSensorNode::new(\"/dev/ttyUSB0\")?;\n    ft_sensor.set_sensor_type(FTSensorType::ATIMini40);\n    ft_sensor.tare()?;  // Zero sensor\n\n    scheduler.add(Box::new(ft_sensor), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/force-torque:53:bash",
      "file": "content/docs/rust/library/built-in-nodes/force-torque.mdx",
      "lineStart": 53,
      "lineEnd": 56,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: netft)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/force-torque:62:yaml",
      "file": "content/docs/rust/library/built-in-nodes/force-torque.mdx",
      "lineStart": 62,
      "lineEnd": 67,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - netft",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/force-torque:73:toml",
      "file": "content/docs/rust/library/built-in-nodes/force-torque.mdx",
      "lineStart": 73,
      "lineEnd": 76,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"netft\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/force-torque:80:rust",
      "file": "content/docs/rust/library/built-in-nodes/force-torque.mdx",
      "lineStart": 80,
      "lineEnd": 94,
      "language": "rust",
      "code": "let hub = Hub::<ForceTorqueData>::new(\"ft_sensor.data\")?;\n\nif let Some(data) = hub.recv(&mut None) {\n    println!(\"Force: [{:.2}, {:.2}, {:.2}] N\",\n        data.fx, data.fy, data.fz);\n    println!(\"Torque: [{:.2}, {:.2}, {:.2}] Nm\",\n        data.tx, data.ty, data.tz);\n\n    // Detect contact\n    if data.fz > 5.0 {\n        println!(\"Contact detected!\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 28,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Option 1: Simulation mode (no hardware needed)\n    let gps = GpsNode::new()?;\n\n    // Option 2: With real GPS hardware\n    let mut gps = GpsNode::new_with_backend(\"gps.fix\", GpsBackend::NmeaSerial)?;\n    gps.set_serial_config(\"/dev/ttyUSB0\", 9600);\n    gps.set_update_rate(1.0);  // 1 Hz\n\n    scheduler.add(Box::new(gps), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:54:text",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 54,
      "lineEnd": 60,
      "language": "text",
      "code": "Raspberry Pi          GPS Module\nGPIO TX (14)    --->  RX\nGPIO RX (15)    <---  TX\n3.3V or 5V      --->  VCC\nGND             ---   GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:66:bash",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 66,
      "lineEnd": 72,
      "language": "bash",
      "code": "# List USB serial devices\nls -l /dev/ttyUSB* /dev/ttyACM*\n\n# Check dmesg for connection\ndmesg | grep tty",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:79:bash",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 79,
      "lineEnd": 84,
      "language": "bash",
      "code": "sudo raspi-config\n# Interface Options -> Serial Port\n# \"Would you like a login shell accessible over serial?\" -> No\n# \"Would you like serial port hardware enabled?\" -> Yes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:87:text",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 87,
      "lineEnd": 90,
      "language": "text",
      "code": "# Disable Bluetooth to free up UART\ndtoverlay=disable-bt",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:102:bash",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 102,
      "lineEnd": 105,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: nmea-gps)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:111:yaml",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 111,
      "lineEnd": 116,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - nmea-gps",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:122:toml",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 122,
      "lineEnd": 125,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"nmea-gps\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:131:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 131,
      "lineEnd": 142,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topic \"gps.fix\" in simulation mode\nlet mut gps = GpsNode::new()?;\n\n// Create with custom topic in simulation mode\nlet mut gps = GpsNode::new_with_topic(\"navigation.gps\")?;\n\n// Create with specific backend\nlet mut gps = GpsNode::new_with_backend(\"gps.fix\", GpsBackend::NmeaSerial)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:146:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 146,
      "lineEnd": 172,
      "language": "rust",
      "code": "// Set GPS backend (Simulation or NmeaSerial)\ngps.set_backend(GpsBackend::NmeaSerial);\n\n// Configure serial port and baud rate\ngps.set_serial_config(\"/dev/ttyUSB0\", 9600);\n\n// Set update rate in Hz (0.1-20 Hz, typical 1-10 Hz)\ngps.set_update_rate(1.0);  // 1 Hz (standard)\ngps.set_update_rate(5.0);  // 5 Hz (high performance)\ngps.set_update_rate(10.0); // 10 Hz (maximum for most modules)\n\n// Set minimum satellites required for valid fix\ngps.set_min_satellites(4);  // Minimum for 3D fix\ngps.set_min_satellites(6);  // Better accuracy\n\n// Set maximum acceptable HDOP\ngps.set_max_hdop(5.0);   // Excellent to good accuracy\ngps.set_max_hdop(10.0);  // Moderate accuracy\ngps.set_max_hdop(20.0);  // Poor accuracy (default)\n\n// Set coordinate frame ID\ngps.set_frame_id(\"gps_link\");\n\n// Set simulation position (simulation mode only)\ngps.set_simulation_position(37.7749, -122.4194, 10.0);  // San Francisco",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:176:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 176,
      "lineEnd": 191,
      "language": "rust",
      "code": "// Get last GPS fix\nlet fix = gps.get_last_fix();\nprintln!(\"Position: {:.6}, {:.6}\", fix.latitude, fix.longitude);\n\n// Get total number of fixes received\nlet count = gps.get_fix_count();\nprintln!(\"Fixes received: {}\", count);\n\n// Check if we have a valid GPS fix\nif gps.has_valid_fix() {\n    println!(\"GPS fix valid\");\n} else {\n    println!(\"Waiting for GPS fix...\");\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:232:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 232,
      "lineEnd": 267,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct PositionMonitor {\n    gps_sub: Hub<NavSatFix>,\n}\n\nimpl PositionMonitor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            gps_sub: Hub::new(\"gps.fix\")?,\n        })\n    }\n}\n\nimpl Node for PositionMonitor {\n    fn name(&self) -> &'static str { \"PositionMonitor\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(fix) = self.gps_sub.recv(&mut ctx) {\n            if fix.has_fix() && fix.is_valid() {\n                if let Some(ctx) = ctx {\n                    ctx.log_info(&format!(\n                        \"Position: {:.6}°, {:.6}°, Alt: {:.1}m\",\n                        fix.latitude, fix.longitude, fix.altitude\n                    ));\n                    ctx.log_info(&format!(\n                        \"Satellites: {}, HDOP: {:.1}, Accuracy: {:.1}m\",\n                        fix.satellites_visible, fix.hdop, fix.horizontal_accuracy()\n                    ));\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:271:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 271,
      "lineEnd": 319,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct GeofenceMonitor {\n    gps_sub: Hub<NavSatFix>,\n    home_lat: f64,\n    home_lon: f64,\n    radius_meters: f64,\n}\n\nimpl GeofenceMonitor {\n    fn new(home_lat: f64, home_lon: f64, radius_meters: f64) -> Result<Self> {\n        Ok(Self {\n            gps_sub: Hub::new(\"gps.fix\")?,\n            home_lat,\n            home_lon,\n            radius_meters,\n        })\n    }\n}\n\nimpl Node for GeofenceMonitor {\n    fn name(&self) -> &'static str { \"GeofenceMonitor\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(fix) = self.gps_sub.recv(&mut ctx) {\n            if fix.has_fix() && fix.is_valid() {\n                // Create home position fix for distance calculation\n                let home = NavSatFix::from_coordinates(self.home_lat, self.home_lon, 0.0);\n                let distance = fix.distance_to(&home);\n\n                if let Some(ctx) = ctx {\n                    if distance > self.radius_meters {\n                        ctx.log_warning(&format!(\n                            \"OUTSIDE GEO-FENCE! Distance: {:.1}m from home\",\n                            distance\n                        ));\n                    } else {\n                        ctx.log_info(&format!(\n                            \"Inside geo-fence: {:.1}m from home\",\n                            distance\n                        ));\n                    }\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:323:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 323,
      "lineEnd": 353,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct VelocityTracker {\n    gps_sub: Hub<NavSatFix>,\n}\n\nimpl Node for VelocityTracker {\n    fn name(&self) -> &'static str { \"VelocityTracker\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(fix) = self.gps_sub.recv(&mut ctx) {\n            if fix.has_fix() && fix.is_valid() {\n                // Convert m/s to km/h\n                let speed_kmh = fix.speed * 3.6;\n\n                if let Some(ctx) = ctx {\n                    if fix.speed > 0.5 {  // Moving (threshold to avoid noise)\n                        ctx.log_info(&format!(\n                            \"Moving: {:.1} km/h, Heading: {:.0}°\",\n                            speed_kmh, fix.heading\n                        ));\n                    } else {\n                        ctx.log_info(\"Stationary\");\n                    }\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:361:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 361,
      "lineEnd": 376,
      "language": "rust",
      "code": "pub struct NavSatFix {\n    pub latitude: f64,              // Degrees (positive=North, negative=South)\n    pub longitude: f64,             // Degrees (positive=East, negative=West)\n    pub altitude: f64,              // Meters above WGS84 ellipsoid\n    pub position_covariance: [f64; 9],  // 3x3 covariance matrix [lat, lon, alt]\n    pub position_covariance_type: u8,   // Covariance type (0-3)\n    pub status: u8,                 // Fix status (0=no_fix, 1=fix, 2=sbas_fix, 3=gbas_fix)\n    pub satellites_visible: u16,    // Number of satellites in view\n    pub hdop: f32,                  // Horizontal dilution of precision\n    pub vdop: f32,                  // Vertical dilution of precision\n    pub speed: f32,                 // Ground speed in m/s\n    pub heading: f32,               // Course/heading in degrees (0-360)\n    pub timestamp: u64,             // Time in nanoseconds since epoch\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:385:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 385,
      "lineEnd": 397,
      "language": "rust",
      "code": "// Check if we have a valid GPS fix\nfix.has_fix() -> bool\n\n// Check if coordinates are valid\nfix.is_valid() -> bool\n\n// Get horizontal accuracy estimate in meters\nfix.horizontal_accuracy() -> f32\n\n// Calculate distance to another GPS position (Haversine formula)\nfix.distance_to(&other_fix) -> f64",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:547:text",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 547,
      "lineEnd": 550,
      "language": "text",
      "code": "[INFO] GPS simulation mode enabled\n[DEBUG] GPS: 37.774900, -122.419400, alt=10.0m, sats=8",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/gps:560:rust",
      "file": "content/docs/rust/library/built-in-nodes/gps.mdx",
      "lineStart": 560,
      "lineEnd": 564,
      "language": "rust",
      "code": "gps.set_simulation_position(37.7749, -122.4194, 10.0);  // San Francisco\ngps.set_simulation_position(51.5074, -0.1278, 50.0);    // London\ngps.set_simulation_position(35.6762, 139.6503, 40.0);   // Tokyo",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 28,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create I2C bus node\n    let mut i2c = I2cBusNode::new()?; // Default: bus 1, 400kHz\n\n    // Configure\n    i2c.set_bus_number(1);\n    i2c.set_clock_speed(400_000); // 400kHz\n    i2c.register_device(0x68, \"MPU6050 IMU\");\n    i2c.register_device(0x40, \"INA219 Power Monitor\");\n\n    scheduler.add(Box::new(i2c), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:53:bash",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 53,
      "lineEnd": 63,
      "language": "bash",
      "code": "# Install I2C tools\nsudo apt install i2c-tools\n\n# Enable I2C interface\nsudo raspi-config  # Interface Options -> I2C\n\n# Add user to i2c group\nsudo usermod -a -G i2c $USER\n# Log out and back in for group to take effect",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:73:bash",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 73,
      "lineEnd": 76,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: i2c-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:82:yaml",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 82,
      "lineEnd": 87,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - i2c-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:93:toml",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 93,
      "lineEnd": 96,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"i2c-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:100:bash",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 100,
      "lineEnd": 106,
      "language": "bash",
      "code": "# List I2C buses\nls /dev/i2c-*\n\n# Scan for devices on bus 1\ni2cdetect -y 1",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:109:text",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 109,
      "lineEnd": 119,
      "language": "text",
      "code": "     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:126:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 126,
      "lineEnd": 136,
      "language": "rust",
      "code": "let mut i2c = I2cBusNode::new()?;\n\n// Select I2C bus (0, 1, 2, etc.)\ni2c.set_bus_number(1);\n\n// Set clock speed\ni2c.set_clock_speed(100_000);  // 100kHz (standard mode)\ni2c.set_clock_speed(400_000);  // 400kHz (fast mode)\ni2c.set_clock_speed(1_000_000); // 1MHz (fast mode plus)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:140:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 140,
      "lineEnd": 146,
      "language": "rust",
      "code": "// Set retry count for failed transactions\ni2c.set_retry_count(3);\n\n// Set transaction timeout\ni2c.set_timeout(100); // milliseconds",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:150:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 150,
      "lineEnd": 157,
      "language": "rust",
      "code": "// Label devices for easier debugging\ni2c.register_device(0x68, \"MPU6050 IMU\");\ni2c.register_device(0x40, \"INA219 Power Monitor\");\n\n// Add simulated devices for testing\ni2c.add_simulated_device(0x50, 256); // 256-byte EEPROM simulation",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:161:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 161,
      "lineEnd": 168,
      "language": "rust",
      "code": "// Use custom topic names\nlet i2c = I2cBusNode::new_with_config(\n    1,                  // Bus number\n    \"sensors.i2c.req\",  // Request topic\n    \"sensors.i2c.resp\"  // Response topic\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:174:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 174,
      "lineEnd": 197,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create I2C transaction request\nlet request = I2cMessage::read(\n    1,      // Bus number\n    0x68,   // Device address\n    6       // Number of bytes to read\n);\n\n// Publish request\nlet hub = Hub::<I2cMessage>::new(\"i2c.request\")?;\nhub.send(request, &mut None).ok();\n\n// Receive response\nlet response_hub = Hub::<I2cMessage>::new(\"i2c.response\")?;\nif let Some(response) = response_hub.recv(&mut None) {\n    if response.success {\n        println!(\"Data: {:?}\", &response.data[..response.data_length as usize]);\n    } else {\n        println!(\"Error code: {}\", response.error_code);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:201:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 201,
      "lineEnd": 207,
      "language": "rust",
      "code": "let mut request = I2cMessage::write(1, 0x68, 2);\nrequest.data[0] = 0x6B; // Register address\nrequest.data[1] = 0x00; // Value to write\n\nhub.send(request, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:211:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 211,
      "lineEnd": 223,
      "language": "rust",
      "code": "// Read from specific register\nlet request = I2cMessage::read_register(\n    1,      // Bus\n    0x68,   // Device address\n    0x3B,   // Register address\n    6       // Bytes to read\n);\n\n// Write to specific register\nlet mut request = I2cMessage::write_register(1, 0x68, 0x6B, 1);\nrequest.data[0] = 0x00; // Value to write",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:229:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 229,
      "lineEnd": 240,
      "language": "rust",
      "code": "// Read accelerometer data (registers 0x3B-0x40)\nlet request = I2cMessage::read_register(1, 0x68, 0x3B, 6);\nhub.send(request, &mut None).ok();\n\nif let Some(resp) = response_hub.recv(&mut None) {\n    let ax = i16::from_be_bytes([resp.data[0], resp.data[1]]);\n    let ay = i16::from_be_bytes([resp.data[2], resp.data[3]]);\n    let az = i16::from_be_bytes([resp.data[4], resp.data[5]]);\n    println!(\"Accel: x={}, y={}, z={}\", ax, ay, az);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:244:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 244,
      "lineEnd": 254,
      "language": "rust",
      "code": "// Read bus voltage (register 0x02)\nlet request = I2cMessage::read_register(1, 0x40, 0x02, 2);\nhub.send(request, &mut None).ok();\n\nif let Some(resp) = response_hub.recv(&mut None) {\n    let raw = u16::from_be_bytes([resp.data[0], resp.data[1]]);\n    let voltage = (raw >> 3) as f32 * 0.004; // LSB = 4mV\n    println!(\"Bus voltage: {:.3} V\", voltage);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:258:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 258,
      "lineEnd": 264,
      "language": "rust",
      "code": "// Send command to display\nlet mut request = I2cMessage::write(1, 0x3C, 2);\nrequest.data[0] = 0x00; // Command mode\nrequest.data[1] = 0xAF; // Display ON command\nhub.send(request, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:282:text",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 282,
      "lineEnd": 293,
      "language": "text",
      "code": "[WARN] I2cBusNode: Hardware unavailable - using SIMULATION mode\n[WARN]   Tried: /dev/i2c-1\n[WARN]   Error: Permission denied (os error 13)\n[WARN]   Fix:\n[WARN]     1. Install: sudo apt install i2c-tools\n[WARN]     2. Enable I2C: sudo raspi-config -> Interface Options -> I2C\n[WARN]     3. Add user to group: sudo usermod -a -G i2c $USER\n[WARN]     4. Reboot or re-login\n[WARN]     5. If using cargo: cargo build --features=\"i2c-hardware\"\n[WARN]        (horus run auto-detects features)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:304:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 304,
      "lineEnd": 309,
      "language": "rust",
      "code": "// Get transaction statistics\nlet (total, successful, failed, last_error) = i2c.get_stats();\nprintln!(\"Total: {}, Success: {}, Failed: {}, Last Error: {}\",\n    total, successful, failed, last_error);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:313:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 313,
      "lineEnd": 317,
      "language": "rust",
      "code": "// Scan I2C bus for devices\nlet devices = i2c.scan_bus(None);\nprintln!(\"Found {} devices: {:?}\", devices.len(), devices);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:320:text",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 320,
      "lineEnd": 324,
      "language": "text",
      "code": "Found I2C device at 0x40\nFound I2C device at 0x68\nI2C scan complete: 2 devices found",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:328:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 328,
      "lineEnd": 341,
      "language": "rust",
      "code": "pub struct I2cMessage {\n    pub bus_number: u8,           // I2C bus (0, 1, 2, etc.)\n    pub device_address: u16,      // 7-bit address (0x00-0x7F)\n    pub register_address: u8,     // Register to read/write\n    pub transaction_type: u8,     // READ, WRITE, READ_REG, WRITE_REG\n    pub data: [u8; 256],         // Data buffer\n    pub data_length: u8,         // Number of bytes\n    pub clock_speed: u32,        // Clock frequency (Hz)\n    pub success: bool,           // Transaction result\n    pub error_code: u8,          // Error if failed\n    pub timestamp: u64,          // Transaction time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:345:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 345,
      "lineEnd": 350,
      "language": "rust",
      "code": "pub const TYPE_READ: u8 = 0;           // Simple read\npub const TYPE_WRITE: u8 = 1;          // Simple write\npub const TYPE_READ_REGISTER: u8 = 2;  // Write reg, then read\npub const TYPE_WRITE_REGISTER: u8 = 3; // Write reg and data",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/i2c-bus:354:rust",
      "file": "content/docs/rust/library/built-in-nodes/i2c-bus.mdx",
      "lineStart": 354,
      "lineEnd": 358,
      "language": "rust",
      "code": "pub const SPEED_STANDARD: u32 = 100_000;   // 100kHz\npub const SPEED_FAST: u32 = 400_000;       // 400kHz\npub const SPEED_FAST_PLUS: u32 = 1_000_000; // 1MHz",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:30:rust",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 30,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut processor = ImageProcessorNode::new()?;\n    processor.enable_color_filter(true);\n    processor.set_hsv_range(\n        (100, 100, 100),  // Lower HSV\n        (130, 255, 255)   // Upper HSV (blue)\n    );\n\n    scheduler.add(Box::new(processor), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:59:bash",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 59,
      "lineEnd": 62,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: opencv-backend)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:68:yaml",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 68,
      "lineEnd": 73,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - opencv-backend",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:79:toml",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 79,
      "lineEnd": 82,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"opencv-backend\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:86:rust",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 86,
      "lineEnd": 94,
      "language": "rust",
      "code": "// Enable processing features\nprocessor.enable_edge_detection(true);\nprocessor.set_canny_thresholds(50, 150);\n\n// Color filtering\nprocessor.enable_color_filter(true);\nprocessor.set_hsv_range((0, 120, 70), (10, 255, 255));  // Red",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:100:rust",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 100,
      "lineEnd": 114,
      "language": "rust",
      "code": "let frame_hub = Hub::<CameraFrame>::new(\"camera.frame\")?;\nlet objects_hub = Hub::<DetectedObjects>::new(\"vision.objects\")?;\n\nif let Some(frame) = frame_hub.recv(&mut None) {\n    // Process frame...\n}\n\nif let Some(objects) = objects_hub.recv(&mut None) {\n    for obj in &objects.objects {\n        println!(\"Object at ({}, {}), size: {}x{}\",\n            obj.x, obj.y, obj.width, obj.height);\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:118:rust",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 118,
      "lineEnd": 128,
      "language": "rust",
      "code": "// Track red objects\nprocessor.set_hsv_range((0, 120, 70), (10, 255, 255));\n\nlet blobs_hub = Hub::<BlobList>::new(\"vision.blobs\")?;\nif let Some(blobs) = blobs_hub.recv(&mut None) {\n    if let Some(largest) = blobs.largest() {\n        println!(\"Largest blob at ({}, {})\", largest.x, largest.y);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:132:rust",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 132,
      "lineEnd": 142,
      "language": "rust",
      "code": "processor.enable_aruco_detection(true);\nprocessor.set_aruco_dictionary(ArucoDictionary::Dict4x4_50);\n\nlet markers_hub = Hub::<ArucoMarkers>::new(\"vision.markers\")?;\nif let Some(markers) = markers_hub.recv(&mut None) {\n    for marker in &markers.markers {\n        println!(\"Marker ID: {}, pose: {:?}\", marker.id, marker.pose);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/image-processor:148:rust",
      "file": "content/docs/rust/library/built-in-nodes/image-processor.mdx",
      "lineStart": 148,
      "lineEnd": 153,
      "language": "rust",
      "code": "// Red: (0, 120, 70) to (10, 255, 255)\n// Green: (40, 40, 40) to (80, 255, 255)\n// Blue: (100, 100, 100) to (130, 255, 255)\n// Yellow: (20, 100, 100) to (30, 255, 255)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 29,
      "lineEnd": 55,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Option 1: Simulation mode (no hardware needed)\n    let imu = ImuNode::new()?;\n\n    // Option 2: With real hardware (MPU6050)\n    let imu = ImuNode::builder()\n        .with_backend(ImuBackend::Mpu6050)\n        .with_i2c(\"/dev/i2c-1\", 0x68)\n        .build()?;\n\n    scheduler.add(Box::new(imu), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n// Subscribe to IMU data in another node:\nlet imu_hub = Hub::<Imu>::new(\"imu\")?;\nif let Some(data) = imu_hub.recv(&mut ctx) {\n    println!(\"Angular velocity: [{:.2}, {:.2}, {:.2}] rad/s\",\n        data.angular_velocity[0], data.angular_velocity[1], data.angular_velocity[2]);\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:75:bash",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 75,
      "lineEnd": 78,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: bno055-imu)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:84:yaml",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 84,
      "lineEnd": 89,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - bno055-imu  # or mpu6050-imu",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:95:toml",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 95,
      "lineEnd": 100,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"mpu6050-imu\"] }\n# or\nhorus_library = { version = \"0.1\", features = [\"bno055-imu\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:106:text",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 106,
      "lineEnd": 112,
      "language": "text",
      "code": "Raspberry Pi    MPU6050\nGPIO 2 (SDA) --> SDA\nGPIO 3 (SCL) --> SCL\n3.3V         --> VCC\nGND          --- GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:116:text",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 116,
      "lineEnd": 124,
      "language": "text",
      "code": "Raspberry Pi    BNO055\nGPIO 2 (SDA) --> SDA\nGPIO 3 (SCL) --> SCL\n3.3V         --> VIN\nGND          --- GND\n                PS0 --> GND (I2C mode)\n                PS1 --> GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:130:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 130,
      "lineEnd": 141,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topic \"imu\" in simulation mode\nlet mut imu = ImuNode::new()?;\n\n// Create with custom topic\nlet mut imu = ImuNode::new_with_topic(\"sensors.imu\")?;\n\n// Create with specific hardware backend\nlet mut imu = ImuNode::new_with_backend(\"imu\", ImuBackend::Mpu6050)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:145:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 145,
      "lineEnd": 165,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Simple builder usage\nlet imu = ImuNode::builder()\n    .with_topic(\"robot.imu\")\n    .with_backend(ImuBackend::Mpu6050)\n    .with_i2c(\"/dev/i2c-1\", 0x68)\n    .build()?;\n\n// Builder with data processing closure\nlet imu = ImuNode::builder()\n    .with_topic(\"imu\")\n    .with_backend(ImuBackend::Bno055)\n    .with_closure(|mut imu_data| {\n        // Apply calibration offset\n        imu_data.angular_velocity[0] -= 0.01;  // Remove gyro bias\n        imu_data\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:169:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 169,
      "lineEnd": 184,
      "language": "rust",
      "code": "// Set hardware backend\nimu.set_backend(ImuBackend::Mpu6050);\n\n// Set I2C bus and address\nimu.set_i2c_config(\"/dev/i2c-1\", 0x68);\n\n// Set coordinate frame ID\nimu.set_frame_id(\"base_imu\");\n\n// Set sample rate (Hz, clamped to 1.0-1000.0)\nimu.set_sample_rate(200.0);\n\n// Get actual measured sample rate\nlet actual_rate = imu.get_actual_sample_rate();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:188:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 188,
      "lineEnd": 205,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Simulation mode (no hardware required)\nimu.set_backend(ImuBackend::Simulation);\n\n// MPU6050 (6-axis: accelerometer + gyroscope)\nimu.set_backend(ImuBackend::Mpu6050);\nimu.set_i2c_config(\"/dev/i2c-1\", 0x68);\n\n// BNO055 (9-axis with built-in sensor fusion)\nimu.set_backend(ImuBackend::Bno055);\nimu.set_i2c_config(\"/dev/i2c-1\", 0x28);\n\n// ICM20948 (9-axis)\nimu.set_backend(ImuBackend::Icm20948);\nimu.set_i2c_config(\"/dev/i2c-1\", 0x68);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:222:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 222,
      "lineEnd": 241,
      "language": "rust",
      "code": "let hub = Hub::<Imu>::new(\"imu\")?;\n\nif let Some(data) = hub.recv(&mut None) {\n    // Orientation as quaternion [x, y, z, w]\n    println!(\"Orientation: [{:.3}, {:.3}, {:.3}, {:.3}]\",\n        data.orientation[0], data.orientation[1],\n        data.orientation[2], data.orientation[3]);\n\n    // Angular velocity [x, y, z] in rad/s\n    println!(\"Angular velocity: [{:.2}, {:.2}, {:.2}] rad/s\",\n        data.angular_velocity[0], data.angular_velocity[1],\n        data.angular_velocity[2]);\n\n    // Linear acceleration [x, y, z] in m/s²\n    println!(\"Acceleration: [{:.2}, {:.2}, {:.2}] m/s²\",\n        data.linear_acceleration[0], data.linear_acceleration[1],\n        data.linear_acceleration[2]);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:245:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 245,
      "lineEnd": 290,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::f64::consts::PI;\n\nstruct OrientationMonitor {\n    imu_sub: Hub<Imu>,\n}\n\nimpl OrientationMonitor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            imu_sub: Hub::new(\"imu\")?,\n        })\n    }\n}\n\nimpl Node for OrientationMonitor {\n    fn name(&self) -> &'static str {\n        \"OrientationMonitor\"\n    }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(imu_data) = self.imu_sub.recv(&mut ctx) {\n            if imu_data.has_orientation() {\n                // Convert quaternion to Euler angles\n                let q = Quaternion::new(\n                    imu_data.orientation[0],\n                    imu_data.orientation[1],\n                    imu_data.orientation[2],\n                    imu_data.orientation[3]\n                );\n                let (roll, pitch, yaw) = q.to_euler();\n\n                if let Some(ctx) = ctx {\n                    ctx.log_info(&format!(\n                        \"Roll: {:.2}°, Pitch: {:.2}°, Yaw: {:.2}°\",\n                        roll * 180.0 / PI,\n                        pitch * 180.0 / PI,\n                        yaw * 180.0 / PI\n                    ));\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:294:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 294,
      "lineEnd": 323,
      "language": "rust",
      "code": "struct MotionDetector {\n    imu_sub: Hub<Imu>,\n    angular_threshold: f64,\n    accel_threshold: f64,\n}\n\nimpl Node for MotionDetector {\n    fn name(&self) -> &'static str { \"MotionDetector\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(imu_data) = self.imu_sub.recv(&mut ctx) {\n            // Calculate angular velocity magnitude\n            let angular_mag = (\n                imu_data.angular_velocity[0].powi(2) +\n                imu_data.angular_velocity[1].powi(2) +\n                imu_data.angular_velocity[2].powi(2)\n            ).sqrt();\n\n            if angular_mag > self.angular_threshold {\n                if let Some(ctx) = ctx {\n                    ctx.log_warning(&format!(\n                        \"Motion detected! Angular: {:.2} rad/s\", angular_mag\n                    ));\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:329:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 329,
      "lineEnd": 346,
      "language": "rust",
      "code": "pub struct Imu {\n    /// Orientation as quaternion [x, y, z, w]\n    pub orientation: [f64; 4],\n    /// Orientation covariance matrix (row-major, -1 = no data)\n    pub orientation_covariance: [f64; 9],\n    /// Angular velocity [x, y, z] in rad/s\n    pub angular_velocity: [f64; 3],\n    /// Angular velocity covariance matrix\n    pub angular_velocity_covariance: [f64; 9],\n    /// Linear acceleration [x, y, z] in m/s²\n    pub linear_acceleration: [f64; 3],\n    /// Linear acceleration covariance matrix\n    pub linear_acceleration_covariance: [f64; 9],\n    /// Timestamp in nanoseconds since epoch\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:350:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 350,
      "lineEnd": 359,
      "language": "rust",
      "code": "impl Imu {\n    pub fn new() -> Self;\n    pub fn set_orientation_from_euler(&mut self, roll: f64, pitch: f64, yaw: f64);\n    pub fn has_orientation(&self) -> bool;\n    pub fn is_valid(&self) -> bool;\n    pub fn angular_velocity_vec(&self) -> Vector3;\n    pub fn linear_acceleration_vec(&self) -> Vector3;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:390:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 390,
      "lineEnd": 401,
      "language": "rust",
      "code": "// Check IMU initialization\nlet actual_rate = imu.get_actual_sample_rate();\nif actual_rate == 0.0 {\n    eprintln!(\"IMU not publishing - check hardware connection\");\n}\n\n// For I2C IMUs, verify:\n// 1. I2C bus is enabled\n// 2. Correct I2C address\n// 3. Pull-up resistors present",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:406:bash",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 406,
      "lineEnd": 413,
      "language": "bash",
      "code": "# Check I2C devices\ni2cdetect -y 1\n\n# Verify IMU address (common: 0x68, 0x69)\n# Reduce I2C bus speed if needed (in /boot/config.txt)\ndtparam=i2c_arm_baudrate=100000  # Reduce to 100 kHz",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/imu:418:rust",
      "file": "content/docs/rust/library/built-in-nodes/imu.mdx",
      "lineStart": 418,
      "lineEnd": 433,
      "language": "rust",
      "code": "// Apply low-pass filter\nstruct LowPassFilter {\n    alpha: f64,  // 0.0-1.0, lower = more filtering\n    prev: [f64; 3],\n}\n\nimpl LowPassFilter {\n    fn filter(&mut self, input: [f64; 3]) -> [f64; 3] {\n        for i in 0..3 {\n            self.prev[i] = self.alpha * input[i] + (1.0 - self.alpha) * self.prev[i];\n        }\n        self.prev\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:17:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 17,
      "lineEnd": 30,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Add any built-in node\n    let ultrasonic = UltrasonicNode::new()?;\n    scheduler.add(Box::new(ultrasonic), 1, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:60:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 60,
      "lineEnd": 74,
      "language": "rust",
      "code": "// 1. Create with defaults\nlet mut battery = BatteryMonitorNode::new()?;\n\n// 2. Configure clearly\nbattery.set_cell_count(4);  // Not: battery.configure(0x04)\nbattery.configure_4s_lipo(5000.0);  // Preset: clear intent\n\n// 3. Access state\nlet state = battery.get_state();\nprintln!(\"Battery: {:.2}V, {:.0}%\", state.voltage, state.percentage);\n\n// 4. Add to scheduler - tick() called automatically\nscheduler.add(Box::new(battery), 50, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:79:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 79,
      "lineEnd": 89,
      "language": "rust",
      "code": "// Standard robotics application\nlet mut battery = BatteryMonitorNode::new()?;\nbattery.configure_4s_lipo(5000.0);  // Real battery monitoring\n\nlet mut motors = BlDcMotorNode::new()?;\nmotors.configure_gpio(12, EscProtocol::DShot600);  // Real ESCs\n\nscheduler.add(Box::new(battery), 50, Some(true));\nscheduler.add(Box::new(motors), 10, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:92:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 92,
      "lineEnd": 108,
      "language": "rust",
      "code": "// Add custom algorithm on top of hardware driver\nstruct AdaptiveBattery {\n    inner: BatteryMonitorNode,  // Handles real hardware\n    prediction_model: KalmanFilter,  // Your custom logic\n}\n\nimpl Node for AdaptiveBattery {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        self.inner.tick(&mut ctx);  // Real hardware monitoring\n\n        let state = self.inner.get_state();\n        let prediction = self.prediction_model.predict(state);  // Your algorithm\n        // ...\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:133:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 133,
      "lineEnd": 140,
      "language": "rust",
      "code": "// Traditional: Import driver, manually configure everything\nuse sensor_driver::SensorX;\nlet mut sensor = SensorX::new()?;\nsensor.set_register(0x2A, 0xFF);  // What does this do?\nsensor.configure_mode(3);          // Magic numbers\n// ...lots of low-level setup",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:143:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 143,
      "lineEnd": 150,
      "language": "rust",
      "code": "// HORUS: Pre-configured, high-level node with explicit API\nlet mut sensor = SensorXNode::new()?;\nsensor.set_sample_rate(100);      // Explicit configuration\nsensor.set_filter_mode(FilterMode::Median);\nsensor.calibrate()?;\n// Ready to use with sensible defaults",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:173:bash",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 173,
      "lineEnd": 179,
      "language": "bash",
      "code": "# Publish your custom node package\nhorus pkg publish my-custom-driver\n\n# Others can install it\nhorus pkg install your-username/my-custom-driver",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:279:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 279,
      "lineEnd": 282,
      "language": "rust",
      "code": "// Automatically uses hardware if available, simulation otherwise\nlet ultrasonic = UltrasonicNode::new()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:285:text",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 285,
      "lineEnd": 287,
      "language": "text",
      "code": "[INFO] UltrasonicNode sensor 0: (SIM) distance 1.234 m",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:293:bash",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 293,
      "lineEnd": 306,
      "language": "bash",
      "code": "$ horus run robot.rs\n\n[WARNING] Hardware Configuration Check\n\nMissing cargo features:\n  • i2c-hardware\n  • gpio-hardware\n\nTo enable hardware support:\n  > cargo build --features=\"i2c-hardware,gpio-hardware\"\n\nNote: Nodes will automatically fall back to SIMULATION mode if hardware is unavailable.",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:312:bash",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 312,
      "lineEnd": 318,
      "language": "bash",
      "code": "# Raspberry Pi / Debian-based\nsudo apt install libraspberrypi-dev i2c-tools can-utils\n\n# Enable interfaces\nsudo raspi-config  # Interface Options -> I2C, SPI, etc.",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:326:bash",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 326,
      "lineEnd": 329,
      "language": "bash",
      "code": "horus run main.rs --release\n# Output: Auto-detected hardware nodes (features: i2c-hardware, gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:335:yaml",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 335,
      "lineEnd": 341,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - i2c-hardware\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:347:toml",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 347,
      "lineEnd": 350,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"i2c-hardware\", \"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:376:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 376,
      "lineEnd": 390,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // All sensors at same priority (run in parallel)\n    scheduler.add(Box::new(UltrasonicNode::new()?), 2, Some(true));\n    scheduler.add(Box::new(ImuNode::new()?), 2, Some(true));\n    scheduler.add(Box::new(GpsNode::new()?), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:394:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 394,
      "lineEnd": 408,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Control pipeline\n    scheduler.add(Box::new(JoystickNode::new()?), 1, Some(true));\n    scheduler.add(Box::new(DifferentialDriveNode::new(...)?), 2, Some(true));\n    scheduler.add(Box::new(DcMotorNode::new()?), 3, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/index:412:rust",
      "file": "content/docs/rust/library/built-in-nodes/index.mdx",
      "lineStart": 412,
      "lineEnd": 426,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Protocol bridges\n    scheduler.add(Box::new(I2cBusNode::new()?), 1, Some(true));\n    scheduler.add(Box::new(CanBusNode::new(\"can0\")?), 1, Some(true));\n    scheduler.add(Box::new(SerialNode::new(\"/dev/ttyUSB0\")?), 1, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:30:rust",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 30,
      "lineEnd": 43,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut joystick = JoystickNode::new(0)?;  // Controller index 0\n    joystick.set_deadzone(0.1);  // 10% deadzone\n\n    scheduler.add(Box::new(joystick), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:55:bash",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 55,
      "lineEnd": 58,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gilrs)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:64:yaml",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 64,
      "lineEnd": 69,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gilrs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:75:toml",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 75,
      "lineEnd": 78,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gilrs\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:82:rust",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 82,
      "lineEnd": 92,
      "language": "rust",
      "code": "// Set deadzone for analog sticks\njoystick.set_deadzone(0.15);  // 15%\n\n// Map axes\njoystick.map_axis(0, AxisType::LeftStickX);\njoystick.map_axis(1, AxisType::LeftStickY);\n\n// Button mapping\njoystick.map_button(0, ButtonType::Cross);  // PS: X, Xbox: A",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:96:rust",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 96,
      "lineEnd": 115,
      "language": "rust",
      "code": "let hub = Hub::<JoystickState>::new(\"joystick.state\")?;\n\nif let Some(state) = hub.recv(&mut None) {\n    // Read analog sticks\n    println!(\"Left stick: ({:.2}, {:.2})\",\n        state.left_stick_x, state.left_stick_y);\n    println!(\"Right stick: ({:.2}, {:.2})\",\n        state.right_stick_x, state.right_stick_y);\n\n    // Check buttons\n    if state.button_cross {\n        println!(\"Cross/A button pressed\");\n    }\n\n    // Read triggers\n    println!(\"Triggers: L2={:.2}, R2={:.2}\",\n        state.left_trigger, state.right_trigger);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/joystick:119:rust",
      "file": "content/docs/rust/library/built-in-nodes/joystick.mdx",
      "lineStart": 119,
      "lineEnd": 130,
      "language": "rust",
      "code": "// Convert joystick to velocity commands\nlet joy_hub = Hub::<JoystickState>::new(\"joystick.state\")?;\nlet cmd_hub = Hub::<TwistCommand>::new(\"cmd_vel\")?;\n\nif let Some(joy) = joy_hub.recv(&mut None) {\n    cmd_hub.send(TwistCommand {\n        linear_x: joy.left_stick_y * 1.0,  // Max 1 m/s\n        angular_z: joy.left_stick_x * 2.0, // Max 2 rad/s\n    }, None)?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/keyboard-input:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/keyboard-input.mdx",
      "lineStart": 27,
      "lineEnd": 40,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut keyboard = KeyboardInputNode::new()?;\n    keyboard.enable_key_repeat(false);\n\n    scheduler.add(Box::new(keyboard), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/keyboard-input:52:bash",
      "file": "content/docs/rust/library/built-in-nodes/keyboard-input.mdx",
      "lineStart": 52,
      "lineEnd": 55,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: crossterm)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/keyboard-input:61:yaml",
      "file": "content/docs/rust/library/built-in-nodes/keyboard-input.mdx",
      "lineStart": 61,
      "lineEnd": 66,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - crossterm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/keyboard-input:72:toml",
      "file": "content/docs/rust/library/built-in-nodes/keyboard-input.mdx",
      "lineStart": 72,
      "lineEnd": 75,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"crossterm\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/keyboard-input:79:rust",
      "file": "content/docs/rust/library/built-in-nodes/keyboard-input.mdx",
      "lineStart": 79,
      "lineEnd": 94,
      "language": "rust",
      "code": "let hub = Hub::<KeyEvent>::new(\"keyboard.event\")?;\n\nif let Some(event) = hub.recv(&mut None) {\n    if event.pressed {\n        match event.key {\n            Key::W | Key::Up => println!(\"Forward\"),\n            Key::S | Key::Down => println!(\"Backward\"),\n            Key::A | Key::Left => println!(\"Turn left\"),\n            Key::D | Key::Right => println!(\"Turn right\"),\n            Key::Space => println!(\"Stop\"),\n            _ => {}\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/keyboard-input:98:rust",
      "file": "content/docs/rust/library/built-in-nodes/keyboard-input.mdx",
      "lineStart": 98,
      "lineEnd": 122,
      "language": "rust",
      "code": "let key_hub = Hub::<KeyEvent>::new(\"keyboard.event\")?;\nlet cmd_hub = Hub::<TwistCommand>::new(\"cmd_vel\")?;\n\nlet mut linear = 0.0;\nlet mut angular = 0.0;\n\nwhile let Some(event) = key_hub.recv(&mut None) {\n    if event.pressed {\n        match event.key {\n            Key::W => linear = 0.5,\n            Key::S => linear = -0.5,\n            Key::A => angular = 1.0,\n            Key::D => angular = -1.0,\n            _ => {}\n        }\n    } else {\n        // Key released\n        linear = 0.0;\n        angular = 0.0;\n    }\n\n    cmd_hub.send(TwistCommand { linear_x: linear, angular_z: angular }, &mut None).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 28,
      "lineEnd": 47,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Option 1: Simulation mode (no hardware needed)\n    let lidar = LidarNode::new()?;\n\n    // Option 2: With real LiDAR hardware\n    let mut lidar = LidarNode::new_with_backend(\"scan\", LidarBackend::RpLidar)?;\n    lidar.set_serial_port(\"/dev/ttyUSB0\");\n    lidar.set_scan_frequency(10.0);     // 10 Hz\n    lidar.set_range_limits(0.15, 12.0); // 15cm to 12m\n\n    scheduler.add(Box::new(lidar), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:61:bash",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 61,
      "lineEnd": 64,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: rplidar)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:70:yaml",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 70,
      "lineEnd": 75,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - rplidar",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:81:toml",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 81,
      "lineEnd": 84,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"rplidar\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:118:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 118,
      "lineEnd": 129,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topic \"scan\"\nlet mut lidar = LidarNode::new()?;\n\n// Create with custom topic name\nlet mut lidar = LidarNode::new_with_topic(\"front_lidar\")?;\n\n// Create with specific backend\nlet mut lidar = LidarNode::new_with_backend(\"scan\", LidarBackend::RplidarA2)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:133:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 133,
      "lineEnd": 155,
      "language": "rust",
      "code": "// Set LiDAR backend\nlidar.set_backend(LidarBackend::RplidarA2);\n\n// Set serial port for hardware LiDAR\nlidar.set_serial_port(\"/dev/ttyUSB0\");\n\n// Set coordinate frame ID for transforms\nlidar.set_frame_id(\"base_laser\");\n\n// Set scan frequency (Hz)\nlidar.set_scan_frequency(15.0);  // 15 Hz scan rate\n\n// Set range limits (min, max in meters)\nlidar.set_range_limits(0.15, 12.0);  // 15cm - 12m range\n\n// Set angular resolution (radians)\nlidar.set_angle_increment(std::f32::consts::PI / 360.0);  // 0.5 degrees\n\n// Get actual scan rate (diagnostics)\nlet actual_rate = lidar.get_actual_scan_rate();\neprintln!(\"Actual scan rate: {} Hz\", actual_rate);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:179:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 179,
      "lineEnd": 233,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n/// Custom node that detects obstacles from LiDAR scans\nstruct ObstacleDetector {\n    scan_sub: Hub<LaserScan>,\n    warning_distance: f32,\n}\n\nimpl ObstacleDetector {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            scan_sub: Hub::new(\"scan\")?,\n            warning_distance: 0.5, // meters\n        })\n    }\n}\n\nimpl Node for ObstacleDetector {\n    fn name(&self) -> &'static str {\n        \"ObstacleDetector\"\n    }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            // Find closest obstacle\n            if let Some(min_dist) = scan.min_range() {\n                if min_dist < self.warning_distance {\n                    if let Some(ctx) = ctx {\n                        ctx.log_warning(&format!(\"Obstacle at {:.2} meters!\", min_dist));\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create LiDAR node\n    let mut lidar = LidarNode::new()?;\n    lidar.set_scan_frequency(10.0);\n    lidar.set_range_limits(0.1, 30.0);\n\n    // Create obstacle detector\n    let detector = ObstacleDetector::new()?;\n\n    scheduler.add(Box::new(lidar), 50, Some(true));\n    scheduler.add(Box::new(detector), 51, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:237:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 237,
      "lineEnd": 302,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n/// Monitors multiple LiDAR sensors\nstruct MultiLidarMonitor {\n    front_sub: Hub<LaserScan>,\n    rear_sub: Hub<LaserScan>,\n}\n\nimpl MultiLidarMonitor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            front_sub: Hub::new(\"front.scan\")?,\n            rear_sub: Hub::new(\"rear.scan\")?,\n        })\n    }\n}\n\nimpl Node for MultiLidarMonitor {\n    fn name(&self) -> &'static str {\n        \"MultiLidarMonitor\"\n    }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        // Process front scan\n        if let Some(scan) = self.front_sub.recv(&mut ctx) {\n            if let Some(ctx) = ctx {\n                ctx.log_info(&format!(\"Front LiDAR: {} valid points\", scan.valid_count()));\n            }\n        }\n\n        // Process rear scan\n        if let Some(scan) = self.rear_sub.recv(&mut ctx) {\n            if let Some(ctx) = ctx {\n                ctx.log_info(&format!(\"Rear LiDAR: {} valid points\", scan.valid_count()));\n            }\n        }\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Front LiDAR\n    let mut front_lidar = LidarNode::new_with_topic(\"front.scan\")?;\n    front_lidar.set_frame_id(\"front_laser\");\n    front_lidar.set_scan_frequency(10.0);\n    front_lidar.set_range_limits(0.15, 12.0);\n\n    // Rear LiDAR\n    let mut rear_lidar = LidarNode::new_with_topic(\"rear.scan\")?;\n    rear_lidar.set_frame_id(\"rear_laser\");\n    rear_lidar.set_scan_frequency(10.0);\n    rear_lidar.set_range_limits(0.15, 12.0);\n\n    // Create monitor node\n    let monitor = MultiLidarMonitor::new()?;\n\n    scheduler.add(Box::new(front_lidar), 50, Some(true));\n    scheduler.add(Box::new(rear_lidar), 50, Some(true));\n    scheduler.add(Box::new(monitor), 51, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:306:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 306,
      "lineEnd": 335,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn check_collision_zones(scan: &LaserScan, num_zones: usize, danger_distance: f32) {\n    let zone_angle = 2.0 * std::f32::consts::PI / num_zones as f32;\n\n    for zone in 0..num_zones {\n        let mut min_dist_in_zone = f32::MAX;\n        let zone_start = zone as f32 * zone_angle;\n        let zone_end = (zone + 1) as f32 * zone_angle;\n\n        // Check all points in this zone\n        for i in 0..360 {\n            if !scan.is_range_valid(i) {\n                continue;\n            }\n\n            let angle = scan.angle_at(i);\n            if angle >= zone_start && angle < zone_end {\n                min_dist_in_zone = min_dist_in_zone.min(scan.ranges[i]);\n            }\n        }\n\n        // Alert if obstacle too close in this zone\n        if min_dist_in_zone < danger_distance {\n            eprintln!(\"Zone {}: COLLISION RISK at {:.2}m\", zone, min_dist_in_zone);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:343:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 343,
      "lineEnd": 372,
      "language": "rust",
      "code": "pub struct LaserScan {\n    /// Range measurements in meters (0 = invalid reading)\n    pub ranges: [f32; 360],\n\n    /// Start angle of the scan in radians\n    pub angle_min: f32,\n\n    /// End angle of the scan in radians\n    pub angle_max: f32,\n\n    /// Minimum valid range in meters\n    pub range_min: f32,\n\n    /// Maximum valid range in meters\n    pub range_max: f32,\n\n    /// Angular resolution in radians\n    pub angle_increment: f32,\n\n    /// Time between measurements in seconds\n    pub time_increment: f32,\n\n    /// Time to complete full scan in seconds\n    pub scan_time: f32,\n\n    /// Timestamp in nanoseconds since epoch\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:376:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 376,
      "lineEnd": 392,
      "language": "rust",
      "code": "// Get angle for a specific range index\nlet angle = scan.angle_at(index);\n\n// Check if a range reading is valid\nif scan.is_range_valid(index) {\n    // Process valid range\n}\n\n// Count all valid range readings\nlet valid_count = scan.valid_count();\n\n// Find closest obstacle\nif let Some(min_dist) = scan.min_range() {\n    eprintln!(\"Closest obstacle at {} meters\", min_dist);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:396:text",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 396,
      "lineEnd": 404,
      "language": "text",
      "code": "        0° (forward)\n             |\n             |\n   270° -----+----- 90°\n  (left)     |    (right)\n             |\n          180° (rear)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:412:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 412,
      "lineEnd": 418,
      "language": "rust",
      "code": "// 1 degree resolution (360 points per scan)\nlidar.set_angle_increment(std::f32::consts::PI / 180.0);\n\n// 0.5 degree resolution (720 points per scan)\nlidar.set_angle_increment(std::f32::consts::PI / 360.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:428:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 428,
      "lineEnd": 437,
      "language": "rust",
      "code": "// Indoor navigation (short-range, high precision)\nlidar.set_range_limits(0.1, 5.0);\n\n// Outdoor navigation (long-range)\nlidar.set_range_limits(0.2, 30.0);\n\n// Obstacle avoidance (medium-range)\nlidar.set_range_limits(0.15, 12.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:443:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 443,
      "lineEnd": 452,
      "language": "rust",
      "code": "// Low frequency for mapping (5 Hz)\nlidar.set_scan_frequency(5.0);\n\n// Medium frequency for navigation (10 Hz)\nlidar.set_scan_frequency(10.0);\n\n// High frequency for dynamic obstacle avoidance (20 Hz)\nlidar.set_scan_frequency(20.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:458:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 458,
      "lineEnd": 492,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nstruct SlamProcessor {\n    scan_sub: Hub<LaserScan>,\n    min_valid_ratio: f32,\n}\n\nimpl SlamProcessor {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            scan_sub: Hub::new(\"scan\")?,\n            min_valid_ratio: 0.8, // At least 80% valid points\n        })\n    }\n}\n\nimpl Node for SlamProcessor {\n    fn name(&self) -> &'static str { \"SlamProcessor\" }\n\n    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            // Filter out invalid readings for better SLAM results\n            let valid_ratio = scan.valid_count() as f32 / 360.0;\n            if valid_ratio > self.min_valid_ratio {\n                // Process scan for SLAM\n                if let Some(ctx) = ctx {\n                    ctx.log_debug(&format!(\"SLAM: processed scan with {:.0}% valid points\",\n                        valid_ratio * 100.0));\n                }\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:496:rust",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 496,
      "lineEnd": 525,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nconst GRID_SIZE: usize = 200;  // 200x200 grid\nconst GRID_RESOLUTION: f32 = 0.05;  // 5cm per cell\n\nfn generate_costmap(scan: &LaserScan) -> [[u8; GRID_SIZE]; GRID_SIZE] {\n    let mut costmap = [[0u8; GRID_SIZE]; GRID_SIZE];\n    let center = GRID_SIZE / 2;\n\n    for i in 0..360 {\n        if !scan.is_range_valid(i) {\n            continue;\n        }\n\n        let angle = scan.angle_at(i);\n        let distance = scan.ranges[i];\n\n        // Mark obstacle cell\n        let x = center + (distance * angle.cos() / GRID_RESOLUTION) as usize;\n        let y = center + (distance * angle.sin() / GRID_RESOLUTION) as usize;\n\n        if x < GRID_SIZE && y < GRID_SIZE {\n            costmap[y][x] = 255;  // Obstacle\n        }\n    }\n\n    costmap\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:554:bash",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 554,
      "lineEnd": 563,
      "language": "bash",
      "code": "# Add user to dialout group (Linux)\nsudo usermod -a -G dialout $USER\n\n# Set permissions on device\nsudo chmod 666 /dev/ttyUSB0\n\n# Verify device exists\nls -l /dev/ttyUSB*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:566:bash",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 566,
      "lineEnd": 576,
      "language": "bash",
      "code": "# Create udev rule\nsudo nano /etc/udev/rules.d/99-lidar.rules\n\n# Add rule for RPLidar\nKERNEL==\"ttyUSB*\", ATTRS{idVendor}==\"10c4\", ATTRS{idProduct}==\"ea60\", MODE=\"0666\"\n\n# Reload rules\nsudo udevadm control --reload-rules\nsudo udevadm trigger",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:614:bash",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 614,
      "lineEnd": 617,
      "language": "bash",
      "code": "# Disable USB autosuspend (Linux)\necho -1 | sudo tee /sys/module/usbcore/parameters/autosuspend",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/lidar:640:text",
      "file": "content/docs/rust/library/built-in-nodes/lidar.mdx",
      "lineStart": 640,
      "lineEnd": 644,
      "language": "text",
      "code": "Rate = scan_frequency × scan_size\n     = 10 Hz × 1.5 KB\n     = 15 KB/s per LiDAR",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/localization:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/localization.mdx",
      "lineStart": 27,
      "lineEnd": 43,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut localization = LocalizationNode::new()?;\n    localization.set_algorithm(LocalizationAlgorithm::EKF);\n    localization.enable_sensor(SensorType::Odometry);\n    localization.enable_sensor(SensorType::IMU);\n    localization.enable_sensor(SensorType::GPS);\n\n    scheduler.add(Box::new(localization), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/localization:47:rust",
      "file": "content/docs/rust/library/built-in-nodes/localization.mdx",
      "lineStart": 47,
      "lineEnd": 55,
      "language": "rust",
      "code": "let hub = Hub::<Pose>::new(\"localization.pose\")?;\n\nif let Some(pose) = hub.recv(&mut None) {\n    println!(\"Fused position: ({:.2}, {:.2}), heading: {:.1}°\",\n        pose.x, pose.y, pose.theta * 180.0 / PI);\n    println!(\"Covariance: {:.4}\", pose.covariance);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 29,
      "lineEnd": 44,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create Modbus RTU node\n    let mut modbus = ModbusNode::new_rtu(\"/dev/ttyUSB0\")?;\n    modbus.set_baud_rate(19200);\n    modbus.set_slave_id(1);\n\n    scheduler.add(Box::new(modbus), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:50:bash",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 50,
      "lineEnd": 59,
      "language": "bash",
      "code": "# Install Modbus tools\nsudo apt install libmodbus-dev\n\n# For RTU: Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# For TCP: Ensure network connectivity\nping 192.168.1.100",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:63:text",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 63,
      "lineEnd": 68,
      "language": "text",
      "code": "USB-RS485 Adapter    Device\nA/D+ (Green)   ---   A/D+\nB/D- (White)   ---   B/D-\nGND  (Black)   ---   GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:74:bash",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 74,
      "lineEnd": 77,
      "language": "bash",
      "code": "# No special wiring - uses standard Ethernet\n# Default port: 502",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:87:bash",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 87,
      "lineEnd": 90,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: serial-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:96:yaml",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 96,
      "lineEnd": 101,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - serial-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:107:toml",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 107,
      "lineEnd": 110,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"serial-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:116:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 116,
      "lineEnd": 132,
      "language": "rust",
      "code": "// Create RTU master\nlet mut modbus = ModbusNode::new_rtu(\"/dev/ttyUSB0\")?;\n\n// Configure serial parameters\nmodbus.set_baud_rate(19200);     // Common: 9600, 19200, 38400\nmodbus.set_parity(Parity::Even); // Even parity typical for Modbus\nmodbus.set_data_bits(8);\nmodbus.set_stop_bits(1);\n\n// Set slave ID (1-247)\nmodbus.set_slave_id(1);\n\n// Timeouts\nmodbus.set_response_timeout(1000); // 1 second\nmodbus.set_byte_timeout(50);       // 50ms between bytes",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:136:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 136,
      "lineEnd": 145,
      "language": "rust",
      "code": "// Create TCP master\nlet mut modbus = ModbusNode::new_tcp(\"192.168.1.100:502\")?;\n\n// Set slave ID (unit identifier)\nmodbus.set_slave_id(1);\n\n// Timeout\nmodbus.set_response_timeout(5000); // 5 seconds",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:149:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 149,
      "lineEnd": 156,
      "language": "rust",
      "code": "// Master mode (default) - initiates requests\nmodbus.set_mode(ModbusMode::Master);\n\n// Slave mode - responds to requests\nmodbus.set_mode(ModbusMode::Slave);\nmodbus.set_slave_id(1);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:162:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 162,
      "lineEnd": 172,
      "language": "rust",
      "code": "// 0x01: Read Coils\nmodbus.read_coils(1, 0, 16)?; // slave, address, count\n\n// 0x05: Write Single Coil\nmodbus.write_single_coil(1, 0, true)?;\n\n// 0x0F: Write Multiple Coils\nlet coils = vec![true, false, true, false];\nmodbus.write_multiple_coils(1, 0, &coils)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:176:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 176,
      "lineEnd": 179,
      "language": "rust",
      "code": "// 0x02: Read Discrete Inputs\nmodbus.read_discrete_inputs(1, 0, 8)?; // slave, address, count",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:183:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 183,
      "lineEnd": 187,
      "language": "rust",
      "code": "// 0x04: Read Input Registers\nlet values = modbus.read_input_registers(1, 0, 10)?;\nprintln!(\"Input registers: {:?}\", values);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:191:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 191,
      "lineEnd": 201,
      "language": "rust",
      "code": "// 0x03: Read Holding Registers\nlet registers = modbus.read_holding_registers(1, 0, 10)?;\n\n// 0x06: Write Single Register\nmodbus.write_single_register(1, 0, 1234)?;\n\n// 0x10: Write Multiple Registers\nlet data = vec![100, 200, 300, 400];\nmodbus.write_multiple_registers(1, 0, &data)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:207:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 207,
      "lineEnd": 235,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create Modbus request\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x04,  // Read Input Registers\n    address: 0,\n    count: 2,\n    data: vec![],\n};\n\n// Send request\nlet hub = Hub::<ModbusRequest>::new(\"modbus.request\")?;\nhub.send(request, &mut None).ok();\n\n// Receive response\nlet resp_hub = Hub::<ModbusResponse>::new(\"modbus.response\")?;\nif let Some(response) = resp_hub.recv(&mut None) {\n    if response.success {\n        // Convert registers to temperature (example)\n        let raw = (response.data[0] as u32) << 16 | response.data[1] as u32;\n        let temp = raw as f32 / 10.0;\n        println!(\"Temperature: {:.1}°C\", temp);\n    } else {\n        println!(\"Error: 0x{:02X}\", response.exception_code);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:239:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 239,
      "lineEnd": 249,
      "language": "rust",
      "code": "// Write setpoint to holding register\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x06,  // Write Single Register\n    address: 100,\n    count: 1,\n    data: vec![5000],  // Setpoint value\n};\nhub.send(request, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:253:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 253,
      "lineEnd": 269,
      "language": "rust",
      "code": "// Poll 3 slaves in sequence\nfor slave_id in 1..=3 {\n    let request = ModbusRequest {\n        slave_id,\n        function_code: 0x03,\n        address: 0,\n        count: 10,\n        data: vec![],\n    };\n    hub.send(request, &mut None).ok();\n\n    if let Some(resp) = resp_hub.recv(Some(Duration::from_millis(500))) {\n        println!(\"Slave {}: {:?}\", slave_id, resp.data);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:275:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 275,
      "lineEnd": 295,
      "language": "rust",
      "code": "// Read voltage (register 0x0000)\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x04,\n    address: 0x0000,\n    count: 2,  // Float32 = 2 registers\n    data: vec![],\n};\nhub.send(request, &mut None).ok();\n\n// Read current (register 0x0006)\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x04,\n    address: 0x0006,\n    count: 2,\n    data: vec![],\n};\nhub.send(request, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:299:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 299,
      "lineEnd": 317,
      "language": "rust",
      "code": "// Read process value (PV)\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x03,  // Read Holding Registers\n    address: 0x1000,\n    count: 1,\n    data: vec![],\n};\n\n// Write setpoint (SP)\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x06,\n    address: 0x1001,\n    count: 1,\n    data: vec![2500],  // 25.00°C\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:321:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 321,
      "lineEnd": 348,
      "language": "rust",
      "code": "// Read motor speed (Hz)\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x03,\n    address: 0x2103,\n    count: 1,\n    data: vec![],\n};\n\n// Set frequency setpoint\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x06,\n    address: 0x2001,\n    count: 1,\n    data: vec![5000],  // 50.00 Hz\n};\n\n// Start motor (write coil)\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x05,\n    address: 0x0000,\n    count: 1,\n    data: vec![1],  // ON\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:352:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 352,
      "lineEnd": 370,
      "language": "rust",
      "code": "// Read digital inputs\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x02,  // Read Discrete Inputs\n    address: 0,\n    count: 16,\n    data: vec![],\n};\n\n// Write digital outputs\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x0F,  // Write Multiple Coils\n    address: 0,\n    count: 8,\n    data: vec![0b10101010],  // Coil states\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:376:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 376,
      "lineEnd": 385,
      "language": "rust",
      "code": "pub struct ModbusRequest {\n    pub slave_id: u8,         // Slave address (1-247)\n    pub function_code: u8,    // Function code (0x01-0x17)\n    pub address: u16,         // Starting address\n    pub count: u16,           // Number of coils/registers\n    pub data: Vec<u16>,       // Data to write\n    pub timestamp: u64,       // Request time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:389:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 389,
      "lineEnd": 398,
      "language": "rust",
      "code": "pub struct ModbusResponse {\n    pub slave_id: u8,         // Slave address\n    pub function_code: u8,    // Function code\n    pub data: Vec<u16>,       // Response data\n    pub success: bool,        // Request succeeded\n    pub exception_code: u8,   // Error code if failed\n    pub timestamp: u64,       // Response time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:402:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 402,
      "lineEnd": 412,
      "language": "rust",
      "code": "pub const ILLEGAL_FUNCTION: u8 = 0x01;\npub const ILLEGAL_DATA_ADDRESS: u8 = 0x02;\npub const ILLEGAL_DATA_VALUE: u8 = 0x03;\npub const SLAVE_DEVICE_FAILURE: u8 = 0x04;\npub const ACKNOWLEDGE: u8 = 0x05;\npub const SLAVE_DEVICE_BUSY: u8 = 0x06;\npub const MEMORY_PARITY_ERROR: u8 = 0x08;\npub const GATEWAY_PATH_UNAVAILABLE: u8 = 0x0A;\npub const GATEWAY_TARGET_NO_RESPONSE: u8 = 0x0B;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:416:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 416,
      "lineEnd": 487,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure Modbus RTU\n    let mut modbus = ModbusNode::new_rtu(\"/dev/ttyUSB0\")?;\n    modbus.set_baud_rate(19200);\n    modbus.set_response_timeout(1000);\n\n    scheduler.add(Box::new(modbus), 1, Some(true));\n\n    // SCADA polling node\n    let scada_node = node! {\n        name: \"scada_poller\",\n        tick: |ctx| {\n            let req_hub = Hub::<ModbusRequest>::new(\"modbus.request\")?;\n            let resp_hub = Hub::<ModbusResponse>::new(\"modbus.response\")?;\n\n            // Poll slave 1: Temperature sensor\n            let request = ModbusRequest {\n                slave_id: 1,\n                function_code: 0x04,  // Read Input Registers\n                address: 0,\n                count: 2,\n                data: vec![],\n            };\n            req_hub.send(request, &mut None).ok();\n\n            if let Some(resp) = resp_hub.recv(Some(Duration::from_millis(500))) {\n                if resp.success {\n                    let temp = resp.data[0] as f32 / 10.0;\n                    ctx.log_info(&format!(\"Slave 1 Temp: {:.1}°C\", temp));\n\n                    // Check alarm condition\n                    if temp > 80.0 {\n                        ctx.log_warning(\"High temperature alarm!\");\n                        // Send shutdown command to slave 2\n                    }\n                } else {\n                    ctx.log_error(&format!(\n                        \"Slave 1 error: 0x{:02X}\", resp.exception_code\n                    ));\n                }\n            }\n\n            // Poll slave 2: Motor controller\n            let request = ModbusRequest {\n                slave_id: 2,\n                function_code: 0x03,\n                address: 100,\n                count: 4,\n                data: vec![],\n            };\n            req_hub.send(request, &mut None).ok();\n\n            if let Some(resp) = resp_hub.recv(Some(Duration::from_millis(500))) {\n                if resp.success {\n                    ctx.log_info(&format!(\"Motor status: {:?}\", resp.data));\n                }\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(scada_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:493:rust",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 493,
      "lineEnd": 508,
      "language": "rust",
      "code": "// Define register map\nconst REG_VOLTAGE: u16 = 0x0000;\nconst REG_CURRENT: u16 = 0x0006;\nconst REG_POWER: u16 = 0x000C;\nconst REG_ENERGY: u16 = 0x0156;\n\n// Read using named constants\nlet request = ModbusRequest {\n    slave_id: 1,\n    function_code: 0x04,\n    address: REG_VOLTAGE,\n    count: 2,\n    data: vec![],\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/modbus:599:bash",
      "file": "content/docs/rust/library/built-in-nodes/modbus.mdx",
      "lineStart": 599,
      "lineEnd": 608,
      "language": "bash",
      "code": "# Modbus RTU testing\nmodpoll -m rtu -b 19200 -p even -a 1 -t 4 -r 1 -c 10 /dev/ttyUSB0\n\n# Modbus TCP testing\nmodpoll -m tcp -a 1 -t 4 -r 1 -c 10 192.168.1.100\n\n# Modbus slave simulator\ndiagslave -m rtu -b 19200 -p even /dev/ttyUSB0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/odometry:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/odometry.mdx",
      "lineStart": 27,
      "lineEnd": 42,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut odom = OdometryNode::new()?;\n    odom.set_wheel_base(0.3);\n    odom.set_wheel_diameter(0.1);\n    odom.set_encoder_cpr(600);  // Counts per revolution\n\n    scheduler.add(Box::new(odom), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/odometry:46:rust",
      "file": "content/docs/rust/library/built-in-nodes/odometry.mdx",
      "lineStart": 46,
      "lineEnd": 55,
      "language": "rust",
      "code": "let hub = Hub::<Odometry>::new(\"odom.pose\")?;\n\nif let Some(pose) = hub.recv(&mut None) {\n    println!(\"Position: ({:.2}, {:.2}), Heading: {:.1}°\",\n        pose.x, pose.y, pose.theta * 180.0 / PI);\n    println!(\"Velocity: {:.2} m/s, {:.2} rad/s\",\n        pose.linear_velocity, pose.angular_velocity);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:37:yaml",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 37,
      "lineEnd": 42,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:46:rust",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 46,
      "lineEnd": 69,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let config = InferenceConfig {\n        use_gpu: true,\n        input_size: Some([224, 224]),\n        ..Default::default()\n    };\n\n    let inference_node = ONNXInferenceNode::new(\n        \"models/mobilenet_v2.onnx\",\n        \"camera.raw\",\n        \"ml.predictions\",\n        config,\n    )?;\n\n    scheduler.add(Box::new(inference_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:117:rust",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 117,
      "lineEnd": 128,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Predictions;\n\nlet predictions_hub = Hub::<Predictions>::new(\"ml.predictions\")?;\n\nif let Some(preds) = predictions_hub.recv(&mut None) {\n    // Get top-k predictions\n    for (class_id, confidence) in preds.top_k(5) {\n        println!(\"Class {}: {:.2}%\", class_id, confidence * 100.0);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:132:rust",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 132,
      "lineEnd": 147,
      "language": "rust",
      "code": "let config = InferenceConfig {\n    input_size: Some([320, 320]),\n    // Custom normalization for your model\n    norm_mean: [0.5, 0.5, 0.5],\n    norm_std: [0.5, 0.5, 0.5],\n    ..Default::default()\n};\n\nlet node = ONNXInferenceNode::new(\n    \"models/custom_model.onnx\",\n    \"sensor.image\",\n    \"custom.output\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:151:rust",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 151,
      "lineEnd": 157,
      "language": "rust",
      "code": "let config = InferenceConfig {\n    batch_size: 4,  // Process 4 images at once\n    use_gpu: true,  // GPU recommended for batching\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:161:rust",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 161,
      "lineEnd": 180,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Tensor;\n\n// For models that don't use images\nlet input_pub = Hub::<Tensor>::new(\"ml.input.tensor\")?;\nlet output_sub = Hub::<Tensor>::new(\"ml.output.tensor\")?;\n\n// Send custom tensor\nlet tensor = Tensor {\n    data: vec![1.0, 2.0, 3.0, 4.0],\n    shape: vec![1, 4],\n    dtype: \"float32\".to_string(),\n};\ninput_pub.send(tensor, &mut None).ok();\n\n// Receive output\nif let Some(output) = output_sub.recv(&mut None) {\n    println!(\"Output shape: {:?}\", output.shape);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:188:python",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 188,
      "lineEnd": 201,
      "language": "python",
      "code": "import torch\nimport torchvision.models as models\n\nmodel = models.mobilenet_v2(pretrained=True)\nmodel.eval()\n\ndummy_input = torch.randn(1, 3, 224, 224)\ntorch.onnx.export(model, dummy_input, \"mobilenet_v2.onnx\",\n                  input_names=['input'],\n                  output_names=['output'],\n                  dynamic_axes={'input': {0: 'batch_size'},\n                              'output': {0: 'batch_size'}})",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/onnx-inference:205:python",
      "file": "content/docs/rust/library/built-in-nodes/onnx-inference.mdx",
      "lineStart": 205,
      "lineEnd": 213,
      "language": "python",
      "code": "import tf2onnx\nimport tensorflow as tf\n\nmodel = tf.keras.applications.MobileNetV2()\nspec = (tf.TensorSpec((None, 224, 224, 3), tf.float32),)\ntf2onnx.convert.from_keras(model, input_signature=spec,\n                           output_path=\"mobilenet_v2.onnx\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/path-planner:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/path-planner.mdx",
      "lineStart": 27,
      "lineEnd": 41,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut planner = PathPlannerNode::new()?;\n    planner.set_algorithm(PlannerAlgorithm::AStar);\n    planner.set_grid_resolution(0.05);  // 5cm grid\n\n    scheduler.add(Box::new(planner), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/path-planner:45:rust",
      "file": "content/docs/rust/library/built-in-nodes/path-planner.mdx",
      "lineStart": 45,
      "lineEnd": 62,
      "language": "rust",
      "code": "let hub = Hub::<PathRequest>::new(\"path_planner.request\")?;\n\n// Request path from (0,0) to (5,5)\nhub.send(PathRequest {\n    start_x: 0.0,\n    start_y: 0.0,\n    goal_x: 5.0,\n    goal_y: 5.0,\n}, None)?;\n\nlet path_hub = Hub::<Path>::new(\"path_planner.path\")?;\nif let Some(path) = path_hub.recv(&mut None) {\n    for waypoint in &path.waypoints {\n        println!(\"Waypoint: ({:.2}, {:.2})\", waypoint.x, waypoint.y);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 28,
      "lineEnd": 58,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create PID controller\n    let mut pid = PidControllerNode::new(\n        \"pid.setpoint\",  // Subscribe to setpoint commands\n        \"pid.feedback\",  // Subscribe to feedback values\n        \"motor_cmd\",     // Publish motor commands\n    )?;\n\n    // Configure PID gains\n    pid.set_gains(1.0, 0.1, 0.05);  // Kp=1.0, Ki=0.1, Kd=0.05\n    pid.set_output_limits(-1.0, 1.0);  // Output range\n    pid.set_integral_limits(-0.5, 0.5);  // Anti-windup\n\n    scheduler.add(Box::new(pid), 50, Some(true));\n    scheduler.run()?;\n    Ok(())\n}\n\n// Send setpoint from another node:\nlet setpoint_hub = Hub::<SetpointCommand>::new(\"pid.setpoint\")?;\nsetpoint_hub.send(SetpointCommand::new(0, 100.0), None);  // Target: 100.0\n\n// Send feedback from sensor:\nlet feedback_hub = Hub::<FeedbackValue>::new(\"pid.feedback\")?;\nfeedback_hub.send(FeedbackValue::new(0, 95.0), None);  // Current: 95.0",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:85:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 85,
      "lineEnd": 98,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create with default topics\nlet mut pid = PidControllerNode::new()?;\n\n// Create with custom topics\nlet mut pid = PidControllerNode::new_with_topics(\n    \"target.position\",      // setpoint topic\n    \"encoder_position\",     // feedback topic\n    \"motor.command\",        // output topic\n    \"pid_params\"            // config topic\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:102:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 102,
      "lineEnd": 123,
      "language": "rust",
      "code": "// Set PID gains\npid.set_gains(2.0, 0.5, 0.1);\n\n// Set output limits\npid.set_output_limits(-255.0, 255.0);\n\n// Set integral limits (anti-windup)\npid.set_integral_limits(-100.0, 100.0);\n\n// Set error deadband\npid.set_deadband(0.05);\n\n// Set motor ID for output commands\npid.set_motor_id(1);\n\n// Reset PID controller state\npid.reset();\n\n// Get current state (setpoint, feedback, error, integral)\nlet (setpoint, feedback, error, integral) = pid.get_state();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:159:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 159,
      "lineEnd": 183,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut scheduler = Scheduler::new();\n\n    // Create PID controller for motor position control\n    let mut pid = PidControllerNode::new_with_topics(\n        \"target.position\",\n        \"encoder_position\",\n        \"motor.command\",\n        \"pid_config\"\n    )?;\n\n    // Configure for position control\n    pid.set_gains(2.0, 0.5, 0.1);\n    pid.set_output_limits(-100.0, 100.0);\n    pid.set_motor_id(0);\n\n    scheduler.add(Box::new(pid), 50, Some(true));\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:187:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 187,
      "lineEnd": 201,
      "language": "rust",
      "code": "// Create PID controller for velocity control\nlet mut pid = PidControllerNode::new_with_topics(\n    \"target.velocity\",\n    \"measured.velocity\",\n    \"motor.pwm\",\n    \"pid_config\"\n)?;\n\n// Configure for velocity control (typically needs less integral gain)\npid.set_gains(1.5, 0.1, 0.05);\npid.set_output_limits(-255.0, 255.0);\npid.set_integral_limits(-50.0, 50.0);\npid.set_motor_id(0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:205:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 205,
      "lineEnd": 219,
      "language": "rust",
      "code": "// Create PID controller for temperature control\nlet mut pid = PidControllerNode::new_with_topics(\n    \"target_temperature\",\n    \"current_temperature\",\n    \"heater_power\",\n    \"pid_config\"\n)?;\n\n// Configure for temperature control (slower system, more integral)\npid.set_gains(5.0, 1.0, 0.5);\npid.set_output_limits(0.0, 100.0);  // 0-100% heater power\npid.set_integral_limits(-20.0, 20.0);\npid.set_deadband(0.5);  // 0.5 degree deadband",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:223:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 223,
      "lineEnd": 246,
      "language": "rust",
      "code": "// Left wheel velocity controller\nlet mut left_pid = PidControllerNode::new_with_topics(\n    \"left_target_vel\",\n    \"left_measured_vel\",\n    \"left_motor_cmd\",\n    \"left_pid_config\"\n)?;\nleft_pid.set_gains(1.5, 0.2, 0.05);\nleft_pid.set_motor_id(0);\n\n// Right wheel velocity controller\nlet mut right_pid = PidControllerNode::new_with_topics(\n    \"right_target_vel\",\n    \"right_measured_vel\",\n    \"right_motor_cmd\",\n    \"right_pid_config\"\n)?;\nright_pid.set_gains(1.5, 0.2, 0.05);\nright_pid.set_motor_id(1);\n\nscheduler.add(Box::new(left_pid), 50, Some(true));\nscheduler.add(Box::new(right_pid), 50, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:252:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 252,
      "lineEnd": 258,
      "language": "rust",
      "code": "pub struct PidConfig {\n    pub kp: f64,\n    pub ki: f64,\n    pub kd: f64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:262:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 262,
      "lineEnd": 268,
      "language": "rust",
      "code": "pub enum MotorCommand {\n    Velocity { motor_id: u8, value: f64 },\n    Position { motor_id: u8, value: f64 },\n    Torque { motor_id: u8, value: f64 },\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:314:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 314,
      "lineEnd": 317,
      "language": "rust",
      "code": "// Set integral limits to prevent windup\npid.set_integral_limits(-50.0, 50.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:328:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 328,
      "lineEnd": 331,
      "language": "rust",
      "code": "// Ignore errors smaller than 0.05\npid.set_deadband(0.05);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:342:text",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 342,
      "lineEnd": 349,
      "language": "text",
      "code": "error = setpoint - feedback\noutput = Kp * error + Ki * integral + Kd * derivative\n\nwhere:\n  integral = sum(error * dt)  [clamped to integral_min/max]\n  derivative = (error - last_error) / dt",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:353:text",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 353,
      "lineEnd": 355,
      "language": "text",
      "code": "effective_error = (abs(error) < deadband) ? 0 : error",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:359:text",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 359,
      "lineEnd": 361,
      "language": "text",
      "code": "output = clamp(output, output_min, output_max)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:370:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 370,
      "lineEnd": 376,
      "language": "rust",
      "code": "// Reduce Kp by 20-50%\npid.set_gains(kp * 0.7, ki, kd);\n\n// Or increase Kd\npid.set_gains(kp, ki, kd * 1.5);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:383:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 383,
      "lineEnd": 389,
      "language": "rust",
      "code": "// Increase Ki\npid.set_gains(kp, ki * 2.0, kd);\n\n// Or relax integral limits\npid.set_integral_limits(-100.0, 100.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:396:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 396,
      "lineEnd": 399,
      "language": "rust",
      "code": "// Increase Kp by 20-50%\npid.set_gains(kp * 1.3, ki, kd);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pid-controller:406:rust",
      "file": "content/docs/rust/library/built-in-nodes/pid-controller.mdx",
      "lineStart": 406,
      "lineEnd": 412,
      "language": "rust",
      "code": "// Increase output limits\npid.set_output_limits(-200.0, 200.0);\n\n// Or reduce gains\npid.set_gains(kp * 0.8, ki * 0.8, kd);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pose-estimation:28:yaml",
      "file": "content/docs/rust/library/built-in-nodes/pose-estimation.mdx",
      "lineStart": 28,
      "lineEnd": 33,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pose-estimation:37:rust",
      "file": "content/docs/rust/library/built-in-nodes/pose-estimation.mdx",
      "lineStart": 37,
      "lineEnd": 60,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let config = PoseConfig {\n        model_type: PoseModelType::MoveNetLightning,\n        confidence_threshold: 0.3,\n        ..Default::default()\n    };\n\n    let pose_node = PoseEstimationNode::new(\n        \"models/movenet_lightning.onnx\",\n        \"camera.raw\",\n        \"vision.poses\",\n        config,\n    )?;\n\n    scheduler.add(Box::new(pose_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pose-estimation:100:text",
      "file": "content/docs/rust/library/built-in-nodes/pose-estimation.mdx",
      "lineStart": 100,
      "lineEnd": 118,
      "language": "text",
      "code": "       0: nose\n      / \\\n    1   2: left/right eye\n    |   |\n    3   4: left/right ear\n      |\n      5: left shoulder -- 6: right shoulder\n      |                   |\n      7: left elbow    8: right elbow\n      |                   |\n      9: left wrist   10: right wrist\n      |\n     11: left hip  -- 12: right hip\n      |                   |\n     13: left knee   14: right knee\n      |                   |\n     15: left ankle  16: right ankle",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pose-estimation:124:rust",
      "file": "content/docs/rust/library/built-in-nodes/pose-estimation.mdx",
      "lineStart": 124,
      "lineEnd": 140,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides PoseArray;\n\nlet poses_hub = Hub::<PoseArray>::new(\"vision.poses\")?;\n\nif let Some(poses) = poses_hub.recv(&mut None) {\n    for pose in &poses.poses {\n        // Check if arm is raised (wrist above shoulder)\n        let left_wrist = &pose.keypoints[9];\n        let left_shoulder = &pose.keypoints[5];\n\n        if left_wrist.y < left_shoulder.y && left_wrist.confidence > 0.5 {\n            println!(\"Left arm raised!\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pose-estimation:144:rust",
      "file": "content/docs/rust/library/built-in-nodes/pose-estimation.mdx",
      "lineStart": 144,
      "lineEnd": 158,
      "language": "rust",
      "code": "// Track the closest person to the robot\nlet config = PoseConfig {\n    max_persons: 1,  // Focus on one person\n    confidence_threshold: 0.5,\n    ..Default::default()\n};\n\nlet pose_node = PoseEstimationNode::new(\n    \"models/movenet_thunder.onnx\",\n    \"camera.front\",\n    \"interaction.person_pose\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/pose-estimation:162:rust",
      "file": "content/docs/rust/library/built-in-nodes/pose-estimation.mdx",
      "lineStart": 162,
      "lineEnd": 179,
      "language": "rust",
      "code": "// Detect people in robot workspace\nstruct SafetyMonitor {\n    poses_sub: Hub<PoseArray>,\n    alert_pub: Hub<SafetyAlert>,\n}\n\nimpl Node for SafetyMonitor {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(poses) = self.poses_sub.recv(&mut ctx) {\n            if !poses.poses.is_empty() {\n                // Person detected in workspace\n                self.alert_pub.send(SafetyAlert::PersonDetected, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:31:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 31,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create Roboclaw node\n    let mut roboclaw = RoboclawMotorNode::new(\"/dev/ttyUSB0\")?;\n    roboclaw.set_baud_rate(38400);\n    roboclaw.set_address(0x80);  // Default address\n\n    scheduler.add(Box::new(roboclaw), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:52:bash",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 52,
      "lineEnd": 61,
      "language": "bash",
      "code": "# Install USB-serial drivers\nsudo apt install setserial\n\n# Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# Verify port\nls -l /dev/ttyUSB*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:65:text",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 65,
      "lineEnd": 74,
      "language": "text",
      "code": "Raspberry Pi    Roboclaw    Motors\nGPIO TX   -->   S1 (RX)\nGPIO RX   <--   S2 (TX)\nGND       ---   GND\n                M1A/M1B --> Motor 1\n                M2A/M2B --> Motor 2\n                +12-34V --> Battery\n                GND     --> Battery GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:78:text",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 78,
      "lineEnd": 86,
      "language": "text",
      "code": "Roboclaw        Encoder 1       Encoder 2\nENC1A     <--   Channel A\nENC1B     <--   Channel B\nENC2A     <--   Channel A\nENC2B     <--   Channel B\nGND       ---   GND\n+5V       -->   VCC (if needed)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:96:bash",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 96,
      "lineEnd": 99,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: serial-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:105:yaml",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 105,
      "lineEnd": 110,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - serial-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:116:toml",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 116,
      "lineEnd": 119,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"serial-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:125:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 125,
      "lineEnd": 136,
      "language": "rust",
      "code": "// 7.2V - 34V models\nRoboclawModel::_2x7A   // 2x7A continuous\nRoboclawModel::_2x15A  // 2x15A continuous\nRoboclawModel::_2x30A  // 2x30A continuous\nRoboclawModel::_2x45A  // 2x45A continuous\nRoboclawModel::_2x60A  // 2x60A continuous\n\n// High-voltage models (12V - 60V)\nRoboclawModel::_HV_2x30A\nRoboclawModel::_HV_2x60A",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:142:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 142,
      "lineEnd": 152,
      "language": "rust",
      "code": "let mut roboclaw = RoboclawMotorNode::new(\"/dev/ttyUSB0\")?;\n\n// Set baud rate (must match controller DIP switches or settings)\nroboclaw.set_baud_rate(38400);    // Default\nroboclaw.set_baud_rate(115200);   // High-speed\n\n// Set controller address (0x80-0x87 for up to 8 controllers)\nroboclaw.set_address(0x80);  // Controller 1\nroboclaw.set_address(0x81);  // Controller 2",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:156:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 156,
      "lineEnd": 167,
      "language": "rust",
      "code": "// Set encoder counts per revolution\nroboclaw.set_encoder_cpr(1, 1440);  // Motor 1: 1440 CPR\nroboclaw.set_encoder_cpr(2, 1440);  // Motor 2: 1440 CPR\n\n// Set encoder mode\nroboclaw.set_encoder_mode(1, EncoderMode::Quadrature);\nroboclaw.set_encoder_mode(2, EncoderMode::Quadrature);\n\n// Invert encoder direction if needed\nroboclaw.invert_encoder(1, true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:171:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 171,
      "lineEnd": 178,
      "language": "rust",
      "code": "// Set motor direction\nroboclaw.invert_motor(1, false);\nroboclaw.invert_motor(2, true);  // Reverse for differential drive\n\n// Set PWM frequency (1kHz - 30kHz)\nroboclaw.set_pwm_frequency(20000);  // 20 kHz",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:182:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 182,
      "lineEnd": 190,
      "language": "rust",
      "code": "// Position PID gains for motor 1\nroboclaw.set_position_pid(1, 0x00010000, 0x00008000, 0x00004000, 2000000);\n// Parameters: motor_id, P, I, D, max_speed\n\n// Velocity PID gains\nroboclaw.set_velocity_pid(1, 0x00020000, 0x00010000, 0x00000000, 44000);\n// Parameters: motor_id, P, I, D, QPPS (quadrature pulses per second)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:194:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 194,
      "lineEnd": 204,
      "language": "rust",
      "code": "// Set current limit (Amps * 10)\nroboclaw.set_current_limit(1, 50);  // 5.0 A\n\n// Set min/max voltage\nroboclaw.set_min_voltage(10.5);  // Volts\nrobococlaw.set_max_voltage(14.8);  // Volts\n\n// Set max speed (encoder counts/sec)\nroboclaw.set_max_speed(1, 10000);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:210:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 210,
      "lineEnd": 230,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Drive motor 1 at 50% forward\nlet cmd = RoboclawCommand {\n    motor_id: 1,\n    command_type: RoboclawCommand::CMD_DUTY,\n    value: 16384,  // -32768 to +32767 (-100% to +100%)\n};\n\nlet hub = Hub::<RoboclawCommand>::new(\"roboclaw.command\")?;\nhub.send(cmd, &mut None).ok();\n\n// Stop motor\nlet cmd = RoboclawCommand {\n    motor_id: 1,\n    command_type: RoboclawCommand::CMD_DUTY,\n    value: 0,\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:234:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 234,
      "lineEnd": 243,
      "language": "rust",
      "code": "// Set velocity in QPPS (Quadrature Pulses Per Second)\nlet cmd = RoboclawCommand {\n    motor_id: 1,\n    command_type: RoboclawCommand::CMD_VELOCITY,\n    value: 5000,  // 5000 QPPS\n    accel: 10000,  // Acceleration (QPPS²)\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:247:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 247,
      "lineEnd": 259,
      "language": "rust",
      "code": "// Move to absolute position\nlet cmd = RoboclawCommand {\n    motor_id: 1,\n    command_type: RoboclawCommand::CMD_POSITION,\n    position: 14400,  // 10 revolutions (1440 CPR * 10)\n    speed: 5000,      // Speed (QPPS)\n    accel: 10000,     // Acceleration\n    deccel: 10000,    // Deceleration\n    buffer: true,     // Buffer command\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:263:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 263,
      "lineEnd": 272,
      "language": "rust",
      "code": "// Drive forward at speed with turning\nlet cmd = RoboclawMixedCommand {\n    forward_speed: 5000,   // Forward velocity (QPPS)\n    turn_rate: -1000,      // Turn rate (negative = left)\n};\n\nlet hub = Hub::<RoboclawMixedCommand>::new(\"roboclaw.mixed\")?;\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:278:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 278,
      "lineEnd": 342,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure Roboclaw for differential drive\n    let mut roboclaw = RoboclawMotorNode::new(\"/dev/ttyUSB0\")?;\n    roboclaw.set_baud_rate(38400);\n    roboclaw.set_address(0x80);\n\n    // Configure encoders (1440 CPR wheels)\n    roboclaw.set_encoder_cpr(1, 1440);\n    roboclaw.set_encoder_cpr(2, 1440);\n\n    // Invert motor 2 for differential drive\n    roboclaw.invert_motor(2, true);\n\n    // Set velocity PID\n    roboclaw.set_velocity_pid(1, 0x00020000, 0x00010000, 0x00000000, 44000);\n    roboclaw.set_velocity_pid(2, 0x00020000, 0x00010000, 0x00000000, 44000);\n\n    scheduler.add(Box::new(roboclaw), 1, Some(true));\n\n    // Drive control node\n    let drive_node = node! {\n        name: \"drive_control\",\n        tick: |ctx| {\n            let hub = Hub::<RoboclawMixedCommand>::new(\"roboclaw.mixed\")?;\n\n            // Example: Drive forward\n            hub.send(RoboclawMixedCommand {\n                forward_speed: 5000,\n                turn_rate: 0,\n            }, None)?;\n\n            // Monitor status\n            let status_hub = Hub::<RoboclawStatus>::new(\"roboclaw.status\")?;\n            if let Some(status) = status_hub.recv(&mut None) {\n                ctx.log_info(&format!(\n                    \"M1: {} counts, {} QPPS | M2: {} counts, {} QPPS\",\n                    status.encoder1, status.speed1,\n                    status.encoder2, status.speed2\n                ));\n\n                // Check battery\n                if status.battery_voltage < 11.0 {\n                    ctx.log_warning(\"Low battery!\");\n                }\n\n                // Check current\n                if status.current1 > 5.0 {\n                    ctx.log_warning(\"Motor 1 high current!\");\n                }\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(drive_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:346:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 346,
      "lineEnd": 357,
      "language": "rust",
      "code": "// Read encoder positions\nlet status_hub = Hub::<RoboclawStatus>::new(\"roboclaw.status\")?;\n\nif let Some(status) = status_hub.recv(&mut None) {\n    let motor1_revolutions = status.encoder1 as f32 / 1440.0;\n    let motor2_revolutions = status.encoder2 as f32 / 1440.0;\n\n    println!(\"M1: {:.2} rev, M2: {:.2} rev\",\n        motor1_revolutions, motor2_revolutions);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:361:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 361,
      "lineEnd": 369,
      "language": "rust",
      "code": "// Reset encoder counts to zero\nlet cmd = RoboclawCommand {\n    motor_id: 1,\n    command_type: RoboclawCommand::CMD_RESET_ENCODER,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:375:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 375,
      "lineEnd": 386,
      "language": "rust",
      "code": "pub struct RoboclawCommand {\n    pub motor_id: u8,         // Motor ID (1 or 2)\n    pub command_type: u8,     // Command type\n    pub value: i32,           // Duty/velocity value\n    pub position: i32,        // Target position\n    pub speed: u32,           // Speed for position mode\n    pub accel: u32,           // Acceleration\n    pub deccel: u32,          // Deceleration\n    pub buffer: bool,         // Buffer command\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:390:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 390,
      "lineEnd": 397,
      "language": "rust",
      "code": "pub const CMD_DUTY: u8 = 0;              // Duty cycle control\npub const CMD_VELOCITY: u8 = 1;          // Velocity control\npub const CMD_POSITION: u8 = 2;          // Position control\npub const CMD_RESET_ENCODER: u8 = 3;     // Reset encoder\npub const CMD_STOP: u8 = 4;              // Stop motor\npub const CMD_ESTOP: u8 = 5;             // Emergency stop",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:401:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 401,
      "lineEnd": 406,
      "language": "rust",
      "code": "pub struct RoboclawMixedCommand {\n    pub forward_speed: i32,   // Forward velocity (QPPS)\n    pub turn_rate: i32,       // Turn rate (QPPS)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:410:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 410,
      "lineEnd": 423,
      "language": "rust",
      "code": "pub struct RoboclawStatus {\n    pub encoder1: i32,            // Motor 1 encoder count\n    pub encoder2: i32,            // Motor 2 encoder count\n    pub speed1: i32,              // Motor 1 speed (QPPS)\n    pub speed2: i32,              // Motor 2 speed (QPPS)\n    pub current1: f32,            // Motor 1 current (A)\n    pub current2: f32,            // Motor 2 current (A)\n    pub battery_voltage: f32,     // Battery voltage (V)\n    pub temperature: f32,         // Controller temp (°C)\n    pub error_status: u16,        // Error flags\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/roboclaw-motor:427:rust",
      "file": "content/docs/rust/library/built-in-nodes/roboclaw-motor.mdx",
      "lineStart": 427,
      "lineEnd": 437,
      "language": "rust",
      "code": "pub const ERROR_E_STOP: u16 = 0x0001;\npub const ERROR_TEMPERATURE: u16 = 0x0002;\npub const ERROR_MAIN_VOLTAGE_HIGH: u16 = 0x0004;\npub const ERROR_LOGIC_VOLTAGE_HIGH: u16 = 0x0008;\npub const ERROR_LOGIC_VOLTAGE_LOW: u16 = 0x0010;\npub const ERROR_M1_DRIVER_FAULT: u16 = 0x0020;\npub const ERROR_M2_DRIVER_FAULT: u16 = 0x0040;\npub const ERROR_M1_OVER_CURRENT: u16 = 0x0080;\npub const ERROR_M2_OVER_CURRENT: u16 = 0x0100;",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/safety-monitor:31:rust",
      "file": "content/docs/rust/library/built-in-nodes/safety-monitor.mdx",
      "lineStart": 31,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let mut safety = SafetyMonitorNode::new()?;\n    safety.set_temperature_threshold(80.0);  // °C\n    safety.set_voltage_range(10.0, 14.8);    // Min/max volts\n    safety.enable_auto_shutdown(true);\n\n    scheduler.add(Box::new(safety), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/safety-monitor:50:rust",
      "file": "content/docs/rust/library/built-in-nodes/safety-monitor.mdx",
      "lineStart": 50,
      "lineEnd": 64,
      "language": "rust",
      "code": "let hub = Hub::<SafetyAlert>::new(\"safety.alert\")?;\n\nwhile let Some(alert) = hub.recv(&mut None) {\n    match alert.alert_type {\n        AlertType::HighTemperature => {\n            println!(\"WARNING: High temperature {:.1}°C\", alert.value);\n        }\n        AlertType::LowVoltage => {\n            println!(\"CRITICAL: Low voltage {:.2}V\", alert.value);\n        }\n        _ => {}\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:28:yaml",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 28,
      "lineEnd": 33,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:37:rust",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 37,
      "lineEnd": 60,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let config = SegmentationConfig {\n        num_classes: 21,  // Pascal VOC classes\n        use_gpu: true,\n        ..Default::default()\n    };\n\n    let segmentation = SemanticSegmentationNode::new(\n        \"models/deeplabv3.onnx\",\n        \"camera.raw\",\n        \"vision.segmentation\",\n        config,\n    )?;\n\n    scheduler.add(Box::new(segmentation), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:94:text",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 94,
      "lineEnd": 100,
      "language": "text",
      "code": "0: background, 1: aeroplane, 2: bicycle, 3: bird, 4: boat,\n5: bottle, 6: bus, 7: car, 8: cat, 9: chair, 10: cow,\n11: dining table, 12: dog, 13: horse, 14: motorbike,\n15: person, 16: potted plant, 17: sheep, 18: sofa,\n19: train, 20: tv/monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:104:text",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 104,
      "lineEnd": 109,
      "language": "text",
      "code": "0: road, 1: sidewalk, 2: building, 3: wall, 4: fence,\n5: pole, 6: traffic light, 7: traffic sign, 8: vegetation,\n9: terrain, 10: sky, 11: person, 12: rider, 13: car,\n14: truck, 15: bus, 16: train, 17: motorcycle, 18: bicycle",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:115:rust",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 115,
      "lineEnd": 131,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides SegmentationMask;\n\nlet seg_hub = Hub::<SegmentationMask>::new(\"vision.segmentation\")?;\n\nif let Some(mask) = seg_hub.recv(&mut None) {\n    // Find navigable pixels (road = 0 in Cityscapes)\n    let navigable_pixels: Vec<(usize, usize)> = mask.data\n        .iter()\n        .enumerate()\n        .filter(|(_, &class_id)| class_id == 0)  // Road\n        .map(|(i, _)| (i % mask.width, i / mask.width))\n        .collect();\n\n    println!(\"Navigable area: {} pixels\", navigable_pixels.len());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:135:rust",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 135,
      "lineEnd": 161,
      "language": "rust",
      "code": "struct NavigationNode {\n    seg_sub: Hub<SegmentationMask>,\n    cmd_pub: Hub<CmdVel>,\n}\n\nimpl Node for NavigationNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(mask) = self.seg_sub.recv(&mut ctx) {\n            // Check center region for obstacles\n            let center_x = mask.width / 2;\n            let obstacle_classes = [11, 12, 13, 14, 15];  // Vehicles, people\n\n            let obstacle_ahead = (0..mask.height)\n                .any(|y| {\n                    let idx = y * mask.width + center_x;\n                    obstacle_classes.contains(&mask.data[idx])\n                });\n\n            if obstacle_ahead {\n                // Stop or navigate around\n                self.cmd_pub.send(CmdVel::stop(), &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/semantic-segmentation:165:rust",
      "file": "content/docs/rust/library/built-in-nodes/semantic-segmentation.mdx",
      "lineStart": 165,
      "lineEnd": 182,
      "language": "rust",
      "code": "let config = SegmentationConfig {\n    num_classes: 10,\n    class_names: vec![\n        \"floor\".to_string(),\n        \"wall\".to_string(),\n        \"ceiling\".to_string(),\n        \"door\".to_string(),\n        \"window\".to_string(),\n        \"furniture\".to_string(),\n        \"person\".to_string(),\n        \"robot\".to_string(),\n        \"obstacle\".to_string(),\n        \"unknown\".to_string(),\n    ],\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 28,
      "lineEnd": 45,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create serial node\n    let mut serial = SerialNode::new(\"/dev/ttyUSB0\")?;\n    serial.set_baud_rate(9600);\n    serial.set_data_bits(8);\n    serial.set_parity(Parity::None);\n    serial.set_stop_bits(1);\n\n    scheduler.add(Box::new(serial), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:51:bash",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 51,
      "lineEnd": 60,
      "language": "bash",
      "code": "# Install serial tools\nsudo apt install setserial\n\n# Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# Verify serial ports\nls -l /dev/ttyUSB* /dev/ttyS* /dev/ttyAMA*",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:64:text",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 64,
      "lineEnd": 69,
      "language": "text",
      "code": "Common adapters:\n- FTDI FT232RL   → /dev/ttyUSB0\n- Prolific PL2303 → /dev/ttyUSB0\n- CP2102         → /dev/ttyUSB0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:73:text",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 73,
      "lineEnd": 78,
      "language": "text",
      "code": "Computer (DB9)    Device\nPin 2 (RX)  <--   TX\nPin 3 (TX)  -->   RX\nPin 5 (GND) ---   GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:82:text",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 82,
      "lineEnd": 87,
      "language": "text",
      "code": "RS485 Adapter     Device\nA (Data+)   ---   A/D+\nB (Data-)   ---   B/D-\nGND         ---   GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:97:bash",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 97,
      "lineEnd": 100,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: serial-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:106:yaml",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 106,
      "lineEnd": 111,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - serial-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:117:toml",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 117,
      "lineEnd": 120,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"serial-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:126:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 126,
      "lineEnd": 135,
      "language": "rust",
      "code": "let mut serial = SerialNode::new(\"/dev/ttyUSB0\")?;\n\n// Common baud rates\nserial.set_baud_rate(9600);     // GPS, Arduino\nserial.set_baud_rate(19200);    // Modbus RTU\nserial.set_baud_rate(57600);    // Fast sensors\nserial.set_baud_rate(115200);   // High-speed data\nserial.set_baud_rate(921600);   // Maximum speed",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:139:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 139,
      "lineEnd": 154,
      "language": "rust",
      "code": "// 8N1 (most common: 8 data bits, no parity, 1 stop bit)\nserial.set_data_bits(8);\nserial.set_parity(Parity::None);\nserial.set_stop_bits(1);\n\n// 7E1 (7 data bits, even parity, 1 stop bit)\nserial.set_data_bits(7);\nserial.set_parity(Parity::Even);\nserial.set_stop_bits(1);\n\n// 8E2 (8 data bits, even parity, 2 stop bits)\nserial.set_data_bits(8);\nserial.set_parity(Parity::Even);\nserial.set_stop_bits(2);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:158:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 158,
      "lineEnd": 167,
      "language": "rust",
      "code": "// No flow control (default)\nserial.set_flow_control(FlowControl::None);\n\n// Hardware flow control (RTS/CTS)\nserial.set_flow_control(FlowControl::Hardware);\n\n// Software flow control (XON/XOFF)\nserial.set_flow_control(FlowControl::Software);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:171:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 171,
      "lineEnd": 177,
      "language": "rust",
      "code": "// Read timeout (milliseconds)\nserial.set_read_timeout(1000);  // 1 second\n\n// Write timeout\nserial.set_write_timeout(500);  // 500ms",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:181:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 181,
      "lineEnd": 193,
      "language": "rust",
      "code": "// Line-based (newline-terminated)\nserial.set_framing_mode(FramingMode::Line);\nserial.set_line_ending(\"\\r\\n\");  // CRLF\nserial.set_line_ending(\"\\n\");    // LF\n\n// Binary (fixed-length packets)\nserial.set_framing_mode(FramingMode::Binary);\nserial.set_packet_size(16);\n\n// Raw (no framing)\nserial.set_framing_mode(FramingMode::Raw);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:199:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 199,
      "lineEnd": 212,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create serial message\nlet msg = SerialMessage {\n    port: \"/dev/ttyUSB0\".to_string(),\n    data: b\"AT+CSQ\\r\\n\".to_vec(),  // AT command\n    length: 8,\n};\n\n// Send\nlet hub = Hub::<SerialMessage>::new(\"serial.tx\")?;\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:216:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 216,
      "lineEnd": 229,
      "language": "rust",
      "code": "// Subscribe to RX topic\nlet hub = Hub::<SerialMessage>::new(\"serial.rx\")?;\n\nif let Some(msg) = hub.recv(&mut None) {\n    // Convert to string if ASCII\n    if let Ok(text) = String::from_utf8(msg.data.clone()) {\n        println!(\"RX: {}\", text);\n    } else {\n        // Binary data\n        println!(\"RX: {:02X?}\", msg.data);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:233:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 233,
      "lineEnd": 251,
      "language": "rust",
      "code": "// Configure for line-based\nserial.set_framing_mode(FramingMode::Line);\nserial.set_line_ending(\"\\r\\n\");\n\n// Send command\nlet cmd = SerialMessage {\n    port: \"/dev/ttyUSB0\".to_string(),\n    data: \"GET_TEMP\\r\\n\".as_bytes().to_vec(),\n    length: 10,\n};\nhub.send(cmd, &mut None).ok();\n\n// Receive response (automatically framed by newline)\nif let Some(resp) = rx_hub.recv(&mut None) {\n    let text = String::from_utf8_lossy(&resp.data);\n    println!(\"Response: {}\", text);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:257:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 257,
      "lineEnd": 272,
      "language": "rust",
      "code": "// Configure for GPS (9600 baud, line-based)\nlet mut serial = SerialNode::new(\"/dev/ttyUSB0\")?;\nserial.set_baud_rate(9600);\nserial.set_framing_mode(FramingMode::Line);\nserial.set_line_ending(\"\\r\\n\");\n\n// Read NMEA sentences\nlet hub = Hub::<SerialMessage>::new(\"serial.rx\")?;\nwhile let Some(msg) = hub.recv(&mut None) {\n    let nmea = String::from_utf8_lossy(&msg.data);\n    if nmea.starts_with(\"$GPGGA\") {\n        println!(\"GPS Fix: {}\", nmea);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:276:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 276,
      "lineEnd": 288,
      "language": "rust",
      "code": "// Configure for Arduino (57600 baud)\nserial.set_baud_rate(57600);\nserial.set_framing_mode(FramingMode::Binary);\n\n// Send Firmata digital write\nlet msg = SerialMessage {\n    port: \"/dev/ttyUSB0\".to_string(),\n    data: vec![0xF5, 0x01, 0x00],  // Digital write pin 1 LOW\n    length: 3,\n};\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:292:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 292,
      "lineEnd": 313,
      "language": "rust",
      "code": "// Configure for Modbus RTU (19200 baud, 8E1)\nserial.set_baud_rate(19200);\nserial.set_data_bits(8);\nserial.set_parity(Parity::Even);\nserial.set_stop_bits(1);\nserial.set_framing_mode(FramingMode::Binary);\n\n// Read holding registers (function code 0x03)\nlet msg = SerialMessage {\n    port: \"/dev/ttyUSB0\".to_string(),\n    data: vec![\n        0x01,       // Slave address\n        0x03,       // Function code: Read holding registers\n        0x00, 0x00, // Start address\n        0x00, 0x0A, // Number of registers\n        0xC5, 0xCD  // CRC16\n    ],\n    length: 8,\n};\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:317:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 317,
      "lineEnd": 337,
      "language": "rust",
      "code": "// Configure for telemetry (57600 baud)\nserial.set_baud_rate(57600);\nserial.set_framing_mode(FramingMode::Raw);\n\n// Send MAVLink heartbeat\nlet heartbeat = vec![\n    0xFE,       // STX\n    0x09,       // Length\n    0x00,       // Sequence\n    0x01,       // System ID\n    0x00,       // Component ID\n    0x00,       // Message ID (HEARTBEAT)\n    // ... payload and checksum\n];\nhub.send(SerialMessage {\n    port: \"/dev/ttyUSB0\".to_string(),\n    data: heartbeat,\n    length: 14,\n}, None)?;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:341:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 341,
      "lineEnd": 348,
      "language": "rust",
      "code": "pub struct SerialMessage {\n    pub port: String,         // Port path (e.g., \"/dev/ttyUSB0\")\n    pub data: Vec<u8>,        // Data bytes\n    pub length: usize,        // Data length\n    pub timestamp: u64,       // Message time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:352:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 352,
      "lineEnd": 405,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure GPS serial port\n    let mut serial = SerialNode::new(\"/dev/ttyUSB0\")?;\n    serial.set_baud_rate(9600);\n    serial.set_data_bits(8);\n    serial.set_parity(Parity::None);\n    serial.set_stop_bits(1);\n    serial.set_framing_mode(FramingMode::Line);\n    serial.set_line_ending(\"\\r\\n\");\n\n    scheduler.add(Box::new(serial), 1, Some(true));\n\n    // GPS parser node\n    let gps_parser = node! {\n        name: \"gps_parser\",\n        tick: |ctx| {\n            let hub = Hub::<SerialMessage>::new(\"serial.rx\")?;\n\n            while let Some(msg) = hub.recv(&mut None) {\n                let nmea = String::from_utf8_lossy(&msg.data);\n\n                // Parse GPGGA sentence (GPS fix data)\n                if nmea.starts_with(\"$GPGGA\") {\n                    let fields: Vec<&str> = nmea.split(',').collect();\n                    if fields.len() >= 10 {\n                        let time = fields[1];\n                        let lat = fields[2];\n                        let lat_dir = fields[3];\n                        let lon = fields[4];\n                        let lon_dir = fields[5];\n                        let fix = fields[6];\n\n                        ctx.log_info(&format!(\n                            \"GPS: {}°{} {}°{} (fix: {})\",\n                            lat, lat_dir, lon, lon_dir, fix\n                        ));\n                    }\n                }\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(gps_parser), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:409:rust",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 409,
      "lineEnd": 419,
      "language": "rust",
      "code": "// List available serial ports\nlet ports = serial.list_ports()?;\nfor port in ports {\n    println!(\"Port: {} ({})\", port.name, port.description);\n}\n\n// Auto-detect device by VID:PID\nlet ftdi_port = serial.find_port_by_vid_pid(0x0403, 0x6001)?; // FTDI\nlet arduino_port = serial.find_port_by_vid_pid(0x2341, 0x0043)?; // Arduino Uno",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/serial:504:bash",
      "file": "content/docs/rust/library/built-in-nodes/serial.mdx",
      "lineStart": 504,
      "lineEnd": 516,
      "language": "bash",
      "code": "# Send test data\necho \"Hello\" > /dev/ttyUSB0\n\n# Receive data\ncat /dev/ttyUSB0\n\n# Monitor with screen\nscreen /dev/ttyUSB0 9600\n\n# Monitor with minicom\nminicom -D /dev/ttyUSB0 -b 9600",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 29,
      "lineEnd": 48,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create servo controller\n    let mut servo = ServoControllerNode::new()?;\n    servo.set_num_servos(2);\n\n    // Configure servo 0\n    servo.set_gpio_pin(0, 18);  // Hardware PWM pin\n    servo.set_angle_range(0, 0, 180);\n    servo.set_pulse_range(0, 500, 2500);\n\n    scheduler.add(Box::new(servo), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:54:bash",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 54,
      "lineEnd": 60,
      "language": "bash",
      "code": "# Install GPIO and I2C libraries\nsudo apt install libraspberrypi-dev i2c-tools\n\n# Enable GPIO and I2C\nsudo raspi-config  # Interface Options",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:64:text",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 64,
      "lineEnd": 69,
      "language": "text",
      "code": "Raspberry Pi    Servo\nGPIO 18 (PWM0) --> Signal (Orange/White)\n5V             --> VCC (Red)\nGND            --- GND (Brown/Black)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:77:text",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 77,
      "lineEnd": 84,
      "language": "text",
      "code": "Raspberry Pi    PCA9685         Servos\nGPIO 2 (SDA) --> SDA\nGPIO 3 (SCL) --> SCL           Servo 0-15\n5V           --> VCC           Signal pins\nGND          --- GND\n                V+ (6V) -->    Servo power",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:100:bash",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 100,
      "lineEnd": 103,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:109:yaml",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 109,
      "lineEnd": 115,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware\n      - i2c-hardware  # For PCA9685 boards",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:121:toml",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 121,
      "lineEnd": 124,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\", \"i2c-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:130:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 130,
      "lineEnd": 141,
      "language": "rust",
      "code": "let mut servo = ServoControllerNode::new()?;\n\n// Number of servos\nservo.set_num_servos(4);\n\n// Configure each servo\nservo.set_gpio_pin(0, 18);  // PWM pin\nservo.set_gpio_pin(1, 19);\nservo.set_gpio_pin(2, 12);\nservo.set_gpio_pin(3, 13);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:145:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 145,
      "lineEnd": 152,
      "language": "rust",
      "code": "// Use PCA9685 controller\nservo.use_pca9685(true);\nservo.set_pca9685_address(0x40);  // Default I2C address\n\n// All 16 channels available\nservo.set_num_servos(16);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:156:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 156,
      "lineEnd": 168,
      "language": "rust",
      "code": "// Set pulse width range (microseconds)\nservo.set_pulse_range(\n    0,      // Servo ID\n    500,    // Min pulse (0°)\n    2500    // Max pulse (180°)\n);\n\n// Common ranges:\n// Standard: 1000-2000 μs\n// Extended: 500-2500 μs\n// Futaba: 1500±600 μs",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:172:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 172,
      "lineEnd": 181,
      "language": "rust",
      "code": "// Set angle range\nservo.set_angle_range(0, 0, 180);   // Standard (0-180°)\nservo.set_angle_range(1, -90, 90);  // Centered (-90 to +90°)\nservo.set_angle_range(2, 0, 270);   // Extended range\n\n// Set center position\nservo.set_center_angle(0, 90);      // 90° is center\nservo.set_center_pulse(0, 1500);    // 1500 μs is center",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:185:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 185,
      "lineEnd": 194,
      "language": "rust",
      "code": "// Set movement speed (degrees per second)\nservo.set_speed(0, 60.0);  // 60°/sec\n\n// Set acceleration (degrees per second²)\nservo.set_acceleration(0, 180.0);  // 180°/sec²\n\n// Disable speed limiting (instant movement)\nservo.set_speed(0, 0.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:198:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 198,
      "lineEnd": 204,
      "language": "rust",
      "code": "// Set soft angle limits\nservo.set_min_angle(0, 10);   // Don't go below 10°\nservo.set_max_angle(0, 170);  // Don't go above 170°\n\n// Limits prevent mechanical damage",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:210:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 210,
      "lineEnd": 222,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Set servo to 90 degrees\nlet cmd = ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_ANGLE,\n    angle: 90.0,\n};\n\nlet hub = Hub::<ServoCommand>::new(\"servo.command\")?;\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:226:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 226,
      "lineEnd": 234,
      "language": "rust",
      "code": "// Set servo directly by pulse width (microseconds)\nlet cmd = ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_PULSE,\n    pulse_width: 1500,  // 1500 μs (center)\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:238:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 238,
      "lineEnd": 249,
      "language": "rust",
      "code": "// Move with speed limiting\nlet cmd = ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_ANGLE,\n    angle: 180.0,\n    speed: 60.0,  // Move at 60°/sec\n};\nhub.send(cmd, &mut None).ok();\n\n// Will take 3 seconds to move from 0° to 180°",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:253:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 253,
      "lineEnd": 269,
      "language": "rust",
      "code": "// Disable servo (no holding torque, saves power)\nlet cmd = ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_DISABLE,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();\n\n// Re-enable\nlet cmd = ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_ENABLE,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:273:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 273,
      "lineEnd": 281,
      "language": "rust",
      "code": "// Find center position\nlet cmd = ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_CENTER,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:285:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 285,
      "lineEnd": 386,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure pan-tilt servos\n    let mut servo = ServoControllerNode::new()?;\n    servo.set_num_servos(2);\n\n    // Pan servo (horizontal)\n    servo.set_gpio_pin(0, 18);\n    servo.set_pulse_range(0, 500, 2500);\n    servo.set_angle_range(0, -90, 90);  // -90° to +90°\n    servo.set_center_angle(0, 0);\n    servo.set_speed(0, 90.0);  // 90°/sec\n    servo.set_acceleration(0, 180.0);\n\n    // Tilt servo (vertical)\n    servo.set_gpio_pin(1, 19);\n    servo.set_pulse_range(1, 500, 2500);\n    servo.set_angle_range(1, -45, 45);  // Limited tilt\n    servo.set_center_angle(1, 0);\n    servo.set_speed(1, 60.0);\n\n    scheduler.add(Box::new(servo), 1, Some(true));\n\n    // Pan-tilt control node\n    let pantilt_node = node! {\n        name: \"pan_tilt_control\",\n        init: |ctx| {\n            // Center both servos\n            let hub = Hub::<ServoCommand>::new(\"servo.command\")?;\n\n            hub.send(ServoCommand {\n                servo_id: 0,\n                command_type: ServoCommand::CMD_CENTER,\n                ..Default::default()\n            }, None)?;\n\n            hub.send(ServoCommand {\n                servo_id: 1,\n                command_type: ServoCommand::CMD_CENTER,\n                ..Default::default()\n            }, None)?;\n\n            ctx.log_info(\"Pan-tilt initialized\");\n            Ok(())\n        },\n        tick: |ctx| {\n            let hub = Hub::<ServoCommand>::new(\"servo.command\")?;\n\n            // Scan pattern\n            // Pan left\n            hub.send(ServoCommand {\n                servo_id: 0,\n                angle: -90.0,\n                speed: 45.0,\n                ..Default::default()\n            }, None)?;\n            std::thread::sleep(Duration::from_secs(2));\n\n            // Pan right\n            hub.send(ServoCommand {\n                servo_id: 0,\n                angle: 90.0,\n                speed: 45.0,\n                ..Default::default()\n            }, None)?;\n            std::thread::sleep(Duration::from_secs(4));\n\n            // Center pan\n            hub.send(ServoCommand {\n                servo_id: 0,\n                angle: 0.0,\n                ..Default::default()\n            }, None)?;\n\n            // Tilt up\n            hub.send(ServoCommand {\n                servo_id: 1,\n                angle: 30.0,\n                ..Default::default()\n            }, None)?;\n            std::thread::sleep(Duration::from_secs(1));\n\n            // Tilt down\n            hub.send(ServoCommand {\n                servo_id: 1,\n                angle: -30.0,\n                ..Default::default()\n            }, None)?;\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(pantilt_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:392:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 392,
      "lineEnd": 401,
      "language": "rust",
      "code": "pub struct ServoCommand {\n    pub servo_id: u8,          // Servo ID (0-15)\n    pub command_type: u8,      // Command type\n    pub angle: f32,            // Target angle (degrees)\n    pub pulse_width: u16,      // Pulse width (μs)\n    pub speed: f32,            // Movement speed (°/sec)\n    pub acceleration: f32,     // Acceleration (°/sec²)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:405:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 405,
      "lineEnd": 413,
      "language": "rust",
      "code": "pub const CMD_ANGLE: u8 = 0;       // Set by angle\npub const CMD_PULSE: u8 = 1;       // Set by pulse width\npub const CMD_CENTER: u8 = 2;      // Move to center\npub const CMD_ENABLE: u8 = 3;      // Enable servo\npub const CMD_DISABLE: u8 = 4;     // Disable servo\npub const CMD_MIN: u8 = 5;         // Move to minimum\npub const CMD_MAX: u8 = 6;         // Move to maximum",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:417:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 417,
      "lineEnd": 427,
      "language": "rust",
      "code": "pub struct ServoStatus {\n    pub servo_id: u8,\n    pub current_angle: f32,\n    pub current_pulse: u16,\n    pub target_angle: f32,\n    pub enabled: bool,\n    pub moving: bool,\n    pub timestamp: u64,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:433:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 433,
      "lineEnd": 438,
      "language": "rust",
      "code": "// Budget option, slower response\n// Update rate: 50 Hz\n// Typical range: 1000-2000 μs\nservo.set_pulse_range(0, 1000, 2000);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:442:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 442,
      "lineEnd": 447,
      "language": "rust",
      "code": "// Faster response, higher torque holding\n// Update rate: 300-400 Hz\n// Extended range often supported\nservo.set_pulse_range(0, 500, 2500);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:451:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 451,
      "lineEnd": 459,
      "language": "rust",
      "code": "// Modified for continuous rotation\n// 1500 μs = stop\n// 1000 μs = full reverse\n// 2000 μs = full forward\n\nservo.set_angle_range(0, -100, 100);  // Map to speed\nservo.set_center_angle(0, 0);  // 0 = stopped",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:465:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 465,
      "lineEnd": 472,
      "language": "rust",
      "code": "// Chain up to 62 PCA9685 boards\nlet servo1 = ServoControllerNode::new()?;\nservo1.set_pca9685_address(0x40);  // Board 1 (servos 0-15)\n\nlet servo2 = ServoControllerNode::new()?;\nservo2.set_pca9685_address(0x41);  // Board 2 (servos 16-31)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:476:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 476,
      "lineEnd": 482,
      "language": "rust",
      "code": "// Disable all outputs (saves power)\nservo.pca9685_output_enable(false);\n\n// Re-enable\nservo.pca9685_output_enable(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:486:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 486,
      "lineEnd": 490,
      "language": "rust",
      "code": "// Set PWM frequency (40-1000 Hz)\nservo.set_pwm_frequency(50);   // Standard (50 Hz)\nservo.set_pwm_frequency(333);  // High-speed (333 Hz)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:494:rust",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 494,
      "lineEnd": 529,
      "language": "rust",
      "code": "// 1. Set servo to test range\nservo.set_pulse_range(0, 500, 2500);\n\n// 2. Move to minimum\nhub.send(ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_MIN,\n    ..Default::default()\n}, None)?;\n// Observe actual angle (should be 0°)\n\n// 3. Move to maximum\nhub.send(ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_MAX,\n    ..Default::default()\n}, None)?;\n// Observe actual angle (should be 180°)\n\n// 4. Adjust pulse range if needed\n// If min angle > 0°, increase min pulse\n// If max angle < 180°, increase max pulse\nservo.set_pulse_range(0, 600, 2400);  // Adjusted\n\n// 5. Find center\nhub.send(ServoCommand {\n    servo_id: 0,\n    command_type: ServoCommand::CMD_CENTER,\n    ..Default::default()\n}, None)?;\n// Should be 90° (perpendicular)\n\n// 6. Adjust center pulse if needed\nservo.set_center_pulse(0, 1520);  // If slightly off",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/servo-controller:632:text",
      "file": "content/docs/rust/library/built-in-nodes/servo-controller.mdx",
      "lineStart": 632,
      "lineEnd": 637,
      "language": "text",
      "code": "Micro servo: 1-3 kg·cm\nStandard servo: 3-10 kg·cm\nLarge servo: 10-30 kg·cm\nHeavy-duty: 30-40+ kg·cm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:27:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 27,
      "lineEnd": 48,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create SPI bus node\n    let mut spi = SpiBusNode::new()?; // Default: bus 0, 1MHz\n\n    // Configure\n    spi.set_bus_number(0);\n    spi.set_default_speed(1_000_000); // 1 MHz\n    spi.set_default_mode(0); // SPI Mode 0\n\n    // Configure device on CS0\n    spi.configure_device(0, 2_000_000, 0); // CS, speed, mode\n\n    scheduler.add(Box::new(spi), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:54:bash",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 54,
      "lineEnd": 63,
      "language": "bash",
      "code": "# Install SPI tools\nsudo apt install libraspberrypi-dev\n\n# Enable SPI interface\nsudo raspi-config  # Interface Options -> SPI\n\n# Add user to spi group\nsudo usermod -a -G spi $USER",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:67:text",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 67,
      "lineEnd": 75,
      "language": "text",
      "code": "Raspberry Pi    SPI Device\nGPIO 10 (MOSI) --> MOSI (SDI)\nGPIO 9  (MISO) <-- MISO (SDO)\nGPIO 11 (SCLK) --> SCLK (SCK)\nGPIO 8  (CE0)  --> CS\n3.3V           --> VCC\nGND            --> GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:85:bash",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 85,
      "lineEnd": 88,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: spi-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:94:yaml",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 94,
      "lineEnd": 99,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - spi-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:105:toml",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 105,
      "lineEnd": 108,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"spi-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:114:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 114,
      "lineEnd": 123,
      "language": "rust",
      "code": "let mut spi = SpiBusNode::new()?;\n\n// Select SPI bus\nspi.set_bus_number(0); // /dev/spidev0.*\n\n// Default speed for all devices\nspi.set_default_speed(1_000_000); // 1 MHz\nspi.set_default_speed(10_000_000); // 10 MHz",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:127:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 127,
      "lineEnd": 133,
      "language": "rust",
      "code": "// Set default mode\nspi.set_default_mode(0); // Mode 0 (CPOL=0, CPHA=0)\nspi.set_default_mode(1); // Mode 1 (CPOL=0, CPHA=1)\nspi.set_default_mode(2); // Mode 2 (CPOL=1, CPHA=0)\nspi.set_default_mode(3); // Mode 3 (CPOL=1, CPHA=1)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:137:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 137,
      "lineEnd": 146,
      "language": "rust",
      "code": "// Configure specific devices\nspi.configure_device(\n    0,          // Chip select 0\n    2_000_000,  // 2 MHz\n    0           // SPI Mode 0\n);\n\nspi.configure_device(1, 500_000, 3); // CS1: 500kHz, Mode 3",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:152:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 152,
      "lineEnd": 173,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create SPI message\nlet mut msg = SpiMessage::new(0, 4); // CS=0, 4 bytes\nmsg.tx_data[0] = 0x01;\nmsg.tx_data[1] = 0x02;\nmsg.tx_data[2] = 0x03;\nmsg.tx_data[3] = 0x04;\n\n// Send request\nlet hub = Hub::<SpiMessage>::new(\"spi.request\")?;\nhub.send(msg, &mut None).ok();\n\n// Receive response\nlet resp_hub = Hub::<SpiMessage>::new(\"spi.response\")?;\nif let Some(response) = resp_hub.recv(&mut None) {\n    if response.success {\n        println!(\"RX: {:?}\", &response.rx_data[..response.length as usize]);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:177:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 177,
      "lineEnd": 181,
      "language": "rust",
      "code": "// Read 4 bytes from device on CS0\nlet msg = SpiMessage::read(0, 4);\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:185:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 185,
      "lineEnd": 192,
      "language": "rust",
      "code": "// Write data to device on CS1\nlet mut msg = SpiMessage::write(1, 3);\nmsg.tx_data[0] = 0xAA;\nmsg.tx_data[1] = 0xBB;\nmsg.tx_data[2] = 0xCC;\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:198:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 198,
      "lineEnd": 211,
      "language": "rust",
      "code": "// Read channel 0\nlet mut msg = SpiMessage::new(0, 3);\nmsg.tx_data[0] = 0x01; // Start bit\nmsg.tx_data[1] = 0x80; // Single-ended, channel 0\nmsg.tx_data[2] = 0x00;\n\nhub.send(msg, &mut None).ok();\n\nif let Some(resp) = resp_hub.recv(&mut None) {\n    let value = ((resp.rx_data[1] as u16 & 0x03) << 8) | (resp.rx_data[2] as u16);\n    println!(\"ADC: {}\", value); // 0-1023\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:215:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 215,
      "lineEnd": 225,
      "language": "rust",
      "code": "// Initialize SD card\nspi.configure_device(0, 400_000, 0); // Start slow for init\n\n// Send CMD0 (GO_IDLE_STATE)\nlet mut msg = SpiMessage::new(0, 6);\nmsg.tx_data[0] = 0x40; // CMD0\nmsg.tx_data[1..5].fill(0x00);\nmsg.tx_data[5] = 0x95; // CRC\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:229:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 229,
      "lineEnd": 241,
      "language": "rust",
      "code": "// Send command\nlet mut msg = SpiMessage::new(0, 2);\nmsg.tx_data[0] = 0x00; // Command mode\nmsg.tx_data[1] = 0xAF; // Display ON\nhub.send(msg, &mut None).ok();\n\n// Send data\nlet mut msg = SpiMessage::new(0, 2);\nmsg.tx_data[0] = 0x40; // Data mode\nmsg.tx_data[1] = 0xFF; // Pixel data\nhub.send(msg, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/spi-bus:245:rust",
      "file": "content/docs/rust/library/built-in-nodes/spi-bus.mdx",
      "lineStart": 245,
      "lineEnd": 256,
      "language": "rust",
      "code": "pub struct SpiMessage {\n    pub chip_select: u8,      // CS line (0-7)\n    pub length: u8,           // Transfer length\n    pub speed_hz: u32,        // Clock speed\n    pub mode: u8,             // SPI mode (0-3)\n    pub tx_data: [u8; 256],  // Data to transmit\n    pub rx_data: [u8; 256],  // Received data\n    pub success: bool,        // Transfer result\n    pub timestamp: u64,       // Transfer time (ns)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:29:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 29,
      "lineEnd": 49,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create stepper controller\n    let mut stepper = StepperMotorNode::new()?;\n\n    // Configure motor 0\n    stepper.set_num_motors(1);\n    stepper.set_steps_per_revolution(0, 200, 16);  // 200 steps, 1/16 microstepping\n    stepper.set_max_velocity(0, 2000.0);           // 2000 steps/sec\n    stepper.set_acceleration(0, 5000.0);           // 5000 steps/sec²\n    stepper.set_gpio_pins(0, 17, 18, 27);          // step, dir, enable pins\n\n    scheduler.add(Box::new(stepper), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:55:bash",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 55,
      "lineEnd": 61,
      "language": "bash",
      "code": "# Install GPIO library\nsudo apt install libraspberrypi-dev\n\n# Enable GPIO interface\nsudo raspi-config  # Interface Options -> Enable all",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:65:text",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 65,
      "lineEnd": 75,
      "language": "text",
      "code": "Raspberry Pi    A4988 Driver    Stepper Motor\nGPIO 17   -->   STEP\nGPIO 18   -->   DIR\nGPIO 27   -->   ENABLE\n5V        -->   VDD\nGND       -->   GND\n12V       -->   VMOT            (Motor power)\n                A1, A2    -->   Motor coil A\n                B1, B2    -->   Motor coil B",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:85:bash",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 85,
      "lineEnd": 88,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:94:yaml",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 94,
      "lineEnd": 99,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:105:toml",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 105,
      "lineEnd": 108,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:114:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 114,
      "lineEnd": 126,
      "language": "rust",
      "code": "let mut stepper = StepperMotorNode::new()?;\n\n// Number of motors (1-8)\nstepper.set_num_motors(4);\n\n// Per-motor configuration\nfor motor_id in 0..4 {\n    stepper.set_steps_per_revolution(motor_id, 200, 16); // 200 steps, 1/16 microstep\n    stepper.set_max_velocity(motor_id, 2000.0);           // steps/sec\n    stepper.set_acceleration(motor_id, 5000.0);           // steps/sec²\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:130:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 130,
      "lineEnd": 142,
      "language": "rust",
      "code": "// Full step (200 steps/rev for NEMA 17)\nstepper.set_steps_per_revolution(0, 200, 1);\n\n// Half step\nstepper.set_steps_per_revolution(0, 200, 2);\n\n// Quarter step\nstepper.set_steps_per_revolution(0, 200, 4);\n\n// 1/16 microstepping (3200 microsteps/rev)\nstepper.set_steps_per_revolution(0, 200, 16);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:146:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 146,
      "lineEnd": 155,
      "language": "rust",
      "code": "// Direct drive (no gearing)\nstepper.set_gear_ratio(0, 1.0);\n\n// 5:1 gear reduction\nstepper.set_gear_ratio(0, 5.0);\n\n// 1:3 gear increase (faster output)\nstepper.set_gear_ratio(0, 1.0 / 3.0);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:159:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 159,
      "lineEnd": 171,
      "language": "rust",
      "code": "// Maximum velocity (steps/sec)\nstepper.set_max_velocity(0, 3000.0);\n\n// Acceleration (steps/sec²)\nstepper.set_acceleration(0, 10000.0);\n\n// Current limit (mA) - driver dependent\nstepper.set_current_limit(0, 1500); // 1.5A\n\n// Invert direction\nstepper.set_direction_inverted(0, true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:175:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 175,
      "lineEnd": 183,
      "language": "rust",
      "code": "// Set GPIO pins for motor 0\nstepper.set_gpio_pins(\n    0,   // Motor ID\n    17,  // STEP pin\n    18,  // DIR pin\n    27   // ENABLE pin\n);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:187:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 187,
      "lineEnd": 193,
      "language": "rust",
      "code": "// Command timeout (ms)\nstepper.set_command_timeout(1000);\n\n// Enable position feedback\nstepper.set_feedback_enabled(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:199:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 199,
      "lineEnd": 214,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Create position command\nlet mut cmd = StepperCommand {\n    motor_id: 0,\n    command_type: StepperCommand::CMD_MOVE_TO,\n    target_position: 3200,  // Move to position (microsteps)\n    velocity: 0.0,\n    acceleration: 0.0,\n};\n\n// Send command\nlet hub = Hub::<StepperCommand>::new(\"stepper_cmd\")?;\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:218:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 218,
      "lineEnd": 226,
      "language": "rust",
      "code": "let mut cmd = StepperCommand {\n    motor_id: 0,\n    command_type: StepperCommand::CMD_MOVE_VELOCITY,\n    velocity: 1000.0,  // 1000 steps/sec\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:230:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 230,
      "lineEnd": 239,
      "language": "rust",
      "code": "// Move 1000 steps forward\nlet mut cmd = StepperCommand {\n    motor_id: 0,\n    command_type: StepperCommand::CMD_MOVE_RELATIVE,\n    target_position: 1000,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:243:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 243,
      "lineEnd": 252,
      "language": "rust",
      "code": "// Start homing sequence\nlet mut cmd = StepperCommand {\n    motor_id: 0,\n    command_type: StepperCommand::CMD_HOME,\n    velocity: -500.0,  // Homing speed (negative = reverse)\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:256:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 256,
      "lineEnd": 272,
      "language": "rust",
      "code": "// Stop motor immediately\nlet mut cmd = StepperCommand {\n    motor_id: 0,\n    command_type: StepperCommand::CMD_STOP,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();\n\n// Emergency stop (all motors)\nlet mut cmd = StepperCommand {\n    motor_id: 0xFF,  // Broadcast to all\n    command_type: StepperCommand::CMD_EMERGENCY_STOP,\n    ..Default::default()\n};\nhub.send(cmd, &mut None).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:280:text",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 280,
      "lineEnd": 290,
      "language": "text",
      "code": "Velocity\n    ^\n    |     /‾‾‾‾‾\\\n    |    /       \\\n    |   /         \\\n    |  /           \\\n    | /             \\\n    |/______________\\___> Time\n      Accel  Cruise  Decel",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:299:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 299,
      "lineEnd": 307,
      "language": "rust",
      "code": "stepper.set_max_velocity(0, 2000.0);     // Max 2000 steps/sec\nstepper.set_acceleration(0, 5000.0);      // Accel at 5000 steps/sec²\n\n// This will:\n// 1. Accelerate from 0 to 2000 steps/sec (0.4s)\n// 2. Cruise at 2000 steps/sec\n// 3. Decelerate to stop at target position",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:311:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 311,
      "lineEnd": 359,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure 3-axis CNC\n    let mut stepper = StepperMotorNode::new()?;\n    stepper.set_num_motors(3);\n\n    // X-axis (motor 0)\n    stepper.set_steps_per_revolution(0, 200, 16);\n    stepper.set_gear_ratio(0, 5.0);  // 5mm per rev (lead screw)\n    stepper.set_max_velocity(0, 3000.0);\n    stepper.set_acceleration(0, 10000.0);\n    stepper.set_gpio_pins(0, 17, 18, 27);\n\n    // Y-axis (motor 1)\n    stepper.set_steps_per_revolution(1, 200, 16);\n    stepper.set_gear_ratio(1, 5.0);\n    stepper.set_max_velocity(1, 3000.0);\n    stepper.set_acceleration(1, 10000.0);\n    stepper.set_gpio_pins(1, 22, 23, 24);\n\n    // Z-axis (motor 2)\n    stepper.set_steps_per_revolution(2, 200, 16);\n    stepper.set_gear_ratio(2, 2.0);  // Slower for vertical\n    stepper.set_max_velocity(2, 1500.0);\n    stepper.set_acceleration(2, 5000.0);\n    stepper.set_gpio_pins(2, 5, 6, 13);\n\n    scheduler.add(Box::new(stepper), 1, Some(true));\n\n    // G-code interpreter node\n    let gcode_node = node! {\n        name: \"gcode\",\n        tick: |ctx| {\n            // Parse G-code and send stepper commands\n            // G0 X10 Y20 Z5 -> Move to position\n            // ...\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(gcode_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:365:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 365,
      "lineEnd": 373,
      "language": "rust",
      "code": "pub struct StepperCommand {\n    pub motor_id: u8,          // Motor ID (0-7, 0xFF for all)\n    pub command_type: u8,      // Command type\n    pub target_position: i64,  // Target position (microsteps)\n    pub velocity: f64,         // Target velocity (steps/sec)\n    pub acceleration: f64,     // Override acceleration\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/stepper-motor:377:rust",
      "file": "content/docs/rust/library/built-in-nodes/stepper-motor.mdx",
      "lineStart": 377,
      "lineEnd": 387,
      "language": "rust",
      "code": "pub const CMD_MOVE_TO: u8 = 0;          // Absolute position\npub const CMD_MOVE_RELATIVE: u8 = 1;    // Relative movement\npub const CMD_MOVE_VELOCITY: u8 = 2;    // Velocity mode\npub const CMD_STOP: u8 = 3;             // Stop motor\npub const CMD_EMERGENCY_STOP: u8 = 4;   // Emergency stop\npub const CMD_HOME: u8 = 5;             // Homing sequence\npub const CMD_SET_HOME: u8 = 6;         // Set current as home\npub const CMD_ENABLE: u8 = 7;           // Enable motor\npub const CMD_DISABLE: u8 = 8;          // Disable motor",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:37:bash",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 37,
      "lineEnd": 44,
      "language": "bash",
      "code": "# Ubuntu 22.04\nsudo apt install nvidia-cuda-toolkit\nsudo apt install tensorrt libnvinfer-dev\n\n# Verify installation\npython3 -c \"import tensorrt; print(tensorrt.__version__)\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:58:yaml",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 58,
      "lineEnd": 63,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:67:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 67,
      "lineEnd": 88,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let config = TensorRTConfig::default()\n        .with_fp16(true)\n        .with_cache_dir(\"/tmp/trt_engines\");\n\n    let inference_node = TensorRTInferenceNode::new_image(\n        \"models/yolov8n.onnx\",\n        \"camera.raw\",\n        \"ml.detections\",\n        config,\n    )?;\n\n    scheduler.add(Box::new(inference_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:94:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 94,
      "lineEnd": 113,
      "language": "rust",
      "code": "let config = TensorRTConfig {\n    batch_size: 1,\n    max_batch_size: 8,\n    precision: TensorRTPrecision::FP16,\n    device_id: 0,\n    confidence_threshold: 0.5,\n    enable_preprocessing: true,\n    input_size: Some([640, 640]),\n    norm_mean: [0.485, 0.456, 0.406],\n    norm_std: [0.229, 0.224, 0.225],\n    workspace_size_mb: 1024,\n    engine_cache_dir: Some(\"/tmp/trt_engines\".into()),\n    force_rebuild: false,\n    use_dla: false,\n    dla_core: 0,\n    enable_cuda_graph: false,\n    max_optimization_profiles: 1,\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:167:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 167,
      "lineEnd": 179,
      "language": "rust",
      "code": "let config = TensorRTConfig::default()\n    .with_fp16(true)\n    .with_input_size(224, 224)\n    .with_cache_dir(\"/tmp/trt_cache\");\n\nlet node = TensorRTInferenceNode::new_image(\n    \"models/resnet50.onnx\",\n    \"camera.raw\",\n    \"classification.predictions\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:183:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 183,
      "lineEnd": 196,
      "language": "rust",
      "code": "let config = TensorRTConfig::default()\n    .with_fp16(true)\n    .with_input_size(640, 640)\n    .with_confidence_threshold(0.25)\n    .with_cache_dir(\"/tmp/trt_cache\");\n\nlet node = TensorRTInferenceNode::new_image(\n    \"models/yolov8n.onnx\",\n    \"camera.raw\",\n    \"detections\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:200:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 200,
      "lineEnd": 214,
      "language": "rust",
      "code": "// INT8 provides maximum speed but may need calibration\nlet config = TensorRTConfig::default()\n    .with_int8(true)\n    .with_cache_dir(\"/tmp/trt_cache\");\n\n// First run will be slow (building INT8 engine)\n// Subsequent runs use cached engine\nlet node = TensorRTInferenceNode::new_image(\n    \"models/yolov8n.onnx\",\n    \"camera.raw\",\n    \"detections\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:218:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 218,
      "lineEnd": 231,
      "language": "rust",
      "code": "// Use Deep Learning Accelerator on Jetson Xavier/Orin\nlet config = TensorRTConfig::default()\n    .with_fp16(true)\n    .with_dla(0)  // DLA core 0\n    .with_cache_dir(\"/tmp/trt_cache\");\n\nlet node = TensorRTInferenceNode::new_image(\n    \"models/yolov8n.onnx\",\n    \"camera.raw\",\n    \"detections\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:235:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 235,
      "lineEnd": 246,
      "language": "rust",
      "code": "// For non-image inputs (e.g., LiDAR point clouds, sensor data)\nlet config = TensorRTConfig::default()\n    .with_fp16(true);\n\nlet node = TensorRTInferenceNode::new_tensor(\n    \"models/pointnet.onnx\",\n    \"lidar.pointcloud.tensor\",\n    \"classification\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:250:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 250,
      "lineEnd": 262,
      "language": "rust",
      "code": "let config = TensorRTConfig::default()\n    .with_batch_size(4)\n    .with_max_batch_size(8)\n    .with_fp16(true);\n\nlet node = TensorRTInferenceNode::new_image(\n    \"models/resnet50.onnx\",\n    \"camera.batch\",\n    \"classification.batch\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:268:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 268,
      "lineEnd": 275,
      "language": "rust",
      "code": "let config = TensorRTConfig::default()\n    .with_fp16(true)\n    .with_cache_dir(\"/tmp/trt_engines\");  // Cache engines here\n\n// First run: ~30-60 seconds (building engine)\n// Subsequent runs: <1 second (loading cached engine)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:283:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 283,
      "lineEnd": 286,
      "language": "rust",
      "code": "// FP16 gives 2-3x speedup with minimal accuracy loss\nlet config = TensorRTConfig::default().with_fp16(true);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:290:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 290,
      "lineEnd": 294,
      "language": "rust",
      "code": "// Use the model's native input size\nlet config = TensorRTConfig::default()\n    .with_input_size(640, 640);  // YOLOv8 native size",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:298:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 298,
      "lineEnd": 302,
      "language": "rust",
      "code": "// Avoid rebuilding engine on every startup\nlet config = TensorRTConfig::default()\n    .with_cache_dir(\"/opt/robot/trt_engines\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:306:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 306,
      "lineEnd": 310,
      "language": "rust",
      "code": "// More workspace = potentially faster but more GPU memory\nlet config = TensorRTConfig::default()\n    .with_workspace_mb(2048);  // 2GB workspace",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:314:rust",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 314,
      "lineEnd": 318,
      "language": "rust",
      "code": "// Batching improves throughput (not latency)\nlet config = TensorRTConfig::default()\n    .with_batch_size(4);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tensorrt-inference:324:text",
      "file": "content/docs/rust/library/built-in-nodes/tensorrt-inference.mdx",
      "lineStart": 324,
      "lineEnd": 326,
      "language": "text",
      "code": "Error: Failed to build TensorRT engine",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:27:yaml",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 27,
      "lineEnd": 32,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - tflite-inference",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:36:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 36,
      "lineEnd": 59,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let config = TFLiteConfig {\n        num_threads: 4,\n        use_gpu_delegate: false,  // CPU only for Pi\n        ..Default::default()\n    };\n\n    let tflite_node = TFLiteInferenceNode::new(\n        \"models/mobilenet_v2_quant.tflite\",\n        \"camera.raw\",\n        \"ml.predictions\",\n        config,\n    )?;\n\n    scheduler.add(Box::new(tflite_node), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:77:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 77,
      "lineEnd": 82,
      "language": "rust",
      "code": "let config = TFLiteConfig {\n    num_threads: 4,  // Use 4 CPU cores\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:86:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 86,
      "lineEnd": 91,
      "language": "rust",
      "code": "let config = TFLiteConfig {\n    use_gpu_delegate: true,\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:95:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 95,
      "lineEnd": 100,
      "language": "rust",
      "code": "let config = TFLiteConfig {\n    use_coral_tpu: true,  // Use USB Coral Accelerator\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:121:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 121,
      "lineEnd": 137,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ml::Predictions;\n\n// Optimized for Raspberry Pi 4\nlet config = TFLiteConfig {\n    num_threads: 4,\n    input_size: Some([224, 224]),\n    ..Default::default()\n};\n\nlet classifier = TFLiteInferenceNode::new(\n    \"models/mobilenet_v2_quant.tflite\",  // Quantized model\n    \"camera.raw\",\n    \"classification.result\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:141:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 141,
      "lineEnd": 155,
      "language": "rust",
      "code": "// Use Coral USB Accelerator for 10x speedup\nlet config = TFLiteConfig {\n    use_coral_tpu: true,\n    input_size: Some([320, 320]),\n    ..Default::default()\n};\n\nlet detector = TFLiteInferenceNode::new(\n    \"models/ssd_mobilenet_edgetpu.tflite\",\n    \"camera.raw\",\n    \"detection.result\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:159:rust",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 159,
      "lineEnd": 168,
      "language": "rust",
      "code": "let predictions_hub = Hub::<Predictions>::new(\"ml.predictions\")?;\n\nif let Some(preds) = predictions_hub.recv(&mut None) {\n    if let Some((class_id, confidence)) = preds.top_k(1).first() {\n        println!(\"Detected class {} with {:.1}% confidence\",\n                 class_id, confidence * 100.0);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:174:bash",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 174,
      "lineEnd": 178,
      "language": "bash",
      "code": "# Download pre-trained TFLite models\nwget https://tfhub.dev/tensorflow/lite-model/mobilenet_v2_1.0_224_quantized/1/default/1?lite-format=tflite \\\n     -O mobilenet_v2_quant.tflite",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:182:bash",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 182,
      "lineEnd": 185,
      "language": "bash",
      "code": "# Edge TPU optimized models\nwget https://raw.githubusercontent.com/google-coral/test_data/master/ssd_mobilenet_v2_coco_quant_postprocess_edgetpu.tflite",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/tflite-inference:208:python",
      "file": "content/docs/rust/library/built-in-nodes/tflite-inference.mdx",
      "lineStart": 208,
      "lineEnd": 225,
      "language": "python",
      "code": "import tensorflow as tf\n\nconverter = tf.lite.TFLiteConverter.from_saved_model(\"saved_model\")\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\nconverter.target_spec.supported_types = [tf.int8]\n\n# Representative dataset for calibration\ndef representative_dataset():\n    for _ in range(100):\n        yield [np.random.rand(1, 224, 224, 3).astype(np.float32)]\n\nconverter.representative_dataset = representative_dataset\ntflite_model = converter.convert()\n\nwith open(\"model_quant.tflite\", \"wb\") as f:\n    f.write(tflite_model)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:28:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 28,
      "lineEnd": 46,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create ultrasonic node\n    let mut ultrasonic = UltrasonicNode::new()?;\n\n    // Configure sensor\n    ultrasonic.set_num_sensors(1);\n    ultrasonic.set_gpio_pins(0, 23, 24); // sensor_id, trigger_pin, echo_pin\n    ultrasonic.set_measurement_rate(10.0); // 10 Hz\n\n    scheduler.add(Box::new(ultrasonic), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:52:text",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 52,
      "lineEnd": 58,
      "language": "text",
      "code": "Raspberry Pi    HC-SR04\nGPIO 23   -->   Trig\nGPIO 24   -->   Echo (via voltage divider!)\n5V        -->   VCC\nGND       -->   GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:64:text",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 64,
      "lineEnd": 70,
      "language": "text",
      "code": "Echo (5V) ---[R1: 1kΩ]---+--- GPIO 24 (3.3V)\n                         |\n                      [R2: 2kΩ]\n                         |\n                        GND",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:76:text",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 76,
      "lineEnd": 82,
      "language": "text",
      "code": "           Raspberry Pi\nSensor 0:  GPIO 23, 24\nSensor 1:  GPIO 25, 8\nSensor 2:  GPIO 7, 1\nSensor 3:  GPIO 12, 16",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:86:bash",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 86,
      "lineEnd": 92,
      "language": "bash",
      "code": "# Install GPIO library\nsudo apt install libraspberrypi-dev\n\n# Enable GPIO\nsudo raspi-config  # Interface Options",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:102:bash",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 102,
      "lineEnd": 105,
      "language": "bash",
      "code": "horus run main.rs\n# Output: Auto-detected hardware nodes (features: gpio-hardware)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:111:yaml",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 111,
      "lineEnd": 116,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - gpio-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:122:toml",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 122,
      "lineEnd": 125,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\"gpio-hardware\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:131:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 131,
      "lineEnd": 140,
      "language": "rust",
      "code": "let mut ultrasonic = UltrasonicNode::new()?;\n\n// Configure multiple sensors\nultrasonic.set_num_sensors(4);\nultrasonic.set_gpio_pins(0, 23, 24); // Front\nultrasonic.set_gpio_pins(1, 25, 8);  // Right\nultrasonic.set_gpio_pins(2, 7, 1);   // Back\nultrasonic.set_gpio_pins(3, 12, 16); // Left",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:144:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 144,
      "lineEnd": 148,
      "language": "rust",
      "code": "// Set measurement frequency (Hz)\nultrasonic.set_measurement_rate(10.0);  // 10 measurements/sec\nultrasonic.set_measurement_rate(20.0);  // 20 measurements/sec",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:152:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 152,
      "lineEnd": 159,
      "language": "rust",
      "code": "// Enable median filtering (reduces noise)\nultrasonic.enable_median_filter(true);\nultrasonic.set_median_filter_size(5); // Median of 5 samples\n\n// Disable filtering\nultrasonic.enable_median_filter(false);",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:163:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 163,
      "lineEnd": 166,
      "language": "rust",
      "code": "// Set valid range (meters)\nultrasonic.set_range_limits(0, 0.02, 4.0); // sensor_id, min, max",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:170:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 170,
      "lineEnd": 178,
      "language": "rust",
      "code": "// Set ambient temperature for speed of sound correction\nultrasonic.set_temperature(20.0); // 20°C\n\n// Speed of sound at different temperatures:\n// 15°C: 340.0 m/s\n// 20°C: 343.0 m/s\n// 25°C: 346.0 m/s",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:184:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 184,
      "lineEnd": 193,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Subscribe to distance measurements\nlet hub = Hub::<Range>::new(\"ultrasonic.range\")?;\n\nif let Some(range) = hub.recv(&mut None) {\n    println!(\"Range: {:.3} m\", range.range);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:197:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 197,
      "lineEnd": 209,
      "language": "rust",
      "code": "let hub = Hub::<Range>::new(\"ultrasonic.range\")?;\n\nwhile let Some(range) = hub.recv(&mut None) {\n    if range.range >= range.min_range && range.range <= range.max_range {\n        if range.range < 0.3 {\n            println!(\"WARNING: Obstacle at {:.2}m!\", range.range);\n        }\n    } else {\n        println!(\"Out of range\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:213:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 213,
      "lineEnd": 232,
      "language": "rust",
      "code": "use std::collections::HashMap;\n\nlet hub = Hub::<Range>::new(\"ultrasonic.range\")?;\nlet mut distances: HashMap<u8, f32> = HashMap::new();\nlet mut sensor_id = 0; // Track which sensor in multi-sensor setup\n\n// Collect from all sensors\nwhile let Some(range) = hub.recv(&mut None) {\n    if range.range >= range.min_range && range.range <= range.max_range {\n        distances.insert(sensor_id, range.range);\n    }\n    sensor_id += 1;\n}\n\n// Find closest obstacle\nif let Some((&id, &dist)) = distances.iter().min_by(|a, b| a.1.partial_cmp(b.1).unwrap()) {\n    println!(\"Closest obstacle: Sensor {} at {:.2}m\", id, dist);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:236:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 236,
      "lineEnd": 285,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Configure 4 sensors around robot\n    let mut ultrasonic = UltrasonicNode::new()?;\n    ultrasonic.set_num_sensors(4);\n    ultrasonic.set_gpio_pins(0, 23, 24);  // Front\n    ultrasonic.set_gpio_pins(1, 25, 8);   // Right\n    ultrasonic.set_gpio_pins(2, 7, 1);    // Back\n    ultrasonic.set_gpio_pins(3, 12, 16);  // Left\n    ultrasonic.set_measurement_rate(10.0);\n    ultrasonic.enable_median_filter(true);\n    ultrasonic.set_median_filter_size(3);\n\n    scheduler.add(Box::new(ultrasonic), 1, Some(true));\n\n    // Obstacle avoidance node\n    let avoidance_node = node! {\n        name: \"obstacle_avoidance\",\n        tick: |ctx| {\n            let hub = Hub::<Range>::new(\"ultrasonic.range\")?;\n            let mut front_clear = true;\n\n            while let Some(range) = hub.recv(&mut None) {\n                // Assuming first reading is front sensor\n                if range.range < 0.5 && range.range >= range.min_range {\n                    front_clear = false;\n                    ctx.log_warning(&format!(\n                        \"Obstacle ahead: {:.2}m\", range.range\n                    ));\n                }\n            }\n\n            if !front_clear {\n                // Send stop command to motors\n                ctx.log_info(\"Stopping due to obstacle\");\n            }\n\n            Ok(())\n        }\n    };\n    scheduler.add(Box::new(avoidance_node), 2, Some(true));\n\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:291:rust",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 291,
      "lineEnd": 300,
      "language": "rust",
      "code": "pub struct Range {\n    pub sensor_type: u8,      // Sensor type (0=ultrasonic, 1=infrared)\n    pub field_of_view: f32,   // Beam angle in radians\n    pub min_range: f32,       // Minimum range in meters\n    pub max_range: f32,       // Maximum range in meters\n    pub range: f32,           // Distance reading in meters\n    pub timestamp: u64,       // Measurement time (ns since epoch)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:319:text",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 319,
      "lineEnd": 324,
      "language": "text",
      "code": "Max range = 4m\nSpeed of sound = 343 m/s (20°C)\nEcho time = (4m × 2) / 343 m/s = 23.3ms\nSafe timeout = 38ms (allows margin)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:388:text",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 388,
      "lineEnd": 398,
      "language": "text",
      "code": "[WARN] UltrasonicNode sensor 0: Hardware unavailable - using SIMULATION mode\n[WARN]   Tried GPIO pins: trigger=23, echo=24\n[WARN]   Error: Permission denied\n[WARN]   Fix:\n[WARN]     1. Install: sudo apt install libraspberrypi-dev\n[WARN]     2. Enable GPIO: sudo raspi-config -> Interface Options\n[WARN]     3. Check wiring: Verify GPIO pin connections\n[WARN]     4. If using cargo: cargo build --features=\"gpio-hardware\"\n[WARN]        (horus run auto-detects features)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/ultrasonic:429:text",
      "file": "content/docs/rust/library/built-in-nodes/ultrasonic.mdx",
      "lineStart": 429,
      "lineEnd": 431,
      "language": "text",
      "code": "[INFO] UltrasonicNode sensor 0: (SIM) distance 1.234 m",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:21:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 21,
      "lineEnd": 41,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Create monocular visual odometry\n    let vo = VisualOdometryNode::new(\n        \"camera.raw\",      // Input topic\n        \"vo.odom\",         // Output topic\n        VOConfig::default()\n            .with_mode(CameraMode::Monocular)\n            .with_feature_detector(FeatureDetector::ORB)\n            .with_max_features(1000),\n    )?;\n\n    scheduler.add(Box::new(vo), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:64:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 64,
      "lineEnd": 73,
      "language": "rust",
      "code": "let config = VOConfig::default()\n    .with_mode(CameraMode::Stereo)\n    .with_feature_detector(FeatureDetector::ORB)\n    .with_matching_method(MatchingMethod::OpticalFlow)\n    .with_max_features(500)\n    .with_intrinsics(fx, fy, cx, cy)  // Camera intrinsics\n    .with_stereo_baseline(0.12)       // 12cm baseline\n    .with_loop_closure(true);         // Enable loop closure",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:108:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 108,
      "lineEnd": 113,
      "language": "rust",
      "code": "let vo = VisualOdometryNode::new(\"camera.left\", \"vo.odom\",\n    VOConfig::default().with_mode(CameraMode::Stereo)\n)?\n.with_stereo(\"camera.right\")?;  // Add stereo input",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:117:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 117,
      "lineEnd": 122,
      "language": "rust",
      "code": "let vo = VisualOdometryNode::new(\"camera.rgb\", \"vo.odom\",\n    VOConfig::default().with_mode(CameraMode::RgbD)\n)?\n.with_depth(\"camera.depth\")?;  // Add depth input",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:128:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 128,
      "lineEnd": 152,
      "language": "rust",
      "code": "// Using builder with filter\nlet node = VisualOdometryNode::builder()\n    .input_topic(\"camera.raw\")\n    .output_topic(\"vo.odom\")\n    .config(VOConfig::default())\n    .with_filter(|odom| {\n        // Only output when moving forward\n        if odom.twist.linear[0] > 0.01 {\n            Some(odom)\n        } else {\n            None\n        }\n    })\n    .build()?;\n\n// Using closure processor\nlet node = VisualOdometryNode::builder()\n    .with_closure(|mut odom| {\n        // Add covariance estimate\n        odom.pose_covariance[0] = 0.1;\n        odom\n    })\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:158:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 158,
      "lineEnd": 176,
      "language": "rust",
      "code": "// Visual odometry provides relative motion estimates\nlet vo = VisualOdometryNode::new(\"camera.raw\", \"vo.odom\", VOConfig::default())?;\n\n// Wheel odometry for scale reference\nlet wheel_odom = OdometryNode::new(\n    \"encoders.left\", \"encoders.right\", \"wheel.odom\",\n    OdometryConfig::default(),\n)?;\n\n// Localization fuses multiple sources\nlet localization = LocalizationNode::new(\n    \"vo.odom\",           // Primary odometry\n    \"localized.pose\",    // Output\n    LocalizationConfig::default()\n        .with_secondary_odom(\"wheel.odom\")  // Fuse wheel odom\n        .with_imu(\"imu.data\"),              // Add IMU\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/visual-odometry:182:rust",
      "file": "content/docs/rust/library/built-in-nodes/visual-odometry.mdx",
      "lineStart": 182,
      "lineEnd": 192,
      "language": "rust",
      "code": "let mut vo = VisualOdometryNode::new(\"camera.raw\", \"vo.odom\",\n    VOConfig::default()\n)?;\n\n// Set scale from wheel odometry or known landmark\nvo.set_scale(1.0);  // meters per unit\n\n// Or use ground plane assumption\n// (scale from known camera height above ground)",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/yolo-detector:29:yaml",
      "file": "content/docs/rust/library/built-in-nodes/yolo-detector.mdx",
      "lineStart": 29,
      "lineEnd": 34,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus_library\n    features:\n      - onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/yolo-detector:38:rust",
      "file": "content/docs/rust/library/built-in-nodes/yolo-detector.mdx",
      "lineStart": 38,
      "lineEnd": 62,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n\n    let config = YOLOConfig {\n        conf_threshold: 0.25,\n        iou_threshold: 0.45,\n        use_gpu: true,\n        ..Default::default()\n    };\n\n    let detector = YOLOv8DetectorNode::new(\n        \"models/yolov8n.onnx\",\n        \"camera.raw\",        // Input image topic\n        \"vision.detections\", // Output detections topic\n        config,\n    )?;\n\n    scheduler.add(Box::new(detector), 1, Some(true));\n    scheduler.run()?;\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/yolo-detector:99:rust",
      "file": "content/docs/rust/library/built-in-nodes/yolo-detector.mdx",
      "lineStart": 99,
      "lineEnd": 110,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Detection, DetectionArray};\n\nlet detections_hub = Hub::<DetectionArray>::new(\"vision.detections\")?;\n\nif let Some(detections) = detections_hub.recv(&mut None) {\n    for det in &detections.detections {\n        println!(\"Detected {} at ({}, {}) with confidence {:.2}\",\n            det.class_name, det.bbox.x, det.bbox.y, det.confidence);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/yolo-detector:114:rust",
      "file": "content/docs/rust/library/built-in-nodes/yolo-detector.mdx",
      "lineStart": 114,
      "lineEnd": 127,
      "language": "rust",
      "code": "let config = YOLOConfig {\n    conf_threshold: 0.5,  // Higher confidence for safety\n    class_names: vec![\"person\".to_string()],  // Only detect people\n    ..Default::default()\n};\n\nlet detector = YOLOv8DetectorNode::new(\n    \"models/yolov8s.onnx\",  // Larger model for accuracy\n    \"camera.front\",\n    \"safety.persons\",\n    config,\n)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/yolo-detector:131:rust",
      "file": "content/docs/rust/library/built-in-nodes/yolo-detector.mdx",
      "lineStart": 131,
      "lineEnd": 144,
      "language": "rust",
      "code": "// Use default COCO classes (80 classes)\nlet config = YOLOConfig::default();\n\n// Or specify custom classes\nlet config = YOLOConfig {\n    class_names: vec![\n        \"robot\".to_string(),\n        \"person\".to_string(),\n        \"obstacle\".to_string(),\n    ],\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/built-in-nodes/yolo-detector:150:bash",
      "file": "content/docs/rust/library/built-in-nodes/yolo-detector.mdx",
      "lineStart": 150,
      "lineEnd": 162,
      "language": "bash",
      "code": "# Nano (fastest, least accurate)\nwget https://github.com/ultralytics/assets/releases/download/v8.3.0/yolov8n.onnx\n\n# Small (balanced)\nwget https://github.com/ultralytics/assets/releases/download/v8.3.0/yolov8s.onnx\n\n# Medium\nwget https://github.com/ultralytics/assets/releases/download/v8.3.0/yolov8m.onnx\n\n# Large (slowest, most accurate)\nwget https://github.com/ultralytics/assets/releases/download/v8.3.0/yolov8l.onnx",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:23:text",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 23,
      "lineEnd": 50,
      "language": "text",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                      Driver Loading Modes                        │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                  │\n│  STATIC MODE                    DYNAMIC MODE                     │\n│  ┌─────────────┐               ┌─────────────┐                  │\n│  │  Compiled   │               │  .so/.dylib │                  │\n│  │   Drivers   │               │   Plugins   │                  │\n│  └──────┬──────┘               └──────┬──────┘                  │\n│         │                              │                         │\n│         ▼                              ▼                         │\n│  ┌─────────────┐               ┌─────────────┐                  │\n│  │    Zero     │               │   dlopen()  │                  │\n│  │   Overhead  │               │    Load     │                  │\n│  └──────┬──────┘               └──────┬──────┘                  │\n│         │                              │                         │\n│         └──────────────┬───────────────┘                        │\n│                        ▼                                         │\n│               ┌─────────────────┐                                │\n│               │  DriverLoader   │                                │\n│               │   Unified API   │                                │\n│               └─────────────────┘                                │\n│                                                                  │\n│  HYBRID MODE: Static + Dynamic combined                         │\n│                                                                  │\n└─────────────────────────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:58:yaml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 58,
      "lineEnd": 84,
      "language": "yaml",
      "code": "# horus.yaml\n\n# Driver loading mode: static, dynamic, or hybrid\ndriver_mode: hybrid\n\n# Plugin configuration\nplugins:\n  # Search paths for dynamic plugins\n  search_paths:\n    - ~/.horus/drivers\n    - /usr/local/lib/horus/drivers\n    - ./plugins\n\n  # Auto-discover plugins in search paths (default: true)\n  auto_discover: true\n\n  # For hybrid mode: drivers to load statically\n  static:\n    - horus-imu          # IMU drivers (compiled in)\n    - horus-motor        # Motor drivers (compiled in)\n\n  # For hybrid mode: drivers to load dynamically\n  dynamic:\n    - horus-camera-fancy  # Specialized camera (loaded at runtime)\n    - horus-lidar-velodyne # Third-party LiDAR plugin",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:94:toml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 94,
      "lineEnd": 109,
      "language": "toml",
      "code": "[dependencies]\nhorus = { version = \"0.5\", features = [\"static-drivers\"] }\n\n[features]\ndefault = []\n\n# Enable specific hardware drivers\nmpu6050-imu = [\"horus/mpu6050-imu\"]\nbno055-imu = [\"horus/bno055-imu\"]\nrplidar = [\"horus/rplidar\"]\nv4l2-camera = [\"horus/v4l2-camera\"]\n\n# All drivers\nfull-hardware = [\"mpu6050-imu\", \"bno055-imu\", \"rplidar\", \"v4l2-camera\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:113:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 113,
      "lineEnd": 144,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::plugin::{DriverLoader, DriverLoaderConfig, DriverMode};\n\nfn main() -> HorusResult<()> {\n    // Create static mode loader\n    let config = DriverLoaderConfig {\n        mode: DriverMode::Static,\n        ..Default::default()\n    };\n\n    let mut loader = DriverLoader::new(config);\n\n    // Register compiled-in drivers\n    #[cfg(feature = \"mpu6050-imu\")]\n    loader.register_static(Box::new(Mpu6050Plugin));\n\n    #[cfg(feature = \"bno055-imu\")]\n    loader.register_static(Box::new(Bno055Plugin));\n\n    #[cfg(feature = \"rplidar\")]\n    loader.register_static(Box::new(RplidarPlugin));\n\n    // Initialize (validates registration)\n    loader.initialize()?;\n\n    // List available drivers\n    println!(\"Available drivers: {:?}\", loader.available_drivers());\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:161:toml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 161,
      "lineEnd": 164,
      "language": "toml",
      "code": "[dependencies]\nhorus = { version = \"0.5\", features = [\"dynamic-plugins\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:168:yaml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 168,
      "lineEnd": 177,
      "language": "yaml",
      "code": "# horus.yaml\ndriver_mode: dynamic\n\nplugins:\n  search_paths:\n    - ~/.horus/drivers\n    - /usr/local/lib/horus/drivers\n  auto_discover: true",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:181:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 181,
      "lineEnd": 213,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::plugin::{DriverLoader, DriverLoaderConfig, DriverMode};\n\nfn main() -> HorusResult<()> {\n    // Create dynamic mode loader\n    let config = DriverLoaderConfig {\n        mode: DriverMode::Dynamic,\n        search_paths: vec![\n            \"~/.horus/drivers\".into(),\n            \"/usr/local/lib/horus/drivers\".into(),\n        ],\n        auto_discover: true,\n        ..Default::default()\n    };\n\n    let mut loader = DriverLoader::new(config);\n\n    // Initialize discovers plugins in search paths\n    loader.initialize()?;\n\n    // List discovered drivers\n    for driver_id in loader.available_drivers() {\n        println!(\"Discovered: {}\", driver_id);\n    }\n\n    // Load and use a driver\n    let config = SingleDriverConfig::default();\n    let imu = loader.create_driver(\"horus-imu\", \"mpu6050\", &config)?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:231:text",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 231,
      "lineEnd": 235,
      "language": "text",
      "code": "libhorus_<name>.so      # Linux\nlibhorus_<name>.dylib   # macOS\nhorus_<name>.dll        # Windows",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:250:yaml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 250,
      "lineEnd": 268,
      "language": "yaml",
      "code": "# horus.yaml\ndriver_mode: hybrid\n\nplugins:\n  search_paths:\n    - ~/.horus/drivers\n\n  # Core drivers compiled in (fast)\n  static:\n    - horus-imu\n    - horus-motor\n    - horus-encoder\n\n  # Specialized drivers loaded at runtime (flexible)\n  dynamic:\n    - horus-camera-realsense\n    - horus-lidar-velodyne",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:272:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 272,
      "lineEnd": 309,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::plugin::{DriverLoader, DriverLoaderConfig, DriverMode};\n\nfn main() -> HorusResult<()> {\n    let config = DriverLoaderConfig {\n        mode: DriverMode::Hybrid,\n        static_drivers: vec![\n            \"horus-imu\".to_string(),\n            \"horus-motor\".to_string(),\n        ],\n        dynamic_drivers: vec![\n            \"horus-camera-realsense\".to_string(),\n        ],\n        search_paths: vec![\"~/.horus/drivers\".into()],\n        auto_discover: true,\n    };\n\n    let mut loader = DriverLoader::new(config);\n\n    // Register static drivers\n    #[cfg(feature = \"mpu6050-imu\")]\n    loader.register_static(Box::new(Mpu6050Plugin));\n\n    #[cfg(feature = \"gpio-motor\")]\n    loader.register_static(Box::new(GpioMotorPlugin));\n\n    // Initialize (registers static + discovers dynamic)\n    loader.initialize()?;\n\n    // Both static and dynamic are now available\n    for driver in loader.available_drivers() {\n        println!(\"Available: {}\", driver);\n    }\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:324:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 324,
      "lineEnd": 342,
      "language": "rust",
      "code": "// Create driver with explicit backend\nlet imu = loader.create_driver(\n    \"horus-imu\",    // Plugin ID\n    \"mpu6050\",      // Backend ID\n    &config,        // SingleDriverConfig\n)?;\n\n// Auto-detect and create best match\nlet imu = loader.auto_create_driver(\n    \"horus-imu\",    // Plugin ID\n    &config,        // SingleDriverConfig\n)?;\n\n// Downcast to concrete type\nlet imu: Box<dyn ImuDriver> = imu\n    .downcast()\n    .map_err(|_| HorusError::driver(\"Type mismatch\"))?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:346:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 346,
      "lineEnd": 360,
      "language": "rust",
      "code": "// Probe for hardware using a specific plugin\nlet results = loader.probe(\"horus-imu\")?;\n\nfor result in results {\n    if result.detected {\n        println!(\n            \"Found {} at {} (confidence: {:.0}%)\",\n            result.backend_id,\n            result.device_path.unwrap_or_default(),\n            result.confidence * 100.0\n        );\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:364:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 364,
      "lineEnd": 375,
      "language": "rust",
      "code": "// Get health of all plugins\nlet health = loader.health();\n\nfor (plugin_id, status) in &health {\n    if status.healthy {\n        println!(\"{}: Healthy\", plugin_id);\n    } else {\n        println!(\"{}: {}\", plugin_id, status.message);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:379:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 379,
      "lineEnd": 390,
      "language": "rust",
      "code": "// Get list of available drivers\nlet drivers = loader.available_drivers();\n\n// Get specific plugin\nlet plugin = loader.get_plugin(\"horus-imu\")?;\n\n// Check plugin metadata\nlet manifest = plugin.manifest();\nprintln!(\"Plugin: {} v{}\", manifest.name, manifest.version);\nprintln!(\"Backends: {:?}\", manifest.backend_ids());",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:402:bash",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 402,
      "lineEnd": 407,
      "language": "bash",
      "code": "# Example usage\nexport HORUS_DRIVER_PATH=\"/opt/custom-drivers\"\nexport HORUS_DRIVER_MODE=\"hybrid\"\n./my_robot",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:415:toml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 415,
      "lineEnd": 423,
      "language": "toml",
      "code": "# Cargo.toml for production\n[profile.release]\nlto = true\ncodegen-units = 1\n\n[features]\nproduction = [\"static-drivers\", \"mpu6050-imu\", \"gpio-motor\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:427:yaml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 427,
      "lineEnd": 434,
      "language": "yaml",
      "code": "# horus-dev.yaml\ndriver_mode: dynamic\nplugins:\n  search_paths:\n    - ./target/debug  # Load from build directory\n  auto_discover: true",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:438:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 438,
      "lineEnd": 457,
      "language": "rust",
      "code": "fn setup_loader() -> HorusResult<DriverLoader> {\n    let config = if cfg!(feature = \"dynamic-plugins\") {\n        DriverLoaderConfig {\n            mode: DriverMode::Hybrid,\n            ..Default::default()\n        }\n    } else {\n        DriverLoaderConfig {\n            mode: DriverMode::Static,\n            ..Default::default()\n        }\n    };\n\n    let mut loader = DriverLoader::new(config);\n    register_static_drivers(&mut loader);\n    loader.initialize()?;\n    Ok(loader)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:461:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 461,
      "lineEnd": 477,
      "language": "rust",
      "code": "fn create_imu(loader: &DriverLoader) -> HorusResult<Box<dyn ImuDriver>> {\n    // Try hardware first\n    let config = SingleDriverConfig::i2c(\"mpu6050\", 1, 0x68);\n\n    match loader.create_driver(\"horus-imu\", \"mpu6050\", &config) {\n        Ok(driver) => driver.downcast().map_err(|_| HorusError::driver(\"Type mismatch\")),\n        Err(e) => {\n            warn!(\"Hardware IMU unavailable: {}. Using simulation.\", e);\n            let sim_config = SingleDriverConfig::simulation();\n            loader.create_driver(\"horus-imu\", \"simulation\", &sim_config)?\n                .downcast()\n                .map_err(|_| HorusError::driver(\"Type mismatch\"))\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:485:rust",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 485,
      "lineEnd": 502,
      "language": "rust",
      "code": "// Check if plugin is discovered\nif loader.available_drivers().contains(&\"horus-imu\".to_string()) {\n    println!(\"Plugin is available\");\n} else {\n    // Check search paths\n    println!(\"Search paths: {:?}\", config.search_paths);\n\n    // List what's in each path\n    for path in &config.search_paths {\n        if path.exists() {\n            for entry in std::fs::read_dir(path)? {\n                println!(\"  Found: {:?}\", entry?.path());\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:508:toml",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 508,
      "lineEnd": 511,
      "language": "toml",
      "code": "[dependencies]\nhorus = { version = \"0.5\", features = [\"dynamic-plugins\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/driver-loader:517:bash",
      "file": "content/docs/rust/library/drivers/driver-loader.mdx",
      "lineStart": 517,
      "lineEnd": 523,
      "language": "bash",
      "code": "# Check plugin version\nnm -D libhorus_mydriver.so | grep horus_version\n\n# Rebuild plugins after HORUS upgrade\ncargo build --release -p my-driver-plugin",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:17:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 17,
      "lineEnd": 54,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// The main error type\npub enum HorusError {\n    // I/O errors (file, network, serial)\n    Io(std::io::Error),\n\n    // Configuration errors\n    Config(String),\n\n    // Backend-specific errors\n    Backend { backend: String, message: String },\n\n    // Driver errors\n    Driver(String),\n\n    // Communication errors\n    Communication(String),\n\n    // Timeout errors\n    Timeout(String),\n\n    // Resource not found\n    NotFound(String),\n\n    // Permission denied\n    PermissionDenied(String),\n\n    // Initialization failures\n    InitializationFailed(String),\n\n    // ... and more\n}\n\n// Convenient Result alias\ntype HorusResult<T> = Result<T, HorusError>;",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:60:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 60,
      "lineEnd": 79,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n// Driver errors\nlet err = HorusError::driver(\"Sensor not responding\");\n\n// Backend errors (specify which backend failed)\nlet err = HorusError::backend(\"mpu6050\", \"I2C communication failed\");\n\n// Configuration errors\nlet err = HorusError::config(\"Invalid sample rate: must be > 0\");\n\n// Not found errors\nlet err = HorusError::not_found(\"Device /dev/i2c-1\");\n\n// Check error types\nif err.is_timeout() { /* handle timeout */ }\nif err.is_not_found() { /* handle missing resource */ }\nif err.is_permission_denied() { /* handle permission issue */ }",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:87:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 87,
      "lineEnd": 126,
      "language": "rust",
      "code": "pub struct MyDriver {\n    status: DriverStatus,\n    device: Option<DeviceHandle>,\n}\n\nimpl MyDriver {\n    pub fn init(&mut self) -> HorusResult<()> {\n        // Validate preconditions\n        if self.status != DriverStatus::Uninitialized {\n            return Err(HorusError::driver(\n                \"Driver already initialized\"\n            ));\n        }\n\n        // Try to open the device\n        let device = self.open_device()\n            .map_err(|e| HorusError::InitializationFailed(\n                format!(\"Failed to open device: {}\", e)\n            ))?;\n\n        // Validate device is responsive\n        device.ping()\n            .map_err(|_| HorusError::backend(\n                &self.backend_name,\n                \"Device not responding during init\"\n            ))?;\n\n        // Configure device\n        device.configure(&self.config)\n            .map_err(|e| HorusError::Config(\n                format!(\"Device rejected configuration: {}\", e)\n            ))?;\n\n        self.device = Some(device);\n        self.status = DriverStatus::Ready;\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:130:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 130,
      "lineEnd": 180,
      "language": "rust",
      "code": "impl MyDriver {\n    pub fn read(&mut self) -> HorusResult<SensorData> {\n        // Check we're initialized\n        let device = self.device.as_mut()\n            .ok_or_else(|| HorusError::driver(\n                \"Driver not initialized - call init() first\"\n            ))?;\n\n        // Update status\n        self.status = DriverStatus::Running;\n\n        // Attempt read with timeout\n        let data = device.read_with_timeout(Duration::from_millis(100))\n            .map_err(|e| match e.kind() {\n                std::io::ErrorKind::TimedOut => {\n                    HorusError::Timeout(\"Sensor read timed out after 100ms\".into())\n                }\n                std::io::ErrorKind::PermissionDenied => {\n                    HorusError::PermissionDenied(\n                        \"No permission to read device\".into()\n                    )\n                }\n                _ => HorusError::Io(e),\n            })?;\n\n        // Validate data\n        self.validate_data(&data)?;\n\n        Ok(data)\n    }\n\n    fn validate_data(&self, data: &SensorData) -> HorusResult<()> {\n        // Check for sensor saturation\n        if data.value > self.max_value {\n            return Err(HorusError::driver(\n                \"Sensor reading saturated - value exceeds max\"\n            ));\n        }\n\n        // Check timestamp is recent\n        if data.timestamp == 0 {\n            return Err(HorusError::driver(\n                \"Invalid timestamp in sensor data\"\n            ));\n        }\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:184:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 184,
      "lineEnd": 205,
      "language": "rust",
      "code": "impl MyDriver {\n    pub fn shutdown(&mut self) -> HorusResult<()> {\n        // Allow shutdown from any state\n        if let Some(device) = self.device.take() {\n            // Best-effort device cleanup\n            if let Err(e) = device.stop() {\n                warn!(\"Error stopping device: {} - continuing shutdown\", e);\n            }\n\n            // Close device handle\n            device.close()\n                .map_err(|e| HorusError::driver(\n                    format!(\"Error closing device: {}\", e)\n                ))?;\n        }\n\n        self.status = DriverStatus::Shutdown;\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:213:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 213,
      "lineEnd": 260,
      "language": "rust",
      "code": "use std::time::Duration;\nuse std::thread;\n\n/// Retry an operation with exponential backoff\npub fn retry_with_backoff<T, F>(\n    mut operation: F,\n    max_retries: usize,\n    initial_delay: Duration,\n) -> HorusResult<T>\nwhere\n    F: FnMut() -> HorusResult<T>,\n{\n    let mut delay = initial_delay;\n\n    for attempt in 0..max_retries {\n        match operation() {\n            Ok(result) => return Ok(result),\n            Err(e) => {\n                if attempt < max_retries - 1 {\n                    warn!(\n                        \"Attempt {} failed: {}. Retrying in {:?}...\",\n                        attempt + 1, e, delay\n                    );\n                    thread::sleep(delay);\n                    delay *= 2; // Exponential backoff\n                } else {\n                    return Err(HorusError::driver(format!(\n                        \"Operation failed after {} attempts: {}\",\n                        max_retries, e\n                    )));\n                }\n            }\n        }\n    }\n\n    unreachable!()\n}\n\n// Usage\nfn read_with_retry(&mut self) -> HorusResult<SensorData> {\n    retry_with_backoff(\n        || self.driver.read(),\n        3,                          // max retries\n        Duration::from_millis(10),  // initial delay\n    )\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:264:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 264,
      "lineEnd": 321,
      "language": "rust",
      "code": "pub struct ReconnectingDriver<D> {\n    driver: D,\n    config: SingleDriverConfig,\n    max_reconnect_attempts: usize,\n    reconnect_delay: Duration,\n}\n\nimpl<D: Driver> ReconnectingDriver<D> {\n    pub fn read(&mut self) -> HorusResult<D::Data> {\n        match self.driver.read() {\n            Ok(data) => Ok(data),\n            Err(e) if self.is_connection_error(&e) => {\n                warn!(\"Connection error: {}. Attempting reconnect...\", e);\n                self.reconnect()?;\n                self.driver.read()\n            }\n            Err(e) => Err(e),\n        }\n    }\n\n    fn reconnect(&mut self) -> HorusResult<()> {\n        for attempt in 0..self.max_reconnect_attempts {\n            info!(\"Reconnection attempt {}/{}\", attempt + 1, self.max_reconnect_attempts);\n\n            // Try to reinitialize\n            if let Err(e) = self.driver.shutdown() {\n                debug!(\"Shutdown during reconnect failed: {}\", e);\n            }\n\n            thread::sleep(self.reconnect_delay);\n\n            match self.driver.init() {\n                Ok(()) => {\n                    info!(\"Reconnection successful\");\n                    return Ok(());\n                }\n                Err(e) => {\n                    warn!(\"Reconnection attempt failed: {}\", e);\n                }\n            }\n        }\n\n        Err(HorusError::driver(format!(\n            \"Failed to reconnect after {} attempts\",\n            self.max_reconnect_attempts\n        )))\n    }\n\n    fn is_connection_error(&self, e: &HorusError) -> bool {\n        matches!(e,\n            HorusError::Io(_) |\n            HorusError::Timeout(_) |\n            HorusError::Communication(_)\n        )\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:325:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 325,
      "lineEnd": 369,
      "language": "rust",
      "code": "/// Driver wrapper that falls back to simulation on hardware errors\npub struct FallbackDriver {\n    hardware_driver: Option<Box<dyn ImuDriver>>,\n    simulation_driver: SimulationImuDriver,\n    using_simulation: bool,\n}\n\nimpl FallbackDriver {\n    pub fn new(hardware_config: &SingleDriverConfig) -> Self {\n        let hardware = match create_hardware_driver(hardware_config) {\n            Ok(d) => Some(d),\n            Err(e) => {\n                warn!(\"Hardware unavailable: {}. Will use simulation.\", e);\n                None\n            }\n        };\n\n        Self {\n            hardware_driver: hardware,\n            simulation_driver: SimulationImuDriver::new(),\n            using_simulation: hardware.is_none(),\n        }\n    }\n\n    pub fn read(&mut self) -> HorusResult<Imu> {\n        if self.using_simulation {\n            return self.simulation_driver.read();\n        }\n\n        match self.hardware_driver.as_mut().unwrap().read() {\n            Ok(data) => Ok(data),\n            Err(e) => {\n                error!(\"Hardware read failed: {}. Falling back to simulation.\", e);\n                self.using_simulation = true;\n                self.simulation_driver.read()\n            }\n        }\n    }\n\n    pub fn is_using_simulation(&self) -> bool {\n        self.using_simulation\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:373:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 373,
      "lineEnd": 434,
      "language": "rust",
      "code": "use std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\n\npub struct HealthMonitoredDriver<D> {\n    driver: D,\n    consecutive_errors: AtomicUsize,\n    error_threshold: usize,\n    health_callback: Option<Box<dyn Fn(DriverHealth) + Send>>,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum DriverHealth {\n    Healthy,\n    Degraded { error_count: usize },\n    Unhealthy { error_count: usize },\n}\n\nimpl<D: Driver> HealthMonitoredDriver<D> {\n    pub fn read(&mut self) -> HorusResult<D::Data> {\n        match self.driver.read() {\n            Ok(data) => {\n                // Reset error counter on success\n                let prev = self.consecutive_errors.swap(0, Ordering::SeqCst);\n                if prev > 0 {\n                    self.notify_health(DriverHealth::Healthy);\n                }\n                Ok(data)\n            }\n            Err(e) => {\n                let count = self.consecutive_errors.fetch_add(1, Ordering::SeqCst) + 1;\n\n                let health = if count >= self.error_threshold {\n                    DriverHealth::Unhealthy { error_count: count }\n                } else {\n                    DriverHealth::Degraded { error_count: count }\n                };\n\n                self.notify_health(health);\n                Err(e)\n            }\n        }\n    }\n\n    fn notify_health(&self, health: DriverHealth) {\n        if let Some(callback) = &self.health_callback {\n            callback(health);\n        }\n    }\n\n    pub fn health(&self) -> DriverHealth {\n        let errors = self.consecutive_errors.load(Ordering::SeqCst);\n        if errors == 0 {\n            DriverHealth::Healthy\n        } else if errors >= self.error_threshold {\n            DriverHealth::Unhealthy { error_count: errors }\n        } else {\n            DriverHealth::Degraded { error_count: errors }\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:442:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 442,
      "lineEnd": 465,
      "language": "rust",
      "code": "impl Node for ImuNode {\n    fn process(&mut self, ctx: &mut NodeContext) -> HorusResult<()> {\n        match self.driver.read() {\n            Ok(data) => {\n                self.publisher.publish(&data)?;\n                Ok(())\n            }\n            Err(e) => {\n                // Log but don't propagate - keep the node running\n                error!(\"IMU read error: {}. Skipping this cycle.\", e);\n                self.error_count += 1;\n\n                // Check if we should request restart\n                if self.error_count > self.max_errors {\n                    ctx.request_node_restart(\"Too many consecutive errors\");\n                }\n\n                Ok(()) // Don't propagate to scheduler\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:469:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 469,
      "lineEnd": 511,
      "language": "rust",
      "code": "/// Wrapper that adds error handling behavior to any node\npub struct ErrorHandlingNode<N> {\n    inner: N,\n    error_policy: ErrorPolicy,\n    stats: ErrorStats,\n}\n\npub enum ErrorPolicy {\n    /// Propagate all errors to scheduler\n    Propagate,\n    /// Log errors but continue processing\n    LogAndContinue,\n    /// Retry N times before propagating\n    RetryThenPropagate { max_retries: usize },\n    /// Fall back to default output on error\n    FallbackValue { default: Box<dyn Any> },\n}\n\nimpl<N: Node> Node for ErrorHandlingNode<N> {\n    fn process(&mut self, ctx: &mut NodeContext) -> HorusResult<()> {\n        let result = self.inner.process(ctx);\n\n        match (&result, &self.error_policy) {\n            (Err(e), ErrorPolicy::LogAndContinue) => {\n                self.stats.record_error(e);\n                warn!(\"Node error (ignored): {}\", e);\n                Ok(())\n            }\n            (Err(e), ErrorPolicy::RetryThenPropagate { max_retries }) => {\n                for _ in 0..*max_retries {\n                    if self.inner.process(ctx).is_ok() {\n                        return Ok(());\n                    }\n                }\n                self.stats.record_error(e);\n                result\n            }\n            _ => result,\n        }\n    }\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:519:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 519,
      "lineEnd": 535,
      "language": "rust",
      "code": "fn handle_device_not_found() -> HorusResult<()> {\n    let path = \"/dev/i2c-1\";\n\n    if !std::path::Path::new(path).exists() {\n        return Err(HorusError::not_found(format!(\n            \"Device {} not found. Ensure:\\n\\\n             1. The device is connected\\n\\\n             2. The correct bus is specified\\n\\\n             3. I2C is enabled (raspi-config on Raspberry Pi)\",\n            path\n        )));\n    }\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:539:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 539,
      "lineEnd": 556,
      "language": "rust",
      "code": "fn handle_permission_denied(path: &str) -> HorusResult<()> {\n    match std::fs::metadata(path) {\n        Ok(_) => {\n            // File exists but we can't access it\n            Err(HorusError::PermissionDenied(format!(\n                \"Cannot access {}. Try:\\n\\\n                 1. Run with sudo (for testing only)\\n\\\n                 2. Add user to 'dialout' or 'i2c' group:\\n\\\n                    sudo usermod -a -G dialout $USER\\n\\\n                 3. Create udev rule for this device\",\n                path\n            )))\n        }\n        Err(e) => Err(e.into()),\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:560:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 560,
      "lineEnd": 585,
      "language": "rust",
      "code": "fn detect_disconnection(error: &std::io::Error) -> bool {\n    matches!(error.kind(),\n        std::io::ErrorKind::BrokenPipe |\n        std::io::ErrorKind::ConnectionReset |\n        std::io::ErrorKind::NotConnected |\n        std::io::ErrorKind::UnexpectedEof\n    )\n}\n\nfn handle_read_error(&mut self, error: std::io::Error) -> HorusResult<SensorData> {\n    if detect_disconnection(&error) {\n        warn!(\"Device appears disconnected. Attempting reconnection...\");\n        self.status = DriverStatus::Error;\n\n        // Try to reconnect\n        thread::sleep(Duration::from_millis(500));\n        self.init()?;\n\n        // Retry read\n        return self.read();\n    }\n\n    Err(error.into())\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:593:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 593,
      "lineEnd": 603,
      "language": "rust",
      "code": "// BAD: Vague error\nErr(HorusError::driver(\"Failed\"))\n\n// GOOD: Actionable error\nErr(HorusError::driver(\n    \"IMU initialization failed: No response on I2C bus 1 at address 0x68. \\\n     Verify: 1) Device is connected, 2) Address jumper is correct, \\\n     3) I2C is enabled (sudo raspi-config)\"\n))",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:607:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 607,
      "lineEnd": 623,
      "language": "rust",
      "code": "fn read_calibration(&self) -> HorusResult<Calibration> {\n    let path = &self.calibration_path;\n\n    let contents = std::fs::read_to_string(path)\n        .map_err(|e| HorusError::Config(format!(\n            \"Failed to read calibration file {}: {}\",\n            path, e\n        )))?;\n\n    serde_yaml::from_str(&contents)\n        .map_err(|e| HorusError::Config(format!(\n            \"Invalid calibration format in {}: {}\",\n            path, e\n        )))\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:627:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 627,
      "lineEnd": 657,
      "language": "rust",
      "code": "// Use specific error types\nimpl MyDriver {\n    fn init(&mut self) -> HorusResult<()> {\n        // Not found\n        if !self.device_path.exists() {\n            return Err(HorusError::not_found(&self.device_path));\n        }\n\n        // Permission denied\n        match std::fs::File::open(&self.device_path) {\n            Err(e) if e.kind() == std::io::ErrorKind::PermissionDenied => {\n                return Err(HorusError::PermissionDenied(\n                    format!(\"Cannot access {}\", self.device_path)\n                ));\n            }\n            Err(e) => return Err(e.into()),\n            Ok(_) => {}\n        }\n\n        // Configuration error\n        if self.config.sample_rate <= 0.0 {\n            return Err(HorusError::config(\n                \"sample_rate must be positive\"\n            ));\n        }\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:661:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 661,
      "lineEnd": 683,
      "language": "rust",
      "code": "fn process_with_logging(&mut self) -> HorusResult<()> {\n    match self.driver.read() {\n        Ok(data) => {\n            trace!(\"Read sensor data: {:?}\", data);  // Trace for detailed debugging\n            Ok(())\n        }\n        Err(e) if e.is_timeout() => {\n            debug!(\"Read timeout - will retry\");     // Debug for expected issues\n            Ok(())\n        }\n        Err(e) if self.error_count < 3 => {\n            warn!(\"Read error ({}): {}\", self.error_count, e);  // Warn for unusual\n            self.error_count += 1;\n            Ok(())\n        }\n        Err(e) => {\n            error!(\"Persistent read error: {}\", e);  // Error for serious issues\n            Err(e)\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/error-handling:689:rust",
      "file": "content/docs/rust/library/drivers/error-handling.mdx",
      "lineStart": 689,
      "lineEnd": 741,
      "language": "rust",
      "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_handles_initialization_error() {\n        let config = SingleDriverConfig {\n            backend: \"nonexistent\".into(),\n            ..Default::default()\n        };\n\n        let result = create_driver(&config);\n        assert!(result.is_err());\n        assert!(matches!(result, Err(HorusError::NotFound(_))));\n    }\n\n    #[test]\n    fn test_retry_succeeds_eventually() {\n        let mut attempts = 0;\n        let result = retry_with_backoff(\n            || {\n                attempts += 1;\n                if attempts < 3 {\n                    Err(HorusError::Timeout(\"test\".into()))\n                } else {\n                    Ok(\"success\")\n                }\n            },\n            5,\n            Duration::from_millis(1),\n        );\n\n        assert_eq!(result.unwrap(), \"success\");\n        assert_eq!(attempts, 3);\n    }\n\n    #[test]\n    fn test_fallback_to_simulation() {\n        let mut driver = FallbackDriver::new(&SingleDriverConfig {\n            backend: \"invalid_hardware\".into(),\n            ..Default::default()\n        });\n\n        // Should fall back to simulation\n        assert!(driver.is_using_simulation());\n\n        // Should still produce valid data\n        let data = driver.read().unwrap();\n        assert!(data.timestamp > 0);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:18:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 18,
      "lineEnd": 35,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {ImuDriver, SimulationImuDriver, Mpu6050Driver, MotorDriver, SimulationMotorDriver, I2cDriver, SimulationI2cDriver}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Development: Use simulation driver\n    let imu = SimulationImuDriver::new();\n\n    // Production: Use real hardware\n    #[cfg(feature = \"mpu6050-imu\")]\n    let imu = Mpu6050Driver::new(\"/dev/i2c-1\", 0x68)?;\n\n    // Read data\n    let data = imu.read()?;\n    println!(\"Accel: {:?}\", data.linear_acceleration);\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/index:43:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 43,
      "lineEnd": 55,
      "language": "rust",
      "code": "// Simple struct - no ceremony\npub struct MyMotorDriver {\n    port: String,\n    status: DriverStatus,\n}\n\nimpl MyMotorDriver {\n    pub fn new(port: &str) -> Result<Self, Error> { ... }\n    pub fn set_speed(&mut self, speed: f64) -> Result<(), Error> { ... }\n    pub fn stop(&mut self) -> Result<(), Error> { ... }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:114:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 114,
      "lineEnd": 140,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {ImuDriver, SimulationImuDriver, DriverStatus}\n\n// Create simulation driver\nlet mut imu = SimulationImuDriver::new();\n\n// Initialize\nimu.init()?;\nassert_eq!(imu.status(), DriverStatus::Ready);\n\n// Read IMU data\nlet data = imu.read()?;\nprintln!(\"Angular velocity: {:?}\", data.angular_velocity);\nprintln!(\"Linear acceleration: {:?}\", data.linear_acceleration);\n\n// With real hardware (MPU6050)\n#[cfg(feature = \"mpu6050-imu\")]\n{\n    use horus::prelude::Mpu6050Driver;\n\n    let mut imu = Mpu6050Driver::new(\"/dev/i2c-1\", 0x68)?;\n    imu.init()?;\n\n    // Same API as simulation\n    let data = imu.read()?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:144:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 144,
      "lineEnd": 172,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {MotorDriver, SimulationMotorDriver}\n\nlet mut motor = SimulationMotorDriver::new();\nmotor.init()?;\n\n// Set speed (-1.0 to 1.0)\nmotor.set_speed(0.5)?;\n\n// Get current speed\nlet speed = motor.get_speed();\n\n// Stop motor\nmotor.stop()?;\n\n// With real hardware (GPIO)\n#[cfg(feature = \"gpio-hardware\")]\n{\n    use horus::prelude::GpioMotorDriver;\n\n    let mut motor = GpioMotorDriver::new(\n        18,  // PWM pin\n        23,  // Direction pin A\n        24,  // Direction pin B\n    )?;\n    motor.init()?;\n    motor.set_speed(0.75)?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:176:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 176,
      "lineEnd": 199,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {JoystickDriver, SimulationJoystickDriver, ButtonMapping}\n\n// Simulation joystick\nlet mut joystick = SimulationJoystickDriver::new();\njoystick.init()?;\n\n// Read input\nlet input = joystick.read()?;\nprintln!(\"Left stick: ({:.2}, {:.2})\", input.left_x, input.left_y);\nprintln!(\"Buttons: {:?}\", input.buttons);\n\n// With real hardware (gilrs)\n#[cfg(feature = \"gilrs\")]\n{\n    use horus::prelude::GilrsJoystickDriver;\n\n    let mut joystick = GilrsJoystickDriver::new()?;\n    joystick.set_mapping(ButtonMapping::Xbox360);\n    joystick.init()?;\n\n    let input = joystick.read()?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:203:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 203,
      "lineEnd": 232,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {KeyboardDriver, SimulationKeyboardDriver, KEY_W, KEY_A, KEY_S, KEY_D, KEY_SPACE}\n\n// Simulation keyboard\nlet mut keyboard = SimulationKeyboardDriver::new();\nkeyboard.init()?;\n\n// Simulate key press\nkeyboard.simulate_key_press(KEY_W);\n\n// Read input\nlet input = keyboard.read()?;\nif input.is_key_pressed(KEY_W) {\n    println!(\"W pressed - moving forward\");\n}\n\n// With real terminal input (crossterm)\n#[cfg(feature = \"crossterm\")]\n{\n    use horus::prelude::CrosstermKeyboardDriver;\n\n    let mut keyboard = CrosstermKeyboardDriver::new()?;\n    keyboard.init()?;\n\n    // Non-blocking read\n    if let Some(input) = keyboard.try_read()? {\n        println!(\"Key pressed: {:?}\", input.keycode);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:236:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 236,
      "lineEnd": 261,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {I2cDriver, SimulationI2cDriver}\n\n// Simulation I2C bus\nlet mut i2c = SimulationI2cDriver::new();\ni2c.init()?;\n\n// Write to device\ni2c.write(0x68, &[0x6B, 0x00])?;  // Wake up MPU6050\n\n// Read from device\nlet mut buffer = [0u8; 6];\ni2c.read(0x68, &mut buffer)?;\n\n// With real hardware (Linux I2C)\n#[cfg(feature = \"i2c-hardware\")]\n{\n    use horus::prelude::LinuxI2cDriver;\n\n    let mut i2c = LinuxI2cDriver::new(\"/dev/i2c-1\")?;\n    i2c.init()?;\n\n    // Same API\n    i2c.write(0x68, &[0x6B, 0x00])?;\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:271:yaml",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 271,
      "lineEnd": 297,
      "language": "yaml",
      "code": "drivers:\n  lidar:\n    backend: rplidar\n    port: /dev/ttyUSB0\n    baud_rate: 115200\n\n  camera:\n    backend: v4l2\n    device: /dev/video0\n    width: 640\n    height: 480\n    fps: 30\n\n  imu:\n    backend: mpu6050\n    i2c_bus: 1\n    i2c_address: 0x68\n\n  motors:\n    backend: gpio\n    enabled: true\n\n  # Use simulation when hardware unavailable\n  gps:\n    backend: simulation",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/index:301:toml",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 301,
      "lineEnd": 316,
      "language": "toml",
      "code": "[drivers.lidar]\nbackend = \"rplidar\"\nport = \"/dev/ttyUSB0\"\nbaud_rate = 115200\n\n[drivers.imu]\nbackend = \"mpu6050\"\ni2c_bus = 1\ni2c_address = 104  # 0x68\n\n[drivers.camera]\nbackend = \"simulation\"\nwidth = 640\nheight = 480",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/index:320:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 320,
      "lineEnd": 345,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {DriversConfig, SingleDriverConfig}\n\n// Load from file\nlet config = DriversConfig::from_file(\"drivers.yaml\")?;\n\n// Or auto-find in standard locations\nlet config = DriversConfig::find_and_load()?;\n\n// Get specific driver config\nlet lidar_config = config.get_driver(\"lidar\")?;\nprintln!(\"LiDAR backend: {}\", lidar_config.backend);\nprintln!(\"Port: {:?}\", lidar_config.port);\n\n// Get with default fallback\nlet gps_config = config.get_driver_or_default(\"gps\");\nif gps_config.is_simulation() {\n    println!(\"GPS: Using simulation mode\");\n}\n\n// List all enabled drivers\nfor (name, cfg) in config.enabled_drivers() {\n    println!(\"{}: {} ({})\", name, cfg.backend,\n        if cfg.is_simulation() { \"sim\" } else { \"hw\" });\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:353:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 353,
      "lineEnd": 375,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {create_imu_driver, create_lidar_driver, create_camera_driver, create_motor_driver, create_drivers_from_config, CreatedDrivers, list_available_backends, SingleDriverConfig}\n\n// Create single driver from config\nlet imu_config = SingleDriverConfig::i2c(\"mpu6050\", 1, 0x68);\nlet imu = create_imu_driver(&imu_config)?;\n\n// Create all drivers from config file\nlet drivers: CreatedDrivers = create_drivers_from_config(\"drivers.yaml\")?;\n\n// Access created drivers\nif let Some(imu) = &drivers.imu {\n    let data = imu.read()?;\n}\nif let Some(lidar) = &drivers.lidar {\n    let scan = lidar.read()?;\n}\n\n// List available backends\nlet backends = list_available_backends();\nprintln!(\"Available IMU backends: {:?}\", backends.imu);\nprintln!(\"Available camera backends: {:?}\", backends.camera);",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:385:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 385,
      "lineEnd": 426,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {DriverStatus, Imu}\n\npub struct MyCustomImuDriver {\n    device_path: String,\n    status: DriverStatus,\n    // Your hardware-specific fields\n}\n\nimpl MyCustomImuDriver {\n    pub fn new(device_path: &str) -> Result<Self, Box<dyn std::error::Error>> {\n        Ok(Self {\n            device_path: device_path.to_string(),\n            status: DriverStatus::Uninitialized,\n        })\n    }\n\n    pub fn init(&mut self) -> Result<(), Box<dyn std::error::Error>> {\n        // Initialize your hardware\n        // ...\n        self.status = DriverStatus::Ready;\n        Ok(())\n    }\n\n    pub fn read(&mut self) -> Result<Imu, Box<dyn std::error::Error>> {\n        // Read from your hardware\n        let mut imu = Imu::new();\n        // Fill in data...\n        Ok(imu)\n    }\n\n    pub fn status(&self) -> DriverStatus {\n        self.status.clone()\n    }\n\n    pub fn shutdown(&mut self) -> Result<(), Box<dyn std::error::Error>> {\n        // Cleanup hardware\n        self.status = DriverStatus::Shutdown;\n        Ok(())\n    }\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:430:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 430,
      "lineEnd": 459,
      "language": "rust",
      "code": "use horus::prelude::*;\n\npub struct MyImuNode {\n    driver: MyCustomImuDriver,\n    publisher: Hub<Imu>,\n}\n\nimpl MyImuNode {\n    pub fn new(device_path: &str) -> Result<Self, Box<dyn std::error::Error>> {\n        let mut driver = MyCustomImuDriver::new(device_path)?;\n        driver.init()?;\n\n        Ok(Self {\n            driver,\n            publisher: Hub::new(\"imu\")?,\n        })\n    }\n}\n\nimpl Node for MyImuNode {\n    fn name(&self) -> &'static str { \"MyImuNode\" }\n\n    fn tick(&mut self, _ctx: Option<&mut NodeInfo>) {\n        if let Ok(data) = self.driver.read() {\n            self.publisher.send(&data);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:465:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 465,
      "lineEnd": 474,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides DriverStatus\n\n// Driver lifecycle states\nDriverStatus::Uninitialized  // Created but not initialized\nDriverStatus::Ready          // Initialized and ready to operate\nDriverStatus::Running        // Actively streaming/operating\nDriverStatus::Error(msg)     // Encountered an error\nDriverStatus::Shutdown       // Gracefully shut down",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:482:toml",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 482,
      "lineEnd": 520,
      "language": "toml",
      "code": "[dependencies]\nhorus_library = { version = \"0.1\", features = [\n    # IMU sensors\n    \"mpu6050-imu\",\n    \"bno055-imu\",\n\n    # Camera backends\n    \"opencv-backend\",\n    \"v4l2-backend\",\n    \"realsense\",\n\n    # LiDAR\n    \"rplidar\",\n\n    # GPS\n    \"nmea-gps\",\n\n    # Communication buses\n    \"i2c-hardware\",\n    \"spi-hardware\",\n    \"can-hardware\",\n    \"serial-hardware\",\n\n    # GPIO\n    \"gpio-hardware\",\n\n    # Input devices\n    \"gilrs\",\n    \"crossterm\",\n\n    # Force/torque sensors\n    \"netft\",\n    \"robotiq-serial\",\n\n    # Modbus\n    \"modbus-hardware\",\n]}",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/index:524:yaml",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 524,
      "lineEnd": 531,
      "language": "yaml",
      "code": "dependencies:\n  - name: horus\n    features:\n      - mpu6050-imu\n      - gpio-hardware\n      - serial-hardware",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/index:539:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 539,
      "lineEnd": 557,
      "language": "rust",
      "code": "use horus::prelude::*; // Includes keyboard keycodes\n\n// Letters\nKEY_A, KEY_B, KEY_C, KEY_D, KEY_W, KEY_S  // 65-90\n\n// Arrows\nKEY_ARROW_UP      // 38\nKEY_ARROW_DOWN    // 40\nKEY_ARROW_LEFT    // 37\nKEY_ARROW_RIGHT   // 39\n\n// Special keys\nKEY_SPACE         // 32\nKEY_ENTER         // 13\nKEY_ESCAPE        // 27\nKEY_TAB           // 9\nKEY_BACKSPACE     // 8",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:565:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 565,
      "lineEnd": 571,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides ButtonMapping\n\nButtonMapping::Xbox360      // Xbox 360 controller layout\nButtonMapping::PlayStation4 // PS4 DualShock layout\nButtonMapping::Generic      // Generic gamepad (default)",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/index:584:rust",
      "file": "content/docs/rust/library/drivers/index.mdx",
      "lineStart": 584,
      "lineEnd": 606,
      "language": "rust",
      "code": "// Good practice: Check status\nif imu.status() == DriverStatus::Ready {\n    let data = imu.read()?;\n}\n\n// Good practice: Handle errors\nmatch motor.set_speed(0.5) {\n    Ok(_) => println!(\"Motor running\"),\n    Err(e) => {\n        eprintln!(\"Motor error: {}\", e);\n        motor.stop().ok();  // Try to stop safely\n    }\n}\n\n// Good practice: Cleanup on exit\nimpl Drop for MyRobot {\n    fn drop(&mut self) {\n        self.motor.stop().ok();\n        self.motor.shutdown().ok();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:19:text",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 19,
      "lineEnd": 50,
      "language": "text",
      "code": "┌──────────────────────────────────────────────────────────────┐\n│                    Differential Drive Robot                   │\n├──────────────────────────────────────────────────────────────┤\n│                                                               │\n│   ┌─────────┐     ┌──────────────────┐     ┌─────────────┐   │\n│   │  IMU    │────▶│  Sensor Fusion   │────▶│ Localization│   │\n│   │ Driver  │     │     Node         │     │    Node     │   │\n│   └─────────┘     └──────────────────┘     └─────────────┘   │\n│                           ▲                       │           │\n│   ┌─────────┐             │                       ▼           │\n│   │Encoder  │─────────────┘               ┌─────────────┐     │\n│   │ Driver  │                             │  Path       │     │\n│   │(Left)   │                             │  Planner    │     │\n│   └─────────┘                             └─────────────┘     │\n│                                                   │           │\n│   ┌─────────┐                                     ▼           │\n│   │Encoder  │                             ┌─────────────┐     │\n│   │ Driver  │                             │ Differential│     │\n│   │(Right)  │                             │   Drive     │     │\n│   └─────────┘                             │    Node     │     │\n│                                           └─────────────┘     │\n│                                            /          \\       │\n│                                           ▼            ▼      │\n│                                    ┌─────────┐  ┌─────────┐   │\n│                                    │ Motor   │  │ Motor   │   │\n│                                    │ Driver  │  │ Driver  │   │\n│                                    │ (Left)  │  │ (Right) │   │\n│                                    └─────────┘  └─────────┘   │\n│                                                               │\n└──────────────────────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:56:text",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 56,
      "lineEnd": 71,
      "language": "text",
      "code": "┌─────────┐\n│  IMU    │──┐\n│ Driver  │  │\n└─────────┘  │\n             │      ┌──────────────────┐      ┌─────────────┐\n┌─────────┐  ├─────▶│  Sensor Fusion   │─────▶│   Output    │\n│  GPS    │──┤      │  (EKF/UKF)       │      │   Pose      │\n│ Driver  │  │      └──────────────────┘      └─────────────┘\n└─────────┘  │\n             │\n┌─────────┐  │\n│Encoders │──┘\n│ Driver  │\n└─────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:80:yaml",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 80,
      "lineEnd": 116,
      "language": "yaml",
      "code": "drivers:\n  # IMU for orientation\n  imu:\n    backend: mpu6050\n    i2c_bus: 1\n    i2c_address: 0x68\n    fps: 100\n\n  # Left wheel motor\n  motor_left:\n    backend: gpio_pwm\n    pin: 18\n    direction_pin: 23\n    frequency: 1000\n\n  # Right wheel motor\n  motor_right:\n    backend: gpio_pwm\n    pin: 19\n    direction_pin: 24\n    frequency: 1000\n\n  # Left wheel encoder\n  encoder_left:\n    backend: gpio_encoder\n    pin_a: 5\n    pin_b: 6\n    ticks_per_rev: 1440\n\n  # Right wheel encoder\n  encoder_right:\n    backend: gpio_encoder\n    pin_a: 12\n    pin_b: 13\n    ticks_per_rev: 1440",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:120:rust",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 120,
      "lineEnd": 195,
      "language": "rust",
      "code": "use horus::prelude::*;\n\npub struct DifferentialDriveNode {\n    // Subscribers\n    cmd_vel_sub: Subscriber<Twist>,\n\n    // Publishers\n    motor_left_pub: Publisher<MotorCommand>,\n    motor_right_pub: Publisher<MotorCommand>,\n\n    // Robot parameters\n    wheel_base: f64,      // meters between wheels\n    wheel_radius: f64,    // meters\n    max_speed: f64,       // m/s\n}\n\nimpl DifferentialDriveNode {\n    pub fn new(\n        cmd_topic: &str,\n        left_topic: &str,\n        right_topic: &str,\n        wheel_base: f64,\n    ) -> HorusResult<Self> {\n        Ok(Self {\n            cmd_vel_sub: Subscriber::new(cmd_topic)?,\n            motor_left_pub: Publisher::new(left_topic)?,\n            motor_right_pub: Publisher::new(right_topic)?,\n            wheel_base,\n            wheel_radius: 0.05, // 5cm wheels\n            max_speed: 1.0,\n        })\n    }\n\n    fn twist_to_wheel_speeds(&self, twist: &Twist) -> (f64, f64) {\n        // Convert linear + angular velocity to wheel speeds\n        let linear = twist.linear[0];  // Forward velocity\n        let angular = twist.angular[2]; // Rotation around Z\n\n        // Differential drive kinematics\n        let v_left = linear - (angular * self.wheel_base / 2.0);\n        let v_right = linear + (angular * self.wheel_base / 2.0);\n\n        // Convert to wheel angular velocity\n        let omega_left = v_left / self.wheel_radius;\n        let omega_right = v_right / self.wheel_radius;\n\n        // Clamp to max speed\n        let max_omega = self.max_speed / self.wheel_radius;\n        (\n            omega_left.clamp(-max_omega, max_omega),\n            omega_right.clamp(-max_omega, max_omega),\n        )\n    }\n}\n\nimpl Node for DifferentialDriveNode {\n    fn name(&self) -> &str {\n        \"differential_drive\"\n    }\n\n    fn process(&mut self, _ctx: &mut NodeContext) -> HorusResult<()> {\n        // Read command velocity\n        if let Some(cmd_vel) = self.cmd_vel_sub.try_recv()? {\n            // Convert to wheel speeds\n            let (left_speed, right_speed) = self.twist_to_wheel_speeds(&cmd_vel);\n\n            // Send to motors\n            self.motor_left_pub.publish(&MotorCommand::velocity(left_speed))?;\n            self.motor_right_pub.publish(&MotorCommand::velocity(right_speed))?;\n        }\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:203:rust",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 203,
      "lineEnd": 309,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus_algorithms::EKF;\n\npub struct SensorFusionNode {\n    // Subscribers\n    imu_sub: Subscriber<Imu>,\n    gps_sub: Subscriber<NavSatFix>,\n    encoder_left_sub: Subscriber<EncoderReading>,\n    encoder_right_sub: Subscriber<EncoderReading>,\n\n    // Publisher\n    pose_pub: Publisher<Pose>,\n\n    // State estimator\n    ekf: EKF,\n\n    // Robot parameters\n    wheel_base: f64,\n    wheel_radius: f64,\n\n    // Last encoder readings for delta\n    last_left_ticks: i64,\n    last_right_ticks: i64,\n}\n\nimpl SensorFusionNode {\n    pub fn new() -> HorusResult<Self> {\n        Ok(Self {\n            imu_sub: Subscriber::new(\"imu\")?,\n            gps_sub: Subscriber::new(\"gps\")?,\n            encoder_left_sub: Subscriber::new(\"encoder/left\")?,\n            encoder_right_sub: Subscriber::new(\"encoder/right\")?,\n            pose_pub: Publisher::new(\"pose\")?,\n            ekf: EKF::new_with_defaults(),\n            wheel_base: 0.3,\n            wheel_radius: 0.05,\n            last_left_ticks: 0,\n            last_right_ticks: 0,\n        })\n    }\n\n    fn process_imu(&mut self, imu: &Imu) {\n        // IMU provides angular velocity (high frequency)\n        self.ekf.predict_with_gyro(&imu.angular_velocity);\n\n        // And orientation update from accelerometer\n        self.ekf.update_orientation(&imu.linear_acceleration);\n    }\n\n    fn process_encoders(&mut self, left: &EncoderReading, right: &EncoderReading) {\n        // Calculate wheel deltas\n        let delta_left = left.ticks - self.last_left_ticks;\n        let delta_right = right.ticks - self.last_right_ticks;\n\n        self.last_left_ticks = left.ticks;\n        self.last_right_ticks = right.ticks;\n\n        // Convert to distance\n        let ticks_per_rev = 1440.0;\n        let dist_left = (delta_left as f64 / ticks_per_rev) * 2.0 * std::f64::consts::PI * self.wheel_radius;\n        let dist_right = (delta_right as f64 / ticks_per_rev) * 2.0 * std::f64::consts::PI * self.wheel_radius;\n\n        // Odometry update\n        self.ekf.update_odometry(dist_left, dist_right, self.wheel_base);\n    }\n\n    fn process_gps(&mut self, gps: &NavSatFix) {\n        // GPS provides absolute position (low frequency, noisy)\n        if gps.status >= 0 { // Has fix\n            self.ekf.update_position(gps.latitude, gps.longitude, gps.position_covariance);\n        }\n    }\n}\n\nimpl Node for SensorFusionNode {\n    fn name(&self) -> &str {\n        \"sensor_fusion\"\n    }\n\n    fn process(&mut self, _ctx: &mut NodeContext) -> HorusResult<()> {\n        // Process all available IMU data (high priority)\n        while let Some(imu) = self.imu_sub.try_recv()? {\n            self.process_imu(&imu);\n        }\n\n        // Process encoder data\n        if let (Some(left), Some(right)) = (\n            self.encoder_left_sub.try_recv()?,\n            self.encoder_right_sub.try_recv()?\n        ) {\n            self.process_encoders(&left, &right);\n        }\n\n        // Process GPS if available\n        if let Some(gps) = self.gps_sub.try_recv()? {\n            self.process_gps(&gps);\n        }\n\n        // Publish fused pose\n        let pose = self.ekf.get_pose();\n        self.pose_pub.publish(&pose)?;\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:317:rust",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 317,
      "lineEnd": 395,
      "language": "rust",
      "code": "pub struct RobotArmController {\n    joints: Vec<JointDriver>,\n    trajectory_sub: Subscriber<JointTrajectory>,\n    state_pub: Publisher<JointState>,\n}\n\nimpl RobotArmController {\n    pub fn new(num_joints: usize) -> HorusResult<Self> {\n        let mut joints = Vec::with_capacity(num_joints);\n\n        for i in 0..num_joints {\n            joints.push(JointDriver::new(&format!(\"joint_{}\", i))?);\n        }\n\n        Ok(Self {\n            joints,\n            trajectory_sub: Subscriber::new(\"trajectory\")?,\n            state_pub: Publisher::new(\"joint_state\")?,\n        })\n    }\n\n    fn execute_synchronized_move(&mut self, targets: &[f64]) -> HorusResult<()> {\n        // Calculate move time based on longest move\n        let current_positions: Vec<f64> = self.joints\n            .iter()\n            .map(|j| j.get_position())\n            .collect();\n\n        let max_distance = current_positions\n            .iter()\n            .zip(targets.iter())\n            .map(|(c, t)| (t - c).abs())\n            .max_by(|a, b| a.partial_cmp(b).unwrap())\n            .unwrap_or(0.0);\n\n        let move_time = max_distance / self.max_velocity();\n\n        // Calculate velocity for each joint to finish simultaneously\n        for (i, joint) in self.joints.iter_mut().enumerate() {\n            let distance = targets[i] - current_positions[i];\n            let velocity = distance / move_time;\n            joint.set_velocity(velocity)?;\n        }\n\n        // Start all joints\n        for joint in &mut self.joints {\n            joint.start_move()?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Node for RobotArmController {\n    fn name(&self) -> &str {\n        \"arm_controller\"\n    }\n\n    fn process(&mut self, _ctx: &mut NodeContext) -> HorusResult<()> {\n        // Process trajectory commands\n        if let Some(trajectory) = self.trajectory_sub.try_recv()? {\n            for point in &trajectory.points {\n                self.execute_synchronized_move(&point.positions)?;\n            }\n        }\n\n        // Publish current joint state\n        let state = JointState {\n            positions: self.joints.iter().map(|j| j.get_position()).collect(),\n            velocities: self.joints.iter().map(|j| j.get_velocity()).collect(),\n            efforts: self.joints.iter().map(|j| j.get_effort()).collect(),\n        };\n        self.state_pub.publish(&state)?;\n\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:403:rust",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 403,
      "lineEnd": 500,
      "language": "rust",
      "code": "pub struct RedundantImuDriver {\n    primary: Box<dyn ImuDriver>,\n    secondary: Box<dyn ImuDriver>,\n    active: RedundantMode,\n    error_count: usize,\n    threshold: usize,\n}\n\nenum RedundantMode {\n    Primary,\n    Secondary,\n    Voting,  // Use both, compare results\n}\n\nimpl RedundantImuDriver {\n    pub fn new(\n        primary: Box<dyn ImuDriver>,\n        secondary: Box<dyn ImuDriver>,\n    ) -> Self {\n        Self {\n            primary,\n            secondary,\n            active: RedundantMode::Primary,\n            error_count: 0,\n            threshold: 5,\n        }\n    }\n\n    fn read_with_voting(&mut self) -> HorusResult<Imu> {\n        let primary_result = self.primary.read();\n        let secondary_result = self.secondary.read();\n\n        match (primary_result, secondary_result) {\n            (Ok(p), Ok(s)) => {\n                // Both succeeded - average the results\n                Ok(self.average_readings(&p, &s))\n            }\n            (Ok(p), Err(e)) => {\n                warn!(\"Secondary IMU failed: {}. Using primary only.\", e);\n                Ok(p)\n            }\n            (Err(e), Ok(s)) => {\n                warn!(\"Primary IMU failed: {}. Using secondary only.\", e);\n                Ok(s)\n            }\n            (Err(e1), Err(e2)) => {\n                Err(HorusError::driver(format!(\n                    \"Both IMUs failed: primary={}, secondary={}\", e1, e2\n                )))\n            }\n        }\n    }\n\n    fn average_readings(&self, a: &Imu, b: &Imu) -> Imu {\n        Imu {\n            linear_acceleration: [\n                (a.linear_acceleration[0] + b.linear_acceleration[0]) / 2.0,\n                (a.linear_acceleration[1] + b.linear_acceleration[1]) / 2.0,\n                (a.linear_acceleration[2] + b.linear_acceleration[2]) / 2.0,\n            ],\n            angular_velocity: [\n                (a.angular_velocity[0] + b.angular_velocity[0]) / 2.0,\n                (a.angular_velocity[1] + b.angular_velocity[1]) / 2.0,\n                (a.angular_velocity[2] + b.angular_velocity[2]) / 2.0,\n            ],\n            timestamp: a.timestamp.max(b.timestamp),\n        }\n    }\n}\n\nimpl ImuDriver for RedundantImuDriver {\n    fn read(&mut self) -> HorusResult<Imu> {\n        match self.active {\n            RedundantMode::Primary => {\n                match self.primary.read() {\n                    Ok(data) => {\n                        self.error_count = 0;\n                        Ok(data)\n                    }\n                    Err(e) => {\n                        self.error_count += 1;\n                        if self.error_count >= self.threshold {\n                            warn!(\"Switching to secondary IMU\");\n                            self.active = RedundantMode::Secondary;\n                        }\n                        Err(e)\n                    }\n                }\n            }\n            RedundantMode::Secondary => self.secondary.read(),\n            RedundantMode::Voting => self.read_with_voting(),\n        }\n    }\n\n    // ... other trait methods\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:508:rust",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 508,
      "lineEnd": 570,
      "language": "rust",
      "code": "pub struct HealthAggregator {\n    drivers: HashMap<String, Box<dyn HealthMonitored>>,\n    health_pub: Publisher<SystemHealth>,\n}\n\npub trait HealthMonitored {\n    fn health(&self) -> DriverHealth;\n    fn name(&self) -> &str;\n}\n\n#[derive(Clone)]\npub struct SystemHealth {\n    pub overall: HealthStatus,\n    pub driver_health: HashMap<String, DriverHealth>,\n    pub timestamp: u64,\n}\n\nimpl HealthAggregator {\n    pub fn check_health(&self) -> SystemHealth {\n        let mut driver_health = HashMap::new();\n        let mut worst_status = HealthStatus::Healthy;\n\n        for (name, driver) in &self.drivers {\n            let health = driver.health();\n            driver_health.insert(name.clone(), health.clone());\n\n            // Track worst status\n            if health.status > worst_status {\n                worst_status = health.status;\n            }\n        }\n\n        SystemHealth {\n            overall: worst_status,\n            driver_health,\n            timestamp: get_timestamp_ns(),\n        }\n    }\n}\n\nimpl Node for HealthAggregator {\n    fn name(&self) -> &str {\n        \"health_aggregator\"\n    }\n\n    fn process(&mut self, _ctx: &mut NodeContext) -> HorusResult<()> {\n        let health = self.check_health();\n\n        // Log warnings for degraded drivers\n        for (name, status) in &health.driver_health {\n            if status.status == HealthStatus::Degraded {\n                warn!(\"Driver {} is degraded: {}\", name, status.message);\n            } else if status.status == HealthStatus::Unhealthy {\n                error!(\"Driver {} is unhealthy: {}\", name, status.message);\n            }\n        }\n\n        self.health_pub.publish(&health)?;\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/multi-driver:578:rust",
      "file": "content/docs/rust/library/drivers/multi-driver.mdx",
      "lineStart": 578,
      "lineEnd": 603,
      "language": "rust",
      "code": "fn main() -> HorusResult<()> {\n    let mut scheduler = Scheduler::new();\n\n    // Fast tier: Sensors (100Hz)\n    scheduler.add(Box::new(ImuNode::new()?), 10, Some(true));\n    scheduler.add(Box::new(EncoderNode::new(\"left\")?), 10, Some(true));\n    scheduler.add(Box::new(EncoderNode::new(\"right\")?), 10, Some(true));\n\n    // Medium tier: Fusion and control (50Hz)\n    scheduler.add(Box::new(SensorFusionNode::new()?), 20, None);\n    scheduler.add(Box::new(DifferentialDriveNode::new()?), 20, None);\n\n    // Slow tier: Planning and GPS (10Hz)\n    scheduler.add(Box::new(GpsNode::new()?), 100, Some(true));\n    scheduler.add(Box::new(PathPlannerNode::new()?), 100, None);\n\n    // Health monitoring (1Hz)\n    scheduler.add(Box::new(HealthAggregator::new()?), 1000, None);\n\n    // Run the system\n    scheduler.run()?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:35:text",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 35,
      "lineEnd": 54,
      "language": "text",
      "code": "┌─────────────────────────────────────────────────────────────┐\n│                     DriverLoader                             │\n│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │\n│  │   Static    │    │   Dynamic   │    │   Hybrid    │      │\n│  │   Plugins   │    │   Plugins   │    │    Mode     │      │\n│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘      │\n└─────────┼──────────────────┼──────────────────┼─────────────┘\n          │                  │                  │\n          ▼                  ▼                  ▼\n    ┌───────────────────────────────────────────────┐\n    │              DriverPlugin Trait                │\n    │  ┌─────────────────────────────────────────┐  │\n    │  │  manifest()  → PluginManifest           │  │\n    │  │  probe()     → Vec<ProbeResult>         │  │\n    │  │  create()    → Box<dyn Any + Send>      │  │\n    │  │  health()    → PluginHealth             │  │\n    │  └─────────────────────────────────────────┘  │\n    └───────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:62:yaml",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 62,
      "lineEnd": 77,
      "language": "yaml",
      "code": "driver_mode: hybrid  # static, dynamic, or hybrid\n\nplugins:\n  search_paths:\n    - ~/.horus/drivers\n    - /usr/local/lib/horus/drivers\n\n  # For hybrid mode\n  static:\n    - imu\n    - motor\n  dynamic:\n    - camera-fancy\n    - lidar-velodyne",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:93:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 93,
      "lineEnd": 155,
      "language": "rust",
      "code": "use horus_core::plugin::{PluginManifest, BackendInfo, SystemDependency};\nuse horus_core::driver::DriverCategory;\nuse std::collections::HashMap;\n\nlet manifest = PluginManifest {\n    // Required: Unique identifier (use reverse-domain style)\n    id: \"horus-imu-mpu6050\".into(),\n\n    // Required: Human-readable name\n    name: \"MPU6050 IMU Driver\".into(),\n\n    // Required: Semver version\n    version: \"1.0.0\".into(),\n\n    // Required: Driver category\n    category: DriverCategory::Sensor,\n\n    // Required: Brief description\n    description: \"Driver for MPU6050 6-axis IMU via I2C\".into(),\n\n    // Optional: Author/maintainer\n    author: Some(\"Your Name\".into()),\n\n    // Optional: SPDX license identifier\n    license: Some(\"MIT OR Apache-2.0\".into()),\n\n    // Optional: Source repository\n    repository: Some(\"https://github.com/you/horus-imu-mpu6050\".into()),\n\n    // Required: Backends provided by this plugin\n    backends: vec![\n        BackendInfo {\n            id: \"mpu6050\".into(),\n            name: \"MPU6050\".into(),\n            description: \"MPU6050 via I2C\".into(),\n            hardware_ids: vec![\"i2c:0x68\".into(), \"i2c:0x69\".into()],\n        },\n    ],\n\n    // Optional: System dependencies\n    system_deps: vec![\n        SystemDependency {\n            name: \"i2c-dev\".into(),\n            kind: \"kernel-module\".into(),\n            required: true,\n            check_cmd: Some(\"lsmod | grep -q i2c_dev\".into()),\n        },\n    ],\n\n    // Required: Compatible HORUS versions (semver range)\n    horus_version: \">=0.5.0, <1.0.0\".into(),\n\n    // Optional: Supported platforms (default: [\"linux\"])\n    platforms: vec![\"linux\".into()],\n\n    // Optional: Feature flags\n    features: vec![],\n\n    // Optional: Extra metadata\n    extra: HashMap::new(),\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:161:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 161,
      "lineEnd": 181,
      "language": "rust",
      "code": "use horus_core::plugin::BackendInfo;\n\nlet backend = BackendInfo {\n    // Unique ID within this plugin\n    id: \"mpu6050\".into(),\n\n    // Human-readable name\n    name: \"MPU6050 6-DOF IMU\".into(),\n\n    // Description\n    description: \"InvenSense MPU6050 via I2C bus\".into(),\n\n    // Hardware identifiers for auto-detection\n    // Format: \"bus:identifier\"\n    hardware_ids: vec![\n        \"i2c:0x68\".into(),  // Default I2C address\n        \"i2c:0x69\".into(),  // Alternative address (AD0 high)\n    ],\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:196:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 196,
      "lineEnd": 211,
      "language": "rust",
      "code": "use horus_core::plugin::ProbeResult;\n\n// Hardware detected successfully\nlet detected = ProbeResult::detected(\"mpu6050\", \"/dev/i2c-1\")\n    .with_metadata(\"address\", \"0x68\")\n    .with_message(\"MPU6050 found at 0x68\");\n\n// Detection with confidence score\nlet maybe = ProbeResult::with_confidence(\"mpu6050\", 0.7, Some(\"/dev/i2c-1\".into()))\n    .with_message(\"Device responds but ID register unclear\");\n\n// Hardware not found\nlet not_found = ProbeResult::not_detected(\"mpu6050\")\n    .with_message(\"No device at 0x68 or 0x69\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:217:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 217,
      "lineEnd": 225,
      "language": "rust",
      "code": "use horus_core::plugin::PluginHealth;\n\n// Plugin is healthy\nlet healthy = PluginHealth::healthy(\"my-plugin\");\n\n// Plugin has issues\nlet unhealthy = PluginHealth::unhealthy(\"my-plugin\", \"I2C bus not accessible\");",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:233:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 233,
      "lineEnd": 262,
      "language": "rust",
      "code": "use horus_core::plugin::{DriverPlugin, PluginManifest, ProbeResult, PluginHealth};\nuse horus_core::driver::SingleDriverConfig;\nuse horus_core::error::HorusResult;\nuse std::any::Any;\n\npub trait DriverPlugin: Send + Sync {\n    /// Get the plugin manifest\n    fn manifest(&self) -> PluginManifest;\n\n    /// Probe for hardware\n    fn probe(&self, backend_id: &str) -> Vec<ProbeResult>;\n\n    /// Create a driver instance\n    fn create(\n        &self,\n        backend_id: &str,\n        config: &SingleDriverConfig,\n    ) -> HorusResult<Box<dyn Any + Send + Sync>>;\n\n    /// Get health status\n    fn health(&self) -> PluginHealth;\n\n    /// Called when plugin loads (optional)\n    fn on_load(&self) -> HorusResult<()> { Ok(()) }\n\n    /// Called when plugin unloads (optional)\n    fn on_unload(&self) {}\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:266:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 266,
      "lineEnd": 433,
      "language": "rust",
      "code": "use horus_core::plugin::{\n    DriverPlugin, PluginManifest, BackendInfo, ProbeResult, PluginHealth\n};\nuse horus_core::driver::{DriverCategory, SingleDriverConfig, DriverStatus};\nuse horus_core::error::{HorusResult, HorusError};\nuse horus_messages::Imu;\nuse std::any::Any;\nuse std::collections::HashMap;\n\n// ============================================================\n// Step 1: Define Your Driver Struct\n// ============================================================\n\npub struct Mpu6050Driver {\n    bus: String,\n    address: u8,\n    status: DriverStatus,\n    // Add your hardware handle here\n}\n\nimpl Mpu6050Driver {\n    pub fn new(bus: &str, address: u8) -> HorusResult<Self> {\n        Ok(Self {\n            bus: bus.to_string(),\n            address,\n            status: DriverStatus::Uninitialized,\n        })\n    }\n\n    pub fn init(&mut self) -> HorusResult<()> {\n        // Initialize I2C, configure sensor registers\n        // ...\n        self.status = DriverStatus::Ready;\n        Ok(())\n    }\n\n    pub fn read(&mut self) -> HorusResult<Imu> {\n        // Read from I2C registers, convert to Imu message\n        let mut imu = Imu::new();\n        // ... populate imu data\n        Ok(imu)\n    }\n\n    pub fn status(&self) -> &DriverStatus {\n        &self.status\n    }\n}\n\n// ============================================================\n// Step 2: Define the Plugin Struct\n// ============================================================\n\npub struct Mpu6050Plugin;\n\nimpl DriverPlugin for Mpu6050Plugin {\n    fn manifest(&self) -> PluginManifest {\n        PluginManifest {\n            id: \"horus-imu-mpu6050\".into(),\n            name: \"MPU6050 IMU Driver\".into(),\n            version: env!(\"CARGO_PKG_VERSION\").into(),\n            category: DriverCategory::Sensor,\n            description: \"Driver for MPU6050 6-axis IMU\".into(),\n            author: Some(env!(\"CARGO_PKG_AUTHORS\").into()),\n            license: Some(\"MIT OR Apache-2.0\".into()),\n            repository: Some(\"https://github.com/softmata/horus\".into()),\n            backends: vec![\n                BackendInfo {\n                    id: \"mpu6050\".into(),\n                    name: \"MPU6050\".into(),\n                    description: \"MPU6050 via I2C\".into(),\n                    hardware_ids: vec![\"i2c:0x68\".into(), \"i2c:0x69\".into()],\n                },\n            ],\n            system_deps: vec![],\n            horus_version: \">=0.5.0\".into(),\n            platforms: vec![\"linux\".into()],\n            features: vec![],\n            extra: HashMap::new(),\n        }\n    }\n\n    fn probe(&self, backend_id: &str) -> Vec<ProbeResult> {\n        let mut results = Vec::new();\n\n        // Only probe if backend matches or empty (probe all)\n        if !backend_id.is_empty() && backend_id != \"mpu6050\" {\n            return vec![ProbeResult::not_detected(backend_id)];\n        }\n\n        // Scan I2C buses for MPU6050\n        for bus in [\"/dev/i2c-0\", \"/dev/i2c-1\"] {\n            for addr in [0x68u8, 0x69u8] {\n                if Self::check_device(bus, addr) {\n                    results.push(\n                        ProbeResult::detected(\"mpu6050\", bus)\n                            .with_metadata(\"address\", format!(\"0x{:02X}\", addr))\n                            .with_message(format!(\"MPU6050 found at {}\", bus))\n                    );\n                }\n            }\n        }\n\n        if results.is_empty() {\n            results.push(ProbeResult::not_detected(\"mpu6050\"));\n        }\n\n        results\n    }\n\n    fn create(\n        &self,\n        backend_id: &str,\n        config: &SingleDriverConfig,\n    ) -> HorusResult<Box<dyn Any + Send + Sync>> {\n        if backend_id != \"mpu6050\" {\n            return Err(HorusError::driver(format!(\n                \"Unknown backend: {}\", backend_id\n            )));\n        }\n\n        // Get configuration\n        let bus = config.port.clone()\n            .or_else(|| config.get_option(\"bus\"))\n            .unwrap_or_else(|| \"/dev/i2c-1\".into());\n\n        let address = config.i2c_address.unwrap_or(0x68);\n\n        // Create and initialize driver\n        let mut driver = Mpu6050Driver::new(&bus, address)?;\n        driver.init()?;\n\n        Ok(Box::new(driver))\n    }\n\n    fn health(&self) -> PluginHealth {\n        PluginHealth::healthy(\"horus-imu-mpu6050\")\n    }\n\n    fn on_load(&self) -> HorusResult<()> {\n        // Check system dependencies\n        // e.g., verify i2c-dev module is loaded\n        Ok(())\n    }\n}\n\nimpl Mpu6050Plugin {\n    fn check_device(bus: &str, address: u8) -> bool {\n        // Try to communicate with the device\n        // Return true if MPU6050 responds correctly\n        // In real code: open I2C bus, read WHO_AM_I register\n        false // Placeholder\n    }\n}\n\n// ============================================================\n// Step 3: Export Entry Point (for dynamic loading)\n// ============================================================\n\n/// Entry point for dynamic plugin loading\n///\n/// HORUS loads plugins by calling this function.\n/// The function name MUST be exactly \"horus_driver_entry\".\n#[no_mangle]\npub extern \"C\" fn horus_driver_entry() -> Box<dyn DriverPlugin> {\n    Box::new(Mpu6050Plugin)\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:443:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 443,
      "lineEnd": 473,
      "language": "rust",
      "code": "use horus_core::plugin::{DriverLoader, DriverLoaderConfig, DriverMode};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create loader in static mode\n    let config = DriverLoaderConfig {\n        mode: DriverMode::Static,\n        ..Default::default()\n    };\n    let mut loader = DriverLoader::new(config);\n\n    // Register your plugin\n    loader.register_static(Box::new(Mpu6050Plugin));\n\n    // Initialize\n    loader.initialize()?;\n\n    // List available drivers\n    println!(\"Available: {:?}\", loader.available_drivers());\n\n    // Create driver from plugin\n    let imu_config = SingleDriverConfig::i2c(\"mpu6050\", 1, 0x68);\n    let driver = loader.create_driver(\"horus-imu-mpu6050\", \"mpu6050\", &imu_config)?;\n\n    // Downcast to your driver type\n    let imu: Box<Mpu6050Driver> = driver.downcast()\n        .map_err(|_| \"Type mismatch\")?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:479:yaml",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 479,
      "lineEnd": 487,
      "language": "yaml",
      "code": "# horus.yaml\ndriver_mode: dynamic\n\nplugins:\n  search_paths:\n    - ~/.horus/drivers\n    - ./plugins",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:489:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 489,
      "lineEnd": 508,
      "language": "rust",
      "code": "use horus_core::plugin::{DriverLoader, DriverLoaderConfig, DriverMode};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let config = DriverLoaderConfig {\n        mode: DriverMode::Dynamic,\n        search_paths: vec![\"~/.horus/drivers\".into()],\n        auto_discover: true,\n        ..Default::default()\n    };\n\n    let mut loader = DriverLoader::new(config);\n    loader.initialize()?; // Scans search paths for .so files\n\n    // Plugin is auto-discovered and available\n    let driver = loader.create_driver(\"horus-imu-mpu6050\", \"mpu6050\", &config)?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:514:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 514,
      "lineEnd": 519,
      "language": "rust",
      "code": "use horus_core::plugin::AutoDetectable;\n\n// Probe hardware and create driver from first detected backend\nlet driver = loader.auto_create_driver(\"horus-imu-mpu6050\", &config)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:527:toml",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 527,
      "lineEnd": 549,
      "language": "toml",
      "code": "[package]\nname = \"horus-imu-mpu6050\"\nversion = \"1.0.0\"\nedition = \"2021\"\nauthors = [\"Your Name <you@example.com>\"]\nlicense = \"MIT OR Apache-2.0\"\ndescription = \"MPU6050 IMU driver plugin for HORUS\"\nrepository = \"https://github.com/you/horus-imu-mpu6050\"\nkeywords = [\"horus\", \"robotics\", \"imu\", \"mpu6050\"]\ncategories = [\"science::robotics\", \"hardware-support\"]\n\n[lib]\ncrate-type = [\"cdylib\", \"rlib\"]  # cdylib for dynamic loading\n\n[dependencies]\nhorus_core = \"0.5\"\nhorus_messages = \"0.5\"\nlinux-i2cdev = \"0.6\"  # Your hardware dependencies\n\n[features]\ndefault = []",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:553:bash",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 553,
      "lineEnd": 561,
      "language": "bash",
      "code": "# Build shared library for dynamic loading\ncargo build --release\n\n# Output: target/release/libhorus_imu_mpu6050.so\n\n# Install to HORUS plugin directory\ncp target/release/libhorus_imu_mpu6050.so ~/.horus/drivers/",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:571:yaml",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 571,
      "lineEnd": 590,
      "language": "yaml",
      "code": "type: driver-plugin\ncategory: sensor\nsubcategory: imu\n\nhardware:\n  - name: MPU6050\n    manufacturer: InvenSense\n    interface: i2c\n    addresses: [0x68, 0x69]\n\nplatforms:\n  - linux-x86_64\n  - linux-aarch64\n\ndependencies:\n  system:\n    - name: i2c-tools\n      package: i2c-tools  # apt package name",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:594:bash",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 594,
      "lineEnd": 600,
      "language": "bash",
      "code": "# Login to registry\nhorus registry login\n\n# Publish\nhorus publish",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:608:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 608,
      "lineEnd": 640,
      "language": "rust",
      "code": "use horus_core::error::{HorusError, HorusResult};\nuse horus_core::plugin::PluginError;\n\n// Creating errors\nlet err = HorusError::driver(\"I2C bus not accessible\");\nlet err = HorusError::config(\"Invalid address format\");\n\n// Plugin-specific errors\nlet err = PluginError::NotFound(\"/path/to/plugin.so\".into());\nlet err = PluginError::BackendNotFound(\"unknown-backend\".into());\nlet err = PluginError::VersionMismatch {\n    required: \">=0.5.0\".into(),\n    found: \"0.4.0\".into(),\n};\n\n// In your create() implementation\nfn create(&self, backend_id: &str, config: &SingleDriverConfig)\n    -> HorusResult<Box<dyn Any + Send + Sync>>\n{\n    if backend_id != \"mpu6050\" {\n        return Err(HorusError::driver(format!(\n            \"Unknown backend '{}'. Available: mpu6050\", backend_id\n        )));\n    }\n\n    let address = config.i2c_address.ok_or_else(|| {\n        HorusError::config(\"i2c_address is required for MPU6050\")\n    })?;\n\n    // ...\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:648:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 648,
      "lineEnd": 667,
      "language": "rust",
      "code": "use horus_core::plugin::HotReloadable;\n\nimpl HotReloadable for Mpu6050Plugin {\n    fn can_hot_reload(&self) -> bool {\n        // Return false if active instances would be invalidated\n        true\n    }\n\n    fn prepare_hot_reload(&self) -> HorusResult<()> {\n        // Save state before unloading\n        Ok(())\n    }\n\n    fn complete_hot_reload(&self) -> HorusResult<()> {\n        // Restore state after reloading\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/plugin-development:673:rust",
      "file": "content/docs/rust/library/drivers/plugin-development.mdx",
      "lineStart": 673,
      "lineEnd": 715,
      "language": "rust",
      "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_manifest() {\n        let plugin = Mpu6050Plugin;\n        let manifest = plugin.manifest();\n\n        assert_eq!(manifest.id, \"horus-imu-mpu6050\");\n        assert!(manifest.supports_current_platform());\n        assert!(manifest.is_compatible_with(\"0.5.0\"));\n    }\n\n    #[test]\n    fn test_probe_not_found() {\n        let plugin = Mpu6050Plugin;\n        let results = plugin.probe(\"mpu6050\");\n\n        // Without hardware, should report not detected\n        assert!(!results.is_empty());\n    }\n\n    #[test]\n    fn test_health() {\n        let plugin = Mpu6050Plugin;\n        let health = plugin.health();\n\n        assert!(health.healthy);\n    }\n\n    #[test]\n    fn test_create_with_config() {\n        let plugin = Mpu6050Plugin;\n        let config = SingleDriverConfig::i2c(\"mpu6050\", 1, 0x68);\n\n        // This will fail without hardware, but tests the path\n        let result = plugin.create(\"mpu6050\", &config);\n        // Assert based on your implementation\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:22:text",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 22,
      "lineEnd": 29,
      "language": "text",
      "code": "Development Cycle:\n┌─────────────────────────────────────────────────────────┐\n│  Write Code → Sim Tests → Hardware Tests → Deploy       │\n│      ↑                                      │           │\n│      └──────────── Fix & Iterate ───────────┘           │\n└─────────────────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/testing:39:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 39,
      "lineEnd": 65,
      "language": "rust",
      "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n    use horus::prelude::*;\n\n    #[test]\n    fn test_driver_lifecycle() {\n        let mut driver = SimulationImuDriver::new();\n\n        // 1. Initial state\n        assert_eq!(driver.status(), DriverStatus::Uninitialized);\n\n        // 2. Initialization\n        driver.init().unwrap();\n        assert_eq!(driver.status(), DriverStatus::Ready);\n\n        // 3. Reading (transitions to Running)\n        let data = driver.read().unwrap();\n        assert_eq!(driver.status(), DriverStatus::Running);\n\n        // 4. Shutdown\n        driver.shutdown().unwrap();\n        assert_eq!(driver.status(), DriverStatus::Shutdown);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:71:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 71,
      "lineEnd": 90,
      "language": "rust",
      "code": "#[test]\nfn test_imu_data_validity() {\n    let mut driver = SimulationImuDriver::new();\n    driver.init().unwrap();\n\n    let data = driver.read().unwrap();\n\n    // Check gravity is approximately correct (Z-axis ~9.81 m/s²)\n    assert!((data.linear_acceleration[2] - 9.81).abs() < 0.5);\n\n    // Check angular velocity is reasonable (not spinning wildly)\n    for &omega in &data.angular_velocity {\n        assert!(omega.abs() < 10.0); // rad/s\n    }\n\n    // Check timestamp is valid\n    assert!(data.timestamp > 0);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:96:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 96,
      "lineEnd": 122,
      "language": "rust",
      "code": "#[test]\nfn test_driver_configuration() {\n    // Custom config\n    let config = SimulationImuConfig {\n        sample_rate: 200.0,\n        add_noise: false,\n        accel_noise_std: 0.0,\n        gyro_noise_std: 0.0,\n    };\n\n    let driver = SimulationImuDriver::with_config(config);\n    assert_eq!(driver.sample_rate(), Some(200.0));\n}\n\n#[test]\nfn test_yaml_config_loading() {\n    let yaml = r#\"\n        backend: simulation\n        sample_rate: 100\n        add_noise: true\n    \"#;\n\n    let config: SingleDriverConfig = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(config.backend, \"simulation\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:143:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 143,
      "lineEnd": 176,
      "language": "rust",
      "code": "use horus::prelude::*;\n\n#[test]\nfn test_with_realistic_noise() {\n    let config = SimulationImuConfig {\n        sample_rate: 100.0,\n        add_noise: true,\n        accel_noise_std: 0.05,  // 0.05 m/s² noise\n        gyro_noise_std: 0.01,   // 0.01 rad/s noise\n    };\n\n    let mut driver = SimulationImuDriver::with_config(config);\n    driver.init().unwrap();\n\n    // Read multiple samples\n    let samples: Vec<_> = (0..100)\n        .map(|_| driver.read().unwrap())\n        .collect();\n\n    // Check variance exists (noise is present)\n    let z_values: Vec<f64> = samples.iter()\n        .map(|s| s.linear_acceleration[2])\n        .collect();\n\n    let mean = z_values.iter().sum::<f64>() / z_values.len() as f64;\n    let variance = z_values.iter()\n        .map(|x| (x - mean).powi(2))\n        .sum::<f64>() / z_values.len() as f64;\n\n    // Should have some variance from noise\n    assert!(variance > 0.0001);\n}",
      "verifiable": false,
      "flags": [
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:182:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 182,
      "lineEnd": 215,
      "language": "rust",
      "code": "#[test]\nfn test_joystick_input_simulation() {\n    let mut joystick = SimulationJoystickDriver::new();\n    joystick.init().unwrap();\n\n    // Simulate joystick movement\n    joystick.simulate_axis(0, 0.75);  // Left stick X\n    joystick.simulate_axis(1, -0.5);  // Left stick Y\n    joystick.simulate_button_press(0); // A button\n\n    let input = joystick.read().unwrap();\n\n    assert!((input.left_x - 0.75).abs() < 0.01);\n    assert!((input.left_y - (-0.5)).abs() < 0.01);\n    assert!(input.buttons[0]);\n}\n\n#[test]\nfn test_keyboard_input_simulation() {\n    let mut keyboard = SimulationKeyboardDriver::new();\n    keyboard.init().unwrap();\n\n    // Simulate WASD input\n    keyboard.simulate_key_press(KEY_W);\n    keyboard.simulate_key_press(KEY_SPACE);\n\n    let input = keyboard.read().unwrap();\n\n    assert!(input.is_key_pressed(KEY_W));\n    assert!(input.is_key_pressed(KEY_SPACE));\n    assert!(!input.is_key_pressed(KEY_S));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:223:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 223,
      "lineEnd": 261,
      "language": "rust",
      "code": "#[cfg(test)]\nmod integration_tests {\n    use horus::prelude::*;\n    use std::sync::{Arc, Mutex};\n\n    #[test]\n    fn test_imu_node_publishes_data() {\n        // Create scheduler\n        let mut scheduler = Scheduler::new();\n\n        // Create IMU node with simulation backend\n        let imu_node = ImuNode::builder()\n            .with_topic(\"test.imu\")\n            .with_backend(ImuBackend::Simulation)\n            .build()\n            .unwrap();\n\n        scheduler.add(Box::new(imu_node), 100, Some(true));\n\n        // Create subscriber to capture data\n        let received = Arc::new(Mutex::new(Vec::new()));\n        let received_clone = received.clone();\n\n        let subscriber = TestSubscriberNode::new(\"test.imu\", move |data: Imu| {\n            received_clone.lock().unwrap().push(data);\n        });\n\n        scheduler.add(Box::new(subscriber), 100, None);\n\n        // Run for a short time\n        scheduler.run_for(Duration::from_millis(100)).unwrap();\n\n        // Verify data was received\n        let data = received.lock().unwrap();\n        assert!(!data.is_empty(), \"Should have received IMU data\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:265:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 265,
      "lineEnd": 292,
      "language": "rust",
      "code": "#[test]\nfn test_sensor_fusion_pipeline() {\n    let mut scheduler = Scheduler::new();\n\n    // Create sensor nodes\n    let imu = ImuNode::new().unwrap();\n    let gps = GpsNode::new().unwrap();\n\n    // Create fusion node that combines both\n    let localization = LocalizationNode::builder()\n        .with_imu_topic(\"imu\")\n        .with_gps_topic(\"gps\")\n        .build()\n        .unwrap();\n\n    scheduler.add(Box::new(imu), 100, Some(true));\n    scheduler.add(Box::new(gps), 10, Some(true));\n    scheduler.add(Box::new(localization), 50, None);\n\n    // Run and verify pose output\n    scheduler.run_for(Duration::from_millis(200)).unwrap();\n\n    // Subscribe to check pose output\n    let pose_hub = Hub::<Pose>::new(\"pose\").unwrap();\n    // Verify pose was computed\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:302:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 302,
      "lineEnd": 322,
      "language": "rust",
      "code": "#[cfg(all(test, feature = \"mpu6050-imu\"))]\nmod hardware_tests {\n    use super::*;\n\n    #[test]\n    #[ignore = \"requires MPU6050 hardware\"]\n    fn test_mpu6050_connection() {\n        let mut driver = Mpu6050Driver::new(\"/dev/i2c-1\", 0x68)\n            .expect(\"Failed to create driver - is hardware connected?\");\n\n        driver.init().expect(\"Failed to initialize MPU6050\");\n\n        let data = driver.read().expect(\"Failed to read from MPU6050\");\n\n        // Verify reasonable data\n        assert!(data.linear_acceleration[2] > 8.0); // Gravity present\n        assert!(data.linear_acceleration[2] < 12.0);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:326:bash",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 326,
      "lineEnd": 332,
      "language": "bash",
      "code": "# Run all tests including hardware\ncargo test --features mpu6050-imu -- --include-ignored\n\n# Run only hardware tests\ncargo test --features mpu6050-imu hardware_tests -- --include-ignored",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/testing:336:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 336,
      "lineEnd": 364,
      "language": "rust",
      "code": "#[cfg(all(test, feature = \"i2c-hardware\"))]\nmod hw_tests {\n    use super::*;\n\n    /// Helper to skip test if hardware not available\n    fn require_i2c() -> Result<(), String> {\n        if !std::path::Path::new(\"/dev/i2c-1\").exists() {\n            return Err(\"I2C bus not available\".into());\n        }\n        Ok(())\n    }\n\n    #[test]\n    fn test_i2c_scan() {\n        if require_i2c().is_err() {\n            println!(\"Skipping: I2C not available\");\n            return;\n        }\n\n        let mut i2c = LinuxI2cDriver::new(\"/dev/i2c-1\").unwrap();\n        i2c.init().unwrap();\n\n        // Scan for devices\n        let devices = i2c.scan().unwrap();\n        println!(\"Found {} I2C devices\", devices.len());\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:372:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 372,
      "lineEnd": 429,
      "language": "rust",
      "code": "/// Mock driver that records all calls for verification\npub struct MockMotorDriver {\n    pub calls: Vec<MockCall>,\n    pub speed: f64,\n}\n\n#[derive(Debug, Clone)]\npub enum MockCall {\n    Init,\n    SetSpeed(f64),\n    Stop,\n    Shutdown,\n}\n\nimpl MockMotorDriver {\n    pub fn new() -> Self {\n        Self {\n            calls: Vec::new(),\n            speed: 0.0,\n        }\n    }\n\n    pub fn init(&mut self) -> HorusResult<()> {\n        self.calls.push(MockCall::Init);\n        Ok(())\n    }\n\n    pub fn set_speed(&mut self, speed: f64) -> HorusResult<()> {\n        self.calls.push(MockCall::SetSpeed(speed));\n        self.speed = speed;\n        Ok(())\n    }\n\n    pub fn stop(&mut self) -> HorusResult<()> {\n        self.calls.push(MockCall::Stop);\n        self.speed = 0.0;\n        Ok(())\n    }\n}\n\n#[test]\nfn test_controller_uses_motor_correctly() {\n    let mut motor = MockMotorDriver::new();\n\n    // Run your control logic\n    motor.init().unwrap();\n    motor.set_speed(0.5).unwrap();\n    motor.set_speed(0.75).unwrap();\n    motor.stop().unwrap();\n\n    // Verify call sequence\n    assert!(matches!(motor.calls[0], MockCall::Init));\n    assert!(matches!(motor.calls[1], MockCall::SetSpeed(s) if (s - 0.5).abs() < 0.01));\n    assert!(matches!(motor.calls[2], MockCall::SetSpeed(s) if (s - 0.75).abs() < 0.01));\n    assert!(matches!(motor.calls[3], MockCall::Stop));\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:433:rust",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 433,
      "lineEnd": 459,
      "language": "rust",
      "code": "/// Robot controller that accepts any motor implementation\npub struct RobotController<M: MotorControl> {\n    motor: M,\n}\n\npub trait MotorControl {\n    fn set_speed(&mut self, speed: f64) -> HorusResult<()>;\n    fn stop(&mut self) -> HorusResult<()>;\n}\n\nimpl<M: MotorControl> RobotController<M> {\n    pub fn new(motor: M) -> Self {\n        Self { motor }\n    }\n\n    pub fn move_forward(&mut self, speed: f64) -> HorusResult<()> {\n        self.motor.set_speed(speed.clamp(-1.0, 1.0))\n    }\n}\n\n// In production:\n// let controller = RobotController::new(GpioMotorDriver::new(...)?);\n\n// In tests:\n// let controller = RobotController::new(MockMotorDriver::new());",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/testing:467:text",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 467,
      "lineEnd": 478,
      "language": "text",
      "code": "my_driver/\n├── src/\n│   ├── lib.rs\n│   ├── driver.rs\n│   └── simulation.rs\n├── tests/\n│   ├── unit_tests.rs       # Fast, no hardware\n│   ├── integration_tests.rs # Node/scheduler tests\n│   └── hardware_tests.rs    # Requires hardware (ignored by default)\n└── Cargo.toml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/testing:482:bash",
      "file": "content/docs/rust/library/drivers/testing.mdx",
      "lineStart": 482,
      "lineEnd": 500,
      "language": "bash",
      "code": "# Run all unit tests (simulation only)\ncargo test\n\n# Run with verbose output\ncargo test -- --nocapture\n\n# Run specific test\ncargo test test_driver_lifecycle\n\n# Run integration tests\ncargo test --test integration_tests\n\n# Run hardware tests (when hardware connected)\ncargo test --features full-hardware -- --include-ignored\n\n# Run tests with coverage\ncargo tarpaulin --out Html",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:17:text",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 17,
      "lineEnd": 25,
      "language": "text",
      "code": "□ 1. Is the device physically connected?\n□ 2. Does the device appear in the OS? (lsusb, ls /dev, i2cdetect)\n□ 3. Do you have permissions to access the device?\n□ 4. Is the correct backend specified in config?\n□ 5. Are hardware-specific features enabled in Cargo.toml?\n□ 6. Is the driver initialized before use?\n□ 7. Are there resource conflicts? (another process using the device)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:37:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 37,
      "lineEnd": 49,
      "language": "bash",
      "code": "# Check if device is connected (USB)\nlsusb\n\n# Check for serial devices\nls -la /dev/ttyUSB* /dev/ttyACM*\n\n# Check for I2C devices\nls -la /dev/i2c-*\n\n# Check kernel messages for device detection\ndmesg | tail -20",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:75:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 75,
      "lineEnd": 85,
      "language": "bash",
      "code": "# List I2C buses\nls /dev/i2c-*\n\n# Scan I2C bus 1 (common on Raspberry Pi)\nsudo i2cdetect -y 1\n\n# Expected output for MPU6050 at 0x68:\n#      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n# 60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:113:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 113,
      "lineEnd": 125,
      "language": "bash",
      "code": "# Watch for device connection\ndmesg -w\n# Then plug in the device\n\n# Check device attributes\nudevadm info -a /dev/ttyUSB0\n\n# Test serial communication\nscreen /dev/ttyUSB0 115200\n# Or\nminicom -D /dev/ttyUSB0 -b 115200",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:137:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 137,
      "lineEnd": 147,
      "language": "bash",
      "code": "# Option 1: Add user to dialout group (serial devices)\nsudo usermod -a -G dialout $USER\n# Log out and back in\n\n# Option 2: Add user to i2c group (I2C devices)\nsudo usermod -a -G i2c $USER\n\n# Option 3: Create udev rule for persistent permissions\nsudo nano /etc/udev/rules.d/99-horus.rules",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:151:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 151,
      "lineEnd": 163,
      "language": "bash",
      "code": "# /etc/udev/rules.d/99-horus.rules\n\n# USB serial devices\nSUBSYSTEM==\"tty\", ATTRS{idVendor}==\"10c4\", ATTRS{idProduct}==\"ea60\", \\\n    SYMLINK+=\"rplidar\", MODE=\"0666\"\n\n# I2C bus\nSUBSYSTEM==\"i2c-dev\", MODE=\"0666\"\n\n# GPIO (Raspberry Pi)\nSUBSYSTEM==\"gpio\", MODE=\"0666\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:166:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 166,
      "lineEnd": 169,
      "language": "bash",
      "code": "sudo udevadm control --reload-rules\nsudo udevadm trigger",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:173:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 173,
      "lineEnd": 181,
      "language": "bash",
      "code": "# Check device permissions\nls -la /dev/ttyUSB0\n# crw-rw---- 1 root dialout 188, 0 ... /dev/ttyUSB0\n\n# Check group membership\ngroups $USER\n# Should include: dialout, i2c, gpio as needed",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:193:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 193,
      "lineEnd": 202,
      "language": "rust",
      "code": "// WRONG: Using driver without init\nlet mut driver = SimulationImuDriver::new();\nlet data = driver.read()?;  // Error!\n\n// CORRECT: Initialize first\nlet mut driver = SimulationImuDriver::new();\ndriver.init()?;  // Initialize\nlet data = driver.read()?;  // Now works",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:210:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 210,
      "lineEnd": 228,
      "language": "rust",
      "code": "use std::time::{Duration, Instant};\n\nfn init_with_timeout<D: Driver>(driver: &mut D, timeout: Duration) -> HorusResult<()> {\n    let start = Instant::now();\n\n    // Try to init\n    let result = driver.init();\n\n    let elapsed = start.elapsed();\n    println!(\"Init took: {:?}\", elapsed);\n\n    if elapsed > timeout {\n        warn!(\"Init was slow: {:?}\", elapsed);\n    }\n\n    result\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:280:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 280,
      "lineEnd": 303,
      "language": "rust",
      "code": "fn diagnose_i2c_issues(bus: &str, address: u8) {\n    // Test multiple reads\n    let mut success = 0;\n    let mut failures = 0;\n\n    for i in 0..100 {\n        match read_i2c_register(bus, address, 0x00) {\n            Ok(_) => success += 1,\n            Err(e) => {\n                failures += 1;\n                eprintln!(\"Read {} failed: {}\", i, e);\n            }\n        }\n        std::thread::sleep(Duration::from_millis(10));\n    }\n\n    println!(\"Success rate: {}/100\", success);\n    if failures > 0 {\n        println!(\"PROBLEM: {} failures detected\", failures);\n        println!(\"Check: wiring, pull-ups, bus speed, interference\");\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:321:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 321,
      "lineEnd": 336,
      "language": "rust",
      "code": "fn profile_driver_performance<D: Driver>(driver: &mut D, iterations: usize) {\n    let start = Instant::now();\n\n    for _ in 0..iterations {\n        let _ = driver.read();\n    }\n\n    let elapsed = start.elapsed();\n    let per_read = elapsed / iterations as u32;\n\n    println!(\"Total time: {:?}\", elapsed);\n    println!(\"Time per read: {:?}\", per_read);\n    println!(\"Reads per second: {:.1}\", iterations as f64 / elapsed.as_secs_f64());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:346:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 346,
      "lineEnd": 367,
      "language": "rust",
      "code": "// BAD: Busy polling\nloop {\n    if driver.has_data() {\n        let data = driver.read()?;\n        break;\n    }\n    // Spins at 100% CPU!\n}\n\n// GOOD: Sleep between polls\nloop {\n    if driver.has_data() {\n        let data = driver.read()?;\n        break;\n    }\n    std::thread::sleep(Duration::from_millis(1));\n}\n\n// BETTER: Use blocking read with timeout\nlet data = driver.read_with_timeout(Duration::from_millis(100))?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:375:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 375,
      "lineEnd": 389,
      "language": "rust",
      "code": "fn measure_actual_rate<D: Driver>(driver: &mut D, duration: Duration) {\n    let start = Instant::now();\n    let mut count = 0;\n\n    while start.elapsed() < duration {\n        if driver.read().is_ok() {\n            count += 1;\n        }\n    }\n\n    let actual_rate = count as f64 / duration.as_secs_f64();\n    println!(\"Actual data rate: {:.1} Hz\", actual_rate);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:403:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 403,
      "lineEnd": 412,
      "language": "bash",
      "code": "# Set log level\nexport RUST_LOG=horus=debug\n\n# Or per-module logging\nexport RUST_LOG=horus::driver=trace,horus::scheduler=debug\n\n# Run your application\ncargo run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:416:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 416,
      "lineEnd": 433,
      "language": "rust",
      "code": "use tracing::{debug, trace, instrument};\n\nimpl MyDriver {\n    #[instrument(skip(self))]\n    pub fn read(&mut self) -> HorusResult<SensorData> {\n        trace!(\"Starting read operation\");\n\n        let raw = self.read_raw()?;\n        debug!(\"Raw data: {:?}\", raw);\n\n        let parsed = self.parse_data(&raw)?;\n        debug!(\"Parsed data: {:?}\", parsed);\n\n        Ok(parsed)\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:437:rust",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 437,
      "lineEnd": 457,
      "language": "rust",
      "code": "impl MyDriver {\n    pub fn debug_info(&self) -> String {\n        format!(\n            \"MyDriver Status:\\n\\\n             - Status: {:?}\\n\\\n             - Backend: {}\\n\\\n             - Reads: {}\\n\\\n             - Errors: {}\\n\\\n             - Last error: {:?}\\n\\\n             - Uptime: {:?}\",\n            self.status,\n            self.backend,\n            self.read_count,\n            self.error_count,\n            self.last_error,\n            self.start_time.elapsed()\n        )\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/troubleshooting:479:bash",
      "file": "content/docs/rust/library/drivers/troubleshooting.mdx",
      "lineStart": 479,
      "lineEnd": 513,
      "language": "bash",
      "code": "#!/bin/bash\n# horus-diagnose.sh - Diagnose common driver issues\n\necho \"=== HORUS Driver Diagnostic ===\"\necho\n\necho \"1. Checking user groups...\"\ngroups $USER\n\necho\necho \"2. Checking serial devices...\"\nls -la /dev/ttyUSB* /dev/ttyACM* 2>/dev/null || echo \"No serial devices found\"\n\necho\necho \"3. Checking I2C buses...\"\nls -la /dev/i2c-* 2>/dev/null || echo \"No I2C buses found\"\n\nif [ -e /dev/i2c-1 ]; then\n    echo\n    echo \"4. Scanning I2C bus 1...\"\n    i2cdetect -y 1 2>/dev/null || echo \"i2cdetect failed (try with sudo)\"\nfi\n\necho\necho \"5. Checking recent USB events...\"\ndmesg | grep -i usb | tail -5\n\necho\necho \"6. Checking for device conflicts...\"\nfuser /dev/ttyUSB* /dev/i2c-* 2>/dev/null\n\necho\necho \"=== Diagnostic complete ===\"",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:15:text",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 15,
      "lineEnd": 27,
      "language": "text",
      "code": "┌────────────────────────────────────────────────────────────────┐\n│                    Development Lifecycle                        │\n├────────────────────────────────────────────────────────────────┤\n│  1. DEVELOP      2. TEST         3. VALIDATE     4. DEPLOY     │\n│  ┌──────────┐    ┌──────────┐    ┌──────────┐   ┌──────────┐   │\n│  │Simulation│ -> │Simulation│ -> │ Hardware │ ->│Production│   │\n│  │  Driver  │    │  Tests   │    │   Tests  │   │  Deploy  │   │\n│  └──────────┘    └──────────┘    └──────────┘   └──────────┘   │\n│      ↑                                               │          │\n│      └──────────── Iterate & Fix ────────────────────┘          │\n└────────────────────────────────────────────────────────────────┘",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:45:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 45,
      "lineEnd": 58,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> HorusResult<()> {\n    // Simulation is the default - no config needed!\n    let mut imu = SimulationImuDriver::new();\n    imu.init()?;\n\n    let data = imu.read()?;\n    println!(\"IMU reading: {:?}\", data);\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:64:text",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 64,
      "lineEnd": 73,
      "language": "text",
      "code": "my_robot/\n├── config/\n│   ├── drivers.yaml           # Default (simulation)\n│   ├── drivers.hardware.yaml  # Hardware config\n│   └── drivers.dev.yaml       # Development overrides\n├── src/\n│   └── main.rs\n└── Cargo.toml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:76:yaml",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 76,
      "lineEnd": 94,
      "language": "yaml",
      "code": "drivers:\n  imu:\n    backend: simulation\n    fps: 100\n    add_noise: true\n    accel_noise_std: 0.02\n\n  lidar:\n    backend: simulation\n    scan_frequency: 10\n    num_points: 360\n\n  motor_left:\n    backend: simulation\n\n  motor_right:\n    backend: simulation",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:97:yaml",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 97,
      "lineEnd": 119,
      "language": "yaml",
      "code": "drivers:\n  imu:\n    backend: mpu6050\n    i2c_bus: 1\n    i2c_address: 0x68\n    fps: 100\n\n  lidar:\n    backend: rplidar\n    port: /dev/ttyUSB0\n    baud_rate: 115200\n\n  motor_left:\n    backend: gpio_pwm\n    pin: 18\n    frequency: 1000\n\n  motor_right:\n    backend: gpio_pwm\n    pin: 19\n    frequency: 1000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:123:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 123,
      "lineEnd": 147,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse std::env;\n\nfn load_config() -> HorusResult<DriversConfig> {\n    // Check for environment-specific config\n    let config_path = match env::var(\"HORUS_ENV\") {\n        Ok(env) if env == \"hardware\" => \"config/drivers.hardware.yaml\",\n        Ok(env) if env == \"dev\" => \"config/drivers.dev.yaml\",\n        _ => \"config/drivers.yaml\", // Default to simulation\n    };\n\n    DriversConfig::from_file(config_path)\n}\n\nfn main() -> HorusResult<()> {\n    let config = load_config()?;\n\n    // Driver selection is now transparent!\n    let imu_config = config.get_driver_or_default(\"imu\");\n    println!(\"Using IMU backend: {}\", imu_config.backend);\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:153:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 153,
      "lineEnd": 186,
      "language": "rust",
      "code": "pub struct RobotController {\n    state: RobotState,\n}\n\nimpl RobotController {\n    pub fn new() -> Self {\n        Self { state: RobotState::default() }\n    }\n\n    /// Update robot state from IMU data\n    /// Works identically with simulation or hardware\n    pub fn update_from_imu(&mut self, imu: &Imu) {\n        // Algorithm doesn't know/care if data is simulated\n        self.state.orientation = Quaternion::from_angular_velocity(\n            imu.angular_velocity,\n            self.state.dt,\n        );\n\n        self.state.linear_velocity += Vector3::new(\n            imu.linear_acceleration[0],\n            imu.linear_acceleration[1],\n            imu.linear_acceleration[2],\n        ) * self.state.dt;\n    }\n\n    /// Compute motor commands\n    pub fn compute_motor_command(&self, target: &Pose) -> MotorCommand {\n        // PID control, path planning, etc.\n        // All developed and tested with simulation\n        todo!()\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:194:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 194,
      "lineEnd": 217,
      "language": "rust",
      "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_controller_integrates_imu() {\n        let mut controller = RobotController::new();\n\n        // Use simulation driver in tests\n        let mut imu = SimulationImuDriver::new();\n        imu.init().unwrap();\n\n        // Simulate movement\n        for _ in 0..100 {\n            let data = imu.read().unwrap();\n            controller.update_from_imu(&data);\n        }\n\n        // Verify expected behavior\n        assert!(controller.state.orientation.norm() > 0.99);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:221:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 221,
      "lineEnd": 241,
      "language": "rust",
      "code": "#[test]\nfn test_full_robot_pipeline() {\n    let mut scheduler = Scheduler::new();\n\n    // All nodes use simulation by default\n    let imu_node = ImuNode::new().unwrap();\n    let controller_node = ControllerNode::new();\n    let motor_node = MotorNode::new().unwrap();\n\n    scheduler.add(Box::new(imu_node), 100, Some(true));\n    scheduler.add(Box::new(controller_node), 100, None);\n    scheduler.add(Box::new(motor_node), 100, None);\n\n    // Run for a simulated duration\n    scheduler.run_for(Duration::from_secs(5)).unwrap();\n\n    // Verify behavior\n    // ...\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial",
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:247:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 247,
      "lineEnd": 271,
      "language": "rust",
      "code": "#[test]\nfn test_controller_handles_noisy_data() {\n    let config = SimulationImuConfig {\n        add_noise: true,\n        accel_noise_std: 0.1,  // Higher noise\n        gyro_noise_std: 0.05,\n        ..Default::default()\n    };\n\n    let mut imu = SimulationImuDriver::with_config(config);\n    imu.init().unwrap();\n\n    let mut controller = RobotController::new();\n\n    // Run with noisy data\n    for _ in 0..1000 {\n        let data = imu.read().unwrap();\n        controller.update_from_imu(&data);\n    }\n\n    // Controller should still be stable\n    assert!(controller.is_stable());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:281:toml",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 281,
      "lineEnd": 292,
      "language": "toml",
      "code": "[features]\ndefault = []  # Simulation only by default\n\n# Individual hardware backends\nmpu6050-imu = [\"horus/mpu6050-imu\"]\nrplidar = [\"horus/rplidar\"]\ngpio = [\"horus/gpio\"]\n\n# All hardware\nfull-hardware = [\"mpu6050-imu\", \"rplidar\", \"gpio\"]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:296:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 296,
      "lineEnd": 331,
      "language": "rust",
      "code": "#[cfg(test)]\nmod hardware_tests {\n    use super::*;\n\n    #[test]\n    #[ignore = \"requires hardware\"]\n    #[cfg(feature = \"mpu6050-imu\")]\n    fn test_mpu6050_initialization() {\n        let mut driver = Mpu6050Driver::new(\"/dev/i2c-1\", 0x68)\n            .expect(\"Failed to create driver - is MPU6050 connected?\");\n\n        driver.init().expect(\"Failed to initialize\");\n\n        let data = driver.read().expect(\"Failed to read\");\n\n        // Hardware-specific assertions\n        assert!((data.linear_acceleration[2] - 9.81).abs() < 0.5);\n    }\n\n    #[test]\n    #[ignore = \"requires hardware\"]\n    #[cfg(feature = \"rplidar\")]\n    fn test_rplidar_scan() {\n        let mut driver = RplidarDriver::new(\"/dev/ttyUSB0\", 115200)\n            .expect(\"Failed to create driver - is RPLidar connected?\");\n\n        driver.init().expect(\"Failed to initialize\");\n\n        let scan = driver.read().expect(\"Failed to read scan\");\n\n        // Should have many scan points\n        assert!(scan.ranges.len() > 100);\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:335:bash",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 335,
      "lineEnd": 344,
      "language": "bash",
      "code": "# On development machine (simulation only)\ncargo test\n\n# On robot with hardware connected\nHORUS_ENV=hardware cargo test --features full-hardware -- --include-ignored\n\n# Run specific hardware test\ncargo test --features mpu6050-imu test_mpu6050_initialization -- --include-ignored",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:365:yaml",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 365,
      "lineEnd": 392,
      "language": "yaml",
      "code": "drivers:\n  imu:\n    backend: mpu6050\n    i2c_bus: 1\n    i2c_address: 0x68\n    fps: 100\n    # Production-specific settings\n    calibration_file: /etc/horus/imu_calibration.yaml\n\n  lidar:\n    backend: rplidar\n    port: /dev/rplidar  # Use udev symlink\n    baud_rate: 115200\n    scan_mode: express\n\n  motor_left:\n    backend: gpio_pwm\n    pin: 18\n    frequency: 1000\n    max_duty: 0.8  # Safety limit\n\n  motor_right:\n    backend: gpio_pwm\n    pin: 19\n    frequency: 1000\n    max_duty: 0.8",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:396:bash",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 396,
      "lineEnd": 417,
      "language": "bash",
      "code": "#!/bin/bash\n# deploy.sh\n\nset -e\n\nROBOT_HOST=\"${ROBOT_HOST:-robot.local}\"\nDEPLOY_DIR=\"/opt/horus/my_robot\"\n\necho \"Building for ARM...\"\ncross build --release --target aarch64-unknown-linux-gnu --features full-hardware\n\necho \"Deploying to $ROBOT_HOST...\"\nssh $ROBOT_HOST \"mkdir -p $DEPLOY_DIR/config\"\nscp target/aarch64-unknown-linux-gnu/release/my_robot $ROBOT_HOST:$DEPLOY_DIR/\nscp config/drivers.production.yaml $ROBOT_HOST:$DEPLOY_DIR/config/drivers.yaml\n\necho \"Restarting service...\"\nssh $ROBOT_HOST \"sudo systemctl restart my-robot\"\n\necho \"Deployment complete!\"",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:421:ini",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 421,
      "lineEnd": 439,
      "language": "ini",
      "code": "# /etc/systemd/system/my-robot.service\n[Unit]\nDescription=My Robot Controller\nAfter=network.target\n\n[Service]\nType=simple\nUser=robot\nWorkingDirectory=/opt/horus/my_robot\nEnvironment=\"HORUS_ENV=production\"\nEnvironment=\"RUST_LOG=info\"\nExecStart=/opt/horus/my_robot/my_robot\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:445:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 445,
      "lineEnd": 477,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn create_imu_driver(config: &SingleDriverConfig) -> HorusResult<Box<dyn ImuDriver>> {\n    match config.backend.as_str() {\n        \"simulation\" => Ok(Box::new(SimulationImuDriver::new())),\n\n        #[cfg(feature = \"mpu6050-imu\")]\n        \"mpu6050\" => {\n            let bus = config.i2c_bus.unwrap_or(1);\n            let addr = config.i2c_address.unwrap_or(0x68);\n            Ok(Box::new(Mpu6050Driver::new(\n                format!(\"/dev/i2c-{}\", bus),\n                addr,\n            )?))\n        }\n\n        #[cfg(feature = \"bno055-imu\")]\n        \"bno055\" => {\n            let bus = config.i2c_bus.unwrap_or(1);\n            let addr = config.i2c_address.unwrap_or(0x28);\n            Ok(Box::new(Bno055Driver::new(\n                format!(\"/dev/i2c-{}\", bus),\n                addr,\n            )?))\n        }\n\n        backend => Err(HorusError::driver(\n            format!(\"Unknown IMU backend: {}\", backend)\n        )),\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:498:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 498,
      "lineEnd": 505,
      "language": "rust",
      "code": "// BAD: Hardcoded backend\nlet imu = Mpu6050Driver::new(\"/dev/i2c-1\", 0x68)?;\n\n// GOOD: Config-driven\nlet config = DriversConfig::find_and_load()?;\nlet imu = create_driver_from_config(&config.get_driver(\"imu\")?)?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:509:bash",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 509,
      "lineEnd": 513,
      "language": "bash",
      "code": "# /etc/udev/rules.d/99-horus.rules\nSUBSYSTEM==\"tty\", ATTRS{idVendor}==\"10c4\", ATTRS{idProduct}==\"ea60\", SYMLINK+=\"rplidar\"\nSUBSYSTEM==\"video4linux\", ATTRS{idVendor}==\"1234\", SYMLINK+=\"robot_camera\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:516:yaml",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 516,
      "lineEnd": 519,
      "language": "yaml",
      "code": "lidar:\n  port: /dev/rplidar  # Stable name!",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:523:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 523,
      "lineEnd": 537,
      "language": "rust",
      "code": "// Try hardware, fall back to simulation\nfn create_imu_with_fallback(config: &SingleDriverConfig) -> Box<dyn ImuDriver> {\n    match create_hardware_imu(config) {\n        Ok(driver) => {\n            info!(\"Using hardware IMU: {}\", config.backend);\n            driver\n        }\n        Err(e) => {\n            warn!(\"Hardware IMU unavailable: {}. Using simulation.\", e);\n            Box::new(SimulationImuDriver::new())\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/rust/library/drivers/workflow:541:rust",
      "file": "content/docs/rust/library/drivers/workflow.mdx",
      "lineStart": 541,
      "lineEnd": 555,
      "language": "rust",
      "code": "fn main() -> HorusResult<()> {\n    let config = DriversConfig::find_and_load()?;\n\n    for (name, driver_config) in &config.drivers {\n        info!(\n            \"Driver '{}': backend={}, enabled={}\",\n            name, driver_config.backend, driver_config.enabled\n        );\n    }\n\n    // Continue with initialization...\n    Ok(())\n}",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:12:bash",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 12,
      "lineEnd": 24,
      "language": "bash",
      "code": "# Use a preset robot arm\nhorus sim2d --preset arm_2dof\n\n# 6-DOF arm\nhorus sim2d --preset arm_6dof\n\n# Humanoid (side view with gravity)\nhorus sim2d --preset humanoid --gravity\n\n# Custom articulated robot\nhorus sim2d --articulated my_robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:70:yaml",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 70,
      "lineEnd": 103,
      "language": "yaml",
      "code": "# articulated_robot.yaml\nname: \"my_arm\"\nbase_position: [0.0, 0.0]\nbase_fixed: true\n\nlinks:\n  - name: \"link1\"\n    length: 0.5\n    width: 0.1\n    mass: 1.0\n    color: [0.8, 0.2, 0.2]\n\n  - name: \"link2\"\n    length: 0.4\n    width: 0.08\n    mass: 0.8\n    color: [0.2, 0.8, 0.2]\n\njoints:\n  - name: \"joint1\"\n    type: revolute\n    parent: base\n    child: link1\n    anchor: [0.0, 0.0]\n    limits: [-3.14, 3.14]\n\n  - name: \"joint2\"\n    type: revolute\n    parent: link1\n    child: link2\n    anchor: [0.5, 0.0]  # At end of link1\n    limits: [-2.5, 2.5]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:140:rust",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 140,
      "lineEnd": 147,
      "language": "rust",
      "code": "pub struct JointCommand {\n    pub names: Vec<String>,      // Joint names\n    pub positions: Vec<f64>,     // Target positions (rad)\n    pub velocities: Vec<f64>,    // Target velocities (rad/s)\n    pub effort: Vec<f64>,        // Target torques (Nm)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:151:rust",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 151,
      "lineEnd": 158,
      "language": "rust",
      "code": "pub struct JointState {\n    pub names: Vec<String>,      // Joint names\n    pub positions: Vec<f64>,     // Current positions (rad)\n    pub velocities: Vec<f64>,    // Current velocities (rad/s)\n    pub effort: Vec<f64>,        // Current torques (Nm)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:162:rust",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 162,
      "lineEnd": 211,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides {JointCommand, JointState};\n\nstruct ArmController {\n    cmd_pub: Hub<JointCommand>,\n    state_sub: Hub<JointState>,\n    target: Vec<f64>,\n}\n\nimpl ArmController {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"robot.joint_command\")?,\n            state_sub: Hub::new(\"robot.joint_state\")?,\n            target: vec![0.0, 0.0],  // 2 joints\n        })\n    }\n}\n\nimpl Node for ArmController {\n    fn name(&self) -> &'static str { \"ArmController\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read current state\n        if let Some(state) = self.state_sub.recv(&mut ctx) {\n            println!(\"Joint positions: {:?}\", state.positions);\n        }\n\n        // Simple oscillation\n        let t = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs_f64();\n\n        self.target[0] = (t * 0.5).sin() * 1.5;\n        self.target[1] = (t * 0.8).cos() * 1.0;\n\n        // Send command\n        let cmd = JointCommand {\n            names: vec![\"joint1\".to_string(), \"joint2\".to_string()],\n            positions: self.target.clone(),\n            velocities: vec![],\n            effort: vec![],\n        };\n\n        self.cmd_pub.send(cmd, &mut ctx).ok();\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:217:rust",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 217,
      "lineEnd": 242,
      "language": "rust",
      "code": "fn inverse_kinematics_2dof(\n    target_x: f64,\n    target_y: f64,\n    l1: f64,  // Link 1 length\n    l2: f64,  // Link 2 length\n) -> Option<(f64, f64)> {\n    let d = (target_x.powi(2) + target_y.powi(2)).sqrt();\n\n    // Check reachability\n    if d > l1 + l2 || d < (l1 - l2).abs() {\n        return None;\n    }\n\n    // Elbow angle (law of cosines)\n    let cos_q2 = (d.powi(2) - l1.powi(2) - l2.powi(2)) / (2.0 * l1 * l2);\n    let q2 = cos_q2.acos();\n\n    // Shoulder angle\n    let alpha = target_y.atan2(target_x);\n    let beta = ((l2 * q2.sin()) / d).asin();\n    let q1 = alpha - beta;\n\n    Some((q1, q2))\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/articulated:248:bash",
      "file": "content/docs/simulators/sim2d/articulated.mdx",
      "lineStart": 248,
      "lineEnd": 250,
      "language": "bash",
      "code": "horus sim2d --preset humanoid --gravity",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:12:bash",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 12,
      "lineEnd": 27,
      "language": "bash",
      "code": "horus sim2d [OPTIONS]\n\nOptions:\n  --robot <FILE>           Robot configuration YAML file\n  --world <FILE>           World configuration YAML file\n  --world-image <FILE>     World from image (PNG, JPG, PGM)\n  --resolution <FLOAT>     Meters per pixel for world image (default: 0.05)\n  --threshold <0-255>      Obstacle threshold - darker = obstacle (default: 128)\n  --topic <PREFIX>         Topic prefix (default: \"robot\")\n  --name <NAME>            Robot name (default: \"robot\")\n  --headless               Run without GUI\n  --articulated <FILE>     Articulated robot YAML file\n  --preset <NAME>          Use preset: arm_2dof, arm_6dof, humanoid\n  --gravity                Enable gravity (for side-view simulation)",
      "verifiable": false,
      "flags": [
        "partial"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:33:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 33,
      "lineEnd": 46,
      "language": "yaml",
      "code": "# robot.yaml\nname: \"my_robot\"\ntopic_prefix: \"robot\"      # Topics: robot.cmd_vel, robot.odom, etc.\nposition: [0.0, 0.0]       # Initial position [x, y] in meters\n\n# Physical dimensions\nwidth: 0.5                 # Robot width (meters)\nlength: 0.8                # Robot length (meters)\nmax_speed: 2.0             # Maximum velocity (m/s)\n\n# Appearance\ncolor: [0.2, 0.8, 0.2]     # RGB (0.0-1.0)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:50:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 50,
      "lineEnd": 56,
      "language": "yaml",
      "code": "kinematics:\n  type: \"differential\"     # Options: differential, ackermann, omni\n  wheel_base: 0.5          # Distance between wheels (m)\n  wheel_radius: 0.1        # Wheel radius (m) - for ackermann\n  max_steering_angle: 0.5  # Radians - for ackermann",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:66:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 66,
      "lineEnd": 74,
      "language": "yaml",
      "code": "lidar:\n  enabled: true\n  range_max: 10.0          # Maximum range (meters)\n  range_min: 0.1           # Minimum range (meters)\n  angle_min: -3.14159      # Start angle (radians) - -180°\n  angle_max: 3.14159       # End angle (radians) - +180°\n  num_rays: 360            # Number of rays (1° resolution)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:78:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 78,
      "lineEnd": 85,
      "language": "yaml",
      "code": "camera:\n  enabled: true\n  width: 640               # Image width (pixels)\n  height: 480              # Image height (pixels)\n  fov: 1.0472              # Field of view (radians) - 60°\n  topic: \"camera.image\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:89:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 89,
      "lineEnd": 98,
      "language": "yaml",
      "code": "gps:\n  enabled: true\n  update_rate: 1.0         # Hz\n  topic: \"gps\"\n  position_noise:\n    enabled: true\n    std_dev: 2.0           # Position noise (meters)\n    mean: 0.0              # Bias",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:102:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 102,
      "lineEnd": 120,
      "language": "yaml",
      "code": "ultrasonic:\n  enabled: true\n  topic_prefix: \"ultrasonic\"\n  sensors:\n    - offset: [0.4, 0.0]   # Position relative to robot center\n      angle: 0.0           # Angle relative to robot heading\n      max_range: 4.0       # Maximum range (meters)\n      min_range: 0.02      # Minimum range (meters)\n      fov: 0.26            # Field of view (radians) - 15°\n      noise:\n        enabled: true\n        std_dev: 0.02\n    - offset: [-0.4, 0.0]  # Rear sensor\n      angle: 3.14159       # Facing backwards\n      max_range: 4.0\n      min_range: 0.02\n      fov: 0.26",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:124:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 124,
      "lineEnd": 133,
      "language": "yaml",
      "code": "contact:\n  enabled: true\n  topic: \"contact\"\n  sensors:\n    - position: [0.4, 0.0]   # Front bumper\n      radius: 0.05\n    - position: [-0.4, 0.0]  # Rear bumper\n      radius: 0.05",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:139:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 139,
      "lineEnd": 158,
      "language": "yaml",
      "code": "visual:\n  turret:\n    width: 0.3\n    length: 0.3\n    offset_x: 0.0\n    offset_y: 0.0\n    color: [0.25, 0.35, 0.18]\n\n  cannon:\n    length: 0.4\n    width: 0.08\n    offset_x: 0.2\n    color: [0.2, 0.2, 0.2]\n\n  treads:\n    width: 0.1\n    offset: 0.3\n    color: [0.15, 0.15, 0.15]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:162:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 162,
      "lineEnd": 210,
      "language": "yaml",
      "code": "# tank_robot.yaml\nname: \"tank\"\ntopic_prefix: \"tank\"\nposition: [0.0, 0.0]\nwidth: 0.6\nlength: 1.0\nmax_speed: 1.5\ncolor: [0.35, 0.45, 0.25]\n\nkinematics:\n  type: \"differential\"\n  wheel_base: 0.5\n\nlidar:\n  enabled: true\n  range_max: 15.0\n  num_rays: 720\n\ncamera:\n  enabled: true\n  width: 640\n  height: 480\n  fov: 1.2\n\ngps:\n  enabled: true\n  update_rate: 5.0\n  position_noise:\n    enabled: true\n    std_dev: 1.0\n\nvisual:\n  turret:\n    width: 0.4\n    length: 0.4\n    offset_x: -0.1\n    offset_y: 0.0\n    color: [0.3, 0.4, 0.2]\n  cannon:\n    length: 0.5\n    width: 0.1\n    offset_x: 0.3\n    color: [0.15, 0.15, 0.15]\n  treads:\n    width: 0.12\n    offset: 0.35\n    color: [0.1, 0.1, 0.1]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:216:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 216,
      "lineEnd": 224,
      "language": "yaml",
      "code": "# world.yaml\nwidth: 20.0                # World width (meters)\nheight: 20.0               # World height (meters)\nwall_color: [0.3, 0.3, 0.3]              # Boundary wall color\ndefault_obstacle_color: [0.6, 0.4, 0.2]  # Default obstacle color\n\nobstacles: []              # List of obstacles",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:230:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 230,
      "lineEnd": 236,
      "language": "yaml",
      "code": "obstacles:\n  - pos: [5.0, 3.0]        # Center position [x, y]\n    shape: rectangle\n    size: [2.0, 1.0]       # [width, height]\n    color: [0.6, 0.3, 0.1] # Optional RGB color",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:240:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 240,
      "lineEnd": 246,
      "language": "yaml",
      "code": "obstacles:\n  - pos: [-3.0, 2.0]\n    shape: circle\n    size: [1.0, 1.0]       # [radius, radius] (use same value)\n    color: [0.5, 0.5, 0.8]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:250:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 250,
      "lineEnd": 263,
      "language": "yaml",
      "code": "obstacles:\n  - pos: [0.0, 5.0]\n    shape: rectangle\n    size: [1.0, 1.0]\n    dynamic:\n      enabled: true\n      velocity: [0.5, 0.0]   # Linear velocity [vx, vy]\n      angular: 0.0           # Angular velocity (rad/s)\n      bounds:                # Movement bounds\n        min: [-5.0, 4.0]\n        max: [5.0, 6.0]\n      bounce: true           # Bounce off bounds",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:267:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 267,
      "lineEnd": 314,
      "language": "yaml",
      "code": "# warehouse.yaml\nwidth: 30.0\nheight: 20.0\nwall_color: [0.4, 0.4, 0.4]\ndefault_obstacle_color: [0.5, 0.3, 0.2]\n\nobstacles:\n  # Shelving units\n  - pos: [-10.0, 5.0]\n    shape: rectangle\n    size: [1.0, 8.0]\n    color: [0.6, 0.4, 0.2]\n\n  - pos: [-5.0, 5.0]\n    shape: rectangle\n    size: [1.0, 8.0]\n    color: [0.6, 0.4, 0.2]\n\n  - pos: [0.0, 5.0]\n    shape: rectangle\n    size: [1.0, 8.0]\n    color: [0.6, 0.4, 0.2]\n\n  # Pillars\n  - pos: [8.0, 8.0]\n    shape: circle\n    size: [0.5, 0.5]\n    color: [0.5, 0.5, 0.5]\n\n  - pos: [8.0, -8.0]\n    shape: circle\n    size: [0.5, 0.5]\n    color: [0.5, 0.5, 0.5]\n\n  # Moving forklift\n  - pos: [5.0, 0.0]\n    shape: rectangle\n    size: [0.8, 1.2]\n    color: [0.8, 0.6, 0.0]\n    dynamic:\n      enabled: true\n      velocity: [0.0, 0.3]\n      bounds:\n        min: [4.0, -8.0]\n        max: [6.0, 8.0]\n      bounce: true",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:320:bash",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 320,
      "lineEnd": 326,
      "language": "bash",
      "code": "# PGM format (common in ROS)\nhorus sim2d --world-image map.pgm --resolution 0.05\n\n# PNG with custom threshold\nhorus sim2d --world-image floor_plan.png --resolution 0.1 --threshold 200",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:350:bash",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 350,
      "lineEnd": 353,
      "language": "bash",
      "code": "# Example: 1000x1000 pixel map at 5cm resolution = 50m x 50m world\nhorus sim2d --world-image my_map.pgm --resolution 0.05",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:359:yaml",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 359,
      "lineEnd": 371,
      "language": "yaml",
      "code": "# robot1.yaml\nname: \"robot1\"\ntopic_prefix: \"robot1\"\nposition: [-5.0, 0.0]\ncolor: [0.8, 0.2, 0.2]\n\n# robot2.yaml\nname: \"robot2\"\ntopic_prefix: \"robot2\"\nposition: [5.0, 0.0]\ncolor: [0.2, 0.2, 0.8]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:375:bash",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 375,
      "lineEnd": 378,
      "language": "bash",
      "code": "# Currently requires library API\n# See Python API documentation for multi-robot support",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/configuration:387:bash",
      "file": "content/docs/simulators/sim2d/configuration.mdx",
      "lineStart": 387,
      "lineEnd": 389,
      "language": "bash",
      "code": "RUST_LOG=debug horus sim2d",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:17:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 17,
      "lineEnd": 26,
      "language": "bash",
      "code": "# Default configuration\nhorus sim2d\n\n# With custom topic prefix\nhorus sim2d --topic myrobot\n\n# Build from source (advanced - for development on sim2d itself)\n# cargo run -p sim2d --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:92:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 92,
      "lineEnd": 95,
      "language": "bash",
      "code": "horus new teleop_demo --rust\ncd teleop_demo",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:101:rust",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 101,
      "lineEnd": 144,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides CmdVel;\nuse std::io::{self, Read};\n\nstruct TeleopNode {\n    cmd_pub: Hub<CmdVel>,\n}\n\nimpl TeleopNode {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"robot.cmd_vel\")?,\n        })\n    }\n}\n\nimpl Node for TeleopNode {\n    fn name(&self) -> &'static str { \"Teleop\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // Read keyboard input (simplified)\n        let mut cmd = CmdVel::default();\n\n        // In a real implementation, use termion or crossterm\n        // for non-blocking keyboard input\n        cmd.linear.x = 0.5;  // Forward\n        cmd.angular.z = 0.0; // No rotation\n\n        self.cmd_pub.send(cmd, &mut ctx).ok();\n\n        std::thread::sleep(std::time::Duration::from_millis(100));\n    }\n}\n\nfn main() -> Result<()> {\n    println!(\"Publishing to robot.cmd_vel...\");\n    println!(\"Robot will move forward at 0.5 m/s\");\n\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(TeleopNode::new()?), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:148:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 148,
      "lineEnd": 154,
      "language": "bash",
      "code": "# Terminal 1: Start simulator\nhorus sim2d\n\n# Terminal 2: Run controller\nhorus run --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:162:rust",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 162,
      "lineEnd": 224,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides {CmdVel, LaserScan};\n\nstruct ObstacleAvoider {\n    cmd_pub: Hub<CmdVel>,\n    scan_sub: Hub<LaserScan>,\n}\n\nimpl ObstacleAvoider {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"robot.cmd_vel\")?,\n            scan_sub: Hub::new(\"robot.scan\")?,\n        })\n    }\n\n    fn find_min_distance(&self, scan: &LaserScan, start: usize, end: usize) -> f64 {\n        scan.ranges[start..end]\n            .iter()\n            .filter(|r| **r > scan.range_min && **r < scan.range_max)\n            .fold(f64::MAX, |min, r| min.min(*r))\n    }\n}\n\nimpl Node for ObstacleAvoider {\n    fn name(&self) -> &'static str { \"ObstacleAvoider\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            let num_rays = scan.ranges.len();\n            let front_start = num_rays * 3 / 8;  // Front 90 degrees\n            let front_end = num_rays * 5 / 8;\n\n            let front_min = self.find_min_distance(&scan, front_start, front_end);\n\n            let mut cmd = CmdVel::default();\n\n            if front_min < 0.5 {\n                // Too close - back up and turn\n                cmd.linear.x = -0.2;\n                cmd.angular.z = 0.5;\n            } else if front_min < 1.0 {\n                // Getting close - slow down and turn\n                cmd.linear.x = 0.2;\n                cmd.angular.z = 0.3;\n            } else {\n                // Clear - full speed ahead\n                cmd.linear.x = 0.5;\n                cmd.angular.z = 0.0;\n            }\n\n            self.cmd_pub.send(cmd, &mut ctx).ok();\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(ObstacleAvoider::new()?), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:241:yaml",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 241,
      "lineEnd": 258,
      "language": "yaml",
      "code": "# my_robot.yaml\nname: \"my_robot\"\nposition: [0.0, 0.0]\nwidth: 0.4\nlength: 0.6\nmax_speed: 1.5\ncolor: [0.8, 0.2, 0.2]  # Red\n\nlidar:\n  enabled: true\n  range_max: 8.0\n  num_rays: 180\n\nkinematics:\n  type: \"differential\"\n  wheel_base: 0.3",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:260:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 260,
      "lineEnd": 262,
      "language": "bash",
      "code": "horus sim2d --robot my_robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:266:yaml",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 266,
      "lineEnd": 281,
      "language": "yaml",
      "code": "# my_world.yaml\nwidth: 20.0\nheight: 20.0\nwall_color: [0.4, 0.4, 0.4]\n\nobstacles:\n  - pos: [5.0, 5.0]\n    shape: rectangle\n    size: [2.0, 1.0]\n    color: [0.6, 0.3, 0.1]\n\n  - pos: [-3.0, 2.0]\n    shape: circle\n    size: [1.0, 1.0]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:283:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 283,
      "lineEnd": 285,
      "language": "bash",
      "code": "horus sim2d --world my_world.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:289:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 289,
      "lineEnd": 293,
      "language": "bash",
      "code": "# Load PGM/PNG as world map\n# Dark pixels = obstacles\nhorus sim2d --world-image map.pgm --resolution 0.05 --threshold 128",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:299:bash",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 299,
      "lineEnd": 305,
      "language": "bash",
      "code": "# No window, just physics\nhorus sim2d --headless\n\n# With specific configuration\nhorus sim2d --headless --robot training_robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/getting-started:329:rust",
      "file": "content/docs/simulators/sim2d/getting-started.mdx",
      "lineStart": 329,
      "lineEnd": 332,
      "language": "rust",
      "code": "// Same topic name = automatic communication\nlet hub = Hub::new(\"robot.cmd_vel\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/index:24:bash",
      "file": "content/docs/simulators/sim2d/index.mdx",
      "lineStart": 24,
      "lineEnd": 36,
      "language": "bash",
      "code": "# Launch with default robot and world\nhorus sim2d\n\n# Custom robot configuration\nhorus sim2d --robot my_robot.yaml\n\n# Load world from image (occupancy grid)\nhorus sim2d --world-image map.pgm --resolution 0.05\n\n# Headless mode for training\nhorus sim2d --headless",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/index:96:rust",
      "file": "content/docs/simulators/sim2d/index.mdx",
      "lineStart": 96,
      "lineEnd": 145,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides {CmdVel, LaserScan};\n\nstruct WallFollower {\n    cmd_pub: Hub<CmdVel>,\n    scan_sub: Hub<LaserScan>,\n}\n\nimpl WallFollower {\n    fn new() -> Result<Self> {\n        Ok(Self {\n            cmd_pub: Hub::new(\"robot.cmd_vel\")?,\n            scan_sub: Hub::new(\"robot.scan\")?,\n        })\n    }\n}\n\nimpl Node for WallFollower {\n    fn name(&self) -> &'static str { \"WallFollower\" }\n\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(scan) = self.scan_sub.recv(&mut ctx) {\n            // Find minimum distance on the right side\n            let right_min = scan.ranges[0..90]\n                .iter()\n                .filter(|r| **r > 0.1)\n                .fold(f64::MAX, |min, r| min.min(*r));\n\n            // Simple wall following\n            let mut cmd = CmdVel::default();\n            cmd.linear.x = 0.3;  // Forward speed\n\n            if right_min < 0.5 {\n                cmd.angular.z = 0.3;  // Turn left\n            } else if right_min > 1.0 {\n                cmd.angular.z = -0.3; // Turn right\n            }\n\n            self.cmd_pub.send(cmd, &mut ctx).ok();\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(WallFollower::new()?), 0, Some(true));\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/index:149:bash",
      "file": "content/docs/simulators/sim2d/index.mdx",
      "lineStart": 149,
      "lineEnd": 155,
      "language": "bash",
      "code": "# Terminal 1: Start simulator\nhorus sim2d\n\n# Terminal 2: Run your controller\nhorus run wall_follower.rs --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:12:bash",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 12,
      "lineEnd": 19,
      "language": "bash",
      "code": "# Install with Python support\npip install horus-sim2d\n\n# Or build from source with Python feature\ncd horus_library/tools/sim2d\nmaturin develop --features python",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:23:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 23,
      "lineEnd": 53,
      "language": "python",
      "code": "from horus.sim2d import Sim2D, RobotConfig, WorldConfig\n\n# Create simulation\nsim = Sim2D(\n    robot=RobotConfig(\n        width=0.5,\n        length=0.8,\n        max_speed=2.0\n    ),\n    world=WorldConfig(\n        width=20.0,\n        height=20.0\n    ),\n    headless=True\n)\n\n# Step simulation\nfor _ in range(1000):\n    # Set velocity command\n    sim.set_velocity(linear=0.5, angular=0.1)\n\n    # Step physics\n    obs = sim.step()\n\n    # Get sensor data\n    lidar = obs['lidar']\n    pose = obs['pose']\n\n    print(f\"Position: ({pose['x']:.2f}, {pose['y']:.2f})\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:59:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 59,
      "lineEnd": 77,
      "language": "python",
      "code": "class Sim2D:\n    def __init__(\n        self,\n        robot: RobotConfig = None,\n        world: WorldConfig = None,\n        headless: bool = False,\n        topic_prefix: str = \"robot\"\n    ):\n        \"\"\"\n        Create a Sim2D simulation instance.\n\n        Args:\n            robot: Robot configuration (uses defaults if None)\n            world: World configuration (uses defaults if None)\n            headless: Run without GUI\n            topic_prefix: HORUS topic prefix\n        \"\"\"",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:93:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 93,
      "lineEnd": 105,
      "language": "python",
      "code": "class RobotConfig:\n    width: float = 0.5       # Robot width (m)\n    length: float = 0.8      # Robot length (m)\n    max_speed: float = 2.0   # Max velocity (m/s)\n    position: tuple = (0, 0) # Initial position\n    color: tuple = (0.2, 0.8, 0.2)  # RGB color\n\n    # Sensors\n    lidar_enabled: bool = True\n    lidar_range: float = 10.0\n    lidar_rays: int = 360",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:109:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 109,
      "lineEnd": 114,
      "language": "python",
      "code": "class WorldConfig:\n    width: float = 20.0      # World width (m)\n    height: float = 20.0     # World height (m)\n    obstacles: list = []     # List of obstacles",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:118:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 118,
      "lineEnd": 124,
      "language": "python",
      "code": "class Obstacle:\n    position: tuple      # (x, y) center\n    shape: str           # \"rectangle\" or \"circle\"\n    size: tuple          # (width, height) or (radius, radius)\n    color: tuple = None  # Optional RGB",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:130:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 130,
      "lineEnd": 158,
      "language": "python",
      "code": "obs = sim.step()\n\n# Pose\nobs['pose'] = {\n    'x': float,      # X position (m)\n    'y': float,      # Y position (m)\n    'theta': float,  # Heading (rad)\n}\n\n# Velocity\nobs['velocity'] = {\n    'linear': float,   # Forward velocity (m/s)\n    'angular': float,  # Turn rate (rad/s)\n}\n\n# LIDAR (if enabled)\nobs['lidar'] = np.array([...])  # Range values\n\n# IMU (if enabled)\nobs['imu'] = {\n    'orientation': float,        # Yaw (rad)\n    'angular_velocity': float,   # Turn rate (rad/s)\n    'linear_acceleration': float # Acceleration (m/s²)\n}\n\n# Collision\nobs['collision'] = bool  # True if colliding",
      "verifiable": false,
      "flags": [
        "has-markers"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:164:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 164,
      "lineEnd": 239,
      "language": "python",
      "code": "import gymnasium as gym\nfrom gymnasium import spaces\nimport numpy as np\nfrom horus.sim2d import Sim2D, RobotConfig, WorldConfig\n\nclass Sim2DEnv(gym.Env):\n    def __init__(self):\n        super().__init__()\n\n        # Create simulation\n        self.sim = Sim2D(headless=True)\n\n        # Action space: [linear_vel, angular_vel]\n        self.action_space = spaces.Box(\n            low=np.array([-1.0, -1.0]),\n            high=np.array([1.0, 1.0]),\n            dtype=np.float32\n        )\n\n        # Observation space: LIDAR + pose\n        self.observation_space = spaces.Dict({\n            'lidar': spaces.Box(\n                low=0, high=10,\n                shape=(360,), dtype=np.float32\n            ),\n            'pose': spaces.Box(\n                low=-20, high=20,\n                shape=(3,), dtype=np.float32\n            )\n        })\n\n        self.goal = np.array([5.0, 5.0])\n\n    def reset(self, seed=None):\n        super().reset(seed=seed)\n        self.sim.reset()\n        obs = self.sim.step()\n        return self._get_obs(obs), {}\n\n    def step(self, action):\n        # Apply action\n        linear = float(action[0])\n        angular = float(action[1])\n        self.sim.set_velocity(linear, angular)\n\n        # Step simulation\n        obs = self.sim.step()\n\n        # Compute reward\n        pose = obs['pose']\n        dist = np.sqrt(\n            (pose['x'] - self.goal[0])**2 +\n            (pose['y'] - self.goal[1])**2\n        )\n        reward = -dist  # Negative distance\n\n        # Check termination\n        terminated = dist < 0.5  # Reached goal\n        truncated = obs['collision']  # Hit obstacle\n\n        return self._get_obs(obs), reward, terminated, truncated, {}\n\n    def _get_obs(self, obs):\n        return {\n            'lidar': np.array(obs['lidar'], dtype=np.float32),\n            'pose': np.array([\n                obs['pose']['x'],\n                obs['pose']['y'],\n                obs['pose']['theta']\n            ], dtype=np.float32)\n        }\n\n    def close(self):\n        self.sim.close()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:243:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 243,
      "lineEnd": 264,
      "language": "python",
      "code": "from stable_baselines3 import PPO\nfrom stable_baselines3.common.vec_env import DummyVecEnv\n\n# Create vectorized environment\nenv = DummyVecEnv([lambda: Sim2DEnv()])\n\n# Train agent\nmodel = PPO(\"MultiInputPolicy\", env, verbose=1)\nmodel.learn(total_timesteps=100000)\n\n# Save model\nmodel.save(\"sim2d_navigation\")\n\n# Test\nobs, _ = env.reset()\nfor _ in range(1000):\n    action, _ = model.predict(obs)\n    obs, reward, done, _, _ = env.step(action)\n    if done:\n        obs, _ = env.reset()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:268:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 268,
      "lineEnd": 289,
      "language": "python",
      "code": "from horus.sim2d import Sim2D, RobotConfig\n\n# Create robots with different prefixes\nrobots = []\nfor i in range(3):\n    robot = RobotConfig(\n        position=(i * 3.0 - 3.0, 0.0),\n        color=(0.2 + i * 0.3, 0.8 - i * 0.2, 0.2)\n    )\n    sim = Sim2D(\n        robot=robot,\n        topic_prefix=f\"robot{i}\",\n        headless=True\n    )\n    robots.append(sim)\n\n# Step all robots\nfor sim in robots:\n    sim.set_velocity(0.5, 0.1 * robots.index(sim))\n    sim.step()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:297:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 297,
      "lineEnd": 299,
      "language": "python",
      "code": "sim = Sim2D(headless=True)  # 10x faster",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:305:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 305,
      "lineEnd": 309,
      "language": "python",
      "code": "for _ in range(4):  # 4 physics steps per observation\n    sim.step(dt=0.004)\nobs = sim.step(dt=0.004)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:315:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 315,
      "lineEnd": 319,
      "language": "python",
      "code": "robot = RobotConfig(\n    lidar_rays=90  # Instead of 360\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/python-api:325:python",
      "file": "content/docs/simulators/sim2d/python-api.mdx",
      "lineStart": 325,
      "lineEnd": 332,
      "language": "python",
      "code": "# Your Python RL agent\nsim = Sim2D(topic_prefix=\"robot\")\n\n# Can communicate with Rust nodes on same topics!\n# Rust node can subscribe to robot.cmd_vel\n# Python can publish to robot.cmd_vel",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:28:yaml",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 28,
      "lineEnd": 36,
      "language": "yaml",
      "code": "lidar:\n  enabled: true\n  range_max: 10.0      # Maximum range (meters)\n  range_min: 0.1       # Minimum range (meters)\n  angle_min: -3.14159  # Start angle (radians)\n  angle_max: 3.14159   # End angle (radians)\n  num_rays: 360        # Number of rays",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:49:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 49,
      "lineEnd": 59,
      "language": "rust",
      "code": "pub struct LaserScan {\n    pub angle_min: f64,      // Start angle (rad)\n    pub angle_max: f64,      // End angle (rad)\n    pub angle_increment: f64, // Angle between rays\n    pub range_min: f64,      // Minimum valid range\n    pub range_max: f64,      // Maximum valid range\n    pub ranges: Vec<f64>,    // Distance measurements\n    pub intensities: Vec<f64>, // Intensity values (optional)\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:63:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 63,
      "lineEnd": 84,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides LaserScan;\n\nfn process_lidar(scan: &LaserScan) {\n    // Find closest obstacle\n    let min_range = scan.ranges\n        .iter()\n        .filter(|r| **r > scan.range_min && **r < scan.range_max)\n        .fold(f64::MAX, |min, r| min.min(*r));\n\n    // Get angle of closest obstacle\n    let min_idx = scan.ranges\n        .iter()\n        .position(|r| (*r - min_range).abs() < 0.01)\n        .unwrap_or(0);\n\n    let angle = scan.angle_min + (min_idx as f64 * scan.angle_increment);\n\n    println!(\"Closest: {:.2}m at {:.1}°\", min_range, angle.to_degrees());\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:94:yaml",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 94,
      "lineEnd": 97,
      "language": "yaml",
      "code": "# In robot config, IMU noise is applied automatically\n# based on physics simulation",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:101:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 101,
      "lineEnd": 107,
      "language": "rust",
      "code": "pub struct Imu {\n    pub orientation: Quaternion,      // Current orientation\n    pub angular_velocity: Vector3,    // rad/s\n    pub linear_acceleration: Vector3, // m/s²\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:111:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 111,
      "lineEnd": 128,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides Imu;\n\nfn process_imu(imu: &Imu) {\n    // Get yaw from quaternion (2D simulation, only Z rotation)\n    let yaw = imu.orientation.z.atan2(imu.orientation.w) * 2.0;\n\n    // Angular velocity (turning rate)\n    let turn_rate = imu.angular_velocity.z;\n\n    // Forward acceleration\n    let accel = imu.linear_acceleration.x;\n\n    println!(\"Yaw: {:.1}°, Turn: {:.2} rad/s, Accel: {:.2} m/s²\",\n             yaw.to_degrees(), turn_rate, accel);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:136:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 136,
      "lineEnd": 141,
      "language": "rust",
      "code": "pub struct Odometry {\n    pub pose: Pose2D,    // x, y, theta\n    pub twist: Twist,    // linear and angular velocity\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:145:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 145,
      "lineEnd": 157,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides Odometry;\n\nfn process_odometry(odom: &Odometry) {\n    println!(\"Position: ({:.2}, {:.2}), Heading: {:.1}°\",\n             odom.pose.x, odom.pose.y,\n             odom.pose.theta.to_degrees());\n\n    println!(\"Velocity: {:.2} m/s, Turn: {:.2} rad/s\",\n             odom.twist.linear.x, odom.twist.angular.z);\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:165:yaml",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 165,
      "lineEnd": 174,
      "language": "yaml",
      "code": "gps:\n  enabled: true\n  update_rate: 1.0         # Hz (typical GPS is 1-10 Hz)\n  topic: \"gps\"\n  position_noise:\n    enabled: true\n    std_dev: 2.0           # Position error (meters)\n    mean: 0.0              # Systematic bias",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:187:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 187,
      "lineEnd": 194,
      "language": "rust",
      "code": "pub struct NavSatFix {\n    pub latitude: f64,   // Degrees\n    pub longitude: f64,  // Degrees\n    pub altitude: f64,   // Meters (0.0 in 2D)\n    pub status: i8,      // Fix status\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:208:yaml",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 208,
      "lineEnd": 229,
      "language": "yaml",
      "code": "ultrasonic:\n  enabled: true\n  topic_prefix: \"ultrasonic\"\n  sensors:\n    # Front sensor\n    - offset: [0.4, 0.0]     # Position on robot\n      angle: 0.0             # Facing direction\n      max_range: 4.0         # meters\n      min_range: 0.02        # meters\n      fov: 0.26              # radians (15°)\n      noise:\n        enabled: true\n        std_dev: 0.02        # 2cm noise\n\n    # Left sensor\n    - offset: [0.0, 0.2]\n      angle: 1.5708          # 90° left\n      max_range: 4.0\n      min_range: 0.02\n      fov: 0.26",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:241:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 241,
      "lineEnd": 249,
      "language": "rust",
      "code": "pub struct Range {\n    pub radiation_type: u8, // ULTRASOUND = 0\n    pub field_of_view: f64, // radians\n    pub min_range: f64,     // meters\n    pub max_range: f64,     // meters\n    pub range: f64,         // Current reading\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:257:yaml",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 257,
      "lineEnd": 273,
      "language": "yaml",
      "code": "contact:\n  enabled: true\n  topic: \"contact\"\n  sensors:\n    - position: [0.4, 0.0]   # Front center\n      radius: 0.05           # Detection radius\n\n    - position: [0.4, 0.2]   # Front left\n      radius: 0.05\n\n    - position: [0.4, -0.2]  # Front right\n      radius: 0.05\n\n    - position: [-0.4, 0.0]  # Rear\n      radius: 0.05",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:277:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 277,
      "lineEnd": 287,
      "language": "rust",
      "code": "pub struct ContactArray {\n    pub contacts: Vec<Contact>,\n}\n\npub struct Contact {\n    pub position: Point,     // Contact location\n    pub normal: Vector3,     // Contact normal\n    pub depth: f64,          // Penetration depth\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:291:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 291,
      "lineEnd": 312,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides ContactArray;\n\nstruct BumperController {\n    contact_sub: Hub<ContactArray>,\n    cmd_pub: Hub<CmdVel>,\n}\n\nimpl Node for BumperController {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        if let Some(contacts) = self.contact_sub.recv(&mut ctx) {\n            if !contacts.contacts.is_empty() {\n                // Collision detected - stop and back up\n                let mut cmd = CmdVel::default();\n                cmd.linear.x = -0.2;  // Reverse\n                self.cmd_pub.send(cmd, &mut ctx).ok();\n            }\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:318:yaml",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 318,
      "lineEnd": 323,
      "language": "yaml",
      "code": "noise:\n  enabled: true\n  std_dev: 0.1    # Standard deviation\n  mean: 0.0       # Bias/offset",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:327:text",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 327,
      "lineEnd": 329,
      "language": "text",
      "code": "noisy_value = true_value + N(mean, std_dev)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim2d/sensors:346:rust",
      "file": "content/docs/simulators/sim2d/sensors.mdx",
      "lineStart": 346,
      "lineEnd": 381,
      "language": "rust",
      "code": "use horus::prelude::*; // Provides {Hub, Odometry, NavSatFix, Imu, SensorFusion}\n\nstruct LocalizationNode {\n    odom_sub: Hub<Odometry>,\n    gps_sub: Hub<NavSatFix>,\n    imu_sub: Hub<Imu>,\n    fusion_x: SensorFusion,\n    fusion_y: SensorFusion,\n}\n\nimpl Node for LocalizationNode {\n    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        // High-confidence odometry\n        if let Some(odom) = self.odom_sub.recv(&mut ctx) {\n            self.fusion_x.add_measurement(\"odom\", odom.pose.x, 0.01);\n            self.fusion_y.add_measurement(\"odom\", odom.pose.y, 0.01);\n        }\n\n        // Low-confidence GPS\n        if let Some(gps) = self.gps_sub.recv(&mut ctx) {\n            // Convert lat/lon to local coordinates\n            let x = (gps.longitude + 122.4194) / 0.00001;\n            let y = (gps.latitude - 37.7749) / 0.00001;\n\n            self.fusion_x.add_measurement(\"gps\", x, 4.0);  // Higher variance\n            self.fusion_y.add_measurement(\"gps\", y, 4.0);\n        }\n\n        // Get fused estimate\n        if let (Some(x), Some(y)) = (self.fusion_x.fuse(), self.fusion_y.fuse()) {\n            println!(\"Fused position: ({:.2}, {:.2})\", x, y);\n        }\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:28:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 28,
      "lineEnd": 36,
      "language": "bash",
      "code": "# Clone and install HORUS (includes sim3d)\ngit clone https://github.com/softmata/horus.git\ncd horus\n./install.sh\n\n# Verify installation\nhorus sim3d --help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:40:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 40,
      "lineEnd": 50,
      "language": "bash",
      "code": "# Clone HORUS repository\ngit clone https://github.com/softmata/horus.git\ncd horus\n\n# Build and run sim3d (recommended)\nhorus sim3d\n\n# Or with specific features\nhorus sim3d --enable cuda,python,editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:53:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 53,
      "lineEnd": 55,
      "language": "bash",
      "code": "cargo build -p sim3d --release --features \"python,cuda,editor\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:59:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 59,
      "lineEnd": 66,
      "language": "bash",
      "code": "# Install Python bindings\npip install horus-robotics\n\n# Or build from source with maturin\ncd horus_library/tools/sim3d\nmaturin develop --release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:70:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 70,
      "lineEnd": 79,
      "language": "bash",
      "code": "# Check version\nhorus sim3d --version\n\n# Run with a test scene\nhorus sim3d --world examples/empty_world.yaml\n\n# Test headless mode\nhorus sim3d --headless --help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:85:text",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 85,
      "lineEnd": 91,
      "language": "text",
      "code": "~/.horus/\n├── sim3d/\n│   ├── assets/      # Downloaded models and textures\n│   ├── recordings/  # Saved trajectories and videos\n│   └── cache/       # Asset cache",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:97:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 97,
      "lineEnd": 103,
      "language": "bash",
      "code": "# Check CUDA availability\nnvidia-smi\n\n# Run sim3d with CUDA support\nhorus sim3d --enable cuda",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:109:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 109,
      "lineEnd": 115,
      "language": "bash",
      "code": "# Ubuntu/Debian\nsudo apt install vulkan-tools libvulkan1\n\n# Verify\nvulkaninfo",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:123:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 123,
      "lineEnd": 132,
      "language": "bash",
      "code": "# NVIDIA\nsudo apt install nvidia-driver-535\n\n# AMD\nsudo apt install mesa-vulkan-drivers\n\n# Intel\nsudo apt install intel-media-va-driver",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:138:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 138,
      "lineEnd": 142,
      "language": "bash",
      "code": "export CUDA_HOME=/usr/local/cuda\nexport PATH=$CUDA_HOME/bin:$PATH\nexport LD_LIBRARY_PATH=$CUDA_HOME/lib64:$LD_LIBRARY_PATH",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:148:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 148,
      "lineEnd": 154,
      "language": "bash",
      "code": "# Install Xvfb\nsudo apt install xvfb\n\n# Run sim3d with virtual display\nxvfb-run -a horus sim3d --world scene.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/installation:158:bash",
      "file": "content/docs/simulators/sim3d/getting-started/installation.mdx",
      "lineStart": 158,
      "lineEnd": 160,
      "language": "bash",
      "code": "horus sim3d --headless --world scene.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:16:yaml",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 16,
      "lineEnd": 51,
      "language": "yaml",
      "code": "# World configuration\nname: \"my_first_world\"\ngravity: [0.0, 0.0, -9.81]\ntime_step: 0.001  # 1ms physics step\n\n# Ground plane\nground:\n  size: [20.0, 20.0]\n  friction: 0.7\n  material: \"concrete\"\n\n# Obstacles\nobjects:\n  - name: \"box1\"\n    type: \"box\"\n    position: [3.0, 0.0, 0.5]\n    size: [1.0, 1.0, 1.0]\n    mass: 10.0\n    color: [0.8, 0.2, 0.2, 1.0]\n\n  - name: \"cylinder1\"\n    type: \"cylinder\"\n    position: [-2.0, 2.0, 0.5]\n    radius: 0.5\n    height: 1.0\n    mass: 5.0\n    color: [0.2, 0.8, 0.2, 1.0]\n\n# Lighting\nlights:\n  - type: \"directional\"\n    direction: [-0.5, -0.5, -1.0]\n    intensity: 1.0\n    color: [1.0, 1.0, 0.95]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:55:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 55,
      "lineEnd": 61,
      "language": "bash",
      "code": "# Via HORUS CLI (recommended)\nhorus sim3d --world my_world.yaml\n\n# Or run sim3d binary directly\nsim3d --world my_world.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:79:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 79,
      "lineEnd": 82,
      "language": "bash",
      "code": "# Specify a URDF file\nhorus sim3d --world my_world.yaml --robot models/my_robot.urdf",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:88:yaml",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 88,
      "lineEnd": 124,
      "language": "yaml",
      "code": "name: \"scout\"\ntype: \"differential_drive\"\n\n# Physical properties\nbase:\n  mass: 10.0\n  size: [0.5, 0.3, 0.15]\n\nwheels:\n  radius: 0.1\n  width: 0.05\n  separation: 0.35\n  max_velocity: 2.0  # m/s\n  max_torque: 10.0   # Nm\n\n# Sensors\nsensors:\n  - type: \"lidar\"\n    name: \"front_lidar\"\n    position: [0.2, 0.0, 0.1]\n    range: 10.0\n    samples: 360\n    rate: 10  # Hz\n\n  - type: \"imu\"\n    name: \"imu\"\n    position: [0.0, 0.0, 0.05]\n    rate: 100  # Hz\n\n  - type: \"camera\"\n    name: \"front_camera\"\n    position: [0.25, 0.0, 0.1]\n    resolution: [640, 480]\n    fov: 60\n    rate: 30  # Hz",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:128:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 128,
      "lineEnd": 130,
      "language": "bash",
      "code": "horus sim3d --world my_world.yaml --robot my_robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:136:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 136,
      "lineEnd": 139,
      "language": "bash",
      "code": "# In another terminal, publish velocity commands\nhorus pub scout.cmd_vel '{\"linear\": [0.5, 0.0, 0.0], \"angular\": [0.0, 0.0, 0.1]}'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:143:rust",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 143,
      "lineEnd": 156,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    // Connect to robot command topic\n    let cmd_hub: Hub<Twist> = Hub::new(\"scout.cmd_vel\")?;\n\n    // Send velocity command\n    let cmd = Twist::new_2d(0.5, 0.1);  // 0.5 m/s forward, 0.1 rad/s turn\n    cmd_hub.send(cmd, &mut None)?;\n\n    Ok(())\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:160:python",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 160,
      "lineEnd": 169,
      "language": "python",
      "code": "from horus import Hub, Twist\n\n# Connect to robot\ncmd_hub = Hub(\"scout.cmd_vel\")\n\n# Send command\ncmd = Twist(linear=[0.5, 0.0, 0.0], angular=[0.0, 0.0, 0.1])\ncmd_hub.send(cmd)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:175:rust",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 175,
      "lineEnd": 201,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nfn main() -> Result<()> {\n    // Subscribe to sensor topics\n    let odom_hub: Hub<Odometry> = Hub::new(\"scout.odom\")?;\n    let scan_hub: Hub<LaserScan> = Hub::new(\"scout.scan\")?;\n    let imu_hub: Hub<Imu> = Hub::new(\"scout.imu\")?;\n\n    loop {\n        // Read odometry\n        if let Some(odom) = odom_hub.recv(&mut None) {\n            println!(\"Position: ({:.2}, {:.2})\", odom.position.x, odom.position.y);\n        }\n\n        // Read LiDAR\n        if let Some(scan) = scan_hub.recv(&mut None) {\n            let min_range = scan.ranges.iter()\n                .filter(|r| **r > scan.range_min)\n                .min_by(|a, b| a.partial_cmp(b).unwrap());\n            println!(\"Closest obstacle: {:?}\", min_range);\n        }\n\n        std::thread::sleep(Duration::from_millis(100));\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:207:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 207,
      "lineEnd": 210,
      "language": "bash",
      "code": "# Run without rendering\nhorus sim3d --headless --world my_world.yaml --robot my_robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:214:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 214,
      "lineEnd": 217,
      "language": "bash",
      "code": "# Use a fixed seed for reproducible results\nhorus sim3d --headless --seed 42 --world my_world.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:223:bash",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 223,
      "lineEnd": 226,
      "language": "bash",
      "code": "# Run at 10x speed (via sim3d binary)\nsim3d --mode headless --speed 10.0 --world my_world.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/quick-start:232:rust",
      "file": "content/docs/simulators/sim3d/getting-started/quick-start.mdx",
      "lineStart": 232,
      "lineEnd": 270,
      "language": "rust",
      "code": "use horus::prelude::*;\n\nnode! {\n    WallFollower {\n        pub {\n            cmd_vel: Twist -> \"scout.cmd_vel\",\n        }\n        sub {\n            scan: LaserScan -> \"scout.scan\",\n        }\n        data {\n            target_distance: f32 = 1.0,\n            kp: f32 = 0.5,\n        }\n        tick(ctx) {\n            if let Some(scan) = self.scan.recv(ctx) {\n                // Get right-side distance (90 degrees)\n                let right_idx = 90;\n                let right_dist = scan.ranges[right_idx];\n\n                // Simple P controller to maintain distance\n                let error = self.target_distance - right_dist;\n                let angular = self.kp * error;\n\n                // Move forward while adjusting\n                let cmd = Twist::new_2d(0.3, angular);\n                self.cmd_vel.send(cmd, ctx).ok();\n            }\n        }\n    }\n}\n\nfn main() -> Result<()> {\n    let mut scheduler = Scheduler::new();\n    scheduler.add(Box::new(WallFollower::new()?), 50, None);\n    scheduler.run()\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:12:bash",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 12,
      "lineEnd": 18,
      "language": "bash",
      "code": "# Load a robot from URDF\nhorus sim3d --robot my_robot.urdf\n\n# Load with custom world\nhorus sim3d --robot my_robot.urdf --world warehouse.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:35:xml",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 35,
      "lineEnd": 95,
      "language": "xml",
      "code": "<?xml version=\"1.0\"?>\n<robot name=\"simple_arm\">\n  <!-- Base link (fixed to world) -->\n  <link name=\"base_link\">\n    <visual>\n      <geometry>\n        <box size=\"0.2 0.2 0.1\"/>\n      </geometry>\n      <material name=\"gray\">\n        <color rgba=\"0.5 0.5 0.5 1\"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size=\"0.2 0.2 0.1\"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value=\"2.0\"/>\n      <inertia ixx=\"0.01\" ixy=\"0\" ixz=\"0\"\n               iyy=\"0.01\" iyz=\"0\" izz=\"0.01\"/>\n    </inertial>\n  </link>\n\n  <!-- First link -->\n  <link name=\"link1\">\n    <visual>\n      <origin xyz=\"0 0 0.25\"/>\n      <geometry>\n        <cylinder radius=\"0.05\" length=\"0.5\"/>\n      </geometry>\n      <material name=\"blue\">\n        <color rgba=\"0.2 0.2 0.8 1\"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz=\"0 0 0.25\"/>\n      <geometry>\n        <cylinder radius=\"0.05\" length=\"0.5\"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value=\"1.0\"/>\n      <origin xyz=\"0 0 0.25\"/>\n      <inertia ixx=\"0.02\" ixy=\"0\" ixz=\"0\"\n               iyy=\"0.02\" iyz=\"0\" izz=\"0.005\"/>\n    </inertial>\n  </link>\n\n  <!-- Joint connecting base to link1 -->\n  <joint name=\"joint1\" type=\"revolute\">\n    <parent link=\"base_link\"/>\n    <child link=\"link1\"/>\n    <origin xyz=\"0 0 0.05\"/>\n    <axis xyz=\"0 0 1\"/>\n    <limit lower=\"-3.14\" upper=\"3.14\"\n           velocity=\"2.0\" effort=\"100\"/>\n  </joint>\n</robot>",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:99:bash",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 99,
      "lineEnd": 114,
      "language": "bash",
      "code": "# TurtleBot3 Burger\nhorus sim3d --preset turtlebot3_burger\n\n# TurtleBot3 Waffle\nhorus sim3d --preset turtlebot3_waffle\n\n# Simple differential drive\nhorus sim3d --preset diff_drive\n\n# 6-DOF arm\nhorus sim3d --preset arm_6dof\n\n# Quadruped\nhorus sim3d --preset quadruped",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:120:rust",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 120,
      "lineEnd": 126,
      "language": "rust",
      "code": "use sim3d::{Sim3DBuilder, RobotConfig};\n\nlet sim = Sim3DBuilder::new()\n    .with_robot(RobotConfig::from_urdf(\"robot.urdf\")?)\n    .build()?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:130:python",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 130,
      "lineEnd": 134,
      "language": "python",
      "code": "from horus.sim3d import Sim3D\n\nsim = Sim3D(robot=\"robot.urdf\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:140:bash",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 140,
      "lineEnd": 146,
      "language": "bash",
      "code": "# Spawn at specific position\nhorus sim3d --robot robot.urdf --spawn-position 1.0,2.0,0.5\n\n# Spawn with rotation (yaw in radians)\nhorus sim3d --robot robot.urdf --spawn-rotation 1.57",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:150:yaml",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 150,
      "lineEnd": 156,
      "language": "yaml",
      "code": "# world.yaml\nrobots:\n  - urdf: \"robot.urdf\"\n    position: [1.0, 2.0, 0.5]\n    rotation: [0.0, 0.0, 1.57]  # Roll, pitch, yaw",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:162:yaml",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 162,
      "lineEnd": 174,
      "language": "yaml",
      "code": "# multi_robot.yaml\nrobots:\n  - urdf: \"turtlebot.urdf\"\n    name: \"robot1\"\n    position: [-2.0, 0.0, 0.0]\n    topic_prefix: \"robot1\"\n\n  - urdf: \"turtlebot.urdf\"\n    name: \"robot2\"\n    position: [2.0, 0.0, 0.0]\n    topic_prefix: \"robot2\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:176:bash",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 176,
      "lineEnd": 178,
      "language": "bash",
      "code": "horus sim3d --world multi_robot.yaml",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:184:text",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 184,
      "lineEnd": 193,
      "language": "text",
      "code": "my_robot/\n├── robot.urdf\n├── meshes/\n│   ├── base.stl\n│   ├── link1.stl\n│   └── link2.stl\n└── textures/\n    └── metal.png",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/getting-started/robots:197:xml",
      "file": "content/docs/simulators/sim3d/getting-started/robots.mdx",
      "lineStart": 197,
      "lineEnd": 203,
      "language": "xml",
      "code": "<visual>\n  <geometry>\n    <mesh filename=\"meshes/base.stl\" scale=\"1 1 1\"/>\n  </geometry>\n</visual>",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:24:bash",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 24,
      "lineEnd": 30,
      "language": "bash",
      "code": "# Run sim3d with a URDF robot\nhorus sim3d --robot models/robot.urdf --world configs/scene.yaml\n\n# Headless mode for training\nhorus sim3d --headless --robot models/robot.urdf",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:34:text",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 34,
      "lineEnd": 45,
      "language": "text",
      "code": "sim3d/\n├── sensors/       # Camera, LiDAR, IMU, force sensors\n├── physics/       # Rigid body, soft body, GPU physics\n├── rl/            # Reinforcement learning tasks\n├── rendering/     # Materials, lighting, post-processing\n├── robot/         # Robot loading and articulation\n├── scene/         # Scene management and spawning\n├── recording/     # Trajectory and video recording\n├── editor/        # Scene editing tools\n└── horus_bridge/  # HORUS topic integration",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:90:bash",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 90,
      "lineEnd": 92,
      "language": "bash",
      "code": "horus run --enable python,editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:96:yaml",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 96,
      "lineEnd": 100,
      "language": "yaml",
      "code": "enable:\n  - python\n  - editor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:103:bash",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 103,
      "lineEnd": 105,
      "language": "bash",
      "code": "horus sim3d",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:111:toml",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 111,
      "lineEnd": 114,
      "language": "toml",
      "code": "[dependencies]\nsim3d = { version = \"0.1\", features = [\"python\", \"editor\"] }",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/index:116:bash",
      "file": "content/docs/simulators/sim3d/index.mdx",
      "lineStart": 116,
      "lineEnd": 118,
      "language": "bash",
      "code": "cargo run -p sim3d --features \"python,editor\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:23:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 23,
      "lineEnd": 41,
      "language": "yaml",
      "code": "# scene.yaml\nphysics:\n  gravity: [0.0, -9.81, 0.0]\n  timestep: 0.001           # 1ms fixed timestep\n  substeps: 4               # Physics substeps per frame\n  solver_iterations: 8\n  stabilization: 0.8\n\n  # Contact parameters\n  contact:\n    max_velocity: 100.0\n    prediction_distance: 0.002\n\n  # Joint solver\n  joints:\n    warmstart: true\n    compliance: 0.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:43:bash",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 43,
      "lineEnd": 46,
      "language": "bash",
      "code": "# CLI options\nhorus sim3d --timestep 0.001 --substeps 4 --gravity -9.81",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:52:rust",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 52,
      "lineEnd": 73,
      "language": "rust",
      "code": "use sim3d::physics::{RigidBodyType, RigidBodyConfig};\n\n// Dynamic - affected by forces\nlet dynamic = RigidBodyConfig {\n    body_type: RigidBodyType::Dynamic,\n    mass: 1.0,\n    ..Default::default()\n};\n\n// Kinematic - moved by user, affects others\nlet kinematic = RigidBodyConfig {\n    body_type: RigidBodyType::KinematicPositionBased,\n    ..Default::default()\n};\n\n// Static - immovable\nlet static_body = RigidBodyConfig {\n    body_type: RigidBodyType::Static,\n    ..Default::default()\n};",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:77:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 77,
      "lineEnd": 100,
      "language": "yaml",
      "code": "objects:\n  - name: box\n    type: rigid_body\n    shape: box\n    size: [1.0, 1.0, 1.0]\n    position: [0, 2, 0]\n    physics:\n      mass: 5.0\n      friction: 0.5\n      restitution: 0.3\n      linear_damping: 0.1\n      angular_damping: 0.1\n\n  - name: sphere\n    type: rigid_body\n    shape: sphere\n    radius: 0.5\n    position: [0, 5, 0]\n    physics:\n      mass: 2.0\n      friction: 0.8\n      restitution: 0.9",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:106:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 106,
      "lineEnd": 130,
      "language": "yaml",
      "code": "colliders:\n  # Box\n  - shape: box\n    size: [1.0, 2.0, 0.5]  # half-extents\n\n  # Sphere\n  - shape: sphere\n    radius: 0.5\n\n  # Capsule\n  - shape: capsule\n    radius: 0.3\n    height: 1.0\n\n  # Cylinder\n  - shape: cylinder\n    radius: 0.5\n    height: 2.0\n\n  # Cone\n  - shape: cone\n    radius: 0.5\n    height: 1.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:134:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 134,
      "lineEnd": 154,
      "language": "yaml",
      "code": "colliders:\n  # Convex hull from mesh\n  - shape: convex_hull\n    mesh: models/part.obj\n\n  # Triangle mesh (static only)\n  - shape: trimesh\n    mesh: models/terrain.obj\n\n  # Compound shape\n  - shape: compound\n    children:\n      - shape: box\n        size: [1, 0.5, 1]\n        offset: [0, 0, 0]\n      - shape: cylinder\n        radius: 0.3\n        height: 1.0\n        offset: [0, 0.75, 0]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:160:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 160,
      "lineEnd": 181,
      "language": "yaml",
      "code": "materials:\n  rubber:\n    friction: 1.2\n    restitution: 0.8\n    density: 1100.0\n\n  metal:\n    friction: 0.4\n    restitution: 0.1\n    density: 7800.0\n\n  ice:\n    friction: 0.05\n    restitution: 0.1\n    density: 917.0\n\nobjects:\n  - name: wheel\n    material: rubber\n    # ...",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:187:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 187,
      "lineEnd": 199,
      "language": "yaml",
      "code": "joints:\n  - name: wheel_joint\n    type: revolute\n    parent: chassis\n    child: wheel\n    anchor: [0.5, 0, 0]\n    axis: [0, 0, 1]\n    limits: [-3.14, 3.14]  # Optional angle limits\n    motor:\n      target_velocity: 10.0\n      max_torque: 100.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:203:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 203,
      "lineEnd": 216,
      "language": "yaml",
      "code": "joints:\n  - name: lift_joint\n    type: prismatic\n    parent: base\n    child: platform\n    anchor: [0, 0, 0]\n    axis: [0, 1, 0]\n    limits: [0.0, 2.0]  # meters\n    motor:\n      target_position: 1.0\n      stiffness: 1000.0\n      damping: 100.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:220:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 220,
      "lineEnd": 227,
      "language": "yaml",
      "code": "joints:\n  - name: mount\n    type: fixed\n    parent: robot\n    child: sensor\n    anchor: [0.1, 0, 0.2]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:231:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 231,
      "lineEnd": 238,
      "language": "yaml",
      "code": "joints:\n  - name: shoulder\n    type: ball\n    parent: torso\n    child: upper_arm\n    anchor: [0.2, 0.5, 0]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:242:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 242,
      "lineEnd": 252,
      "language": "yaml",
      "code": "joints:\n  - name: custom_joint\n    type: generic\n    parent: a\n    child: b\n    locked_axes: [false, false, true, true, true, false]  # x, y, z, rx, ry, rz\n    limits:\n      x: [-1.0, 1.0]\n      rz: [-1.57, 1.57]",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:260:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 260,
      "lineEnd": 269,
      "language": "yaml",
      "code": "joints:\n  - name: arm_joint\n    type: revolute\n    controller:\n      type: position\n      kp: 1000.0\n      kd: 100.0\n      max_torque: 50.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:273:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 273,
      "lineEnd": 281,
      "language": "yaml",
      "code": "joints:\n  - name: wheel_joint\n    type: revolute\n    controller:\n      type: velocity\n      kp: 10.0\n      max_torque: 20.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:285:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 285,
      "lineEnd": 292,
      "language": "yaml",
      "code": "joints:\n  - name: motor_joint\n    type: revolute\n    controller:\n      type: torque\n      max_torque: 100.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:298:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 298,
      "lineEnd": 310,
      "language": "yaml",
      "code": "robots:\n  - name: mobile_robot\n    drive:\n      type: differential\n      wheel_radius: 0.1\n      wheel_separation: 0.5\n      max_linear_velocity: 2.0\n      max_angular_velocity: 3.14\n      wheel_joints: [left_wheel, right_wheel]\n      cmd_topic: cmd_vel\n      odom_topic: odom",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:316:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 316,
      "lineEnd": 336,
      "language": "yaml",
      "code": "objects:\n  - name: cushion\n    type: soft_body\n    mesh: models/cushion.obj\n    physics:\n      mass: 0.5\n      stiffness: 1000.0\n      damping: 10.0\n      volume_preservation: 0.9\n\n  - name: rope\n    type: soft_body\n    shape: rope\n    length: 2.0\n    segments: 20\n    physics:\n      mass: 0.1\n      bend_stiffness: 100.0\n      stretch_stiffness: 10000.0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:342:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 342,
      "lineEnd": 356,
      "language": "yaml",
      "code": "collision_groups:\n  robot: 0x0001\n  environment: 0x0002\n  sensor_rays: 0x0004\n\nobjects:\n  - name: robot_base\n    collision_group: robot\n    collision_filter: environment  # Only collide with environment\n\n  - name: lidar_rays\n    collision_group: sensor_rays\n    collision_filter: environment | robot  # Collide with both",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:362:rust",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 362,
      "lineEnd": 378,
      "language": "rust",
      "code": "use sim3d::physics::ContactEvent;\n\nlet contact_hub = Hub::<ContactEvent>::new(\"physics.contacts\")?;\n\n// In your node\nif let Some(event) = contact_hub.recv(&mut ctx) {\n    match event {\n        ContactEvent::Started { body1, body2, point, normal, impulse } => {\n            println!(\"Collision between {} and {} at {:?}\", body1, body2, point);\n        }\n        ContactEvent::Ended { body1, body2 } => {\n            println!(\"Separation: {} and {}\", body1, body2);\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:384:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 384,
      "lineEnd": 394,
      "language": "yaml",
      "code": "physics:\n  gpu:\n    enabled: true\n    device: 0\n\n  # Particle systems benefit most from GPU\n  particles:\n    enabled: true\n    max_particles: 1000000",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:396:bash",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 396,
      "lineEnd": 398,
      "language": "bash",
      "code": "horus sim3d --gpu-physics --device 0",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:413:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 413,
      "lineEnd": 418,
      "language": "yaml",
      "code": "physics:\n  solver_iterations: 4   # Fast but less accurate\n  solver_iterations: 8   # Default - good balance\n  solver_iterations: 16  # High accuracy for complex assemblies",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/physics/overview:422:yaml",
      "file": "content/docs/simulators/sim3d/physics/overview.mdx",
      "lineStart": 422,
      "lineEnd": 428,
      "language": "yaml",
      "code": "physics:\n  # More substeps = more stable high-speed interactions\n  substeps: 1   # Fast, may miss fast collisions\n  substeps: 4   # Default\n  substeps: 8   # High-speed projectiles, fast robots",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:23:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 23,
      "lineEnd": 43,
      "language": "python",
      "code": "import gymnasium as gym\nimport sim3d\n\n# Create environment\nenv = sim3d.make(\"Reaching-v1\",\n    robot=\"models/robot_arm.urdf\",\n    render_mode=\"human\"\n)\n\n# Standard Gym loop\nobs, info = env.reset()\nfor _ in range(1000):\n    action = env.action_space.sample()\n    obs, reward, terminated, truncated, info = env.step(action)\n\n    if terminated or truncated:\n        obs, info = env.reset()\n\nenv.close()",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:47:rust",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 47,
      "lineEnd": 65,
      "language": "rust",
      "code": "use sim3d::rl::{Environment, ReachingTask, TaskConfig};\n\nlet config = TaskConfig::default()\n    .with_robot(\"models/robot_arm.urdf\")\n    .with_max_steps(1000);\n\nlet mut env = Environment::new(ReachingTask::new(config))?;\n\nlet obs = env.reset()?;\nloop {\n    let action = policy.get_action(&obs);\n    let (obs, reward, done, info) = env.step(action)?;\n\n    if done {\n        break;\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:73:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 73,
      "lineEnd": 80,
      "language": "python",
      "code": "env = sim3d.make(\"Reaching-v1\",\n    robot=\"models/robot_arm.urdf\",\n    target_range=[0.3, 0.8],     # Target distance range\n    goal_threshold=0.02,          # Success threshold (meters)\n    sparse_reward=False,          # Dense or sparse reward\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:90:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 90,
      "lineEnd": 96,
      "language": "python",
      "code": "env = sim3d.make(\"Push-v1\",\n    robot=\"models/robot_arm.urdf\",\n    object_shape=\"box\",\n    object_size=[0.05, 0.05, 0.05],\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:106:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 106,
      "lineEnd": 112,
      "language": "python",
      "code": "env = sim3d.make(\"Manipulation-v1\",\n    robot=\"models/robot_arm_gripper.urdf\",\n    objects=[\"cube\", \"sphere\", \"cylinder\"],\n    num_objects=3,\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:122:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 122,
      "lineEnd": 128,
      "language": "python",
      "code": "env = sim3d.make(\"Navigation-v1\",\n    robot=\"models/diff_drive.urdf\",\n    map=\"maps/warehouse.yaml\",\n    goal_sampling=\"random\",\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:138:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 138,
      "lineEnd": 144,
      "language": "python",
      "code": "env = sim3d.make(\"Locomotion-v1\",\n    robot=\"models/quadruped.urdf\",\n    terrain=\"flat\",              # flat, rough, stairs\n    target_velocity=1.0,          # m/s\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:154:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 154,
      "lineEnd": 159,
      "language": "python",
      "code": "env = sim3d.make(\"Balancing-v1\",\n    robot=\"models/cartpole.urdf\",\n    max_angle=0.4,               # radians\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:169:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 169,
      "lineEnd": 183,
      "language": "python",
      "code": "from sim3d.rl import CurriculumConfig\n\nenv = sim3d.make(\"Reaching-v1\",\n    curriculum=CurriculumConfig(\n        stages=[\n            {\"target_range\": [0.2, 0.3], \"threshold\": 0.05},\n            {\"target_range\": [0.3, 0.5], \"threshold\": 0.03},\n            {\"target_range\": [0.3, 0.8], \"threshold\": 0.02},\n        ],\n        advance_threshold=0.8,    # Success rate to advance\n        window_size=100,          # Episodes to track\n    )\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:187:yaml",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 187,
      "lineEnd": 206,
      "language": "yaml",
      "code": "curriculum:\n  stages:\n    - name: easy\n      config:\n        target_range: [0.2, 0.3]\n        goal_threshold: 0.05\n      advance_threshold: 0.8\n\n    - name: medium\n      config:\n        target_range: [0.3, 0.5]\n        goal_threshold: 0.03\n      advance_threshold: 0.8\n\n    - name: hard\n      config:\n        target_range: [0.3, 0.8]\n        goal_threshold: 0.02",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:214:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 214,
      "lineEnd": 226,
      "language": "python",
      "code": "from sim3d.rl import DomainRandomization\n\nenv = sim3d.make(\"Reaching-v1\",\n    domain_randomization=DomainRandomization(\n        visual=True,\n        camera_position_noise=0.05,\n        lighting_intensity_range=[0.5, 2.0],\n        texture_randomization=True,\n        color_jitter=0.2,\n    )\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:230:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 230,
      "lineEnd": 240,
      "language": "python",
      "code": "env = sim3d.make(\"Manipulation-v1\",\n    domain_randomization=DomainRandomization(\n        physics=True,\n        mass_range=[0.8, 1.2],         # Scale factor\n        friction_range=[0.5, 1.5],\n        joint_damping_range=[0.9, 1.1],\n        actuator_noise=0.05,\n    )\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:244:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 244,
      "lineEnd": 253,
      "language": "python",
      "code": "env = sim3d.make(\"Navigation-v1\",\n    domain_randomization=DomainRandomization(\n        environment=True,\n        obstacle_density_range=[0.1, 0.4],\n        obstacle_size_range=[0.3, 1.0],\n        goal_position_noise=0.1,\n    )\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:259:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 259,
      "lineEnd": 277,
      "language": "python",
      "code": "from sim3d.rl import RewardConfig, RewardComponent\n\nenv = sim3d.make(\"Manipulation-v1\",\n    reward=RewardConfig(\n        components=[\n            RewardComponent(\"distance_to_object\", weight=-1.0),\n            RewardComponent(\"grasp_success\", weight=10.0, sparse=True),\n            RewardComponent(\"lift_height\", weight=5.0),\n            RewardComponent(\"distance_to_goal\", weight=-1.0),\n            RewardComponent(\"place_success\", weight=20.0, sparse=True),\n            RewardComponent(\"action_penalty\", weight=-0.01),\n            RewardComponent(\"collision_penalty\", weight=-5.0, sparse=True),\n        ],\n        normalize=True,\n        clip_range=[-10, 10],\n    )\n)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:296:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 296,
      "lineEnd": 308,
      "language": "python",
      "code": "import sim3d\n\n# Vector environment (CPU)\nenvs = sim3d.make_vec(\"Reaching-v1\", num_envs=16)\n\n# GPU-accelerated (requires CUDA)\nenvs = sim3d.make_vec(\"Reaching-v1\", num_envs=1024, device=\"cuda:0\")\n\n# Step all envs\nactions = policy.get_actions(observations)\nobservations, rewards, dones, infos = envs.step(actions)",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:314:bash",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 314,
      "lineEnd": 320,
      "language": "bash",
      "code": "# CLI\nhorus sim3d --headless --env Reaching-v1 --num-envs 64\n\n# Python\nenv = sim3d.make(\"Reaching-v1\", render_mode=None)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:326:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 326,
      "lineEnd": 334,
      "language": "python",
      "code": "from stable_baselines3 import PPO\nimport sim3d\n\nenv = sim3d.make(\"Reaching-v1\")\nmodel = PPO(\"MlpPolicy\", env, verbose=1)\nmodel.learn(total_timesteps=1_000_000)\nmodel.save(\"reaching_policy\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:338:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 338,
      "lineEnd": 350,
      "language": "python",
      "code": "from ray.rllib.algorithms.ppo import PPOConfig\nimport sim3d\n\nconfig = PPOConfig().environment(\n    env=\"sim3d:Reaching-v1\",\n    env_config={\"robot\": \"models/robot_arm.urdf\"}\n)\nalgo = config.build()\nfor i in range(100):\n    result = algo.train()\n    print(f\"Episode {i}: reward={result['episode_reward_mean']}\")",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:354:python",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 354,
      "lineEnd": 360,
      "language": "python",
      "code": "import sim3d\nimport cleanrl_utils\n\nenv = sim3d.make(\"Locomotion-v1\")\n# Use CleanRL's PPO implementation",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/rl/overview:366:rust",
      "file": "content/docs/simulators/sim3d/rl/overview.mdx",
      "lineStart": 366,
      "lineEnd": 404,
      "language": "rust",
      "code": "use sim3d::rl::{Task, Observation, Action, StepResult};\n\npub struct MyCustomTask {\n    // Task state\n}\n\nimpl Task for MyCustomTask {\n    fn observation_space(&self) -> ObservationSpace {\n        ObservationSpace::Box {\n            low: vec![-1.0; 10],\n            high: vec![1.0; 10],\n        }\n    }\n\n    fn action_space(&self) -> ActionSpace {\n        ActionSpace::Box {\n            low: vec![-1.0; 4],\n            high: vec![1.0; 4],\n        }\n    }\n\n    fn reset(&mut self) -> Observation {\n        // Reset task state\n        self.get_observation()\n    }\n\n    fn step(&mut self, action: Action) -> StepResult {\n        // Apply action, compute reward\n        StepResult {\n            observation: self.get_observation(),\n            reward: self.compute_reward(),\n            terminated: self.is_success(),\n            truncated: self.step_count >= self.max_steps,\n            info: HashMap::new(),\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:33:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 33,
      "lineEnd": 59,
      "language": "yaml",
      "code": "# scene.yaml\nsensors:\n  - name: front_camera\n    type: camera\n    parent: base_link\n    position: [0.2, 0, 0.3]\n    rotation: [0, 0, 0]\n    config:\n      width: 640\n      height: 480\n      fov: 60.0\n      fps: 30.0\n      topic: camera.front\n\n  - name: main_lidar\n    type: lidar3d\n    parent: base_link\n    position: [0, 0, 0.5]\n    config:\n      channels: 16\n      range: 100.0\n      fov_up: 15.0\n      fov_down: -15.0\n      rpm: 600\n      topic: lidar.scan",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:65:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 65,
      "lineEnd": 84,
      "language": "yaml",
      "code": "type: camera\nconfig:\n  width: 1280\n  height: 720\n  fov: 70.0              # Horizontal field of view (degrees)\n  fps: 30.0\n  near_clip: 0.1\n  far_clip: 1000.0\n  distortion:\n    model: brown_conrady  # or fisheye, equidistant\n    k1: 0.0\n    k2: 0.0\n    p1: 0.0\n    p2: 0.0\n  noise:\n    type: gaussian\n    std: 0.01\n  topic: camera.rgb",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:94:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 94,
      "lineEnd": 108,
      "language": "yaml",
      "code": "type: depth\nconfig:\n  width: 640\n  height: 480\n  fov: 87.0\n  fps: 30.0\n  min_depth: 0.1\n  max_depth: 10.0\n  noise:\n    type: depth_quadratic  # Noise increases with distance\n    base_std: 0.001\n    distance_factor: 0.01\n  topic: camera.depth",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:117:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 117,
      "lineEnd": 128,
      "language": "yaml",
      "code": "type: rgbd\nconfig:\n  width: 640\n  height: 480\n  fov: 87.0\n  fps: 30.0\n  min_depth: 0.1\n  max_depth: 10.0\n  align_depth: true\n  topic: camera.rgbd",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:139:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 139,
      "lineEnd": 153,
      "language": "yaml",
      "code": "type: lidar3d\nconfig:\n  channels: 16           # Vertical beams (16, 32, 64, 128)\n  points_per_channel: 1800\n  range: 100.0           # Max range (meters)\n  fov_up: 15.0           # Upper vertical FOV (degrees)\n  fov_down: -15.0        # Lower vertical FOV (degrees)\n  rpm: 600               # Rotations per minute\n  noise:\n    type: gaussian\n    range_std: 0.02\n    angle_std: 0.001\n  topic: lidar.scan",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:163:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 163,
      "lineEnd": 172,
      "language": "yaml",
      "code": "type: imu\nconfig:\n  rate: 200.0            # Hz\n  accel_noise: 0.01      # m/s² std\n  gyro_noise: 0.001      # rad/s std\n  accel_bias: 0.0001     # Bias random walk\n  gyro_bias: 0.00001\n  topic: imu.data",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:181:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 181,
      "lineEnd": 193,
      "language": "yaml",
      "code": "type: gps\nconfig:\n  rate: 10.0             # Hz\n  horizontal_accuracy: 2.0  # meters CEP\n  vertical_accuracy: 4.0\n  fix_type: 3d           # none, 2d, 3d, rtk_float, rtk_fixed\n  origin:                # World origin in lat/lon\n    latitude: 37.7749\n    longitude: -122.4194\n    altitude: 0.0\n  topic: gps.fix",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:203:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 203,
      "lineEnd": 210,
      "language": "yaml",
      "code": "type: encoder\nconfig:\n  joints: [wheel_left, wheel_right]\n  resolution: 4096       # Ticks per revolution\n  noise_std: 0.001\n  topic: encoders",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:219:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 219,
      "lineEnd": 229,
      "language": "yaml",
      "code": "type: force_torque\nconfig:\n  rate: 1000.0           # Hz\n  force_range: 100.0     # N\n  torque_range: 10.0     # Nm\n  noise:\n    force_std: 0.1\n    torque_std: 0.01\n  topic: ft_sensor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:238:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 238,
      "lineEnd": 247,
      "language": "yaml",
      "code": "type: tactile\nconfig:\n  rows: 16\n  cols: 16\n  rate: 100.0\n  sensitivity: 0.01      # N\n  max_pressure: 100.0    # N\n  topic: tactile.gripper",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:256:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 256,
      "lineEnd": 265,
      "language": "yaml",
      "code": "type: event_camera\nconfig:\n  width: 346\n  height: 260\n  threshold_pos: 0.2     # Positive event threshold\n  threshold_neg: 0.2     # Negative event threshold\n  refractory_period: 1.0 # μs\n  topic: events",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:274:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 274,
      "lineEnd": 283,
      "language": "yaml",
      "code": "type: radar\nconfig:\n  range: 200.0           # meters\n  fov: 120.0             # degrees\n  range_resolution: 0.5\n  velocity_resolution: 0.1\n  rate: 20.0\n  topic: radar.detections",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:292:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 292,
      "lineEnd": 300,
      "language": "yaml",
      "code": "type: sonar\nconfig:\n  range: 5.0             # meters\n  fov: 30.0              # degrees (cone angle)\n  rate: 10.0\n  noise_std: 0.02\n  topic: sonar.range",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:309:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 309,
      "lineEnd": 320,
      "language": "yaml",
      "code": "type: thermal\nconfig:\n  width: 320\n  height: 240\n  fov: 50.0\n  fps: 30.0\n  min_temp: -20.0        # °C\n  max_temp: 150.0\n  noise_std: 0.5         # °C\n  topic: thermal.image",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:329:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 329,
      "lineEnd": 343,
      "language": "yaml",
      "code": "type: segmentation\nconfig:\n  width: 640\n  height: 480\n  mode: semantic         # semantic or instance\n  classes:\n    - name: floor\n      color: [128, 128, 128]\n    - name: wall\n      color: [0, 0, 255]\n    - name: robot\n      color: [255, 0, 0]\n  topic: segmentation",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:353:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 353,
      "lineEnd": 372,
      "language": "yaml",
      "code": "noise:\n  # Gaussian noise\n  type: gaussian\n  std: 0.01\n\n  # Uniform noise\n  type: uniform\n  min: -0.01\n  max: 0.01\n\n  # Salt-and-pepper (for cameras)\n  type: salt_pepper\n  probability: 0.001\n\n  # Depth-dependent (for depth cameras)\n  type: depth_quadratic\n  base_std: 0.001\n  distance_factor: 0.01",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/simulators/sim3d/sensors/overview:378:yaml",
      "file": "content/docs/simulators/sim3d/sensors/overview.mdx",
      "lineStart": 378,
      "lineEnd": 399,
      "language": "yaml",
      "code": "distortion:\n  # Brown-Conrady (standard pinhole)\n  model: brown_conrady\n  k1: -0.1    # Radial distortion\n  k2: 0.01\n  k3: 0.0\n  p1: 0.0     # Tangential distortion\n  p2: 0.0\n\n  # Fisheye (wide-angle)\n  model: fisheye\n  k1: -0.2\n  k2: 0.05\n  k3: 0.0\n  k4: 0.0\n\n  # Equidistant\n  model: equidistant\n  k1: -0.15\n  k2: 0.03",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:28:text",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 28,
      "lineEnd": 31,
      "language": "text",
      "code": "Error: Failed to create `Hub<MyMessage>`\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:76:text",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 76,
      "lineEnd": 78,
      "language": "text",
      "code": "thread 'main' panicked at 'Failed to create publisher 'camera': No such file or directory'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:84:text",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 84,
      "lineEnd": 87,
      "language": "text",
      "code": "Topic: \"sensors.camera\"  →  /dev/shm/horus_default_sensors/camera  (FAILS!)\nTopic: \"sensors.camera\"  →  /dev/shm/horus_default_sensors.camera  (Works!)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:91:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 91,
      "lineEnd": 99,
      "language": "rust",
      "code": "// WRONG - causes \"No such file or directory\"\nlet hub = Hub::new(\"sensors.camera\")?;\nlet hub = Hub::new(\"robot.cmd_vel\")?;\n\n// CORRECT - use dots\nlet hub = Hub::new(\"sensors.camera\")?;\nlet hub = Hub::new(\"robot.cmd_vel\")?;",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:254:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 254,
      "lineEnd": 274,
      "language": "rust",
      "code": "// BAD: Variable size\n#[derive(Clone, Serialize, Deserialize)]\npub struct LargeMessage {\n    pub data: Vec<u8>,  // Can be any size - may exceed limit\n}\n\n// GOOD: Fixed size\n#[derive(Clone, Serialize, Deserialize)]\npub struct LargeMessage {\n    pub data: [u8; 4096],  // Fixed 4KB\n}\n\n// BETTER: Split into multiple messages\n#[derive(Clone, Serialize, Deserialize)]\npub struct MessageChunk {\n    pub chunk_id: u32,\n    pub total_chunks: u32,\n    pub data: [u8; 1024],\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:286:toml",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 286,
      "lineEnd": 290,
      "language": "toml",
      "code": "[dependencies]\nhorus = \"0.1\"\nhorus_library = \"0.1\"  # For standard messages",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:293:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 293,
      "lineEnd": 296,
      "language": "rust",
      "code": "use horus::prelude::*;\nuse horus::prelude::*; // Provides *;  // For CmdVel, LaserScan, etc.",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:303:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 303,
      "lineEnd": 309,
      "language": "rust",
      "code": "// Add these three derives to all messages\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MyMessage {\n    pub field: f32,\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:319:bash",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 319,
      "lineEnd": 322,
      "language": "bash",
      "code": "# In a separate terminal\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:373:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 373,
      "lineEnd": 380,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    ctx.log_debug(\"Detailed info for debugging\");\n    ctx.log_info(\"Normal informational message\");\n    ctx.log_warning(\"Something unusual happened\");\n    ctx.log_error(\"Something went wrong!\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:383:bash",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 383,
      "lineEnd": 385,
      "language": "bash",
      "code": "RUST_LOG=debug horus run main.rs",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:391:text",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 391,
      "lineEnd": 397,
      "language": "text",
      "code": "[1234567890123456789] [INFO] [SensorNode] Sensor initialized\n│                     │      │           │\n│                     │      │           └─ Node name\n│                     │      └─ Log level\n│                     └─ Timestamp (nanoseconds since epoch)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:400:text",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 400,
      "lineEnd": 404,
      "language": "text",
      "code": "Event 1: 1234567890123456789\nEvent 2: 1234567890623456789\nDiff:                500000000 (500ms)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:412:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 412,
      "lineEnd": 419,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(msg) = self.hub.recv(&mut ctx) {\n        // Process message\n    }\n    // No message? That's OK, just continue\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:423:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 423,
      "lineEnd": 427,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let msg = self.hub.recv(&mut ctx).unwrap();  // PANIC if no message!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:431:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 431,
      "lineEnd": 440,
      "language": "rust",
      "code": "impl Node for MyNode {\n    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n        if self.sensor.is_broken() {\n            return Err(\"Sensor initialization failed\".into());\n        }\n        Ok(())\n    }\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting-runtime:444:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 444,
      "lineEnd": 451,
      "language": "rust",
      "code": "fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {\n    if self.sensor.is_broken() {\n        panic!(\"Sensor broken\");  // DON'T DO THIS\n    }\n    Ok(())\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:455:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 455,
      "lineEnd": 461,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Quick operations only\n    let data = self.sensor.read_cached();\n    self.hub.send(data, &mut ctx).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting-runtime:465:rust",
      "file": "content/docs/troubleshooting-runtime.mdx",
      "lineStart": 465,
      "lineEnd": 470,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    thread::sleep(Duration::from_millis(100));  // Blocks everything!\n    let data = self.network.fetch();  // Network I/O blocks!\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:25:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 25,
      "lineEnd": 29,
      "language": "bash",
      "code": "cd /path/to/horus\ngit pull\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:32:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 32,
      "lineEnd": 37,
      "language": "bash",
      "code": "git fetch\ngit log HEAD..@{u}  # See what's new\ngit pull\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:40:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 40,
      "lineEnd": 45,
      "language": "bash",
      "code": "git stash\ngit pull\n./install.sh\ngit stash pop  # Restore your changes",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:55:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 55,
      "lineEnd": 57,
      "language": "bash",
      "code": "./verify.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:88:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 88,
      "lineEnd": 141,
      "language": "bash",
      "code": "\n   HORUS Installation Verification\n\n\nSystem Requirements:\n\n   Rust: 1.75.0 (>= 1.70 required)\n   Cargo: 1.75.0\n   Build tools: GCC\n   pkg-config: 0.29.2\n\nSystem Libraries:\n\n   OpenSSL: 3.0.2\n   udev: Not found (optional for some features)\n\nHORUS Installation:\n\n   Binary: v0.1.0 at ~/.cargo/bin/horus\n   In PATH: Yes (correct binary)\n\nCore Libraries:\n\n   Installed version: 0.1.0\n   Main library: v0.1.0\n   Runtime core: v0.1.0\n   Proc macros: v0.1.0\n   Standard library: v0.1.0\n   Python bindings: Not installed (optional)\n\nFunctionality Tests:\n\n   Command: --help\n   All subcommands: Accessible\n\n   Running build verification...\n   Build: cargo check passes (0 warnings)\n   Binary: Debug build functional\n\nDisk Usage:\n\n   ~/.horus: 45M\n   Library cache: 42M\n   Cargo cache: 2.3G\n\n\nSummary:\n\n   Perfect! Everything looks good.\n\n  HORUS is properly installed and ready to use.\n",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/troubleshooting:147:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 147,
      "lineEnd": 158,
      "language": "bash",
      "code": "./verify.sh\nEXIT_CODE=$?\n\nif [ $EXIT_CODE -eq 0 ]; then\n    echo \"All good!\"\nelif [ $EXIT_CODE -eq 1 ]; then\n    echo \"Warnings found\"\nelse\n    echo \"Errors found\"\nfi",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:167:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 167,
      "lineEnd": 171,
      "language": "bash",
      "code": " 'horus' command not found in PATH\n  Add to shell profile (~/.bashrc, ~/.zshrc, etc.):\n  export PATH=\"$HOME/.cargo/bin:$PATH\"",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:174:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 174,
      "lineEnd": 177,
      "language": "bash",
      "code": " Rust: 1.65.0 (< 1.70, please update)\n  Update with: rustup update",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:180:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 180,
      "lineEnd": 184,
      "language": "bash",
      "code": " udev: Not found (optional for some features)\n  Ubuntu/Debian: sudo apt install libudev-dev\n  Fedora: sudo dnf install systemd-devel",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:194:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 194,
      "lineEnd": 209,
      "language": "bash",
      "code": "# Navigate to HORUS source directory\ncd /path/to/horus\n\n# 1. Clean build artifacts\ncargo clean\n\n# 2. Remove cached libraries\nrm -rf ~/.horus/cache\n\n# 3. Fresh install\n./install.sh\n\n# 4. Verify installation\n./verify.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:261:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 261,
      "lineEnd": 273,
      "language": "bash",
      "code": "# Remove everything HORUS-related\ncargo clean\nrm -rf ~/.horus\nrm -f ~/.cargo/bin/horus\nrm -f ~/.cargo/bin/sim2d\n\n# Fresh install\n./install.sh\n\n# Verify\n./verify.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:283:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 283,
      "lineEnd": 286,
      "language": "bash",
      "code": "$ ./install.sh\n Error: Rust is not installed",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:289:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 289,
      "lineEnd": 295,
      "language": "bash",
      "code": "# Install Rust\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Then try again\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:302:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 302,
      "lineEnd": 319,
      "language": "bash",
      "code": "# Ubuntu/Debian/Raspberry Pi OS - Install ALL required packages\nsudo apt update\nsudo apt install -y build-essential pkg-config \\\n  libssl-dev libudev-dev libasound2-dev \\\n  libx11-dev libxrandr-dev libxi-dev libxcursor-dev libxinerama-dev \\\n  libwayland-dev wayland-protocols libxkbcommon-dev \\\n  libvulkan-dev libfontconfig-dev libfreetype-dev \\\n  libv4l-dev\n\n# Fedora/RHEL\nsudo dnf groupinstall \"Development Tools\"\nsudo dnf install -y pkg-config openssl-devel systemd-devel alsa-lib-devel \\\n  libX11-devel libXrandr-devel libXi-devel libXcursor-devel libXinerama-devel \\\n  wayland-devel wayland-protocols-devel libxkbcommon-devel \\\n  vulkan-devel fontconfig-devel freetype-devel \\\n  libv4l-devel",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:325:text",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 325,
      "lineEnd": 328,
      "language": "text",
      "code": "error: linking with `cc` failed: exit status: 1\nerror: could not find native static library `X11`, perhaps an -L flag is missing?",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:331:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 331,
      "lineEnd": 344,
      "language": "bash",
      "code": "# Install ALL missing system libraries (most common cause)\n# Ubuntu/Debian/Raspberry Pi OS\nsudo apt update\nsudo apt install -y build-essential pkg-config \\\n  libssl-dev libudev-dev libasound2-dev \\\n  libx11-dev libxrandr-dev libxi-dev libxcursor-dev libxinerama-dev \\\n  libwayland-dev wayland-protocols libxkbcommon-dev \\\n  libvulkan-dev libfontconfig-dev libfreetype-dev \\\n  libv4l-dev\n\n# Or run manual recovery (see Manual Recovery section)\ncargo clean && rm -rf ~/.horus/cache && ./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:353:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 353,
      "lineEnd": 356,
      "language": "bash",
      "code": "# Try manual recovery\ncargo clean && rm -rf ~/.horus/cache && ./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:363:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 363,
      "lineEnd": 366,
      "language": "bash",
      "code": "# Force rebuild\n./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:375:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 375,
      "lineEnd": 385,
      "language": "bash",
      "code": "# Add to PATH (add to ~/.bashrc or ~/.zshrc)\nexport PATH=\"$HOME/.cargo/bin:$PATH\"\n\n# Then reload shell\nsource ~/.bashrc  # or restart terminal\n\n# Verify\nwhich horus\nhorus --help",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:391:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 391,
      "lineEnd": 394,
      "language": "bash",
      "code": "$ horus --help\nSegmentation fault",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:397:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 397,
      "lineEnd": 400,
      "language": "bash",
      "code": "# Full recovery\ncargo clean && rm -rf ~/.horus/cache && ./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:406:text",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 406,
      "lineEnd": 409,
      "language": "text",
      "code": "error: the package `horus` depends on `horus_core 0.1.0`,\nbut `horus_core 0.1.3` is installed",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:417:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 417,
      "lineEnd": 423,
      "language": "bash",
      "code": "# Clean cached build artifacts and dependencies\nhorus run --clean\n\n# This removes .horus/target/ and forces a fresh build\n# with the new version",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:428:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 428,
      "lineEnd": 434,
      "language": "bash",
      "code": "# Remove the entire .horus directory\nrm -rf .horus/\n\n# Next run will rebuild from scratch\nhorus run",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:437:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 437,
      "lineEnd": 442,
      "language": "bash",
      "code": "# Only needed if --clean doesn't work\n# This reinstalls HORUS libraries globally\ncd /path/to/horus\ncargo clean && rm -rf ~/.horus/cache && ./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:445:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 445,
      "lineEnd": 448,
      "language": "bash",
      "code": "# Clean all projects in your workspace\nfind ~/your-projects -type d -name \".horus\" -exec rm -rf {}/target/ \\;",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:454:text",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 454,
      "lineEnd": 456,
      "language": "text",
      "code": "Error: HORUS source directory not found. Please set HORUS_SOURCE environment variable.",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:459:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 459,
      "lineEnd": 473,
      "language": "bash",
      "code": "# Option 1: Set HORUS_SOURCE (recommended for non-standard installations)\nexport HORUS_SOURCE=/path/to/horus\necho 'export HORUS_SOURCE=/path/to/horus' >> ~/.bashrc\n\n# Option 2: Install HORUS to a standard location\n# The CLI checks these paths automatically:\n#   - ~/softmata/horus\n#   - /horus\n#   - /opt/horus\n#   - /usr/local/horus\n\n# Verify HORUS source is found\nhorus run --build-only",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:487:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 487,
      "lineEnd": 493,
      "language": "bash",
      "code": "# Use release mode (optimized)\nhorus run --release\n\n# Or configure in horus.yaml\nmode: release",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:500:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 500,
      "lineEnd": 510,
      "language": "bash",
      "code": "# Check usage\n./verify.sh\n\n# Clean old cargo cache\ncargo clean\n\n# Remove unused dependencies\ncargo install cargo-cache\ncargo cache --autoclean",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:522:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 522,
      "lineEnd": 534,
      "language": "bash",
      "code": "# Clean build artifacts in current project\nrm -rf .horus/target/\n\n# Or use horus clean flag (next build will be slower)\nhorus run --clean\n\n# Regular cleanup (if working on multiple projects)\nfind . -type d -name \".horus\" -exec rm -rf {}/target/ \\;\n\n# Add to .gitignore (already included in horus new templates)\necho \".horus/target/\" >> .gitignore",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:553:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 553,
      "lineEnd": 555,
      "language": "bash",
      "code": "git pull && ./install.sh  # Pulls latest and rebuilds",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:558:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 558,
      "lineEnd": 560,
      "language": "bash",
      "code": "./verify.sh  # Check for warnings",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:563:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 563,
      "lineEnd": 566,
      "language": "bash",
      "code": "# If Rust/GCC updated, run manual recovery\ncargo clean && rm -rf ~/.horus/cache && ./install.sh",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:570:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 570,
      "lineEnd": 581,
      "language": "bash",
      "code": "# In CI pipeline\n./verify.sh || (cargo clean && rm -rf ~/.horus/cache && ./install.sh)\n\n# Exit codes\nif ./verify.sh; then\n    echo \"Installation OK\"\nelse\n    echo \"Installation has issues, check logs\"\n    exit 1\nfi",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:639:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 639,
      "lineEnd": 642,
      "language": "rust",
      "code": "Error: Failed to create Hub\nthread 'main' panicked at 'Hub::new() failed'",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:651:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 651,
      "lineEnd": 663,
      "language": "bash",
      "code": "# Check /dev/shm permissions\nls -la /dev/shm\n\n# Check available space\ndf -h /dev/shm\n\n# Clean old HORUS shared memory\nrm -f /dev/shm/horus_*\n\n# Fix permissions (if needed)\nsudo chmod 1777 /dev/shm",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:666:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 666,
      "lineEnd": 675,
      "language": "rust",
      "code": "// Ensure topic names are valid (alphanumeric, underscore, slash)\n// Good:\nlet hub = Hub::new(\"sensor_data\")?;\nlet hub = Hub::new(\"robot.cmd_vel\")?;\n\n// Bad (will fail):\nlet hub = Hub::new(\"sensor data\")?;  // Space\nlet hub = Hub::new(\"temp@sensor\")?;  // Special char",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/troubleshooting:682:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 682,
      "lineEnd": 687,
      "language": "rust",
      "code": "// Subscriber never receives messages\nif let Some(data) = self.data_sub.recv(&mut ctx) {\n    println!(\"Got data\");  // Never prints\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:697:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 697,
      "lineEnd": 706,
      "language": "rust",
      "code": "// Publisher\nlet pub_hub = Hub::new(\"temperature\")?;  // Note: \"temperature\"\n\n// Subscriber (wrong - typo!)\nlet sub_hub = Hub::new(\"temperatur\")?;   // Missing 'e'\n\n// Fixed:\nlet sub_hub = Hub::new(\"temperature\")?;  // Now matches!",
      "verifiable": true,
      "flags": [
        "needs-wrapper",
        "uses-try-operator"
      ]
    },
    {
      "id": "content/docs/troubleshooting:709:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 709,
      "lineEnd": 722,
      "language": "rust",
      "code": "// Add logging to publisher\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    let data = 42.0;\n    match self.pub_hub.send(data, &mut ctx) {\n        Ok(()) => {\n        ctx.log_info(\"Published successfully\");\n        }\n        Err(_) => {\n        ctx.log_error(\"Publish failed!\");\n        }\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:725:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 725,
      "lineEnd": 731,
      "language": "bash",
      "code": "# Terminal 1: Run your app\nhorus run\n\n# Terminal 2: Open monitor\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:741:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 741,
      "lineEnd": 749,
      "language": "rust",
      "code": "let mut scheduler = Scheduler::new();\n\n// Publisher (priority 0 - runs first)\nscheduler.add(Box::new(publisher), 0, Some(true));\n\n// Subscriber (priority 1 - runs after)\nscheduler.add(Box::new(subscriber), 1, Some(true));",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:756:text",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 756,
      "lineEnd": 760,
      "language": "text",
      "code": "Starting application...\n[Nodes initialized]\n[Application freezes - no output]",
      "verifiable": false,
      "flags": [
        "has-markers",
        "partial"
      ]
    },
    {
      "id": "content/docs/troubleshooting:770:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 770,
      "lineEnd": 784,
      "language": "rust",
      "code": "// BAD: Infinite loop in tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    loop {  // Never returns!\n        // Process data\n    }\n}\n\n// GOOD: Tick returns after work\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    // Do work once\n    self.process_data();\n    // Return naturally\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:787:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 787,
      "lineEnd": 802,
      "language": "rust",
      "code": "// BAD: Blocking sleep in tick\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    std::thread::sleep(Duration::from_secs(10));  // Blocks scheduler!\n}\n\n// GOOD: Use tick counter for delays\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    self.tick_count += 1;\n\n    // Execute every 10 ticks (~167ms at 60 FPS)\n    if self.tick_count % 10 == 0 {\n        self.slow_operation();\n    }\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:805:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 805,
      "lineEnd": 820,
      "language": "rust",
      "code": "// BAD: Blocking wait\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    while self.data_sub.recv(&mut ctx).is_none() {\n        // Infinite loop if no messages!\n    }\n}\n\n// GOOD: Non-blocking receive\nfn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n    if let Some(data) = self.data_sub.recv(&mut ctx) {\n        // Process data\n    }\n    // Continue even if no message\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:823:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 823,
      "lineEnd": 830,
      "language": "rust",
      "code": "fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {\n        ctx.log_debug(\"Tick started\");\n\n    // Your code here\n        ctx.log_debug(\"Tick completed\");\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:839:text",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 839,
      "lineEnd": 842,
      "language": "text",
      "code": "Error: Message too large for shared memory\nthread 'main' panicked at 'send() failed'",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:851:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 851,
      "lineEnd": 862,
      "language": "rust",
      "code": "use std::mem::size_of;\n\n#[derive(Clone, Debug)]\nstruct LargeMessage {\n    data: [f32; 100000],  // 400KB!\n}\n\nfn main() {\n    println!(\"Message size: {} bytes\", size_of::<LargeMessage>());\n}",
      "verifiable": true,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:865:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 865,
      "lineEnd": 875,
      "language": "rust",
      "code": "// BAD: Huge array\nstruct SensorData {\n    readings: [f32; 100000],  // 400KB\n}\n\n// GOOD: Smaller, reasonable size\nstruct SensorData {\n    readings: [f32; 100],  // 400 bytes\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:878:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 878,
      "lineEnd": 887,
      "language": "rust",
      "code": "// Send data in chunks\nfor chunk in large_data.chunks(100) {\n    let msg = ChunkMessage {\n        data: chunk.to_vec(),\n        index: i,\n    };\n    self.pub_hub.send(msg, &mut ctx).ok();\n}",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:890:rust",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 890,
      "lineEnd": 898,
      "language": "rust",
      "code": "use std::sync::Arc;\n\n// Share large data without copying\ntype LargeData = Arc<Vec<f32>>;\n\nlet data = Arc::new(vec![0.0; 100000]);\nself.pub_hub.send(Arc::clone(&data), &mut ctx).ok();",
      "verifiable": true,
      "flags": [
        "needs-wrapper"
      ]
    },
    {
      "id": "content/docs/troubleshooting:907:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 907,
      "lineEnd": 913,
      "language": "bash",
      "code": "# Terminal 1: Run your application\nhorus run\n\n# Terminal 2: Start monitor\nhorus monitor",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:944:text",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 944,
      "lineEnd": 960,
      "language": "text",
      "code": "1. Check Nodes tab\n   -> All nodes Running? (If Error, check logs)\n\n2. Check Topics tab\n   -> Topics exist? (If no, topic name typo)\n   -> Publishers > 0? (If no, publisher not working)\n   -> Subscribers > 0? (If no, subscriber not created)\n\n3. Check Metrics tab\n   -> Messages sent > 0? (If no, publisher not sending)\n   -> Messages received > 0? (If no, subscriber not receiving)\n   -> IPC latency sane? (If >1ms, system issue)\n\n4. Check Graph tab\n   -> Nodes connected? (If no, topic name mismatch)",
      "verifiable": false,
      "flags": []
    },
    {
      "id": "content/docs/troubleshooting:964:bash",
      "file": "content/docs/troubleshooting.mdx",
      "lineStart": 964,
      "lineEnd": 973,
      "language": "bash",
      "code": "# Problem: Subscriber not receiving messages\n\n# Monitor shows:\n# Nodes: SensorNode (Running), DisplayNode (Running)\n# Topics: \"sensor_data\" (1 pub, 0 sub)  <-- AHA!\n\n# Issue: No subscribers!\n# Fix: Check DisplayNode - likely wrong topic name",
      "verifiable": false,
      "flags": []
    }
  ]
}