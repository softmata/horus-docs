---
title: "Circuit Breaker"
description: "Fault tolerance pattern for preventing cascading failures in node execution"
weight: 32
---

# Circuit Breaker

The circuit breaker pattern prevents cascading failures by temporarily disabling failing nodes. When a node fails repeatedly, the circuit "opens" to stop calling it, giving it time to recover.

## Overview

Circuit breakers protect against:
- Cascading failures from one failing node
- Resource exhaustion from repeated retry attempts
- System-wide slowdowns from blocked calls

## States

| State | Description | Behavior |
|-------|-------------|----------|
| **Closed** | Normal operation | All requests allowed |
| **Open** | Too many failures | All requests rejected |
| **Half-Open** | Testing recovery | Limited requests allowed |

```
    [Closed] ──failure threshold──> [Open]
        ↑                              │
        │                         timeout
        │                              ↓
        └──success threshold── [Half-Open]
                                       │
                                  failure
                                       ↓
                                   [Open]
```

## Basic Usage

```rust
use horus::prelude::*;

// Create circuit breaker
// - Opens after 5 failures
// - Closes after 3 successes in half-open
// - Waits 5000ms before trying half-open
let circuit = CircuitBreaker::new(5, 3, 5000);

// Check if request should be allowed
if circuit.should_allow() {
    match execute_node() {
        Ok(_) => circuit.record_success(),
        Err(_) => circuit.record_failure(),
    }
} else {
    // Circuit is open - skip execution
    println!("Circuit open, skipping node");
}
```

## Configuration

```rust
use horus::prelude::*;

// Conservative settings (for critical nodes)
let critical = CircuitBreaker::new(
    3,     // Open after 3 failures
    5,     // Need 5 successes to close
    10000, // 10 second timeout
);

// Aggressive settings (for non-critical nodes)
let non_critical = CircuitBreaker::new(
    10,    // Open after 10 failures
    2,     // Need 2 successes to close
    2000,  // 2 second timeout
);

// Default settings
let default = CircuitBreaker::default();
// failure_threshold: 5
// success_threshold: 3
// timeout: 5000ms
```

## State Transitions

### Closed → Open

When failures reach the threshold:

```rust
let circuit = CircuitBreaker::new(3, 2, 5000);

circuit.record_failure(); // failure_count = 1
circuit.record_failure(); // failure_count = 2
circuit.record_failure(); // failure_count = 3 -> OPEN

assert_eq!(circuit.get_state(), CircuitState::Open);
assert!(!circuit.should_allow());
```

### Open → Half-Open

After timeout elapses:

```rust
// Circuit is open
assert_eq!(circuit.get_state(), CircuitState::Open);

// Wait for timeout
std::thread::sleep(Duration::from_millis(5000));

// Next call triggers half-open
if circuit.should_allow() {
    // State is now Half-Open
    assert_eq!(circuit.get_state(), CircuitState::HalfOpen);
}
```

### Half-Open → Closed

After success threshold:

```rust
// In Half-Open state
circuit.record_success(); // success_count = 1
circuit.record_success(); // success_count = 2 -> CLOSED

assert_eq!(circuit.get_state(), CircuitState::Closed);
```

### Half-Open → Open

On any failure:

```rust
// In Half-Open state
circuit.record_failure(); // Immediately reopens

assert_eq!(circuit.get_state(), CircuitState::Open);
```

## Monitoring

### Get Statistics

```rust
let stats = circuit.stats();

println!("State: {:?}", stats.state);
println!("Failure count: {}", stats.failure_count);
println!("Success count: {}", stats.success_count);
```

### State Checking

```rust
use horus::prelude::*;

match circuit.get_state() {
    CircuitState::Closed => {
        println!("Normal operation");
    }
    CircuitState::Open => {
        println!("Circuit open - failures detected");
    }
    CircuitState::HalfOpen => {
        println!("Testing recovery");
    }
}
```

## Integration with Scheduler

The scheduler automatically manages circuit breakers for each node:

```rust
use horus::prelude::*;

let config = SchedulerConfig {
    circuit_breaker_enabled: true,
    circuit_breaker_failure_threshold: 5,
    circuit_breaker_success_threshold: 3,
    circuit_breaker_timeout_ms: 5000,
    ..Default::default()
};

let scheduler = Scheduler::with_config(config);

// Circuit breaker events are recorded to BlackBox
// CircuitBreakerChange { name, new_state, failure_count }
```

## Per-Node Configuration

Configure circuit breakers per node for different reliability requirements:

```rust
use horus::prelude::*;

// Critical control node - conservative settings
let control_config = NodeConfig {
    circuit_breaker: Some(CircuitBreaker::new(2, 5, 10000)),
    ..Default::default()
};

// Logging node - aggressive settings
let log_config = NodeConfig {
    circuit_breaker: Some(CircuitBreaker::new(20, 1, 1000)),
    ..Default::default()
};
```

## Thread Safety

The circuit breaker uses lock-free atomics for thread-safe operation:

```rust
use std::sync::Arc;
use std::thread;

let circuit = Arc::new(CircuitBreaker::default());

let handles: Vec<_> = (0..4).map(|_| {
    let c = Arc::clone(&circuit);
    thread::spawn(move || {
        for _ in 0..1000 {
            if c.should_allow() {
                // Safe concurrent access
                c.record_success();
            }
        }
    })
}).collect();

for h in handles {
    h.join().unwrap();
}
```

## Best Practices

### 1. Tune Thresholds Per Node Type

```rust
// Safety-critical: fail fast
let safety_cb = CircuitBreaker::new(2, 5, 15000);

// Sensor: tolerate intermittent failures
let sensor_cb = CircuitBreaker::new(10, 2, 3000);

// Logging: very tolerant
let log_cb = CircuitBreaker::new(50, 1, 1000);
```

### 2. Monitor Circuit State

```rust
fn check_circuits(circuits: &HashMap<String, CircuitBreaker>) {
    for (name, circuit) in circuits {
        if circuit.get_state() == CircuitState::Open {
            log::warn!("Circuit open for node: {}", name);
            alert_operator(name);
        }
    }
}
```

### 3. Handle Open Circuit Gracefully

```rust
if circuit.should_allow() {
    let result = execute_node();
    match result {
        Ok(v) => {
            circuit.record_success();
            Ok(v)
        }
        Err(e) => {
            circuit.record_failure();
            Err(e)
        }
    }
} else {
    // Return cached value or default
    Ok(cached_value.clone())
}
```

### 4. Log State Changes

```rust
let prev_state = circuit.get_state();

// ... after operation ...

let new_state = circuit.get_state();
if new_state != prev_state {
    log::info!(
        "Circuit breaker state change: {:?} -> {:?}",
        prev_state, new_state
    );
}
```

## Common Configurations

| Use Case | Failure Threshold | Success Threshold | Timeout |
|----------|-------------------|-------------------|---------|
| Safety-critical | 2-3 | 5-10 | 10-30s |
| Control loop | 5 | 3 | 5s |
| Sensor | 10 | 2 | 2-3s |
| Logging | 20+ | 1 | 1s |
| Network I/O | 5 | 3 | 10s |

## See Also

- [BlackBox Flight Recorder](/advanced/blackbox) - Event logging
- [Safety Monitor](/advanced/safety-monitor) - Real-time safety
- [Checkpoint System](/advanced/checkpoint) - State recovery
