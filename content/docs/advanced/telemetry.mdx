---
title: "Telemetry & Observability"
description: "Metrics, diagnostics, health monitoring, and remote observability for HORUS systems"
weight: 35
---

# Telemetry & Observability

HORUS provides a comprehensive telemetry system for collecting, exporting, and monitoring metrics from robotic systems. Combined with diagnostics messages, this enables full observability of node health, system performance, and operational status.

## Overview

The observability stack includes:

- **TelemetryManager**: Collect and export metrics to various backends
- **Diagnostics Messages**: Heartbeats, status reports, and health monitoring
- **Resource Monitoring**: CPU, memory, disk, and network usage tracking
- **Safety Status**: Emergency stop, watchdog, and fault monitoring

## Telemetry Manager

The `TelemetryManager` collects metrics and exports them to configurable endpoints:

```rust
use horus::prelude::*;

// Create telemetry manager with 1-second export interval
let mut telemetry = TelemetryManager::new(
    TelemetryEndpoint::from_string("udp://192.168.1.100:9999"),
    1000  // 1000ms interval
);

telemetry.set_scheduler_name("robot_controller");

// Record metrics during operation
telemetry.counter("scheduler_ticks", 1000);
telemetry.gauge("cpu_usage", 45.5);
telemetry.gauge("motor_temperature", 38.2);

// Record metrics with labels
telemetry.counter_with_labels(
    "messages_sent",
    500,
    HashMap::from([
        ("topic".to_string(), "motor.cmd".to_string()),
        ("node".to_string(), "MotorController".to_string()),
    ])
);

// Export when ready
if telemetry.should_export() {
    telemetry.export()?;
}
```

### Telemetry Endpoints

Configure where metrics are exported:

```rust
// Local JSON file
let endpoint = TelemetryEndpoint::LocalFile(PathBuf::from("/tmp/metrics.json"));

// UDP broadcast (for Prometheus, Grafana, etc.)
let endpoint = TelemetryEndpoint::Udp("127.0.0.1:9999".to_string());

// HTTP POST endpoint
let endpoint = TelemetryEndpoint::Http("http://metrics.example.com/api/v1/push".to_string());

// Stdout (debugging)
let endpoint = TelemetryEndpoint::Stdout;

// Disabled
let endpoint = TelemetryEndpoint::Disabled;

// Parse from string (configuration files)
let endpoint = TelemetryEndpoint::from_string("udp://192.168.1.100:9999");
let endpoint = TelemetryEndpoint::from_string("file:///var/log/horus/metrics.json");
let endpoint = TelemetryEndpoint::from_string("stdout");
```

### Metric Types

HORUS supports four metric types:

```rust
/// Counter - monotonically increasing value
telemetry.counter("total_messages", 12345);

/// Gauge - value that can go up or down
telemetry.gauge("queue_depth", 42.0);
telemetry.gauge("temperature", 65.5);

/// Histogram - distribution of values
let latencies = vec![1.2, 1.5, 1.3, 2.1, 1.4];
telemetry.record("tick_latency_ms", MetricValue::Histogram(latencies), labels);

/// Text - string value for status/state
telemetry.record("current_state", MetricValue::Text("Running".to_string()), labels);
```

### Thread-Safe Telemetry

For multi-threaded applications:

```rust
use horus::prelude::*;

// Create shared telemetry
let telemetry = create_shared_telemetry(
    TelemetryEndpoint::from_string("udp://localhost:9999"),
    1000
);

// Clone for use in different threads
let tm_clone = telemetry.clone();

std::thread::spawn(move || {
    let mut tm = tm_clone.lock().unwrap();
    tm.counter("thread_events", 1);
});

// Export from main thread
{
    let mut tm = telemetry.lock().unwrap();
    if tm.should_export() {
        tm.export().ok();
    }
}
```

### Telemetry Snapshots

Get a complete snapshot of all metrics:

```rust
let snapshot = telemetry.get_snapshot();

println!("Scheduler: {}", snapshot.scheduler_name);
println!("Uptime: {:.1}s", snapshot.uptime_secs);
println!("Timestamp: {}", snapshot.timestamp);

for metric in &snapshot.metrics {
    println!("  {} = {:?}", metric.name, metric.value);
}
```

## Diagnostics Messages

HORUS provides standard message types for system monitoring.

### Heartbeat

Periodic signal indicating a node is alive:

```rust
use horus::prelude::*;

// Create heartbeat
let mut heartbeat = Heartbeat::new("MotorController", 1);

// Update on each tick
heartbeat.update(elapsed_secs);

// Check status
println!("Node: {}", heartbeat.name());
println!("Sequence: {}", heartbeat.sequence);
println!("Uptime: {:.1}s", heartbeat.uptime);
println!("Alive: {}", heartbeat.alive);
```

**Heartbeat Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `node_name` | `[u8; 32]` | Node name (null-terminated) |
| `node_id` | `u32` | Unique node identifier |
| `sequence` | `u64` | Heartbeat sequence number |
| `alive` | `bool` | Node is operational |
| `uptime` | `f64` | Seconds since node startup |
| `timestamp` | `u64` | Nanoseconds since epoch |

### Status Messages

General-purpose status reporting:

```rust
use horus::prelude::*;

// Create status messages
let ok = Status::ok("System initialized");
let warn = Status::warn(101, "Battery below 30%");
let error = Status::error(500, "Sensor timeout");
let fatal = Status::fatal(999, "Safety system failure");

// With component name
let status = Status::error(404, "Camera not found")
    .with_component("VisionSystem");

// Access fields
println!("Level: {:?}", status.level);
println!("Code: {}", status.code);
println!("Message: {}", status.message_str());
println!("Component: {}", status.component_str());
```

**StatusLevel Values:**

| Value | Code | Description |
|-------|------|-------------|
| `Ok` | 0 | Everything operational |
| `Warn` | 1 | Warning condition |
| `Error` | 2 | Recoverable error |
| `Fatal` | 3 | System should stop |

### Emergency Stop

Critical safety message:

```rust
use horus::prelude::*;

// Engage emergency stop
let estop = EmergencyStop::engage("Obstacle detected within safety zone")
    .with_source("LidarSafetyMonitor");

if estop.engaged {
    log::error!("E-STOP: {}", estop.reason_str());
}

// Release emergency stop
let release = EmergencyStop::release();
```

### Resource Usage

System resource monitoring:

```rust
use horus::prelude::*;

let mut resources = ResourceUsage::new();

resources.cpu_percent = 45.5;
resources.memory_bytes = 1024 * 1024 * 512;  // 512 MB
resources.memory_percent = 25.0;
resources.disk_bytes = 1024 * 1024 * 1024 * 10;  // 10 GB
resources.disk_percent = 15.0;
resources.temperature = 55.0;
resources.thread_count = 24;

// Check thresholds
if resources.is_cpu_high(80.0) {
    log::warn!("High CPU usage: {:.1}%", resources.cpu_percent);
}

if resources.is_memory_high(90.0) {
    log::warn!("High memory usage: {:.1}%", resources.memory_percent);
}

if resources.is_temperature_high(85.0) {
    log::error!("Critical temperature: {:.1}Â°C", resources.temperature);
}
```

**ResourceUsage Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `cpu_percent` | `f32` | CPU usage (0-100) |
| `memory_bytes` | `u64` | Memory usage in bytes |
| `memory_percent` | `f32` | Memory usage (0-100) |
| `disk_bytes` | `u64` | Disk usage in bytes |
| `disk_percent` | `f32` | Disk usage (0-100) |
| `network_tx_bytes` | `u64` | Network bytes sent |
| `network_rx_bytes` | `u64` | Network bytes received |
| `temperature` | `f32` | System temperature (Celsius) |
| `thread_count` | `u32` | Active thread count |
| `timestamp` | `u64` | Nanoseconds since epoch |

### Diagnostic Reports

Multi-value diagnostic reports:

```rust
use horus::prelude::*;

let mut report = DiagnosticReport::new("MotorController");

// Add diagnostic values (max 16)
report.add_string("firmware_version", "2.3.1")?;
report.add_int("error_count", 0)?;
report.add_float("motor_temp", 42.5)?;
report.add_bool("homing_complete", true)?;

// Set overall status
report.set_level(StatusLevel::Ok);
```

**DiagnosticValue Types:**

| Type | Constant | Description |
|------|----------|-------------|
| String | `TYPE_STRING` | Text value |
| Integer | `TYPE_INT` | 64-bit integer |
| Float | `TYPE_FLOAT` | 64-bit float |
| Boolean | `TYPE_BOOL` | True/false |

## Node Health Monitoring

### NodeState

Execution state enumeration:

```rust
use horus::prelude::*;

let state = NodeState::Running;

match state {
    NodeState::Idle => println!("Node created but not started"),
    NodeState::Initializing => println!("Running initialization"),
    NodeState::Running => println!("Active and executing"),
    NodeState::Paused => println!("Temporarily suspended"),
    NodeState::Stopped => println!("Cleanly shut down"),
    NodeState::Error => println!("Error or crashed"),
}

println!("State: {}", state.as_str());
```

### HealthStatus

Operational health levels:

```rust
use horus::prelude::*;

let health = HealthStatus::Warning;

// Use for UI display
println!("Status: {} ({})", health.as_str(), health.color());

match health {
    HealthStatus::Healthy => println!("Operating normally"),
    HealthStatus::Warning => println!("Degraded performance"),
    HealthStatus::Error => println!("Errors but still running"),
    HealthStatus::Critical => println!("Fatal - about to crash"),
    HealthStatus::Unknown => println!("No heartbeat received"),
}
```

**HealthStatus Values:**

| Value | Color | Description |
|-------|-------|-------------|
| `Healthy` | green | Operating normally |
| `Warning` | yellow | Degraded performance |
| `Error` | orange | Errors but running |
| `Critical` | red | Fatal, unresponsive |
| `Unknown` | gray | No heartbeat |

### NodeHeartbeat

Combines state and health for monitoring:

```rust
use horus::prelude::*;

let mut heartbeat = NodeHeartbeat::new(NodeState::Running, HealthStatus::Healthy);

heartbeat.tick_count = 10000;
heartbeat.target_rate_hz = 100;
heartbeat.actual_rate_hz = 98;
heartbeat.error_count = 0;

// Update timestamp
heartbeat.update_timestamp();

// Check freshness (within last 5 seconds)
if !heartbeat.is_fresh(5) {
    println!("Stale heartbeat - node may be unresponsive");
}

// Serialize for file storage
let bytes = heartbeat.to_bytes();
let restored = NodeHeartbeat::from_bytes(&bytes);
```

**NodeHeartbeat Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `state` | `NodeState` | Execution state |
| `health` | `HealthStatus` | Health status |
| `tick_count` | `u64` | Total tick count |
| `target_rate_hz` | `u32` | Target tick rate |
| `actual_rate_hz` | `u32` | Measured tick rate |
| `error_count` | `u32` | Error count |
| `last_tick_timestamp` | `u64` | Last tick (unix secs) |
| `heartbeat_timestamp` | `u64` | Heartbeat time (unix secs) |

## Safety Status

Monitor safety system state:

```rust
use horus::prelude::*;

let mut safety = SafetyStatus::new();

// Check if safe to operate
if safety.is_safe() {
    println!("System safe for operation");
}

// Update safety indicators
safety.watchdog_ok = true;
safety.limits_ok = true;
safety.comms_ok = true;
safety.estop_engaged = false;

// Set fault
safety.set_fault(101);  // Auto-enters SAFE_STOP mode

// Clear faults
safety.clear_faults();  // Returns to NORMAL mode
```

**Safety Modes:**

| Mode | Constant | Description |
|------|----------|-------------|
| Normal | `MODE_NORMAL` | Normal operation |
| Reduced | `MODE_REDUCED` | Reduced capability |
| Safe Stop | `MODE_SAFE_STOP` | Safe stop mode |

## Monitoring Configuration

Configure monitoring in `SchedulerConfig`:

```rust
use horus::prelude::*;

let config = SchedulerConfig {
    monitoring: MonitoringConfig {
        profiling_enabled: true,
        tracing_enabled: false,
        metrics_interval_ms: 1000,
        telemetry_endpoint: Some("udp://localhost:9999".to_string()),
        black_box_enabled: true,
        black_box_size_mb: 100,
    },
    ..Default::default()
};
```

**MonitoringConfig Fields:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `profiling_enabled` | `bool` | `true` | Enable runtime profiling |
| `tracing_enabled` | `bool` | `false` | Enable distributed tracing |
| `metrics_interval_ms` | `u64` | `1000` | Export interval |
| `telemetry_endpoint` | `Option<String>` | `None` | Telemetry endpoint URL |
| `black_box_enabled` | `bool` | `false` | Enable blackbox recording |
| `black_box_size_mb` | `u64` | `0` | Blackbox buffer size |

## Complete Monitoring Example

```rust
use horus::prelude::*;
use std::collections::HashMap;

struct MonitoredNode {
    telemetry: SharedTelemetry,
    heartbeat_pub: Hub<NodeHeartbeat>,
    status_pub: Hub<Status>,
    resources_pub: Hub<ResourceUsage>,
    start_time: std::time::Instant,
    tick_count: u64,
}

impl Node for MonitoredNode {
    fn name(&self) -> &'static str { "MonitoredNode" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        self.tick_count += 1;

        // Record telemetry metrics
        {
            let mut tm = self.telemetry.lock().unwrap();
            tm.counter("node_ticks", self.tick_count);
            tm.gauge("uptime_secs", self.start_time.elapsed().as_secs_f64());

            // Export periodically
            if tm.should_export() {
                if let Err(e) = tm.export() {
                    log::warn!("Telemetry export failed: {}", e);
                }
            }
        }

        // Publish heartbeat
        let mut heartbeat = NodeHeartbeat::new(NodeState::Running, HealthStatus::Healthy);
        heartbeat.tick_count = self.tick_count;
        heartbeat.target_rate_hz = 100;
        heartbeat.actual_rate_hz = self.calculate_rate();
        self.heartbeat_pub.send(heartbeat, &mut ctx).ok();

        // Publish resource usage
        let resources = self.get_resource_usage();
        self.resources_pub.send(resources, &mut ctx).ok();

        // Publish status on significant events
        if self.tick_count % 1000 == 0 {
            let status = Status::ok(&format!("Completed {} ticks", self.tick_count))
                .with_component("MonitoredNode");
            self.status_pub.send(status, &mut ctx).ok();
        }
    }
}

impl MonitoredNode {
    fn calculate_rate(&self) -> u32 {
        // Calculate actual tick rate
        let elapsed = self.start_time.elapsed().as_secs_f64();
        if elapsed > 0.0 {
            (self.tick_count as f64 / elapsed) as u32
        } else {
            0
        }
    }

    fn get_resource_usage(&self) -> ResourceUsage {
        let mut resources = ResourceUsage::new();
        // Populate with actual system metrics
        resources.cpu_percent = 25.0;
        resources.memory_percent = 40.0;
        resources.temperature = 45.0;
        resources
    }
}
```

## CLI Commands

Monitor telemetry from the command line:

```bash
# Start with telemetry endpoint
horus run robot.yaml --telemetry udp://localhost:9999

# Monitor node health
horus monitor --health

# View diagnostics
horus diag --node MotorController

# Export current metrics
horus metrics --export /tmp/snapshot.json

# Watch real-time metrics
horus metrics --watch
```

## See Also

- [Blackbox Recording](/advanced/blackbox) - Flight recorder for debugging
- [Record & Replay](/advanced/record-replay) - Node recording and replay
- [Circuit Breaker](/advanced/circuit-breaker) - Fault tolerance patterns
- [Safety Monitor](/advanced/safety-monitor) - Safety system monitoring
