---
title: Python Message Library
description: Standard robotics message types for Python
order: 52
---

# Python Message Library (horus.library)

The `horus.library` module provides typed message classes for robotics applications in Python. These messages are compatible with Rust and enable cross-language communication.

## Overview

```python
# Option 1: Import everything (recommended)
import horus

# Option 2: Import specific types
from horus import Pose2D, Twist, CmdVel, LaserScan, Transform, Point3, Vector3, Quaternion
```

**Key Features:**
- **Cross-language compatible** - Binary-compatible with Rust message types
- **Automatic timestamps** - All messages include microsecond-precision timestamps
- **Validation methods** - Built-in checks for finite values, normalized quaternions, etc.
- **Pickle support** - Can be serialized for Python-only communication
- **NumPy integration** - LaserScan uses NumPy arrays for zero-copy efficiency

---

## Geometry Messages

### Pose2D

2D robot pose (position + orientation).

```python
from horus import Pose2D

# Create pose
pose = Pose2D(x=1.0, y=2.0, theta=0.5)

# Static constructors
origin = Pose2D.origin()  # Pose2D(0, 0, 0)

# Properties (read/write)
pose.x = 1.5
pose.y = 2.5
pose.theta = 0.785
timestamp = pose.timestamp  # Microseconds since epoch (read-only)

# Methods
distance = pose.distance_to(other_pose)  # Euclidean distance
pose.normalize_angle()  # Normalize theta to [-π, π]
is_valid = pose.is_valid()  # Check if values are finite

print(pose)  # Pose2D(x=1.500, y=2.500, theta=0.785)
```

**Fields:**
- `x` (float): X position in meters
- `y` (float): Y position in meters
- `theta` (float): Orientation in radians
- `timestamp` (int, read-only): Microsecond timestamp

**Use with Hub:**
```python
from horus import Hub, Pose2D

hub = Hub(Pose2D)  # Typed hub
hub.send(Pose2D(x=1.0, y=2.0, theta=0.5))
pose = hub.recv()  # Returns Pose2D or None
```

---

### Twist

3D velocity (linear + angular).

```python
from horus import Twist

# Create 3D twist
twist = Twist(
    linear=[1.0, 0.0, 0.0],   # [x, y, z] in m/s
    angular=[0.0, 0.0, 0.5]    # [roll, pitch, yaw] in rad/s
)

# Create 2D twist (common for ground robots)
twist_2d = Twist.new_2d(linear_x=1.0, angular_z=0.5)

# Stop command
stop = Twist.stop()  # All zeros

# Properties
twist.linear = [1.5, 0.0, 0.0]
twist.angular = [0.0, 0.0, 0.3]
timestamp = twist.timestamp

# Validation
is_valid = twist.is_valid()  # Check finite values

print(twist)  # Twist(linear=[1.50, 0.00, 0.00], angular=[0.00, 0.00, 0.30])
```

**Fields:**
- `linear` (list[3]): Linear velocity [x, y, z] in m/s
- `angular` (list[3]): Angular velocity [roll, pitch, yaw] in rad/s
- `timestamp` (int, read-only): Microsecond timestamp

---

### Transform

3D transformation (translation + rotation quaternion).

```python
from horus import Transform, Pose2D

# Create transform
tf = Transform(
    translation=[1.0, 2.0, 0.0],  # [x, y, z]
    rotation=[0.0, 0.0, 0.0, 1.0]  # Quaternion [x, y, z, w]
)

# Static constructors
identity = Transform.identity()  # No translation or rotation
from_pose = Transform.from_pose_2d(Pose2D(1.0, 2.0, 0.5))  # Convert from 2D pose

# Properties
tf.translation = [1.5, 2.5, 0.0]
tf.rotation = [0.0, 0.0, 0.707, 0.707]  # 90° rotation around Z
timestamp = tf.timestamp

# Methods
tf.normalize_rotation()  # Ensure quaternion is normalized
is_valid = tf.is_valid()  # Check finite values and normalized quaternion

print(tf)  # Transform(translation=[1.50, 2.50, 0.00], rotation=[...])
```

**Fields:**
- `translation` (list[3]): Position [x, y, z] in meters
- `rotation` (list[4]): Orientation quaternion [x, y, z, w]
- `timestamp` (int, read-only): Microsecond timestamp

---

### Point3, Vector3, Quaternion

Basic 3D geometric types.

```python
from horus import Point3, Vector3, Quaternion

# Point3 - 3D position
point = Point3(x=1.0, y=2.0, z=3.0)
origin = Point3.origin()  # (0, 0, 0)
dist = point.distance_to(other_point)

# Vector3 - 3D vector with operations
vec = Vector3(x=1.0, y=0.0, z=0.0)
zero = Vector3.zero()  # (0, 0, 0)
magnitude = vec.magnitude()
vec.normalize()  # In-place normalization
dot_product = vec.dot(other_vec)
cross_product = vec.cross(other_vec)  # Returns new Vector3

# Quaternion - 3D rotation
quat = Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)
identity = Quaternion.identity()  # No rotation
from_euler = Quaternion.from_euler(roll=0.0, pitch=0.0, yaw=1.57)  # From Euler angles
quat.normalize()  # Ensure unit quaternion
is_valid = quat.is_valid()
```

---

## Control Messages

### CmdVel

2D velocity command (linear + angular).

```python
from horus import CmdVel

# Create velocity command
cmd = CmdVel(linear=1.0, angular=0.5)

# Stop command
stop = CmdVel.zero()  # CmdVel(0.0, 0.0)

# Properties
cmd.linear = 1.5   # m/s
cmd.angular = 0.3  # rad/s
timestamp = cmd.timestamp

print(cmd)  # CmdVel(linear=1.50, angular=0.30)
```

**Fields:**
- `linear` (float): Forward velocity in m/s
- `angular` (float): Angular velocity in rad/s (positive = counter-clockwise)
- `timestamp` (int, read-only): Microsecond timestamp

**Use with Hub:**
```python
from horus import Hub, CmdVel

hub = Hub(CmdVel)  # Typed hub
hub.send(CmdVel(linear=1.0, angular=0.5))
cmd = hub.recv()  # Returns CmdVel or None
```

---

## Sensor Messages

### LaserScan

2D LIDAR scan data (360-point array).

```python
from horus import LaserScan
import numpy as np

# Create laser scan
scan = LaserScan()

# Set ranges (must be exactly 360 elements)
scan.ranges = [1.0] * 360  # List or NumPy array
scan.ranges = np.random.uniform(0.1, 10.0, 360)  # NumPy works too

# Set scan parameters
scan.angle_min = -3.14159       # Start angle (radians)
scan.angle_max = 3.14159        # End angle (radians)
scan.range_min = 0.1            # Minimum valid range (meters)
scan.range_max = 10.0           # Maximum valid range (meters)
scan.angle_increment = 0.01745  # Angular resolution (radians)

# Access ranges as NumPy array (zero-copy)
ranges_array = scan.ranges  # Returns np.ndarray
scan.ranges[90] = 2.5  # Modify directly

# Query methods
angle = scan.angle_at(180)  # Get angle for specific index
is_valid = scan.is_range_valid(180)  # Check if reading is valid
valid_count = scan.valid_count()  # Count valid readings
min_reading = scan.min_range()  # Minimum valid range (or None)

# Length
length = len(scan)  # Always 360

print(scan)  # LaserScan(ranges=360, valid=342, min=0.15m)
```

**Fields:**
- `ranges` (NumPy array[360]): Distance readings in meters
- `angle_min` (float): Start angle in radians
- `angle_max` (float): End angle in radians
- `range_min` (float): Minimum valid range in meters
- `range_max` (float): Maximum valid range in meters
- `angle_increment` (float): Angular resolution in radians
- `timestamp` (int, read-only): Microsecond timestamp

**Use with Hub:**
```python
from horus import Hub, LaserScan

hub = Hub("lidar")  # Generic hub for LaserScan

# Send
scan = LaserScan()
scan.ranges = read_lidar_hardware()  # Your driver
hub.send(scan)

# Receive
scan = hub.recv()  # Returns LaserScan or None
if scan:
    print(f"Got {scan.valid_count()} valid readings")
```

---

## Cross-Language Compatibility

All `horus.library` messages are **binary-compatible with Rust**:

| Python Class | Rust Type |
|--------------|-----------|
| `Pose2D` | `horus_library::messages::geometry::Pose2D` |
| `Twist` | `horus_library::messages::geometry::Twist` |
| `Transform` | `horus_library::messages::geometry::Transform` |
| `CmdVel` | `horus_library::messages::cmd_vel::CmdVel` |
| `LaserScan` | `horus_library::messages::sensor::LaserScan` |
| `Imu` | `horus_library::messages::sensor::Imu` |
| `Odometry` | `horus_library::messages::sensor::Odometry` |
| `Image` | `horus_library::messages::vision::Image` |
| `PointCloud` | `horus_library::messages::perception::PointCloud` |
| `Goal` | `horus_library::messages::navigation::Goal` |
| `Path` | `horus_library::messages::navigation::Path` |
| `OccupancyGrid` | `horus_library::messages::navigation::OccupancyGrid` |
| `WrenchStamped` | `horus_library::messages::force::WrenchStamped` |
| `RobotState` | `horus_library::messages::coordination::RobotState` |
| `TaskAssignment` | `horus_library::messages::coordination::TaskAssignment` |

**Example - Python to Rust:**

```python
# Python sender
from horus import Hub, CmdVel

hub = Hub(CmdVel)  # Typed hub
hub.send(CmdVel(linear=1.0, angular=0.5))
```

```rust
// Rust receiver
use horus::prelude::*;
use horus::prelude::*; // Provides cmd_vel::CmdVel;

let hub = Hub::<CmdVel>::new("cmd_vel")?;
if let Some(cmd) = hub.recv(&mut None) {
    println!("Received: linear={}, angular={}", cmd.linear, cmd.angular);
}
```

---

## Usage Patterns

### Robot Controller with Multiple Sensors

```python
from horus import Node, run, Hub, CmdVel, LaserScan

# Create hubs outside tick function
scan_hub = Hub("lidar")
cmd_hub = Hub(CmdVel)

def controller_tick(node):
    scan = scan_hub.recv()
    if scan:
        # Simple obstacle avoidance
        min_dist = scan.min_range()
        if min_dist and min_dist < 0.5:
            # Too close - stop
            cmd_hub.send(CmdVel.zero())
        else:
            # Safe - move forward
            cmd_hub.send(CmdVel(linear=0.5, angular=0.0))

node = Node(name="controller", tick=controller_tick, rate=10)
run(node)
```

### Pose Tracking

```python
from horus import Hub, Pose2D

# Track robot pose
pose_hub = Hub(Pose2D)

current_pose = Pose2D.origin()

def update_pose(delta_x, delta_y, delta_theta):
    global current_pose
    current_pose.x += delta_x
    current_pose.y += delta_y
    current_pose.theta += delta_theta
    current_pose.normalize_angle()

    if current_pose.is_valid():
        pose_hub.send(current_pose)
```

---

### Imu

Inertial Measurement Unit data (orientation, angular velocity, linear acceleration).

```python
from horus import Imu

imu = Imu()

# Orientation as quaternion [x, y, z, w]
imu.orientation = [0.0, 0.0, 0.0, 1.0]

# Angular velocity [x, y, z] in rad/s
imu.angular_velocity = [0.0, 0.0, 0.1]

# Linear acceleration [x, y, z] in m/s²
imu.linear_acceleration = [0.0, 0.0, 9.81]

print(imu)  # Imu(orientation=[0.00,0.00,0.00,1.00], angular_vel=[0.00,0.00,0.10])
```

---

### Odometry

Robot odometry (pose + velocity).

```python
from horus import Odometry

odom = Odometry()

# 2D pose access
odom.x = 1.0       # meters
odom.y = 2.0       # meters
odom.theta = 0.5   # radians

# 3D pose access
odom.position = [1.0, 2.0, 0.0]      # [x, y, z]
odom.orientation = [0.0, 0.0, 0.25, 0.97]  # quaternion [x, y, z, w]

# Velocity
odom.linear_velocity = [0.5, 0.0, 0.0]   # [vx, vy, vz] m/s
odom.angular_velocity = [0.0, 0.0, 0.1]  # [wx, wy, wz] rad/s

print(odom)  # Odometry(pos=[1.00,2.00,0.50], vel=[0.50,0.00,0.00])
```

---

### BatteryState

Battery status information.

```python
from horus import BatteryState

battery = BatteryState(voltage=12.6, percentage=85.0)

battery.voltage = 11.8       # Volts
battery.percentage = 75.0    # 0-100%
battery.current = 2.5        # Amps (positive = discharging)
battery.temperature = 25.0   # Celsius
```

---

### NavSatFix

GPS/GNSS position fix.

```python
from horus import NavSatFix

gps = NavSatFix(latitude=37.7749, longitude=-122.4194, altitude=10.0)

gps.latitude = 37.7749    # degrees
gps.longitude = -122.4194 # degrees
gps.altitude = 10.0       # meters above sea level
```

---

### Range

Single-point distance sensor (ultrasonic, IR, etc.).

```python
from horus import Range

range_sensor = Range()
range_sensor.range = 1.5       # meters
range_sensor.min_range = 0.02  # minimum valid range
range_sensor.max_range = 4.0   # maximum valid range
range_sensor.field_of_view = 0.26  # radians (~15°)
```

---

## Control Messages (Extended)

### MotorCommand

Individual motor control.

```python
from horus import MotorCommand

cmd = MotorCommand()
cmd.velocity = 100.0      # RPM or rad/s depending on mode
cmd.position = 0.0        # Target position (radians)
cmd.torque = 0.0          # Torque limit (Nm)
cmd.mode = 0              # 0=velocity, 1=position, 2=torque
```

---

### DifferentialDriveCommand

Differential drive robot control.

```python
from horus import DifferentialDriveCommand

cmd = DifferentialDriveCommand()
cmd.left_velocity = 1.0   # Left wheel velocity (m/s or rad/s)
cmd.right_velocity = 1.0  # Right wheel velocity
```

---

### ServoCommand

Servo motor control.

```python
from horus import ServoCommand

cmd = ServoCommand()
cmd.angle = 90.0          # Target angle (degrees)
cmd.speed = 100           # Movement speed (0-100%)
```

---

### PidConfig

PID controller configuration.

```python
from horus import PidConfig

pid = PidConfig()
pid.kp = 1.0   # Proportional gain
pid.ki = 0.1   # Integral gain
pid.kd = 0.05  # Derivative gain
```

---

## Vision Messages

### Image

Raw image data.

```python
from horus import Image, ImageEncoding

img = Image()
img.width = 640
img.height = 480
img.encoding = ImageEncoding.RGB8
img.data = bytes(640 * 480 * 3)  # Raw pixel data

# Access encoding constants
ImageEncoding.RGB8      # 8-bit RGB
ImageEncoding.BGR8      # 8-bit BGR
ImageEncoding.RGBA8     # 8-bit RGBA
ImageEncoding.MONO8     # 8-bit grayscale
ImageEncoding.MONO16    # 16-bit grayscale
ImageEncoding.DEPTH16   # 16-bit depth
ImageEncoding.DEPTH32F  # 32-bit float depth
```

---

### CompressedImage

JPEG/PNG compressed image.

```python
from horus import CompressedImage

img = CompressedImage()
img.format = "jpeg"           # "jpeg" or "png"
img.data = jpeg_bytes         # Compressed image data
```

---

### CameraInfo

Camera calibration parameters.

```python
from horus import CameraInfo

info = CameraInfo()
info.width = 640
info.height = 480
info.fx = 525.0   # Focal length X
info.fy = 525.0   # Focal length Y
info.cx = 320.0   # Principal point X
info.cy = 240.0   # Principal point Y
```

---

### Detection

Object detection result.

```python
from horus import Detection

det = Detection()
det.class_id = 0           # Class index
det.class_name = "person"  # Class label
det.confidence = 0.95      # Detection confidence (0-1)
det.x = 100                # Bounding box X
det.y = 50                 # Bounding box Y
det.width = 200            # Bounding box width
det.height = 400           # Bounding box height
```

---

### DetectionArray

Multiple detections.

```python
from horus import DetectionArray, Detection

detections = DetectionArray()
detections.detections = [
    Detection(),  # Add detection objects
]
detections.source_width = 640
detections.source_height = 480
```

---

## Navigation Messages

### Goal

Navigation goal.

```python
from horus import Goal, GoalStatus

goal = Goal()
goal.x = 10.0           # Target X position
goal.y = 5.0            # Target Y position
goal.theta = 0.0        # Target orientation
goal.tolerance = 0.1    # Position tolerance (meters)

# Goal status values
GoalStatus.PENDING    # Not yet started
GoalStatus.ACTIVE     # Currently executing
GoalStatus.SUCCEEDED  # Completed successfully
GoalStatus.ABORTED    # Failed/cancelled
```

---

### Path

Sequence of waypoints.

```python
from horus import Path, Waypoint

path = Path()
path.waypoints = [
    Waypoint(x=0.0, y=0.0, theta=0.0),
    Waypoint(x=5.0, y=0.0, theta=0.0),
    Waypoint(x=5.0, y=5.0, theta=1.57),
]
```

---

### OccupancyGrid

2D occupancy map.

```python
from horus import OccupancyGrid

grid = OccupancyGrid()
grid.width = 100          # Grid width (cells)
grid.height = 100         # Grid height (cells)
grid.resolution = 0.05    # Meters per cell
grid.origin_x = -2.5      # Map origin X
grid.origin_y = -2.5      # Map origin Y
grid.data = bytes(100 * 100)  # 0=free, 100=occupied, -1=unknown
```

---

### CostMap

Navigation cost map.

```python
from horus import CostMap

costmap = CostMap()
costmap.width = 100
costmap.height = 100
costmap.resolution = 0.05
costmap.data = bytes(100 * 100)  # Cost values 0-255
```

---

## Perception Messages

### PointCloud

3D point cloud data.

```python
from horus import PointCloud, PointField, PointFieldType

cloud = PointCloud()
cloud.width = 1000        # Number of points
cloud.height = 1          # 1 for unorganized, >1 for organized
cloud.point_step = 12     # Bytes per point
cloud.row_step = 12000    # Bytes per row

# Define point format (XYZ float32)
cloud.fields = [
    PointField(name="x", offset=0, datatype=PointFieldType.FLOAT32, count=1),
    PointField(name="y", offset=4, datatype=PointFieldType.FLOAT32, count=1),
    PointField(name="z", offset=8, datatype=PointFieldType.FLOAT32, count=1),
]

cloud.data = point_data_bytes  # Raw point data
```

---

### DepthImage

Depth image data.

```python
from horus import DepthImage

depth = DepthImage()
depth.width = 640
depth.height = 480
depth.encoding = "32FC1"  # 32-bit float, 1 channel
depth.data = depth_bytes  # Raw depth data
```

---

### BoundingBox3D

3D bounding box.

```python
from horus import BoundingBox3D

box = BoundingBox3D()
box.center = [1.0, 2.0, 0.5]       # Center position [x, y, z]
box.size = [0.5, 0.5, 1.8]         # Dimensions [length, width, height]
box.orientation = [0.0, 0.0, 0.0, 1.0]  # Quaternion
box.class_id = 0
box.class_name = "person"
box.confidence = 0.92
```

---

## Force/Tactile Messages

### WrenchStamped

Force and torque measurement.

```python
from horus import WrenchStamped

wrench = WrenchStamped()
wrench.force = [10.0, 0.0, -9.81]   # Force [fx, fy, fz] in Newtons
wrench.torque = [0.0, 0.5, 0.0]     # Torque [tx, ty, tz] in Nm
```

---

### TactileArray

Tactile sensor array.

```python
from horus import TactileArray

tactile = TactileArray()
tactile.rows = 4
tactile.cols = 4
tactile.data = [0.0] * 16  # Pressure values
```

---

### ForceCommand

Force control command.

```python
from horus import ForceCommand

cmd = ForceCommand()
cmd.force = [0.0, 0.0, -10.0]   # Desired force [fx, fy, fz]
cmd.torque = [0.0, 0.0, 0.0]    # Desired torque [tx, ty, tz]
```

---

## Coordination Messages

### RobotState

Robot status for fleet coordination.

```python
from horus import RobotState, RobotType

state = RobotState()
state.robot_id = "robot_01"
state.robot_type = RobotType.GROUND
state.x = 5.0
state.y = 3.0
state.theta = 0.0
state.battery_level = 85.0
state.is_active = True

# Robot types
RobotType.GROUND     # Ground robot (UGV)
RobotType.AERIAL     # Aerial robot (UAV)
RobotType.MARINE     # Marine robot (USV/AUV)
RobotType.ARM        # Robot arm/manipulator
```

---

### FleetStatus

Fleet-wide status.

```python
from horus import FleetStatus, RobotState

fleet = FleetStatus()
fleet.fleet_id = "warehouse_fleet"
fleet.robots = [
    RobotState(),  # Add robot states
]
fleet.active_count = 5
fleet.total_count = 8
```

---

### TaskAssignment

Task assignment for multi-robot systems.

```python
from horus import TaskAssignment, TaskType, TaskStatus

task = TaskAssignment()
task.task_id = "task_001"
task.robot_id = "robot_01"
task.task_type = TaskType.NAVIGATION
task.status = TaskStatus.ACTIVE
task.priority = 5
task.goal_x = 10.0
task.goal_y = 5.0

# Task types
TaskType.NAVIGATION   # Move to location
TaskType.PICKUP       # Pick up object
TaskType.DELIVERY     # Deliver object
TaskType.INSPECTION   # Inspect area
TaskType.CHARGING     # Go to charger

# Task status
TaskStatus.PENDING    # Waiting to start
TaskStatus.ACTIVE     # In progress
TaskStatus.COMPLETED  # Successfully done
TaskStatus.FAILED     # Failed
TaskStatus.CANCELLED  # Cancelled
```

---

### FormationControl

Multi-robot formation control.

```python
from horus import FormationControl, FormationType

formation = FormationControl()
formation.formation_type = FormationType.LINE
formation.spacing = 2.0           # Distance between robots
formation.leader_id = "robot_01"

# Formation types
FormationType.LINE       # Single file line
FormationType.COLUMN     # Side-by-side column
FormationType.WEDGE      # V-shaped wedge
FormationType.CIRCLE     # Circular formation
FormationType.CUSTOM     # Custom positions
```

---

## Complete Message Reference

| Category | Python Classes |
|----------|---------------|
| **Geometry** | Pose2D, Twist, Transform, Point3, Vector3, Quaternion |
| **Control** | CmdVel, MotorCommand, DifferentialDriveCommand, ServoCommand, PwmCommand, StepperCommand, PidConfig |
| **Sensor** | LaserScan, Imu, BatteryState, NavSatFix, Odometry, Range |
| **Diagnostics** | Status, EmergencyStop, Heartbeat, ResourceUsage |
| **Input** | JoystickInput, KeyboardInput |
| **I/O** | DigitalIO, AnalogIO |
| **Vision** | ImageEncoding, Image, CompressedImage, CameraInfo, RegionOfInterest, Detection, DetectionArray, StereoInfo |
| **Navigation** | GoalStatus, Goal, GoalResult, Waypoint, Path, OccupancyGrid, CostMap, VelocityObstacle, VelocityObstacles, PathPlan |
| **Perception** | PointFieldType, PointField, PointCloud, BoundingBox3D, BoundingBoxArray3D, DepthImage, PlaneDetection, PlaneArray |
| **Force/Tactile** | ContactState, WrenchStamped, TactileArray, ImpedanceParameters, ForceCommand, ContactInfo, HapticFeedback |
| **Coordination** | RobotType, CoordinationMode, TaskType, TaskStatus, FormationType, BidStatus, RobotState, FleetStatus, TaskAssignment, FormationControl, AuctionBid |

---

## See Also

- [Python Bindings](/python/api/python-bindings) - Full Python API guide
- [Multi-Language Support](/concepts/multi-language) - Cross-language communication
- [Message Types](/concepts/message-types) - Rust message type documentation
