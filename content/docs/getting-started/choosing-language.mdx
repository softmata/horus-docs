---
title: Choosing a Language
description: Should you use Rust or Python with HORUS?
order: 5
---

# Choosing a Language

HORUS supports both **Rust** and **Python**. This guide helps you choose the right one for your project.

---

## Quick Decision

**Use Python if:**
- You're prototyping or experimenting
- You're new to robotics programming
- You want to integrate with ML/AI libraries (TensorFlow, PyTorch)
- Development speed matters more than runtime performance

**Use Rust if:**
- You need maximum performance
- You're building production systems
- You want compile-time safety guarantees
- You're comfortable with Rust (or want to learn)

---

## Side-by-Side Comparison

### Hello World: Temperature Sensor

**Python:**
```python
from horus import Node, Hub, Scheduler

class TempSensor(Node):
    def __init__(self):
        self.pub = Hub("temperature")

    def name(self):
        return "TempSensor"

    def tick(self, ctx):
        temp = 25.0  # Read sensor
        self.pub.send(temp, ctx)

scheduler = Scheduler()
scheduler.add(TempSensor(), priority=5)
scheduler.run()
```

**Rust:**
```rust
use horus::prelude::*;

struct TempSensor {
    pub_hub: Hub<f32>,
}

impl TempSensor {
    fn new() -> Result<Self> {
        Ok(Self { pub_hub: Hub::new("temperature")? })
    }
}

impl Node for TempSensor {
    fn name(&self) -> &'static str { "TempSensor" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        let temp = 25.0;  // Read sensor
        self.pub_hub.send(temp, &mut ctx).ok();
    }
}

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(TempSensor::new()?), 5, Some(true));
    scheduler.run()
}
```

**Or with the Rust node! macro:**
```rust
use horus::prelude::*;

node! {
    name: TempSensor,
    publishers: [temperature: f32],

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        let temp = 25.0;
        self.temperature.send(temp, &mut ctx).ok();
    }
}

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(TempSensor::new()?), 5, Some(true));
    scheduler.run()
}
```

---

## Detailed Comparison

| Aspect | Python | Rust |
|--------|--------|------|
| **Learning curve** | Easy | Steeper |
| **Setup time** | 5 minutes | 10 minutes |
| **Compile time** | None | A few seconds |
| **Runtime performance** | Good | Excellent |
| **Memory safety** | Runtime checks | Compile-time guarantees |
| **ML/AI integration** | Excellent (numpy, torch, etc.) | Limited |
| **Debugging** | Simple print debugging | More tooling needed |
| **Production readiness** | Good for prototypes | Production-grade |

---

## Performance Comparison

| Operation | Python | Rust | Difference |
|-----------|--------|------|------------|
| Node tick latency | ~10μs | ~1μs | 10x faster |
| Message send | ~2μs | ~400ns | 5x faster |
| Control loop (1kHz) | Achievable | Easy | - |
| Control loop (10kHz) | Difficult | Achievable | - |

**Bottom line:** For most robotics applications, both are fast enough. Rust matters when you need:
- Very high-frequency control (>1kHz)
- Hard real-time guarantees
- Minimal memory footprint

---

## When to Choose Python

### Rapid Prototyping

```python
# Quick experiment - try different approaches fast
from horus import Node, Hub

class ExperimentalController(Node):
    def tick(self, ctx):
        # Easy to modify and test
        if self.strategy == "aggressive":
            output = self.input * 2.0
        else:
            output = self.input * 0.5
        self.pub.send(output, ctx)
```

### Machine Learning Integration

```python
import torch
from horus import Node, Hub

class MLController(Node):
    def __init__(self):
        self.model = torch.load("my_model.pt")
        self.pub = Hub("control_output")

    def tick(self, ctx):
        # Easy integration with PyTorch
        with torch.no_grad():
            output = self.model(self.sensor_data)
        self.pub.send(output.item(), ctx)
```

### Education and Learning

Python's readable syntax makes it easier to understand robotics concepts without fighting the language.

---

## When to Choose Rust

### Production Deployments

```rust
// Rust catches bugs at compile time
impl Node for SafetyMonitor {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Compiler ensures we handle all cases
        match self.check_safety() {
            SafetyStatus::OK => self.continue_operation(),
            SafetyStatus::Warning(msg) => self.log_warning(&msg),
            SafetyStatus::Critical(msg) => self.emergency_stop(&msg),
        }
    }
}
```

### High-Frequency Control

```rust
// Rust can sustain 10kHz+ control loops
impl Node for MotorController {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Microsecond-level timing is reliable
        let error = self.target - self.position;
        let output = self.pid.compute(error);
        self.motor.send(output, &mut ctx).ok();
    }
}
```

### Resource-Constrained Environments

```rust
// Rust has minimal runtime overhead
// Perfect for embedded systems and single-board computers
```

---

## Mixed Language Projects

You can use both languages in the same project! HORUS nodes communicate via shared memory, which works across languages.

**Example:** Python for AI, Rust for control

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Python Node    │     │   Rust Node     │     │   Rust Node     │
│  (ML Inference) │────>│  (Controller)   │────>│  (Motor Driver) │
│  10 Hz          │     │  100 Hz         │     │  1000 Hz        │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

**Python ML node:**
```python
class ObjectDetector(Node):
    def tick(self, ctx):
        detections = self.model.detect(self.camera_image)
        self.pub.send(detections, ctx)  # Publishes to "detections"
```

**Rust control node:**
```rust
impl Node for NavigationController {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(detections) = self.detection_sub.recv(&mut ctx) {
            // React to Python node's output
            self.plan_path(&detections);
        }
    }
}
```

---

## Recommendation by Use Case

| Use Case | Recommended Language |
|----------|---------------------|
| Learning HORUS | Python |
| University project | Python |
| Hobby robot | Either |
| Machine learning robot | Python + Rust |
| Industrial automation | Rust |
| Drone/UAV | Rust |
| Research prototype | Python |
| Competition robot | Rust |
| Product development | Rust |

---

## Getting Started

**Ready to start with Python?**
- [Complete Beginner's Guide](/getting-started/complete-beginners-guide) (uses Python)
- [Python API Reference](/python/api/python-bindings)

**Ready to start with Rust?**
- [Quick Start](/getting-started/quick-start) (uses Rust)
- [node! Macro Guide](/concepts/node-macro)
- [Rust API Reference](/rust/api/core)

---

## Still Unsure?

**Start with Python.** It's faster to get something working, and you can always port critical parts to Rust later. HORUS makes it easy to mix languages.
