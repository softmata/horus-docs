---
title: Building Your Second Application
description: Build a 3-node sensor pipeline with filtering and display
order: 9
---

# Building Your Second Application

Now that you've built your first HORUS application, let's create something more practical: a **3-node sensor pipeline** that reads temperature data, filters out noise, and displays the results.

## What You'll Build

A real-time temperature monitoring system with:

1. **SensorNode**: Publishes simulated temperature readings every second
2. **FilterNode**: Subscribes to raw temperatures, filters noise, republishes clean data
3. **DisplayNode**: Subscribes to filtered data, displays to console

This demonstrates:
- Multi-node communication patterns
- Data pipeline processing
- Real-time filtering
- Monitor monitoring

## Architecture

```
SensorNode          FilterNode          DisplayNode
    |                   |                    |
    | --raw_temp-->     |                    |
    |                   | --filtered_temp--> |
    |                   |                    |
    v                   v                    v
   Publish           Process              Display
   25.3°C          Remove noise          "Temp: 25.0°C"
```

## Step 1: Create the Project

```bash
horus new temperature_pipeline
cd temperature_pipeline
```

## Step 2: Write the Code

Replace `main.rs` with this complete, runnable code:

```rust
use horus::prelude::*;
use std::time::{Duration, Instant};

// ============================================================================
// Node 1: SensorNode - Publishes temperature readings
// ============================================================================

struct SensorNode {
    temp_pub: Hub<f32>,
    last_publish: Instant,
    reading: f32,
}

impl SensorNode {
    fn new() -> Result<Self> {
        Ok(Self {
            temp_pub: Hub::new("raw_temp")?,
            last_publish: Instant::now(),
            reading: 20.0,
        })
    }
}

impl Node for SensorNode {
    fn name(&self) -> &'static str {
        "SensorNode"
    }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Temperature sensor initialized");
        Ok(())
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Publish every 1 second
        if self.last_publish.elapsed() >= Duration::from_secs(1) {
            // Simulate realistic temperature with noise
            // Base temperature oscillates between 20-30°C
            let base_temp = 25.0 + (self.reading * 0.1).sin() * 5.0;

            // Add random noise (+/- 2°C)
            let noise = (self.reading * 0.7).sin() * 2.0;
            let temperature = base_temp + noise;

            // Publish raw temperature
            self.temp_pub.send(temperature, &mut ctx).ok();

            ctx.log_info(&format!("Published raw temp: {:.2}°C", temperature));

            self.reading += 1.0;
            self.last_publish = Instant::now();
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Sensor shutdown complete");
        Ok(())
    }
}

// ============================================================================
// Node 2: FilterNode - Removes noise with exponential moving average
// ============================================================================

struct FilterNode {
    raw_sub: Hub<f32>,
    filtered_pub: Hub<f32>,
    filtered_value: Option<f32>,
    alpha: f32,  // Smoothing factor (0.0 - 1.0)
}

impl FilterNode {
    fn new() -> Result<Self> {
        Ok(Self {
            raw_sub: Hub::new("raw_temp")?,
            filtered_pub: Hub::new("filtered_temp")?,
            filtered_value: None,
            alpha: 0.3,  // 30% new data, 70% previous (smooth but responsive)
        })
    }
}

impl Node for FilterNode {
    fn name(&self) -> &'static str {
        "FilterNode"
    }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info(&format!("Filter initialized (alpha = {:.2})", self.alpha));
        Ok(())
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Check for new temperature reading
        if let Some(raw_temp) = self.raw_sub.recv(&mut ctx) {
            // Apply exponential moving average filter
            let filtered = match self.filtered_value {
                Some(prev) => self.alpha * raw_temp + (1.0 - self.alpha) * prev,
                None => raw_temp,  // First reading, no previous value
            };

            self.filtered_value = Some(filtered);

            // Publish filtered temperature
            self.filtered_pub.send(filtered, &mut ctx).ok();

            ctx.log_info(&format!(
                    "Filtered: {:.2}°C -> {:.2}°C (removed {:.2}°C noise)",
                    raw_temp, filtered, raw_temp - filtered
                ));
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Filter shutdown complete");
        Ok(())
    }
}

// ============================================================================
// Node 3: DisplayNode - Shows filtered temperature on console
// ============================================================================

struct DisplayNode {
    filtered_sub: Hub<f32>,
    display_counter: u32,
}

impl DisplayNode {
    fn new() -> Result<Self> {
        Ok(Self {
            filtered_sub: Hub::new("filtered_temp")?,
            display_counter: 0,
        })
    }
}

impl Node for DisplayNode {
    fn name(&self) -> &'static str {
        "DisplayNode"
    }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Display initialized");
        println!("\n========================================");
        println!("  Temperature Monitor - Press Ctrl+C to stop");
        println!("========================================\n");
        Ok(())
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(temp) = self.filtered_sub.recv(&mut ctx) {
            self.display_counter += 1;

            // Display temperature with visual indicator
            let status = if temp < 22.0 {
                "COLD"
            } else if temp > 28.0 {
                "HOT"
            } else {
                "NORMAL"
            };

            println!(
                "[Reading #{}] Temperature: {:.1}°C - Status: {}",
                self.display_counter, temp, status
            );

            ctx.log_debug(&format!("Displayed reading #{}", self.display_counter));
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        println!("\n========================================");
        println!("  Total readings displayed: {}", self.display_counter);
        println!("========================================\n");
        ctx.log_info("Display shutdown complete");
        Ok(())
    }
}

// ============================================================================
// Main Application - Configure and run the scheduler
// ============================================================================

fn main() -> Result<()> {
    println!("Starting Temperature Pipeline...\n");

    let mut scheduler = Scheduler::new();

    // Add nodes in priority order:
    // 1. SensorNode (Priority 0 - Highest) - Runs first to generate data
    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));

    // 2. FilterNode (Priority 1 - High) - Runs second to process data
    scheduler.add(Box::new(FilterNode::new()?), 1, Some(true));

    // 3. DisplayNode (Priority 2 - Normal) - Runs last to display results
    scheduler.add(Box::new(DisplayNode::new()?), 2, Some(true));

    println!("All nodes initialized. Running...\n");

    // Run the scheduler (blocks until Ctrl+C)
    scheduler.run()?;

    Ok(())
}
```

## Step 3: Run the Application

```bash
horus run
```

**Expected Output:**

```
Starting Temperature Pipeline...

All nodes initialized. Running...

========================================
  Temperature Monitor - Press Ctrl+C to stop
========================================

[Reading #1] Temperature: 23.4°C - Status: NORMAL
[Reading #2] Temperature: 24.1°C - Status: NORMAL
[Reading #3] Temperature: 25.8°C - Status: NORMAL
[Reading #4] Temperature: 27.2°C - Status: NORMAL
[Reading #5] Temperature: 28.6°C - Status: HOT
[Reading #6] Temperature: 27.9°C - Status: NORMAL
[Reading #7] Temperature: 26.3°C - Status: NORMAL
```

Press **Ctrl+C** to stop:

```
^C
Ctrl+C received! Shutting down HORUS scheduler...

========================================
  Total readings displayed: 7
========================================
```

## Step 4: Monitor with Monitor

Open a **second terminal** and run:

```bash
horus monitor
```

The monitor will show:

### Nodes Tab
- **SensorNode**: Publishing to `raw_temp` every ~1 second
- **FilterNode**: Subscribing to `raw_temp`, publishing to `filtered_temp`
- **DisplayNode**: Subscribing to `filtered_temp`

### Topics Tab
- **raw_temp** (f32): Noisy temperature readings
- **filtered_temp** (f32): Smooth temperature readings

### Metrics Tab
- **IPC Latency**: 248ns-437ns (sub-microsecond!)
- **Tick Duration**: How long each node takes to execute
- **Message Counts**: Total messages sent/received

## Understanding the Code

### SensorNode

```rust
// Publish every 1 second
if self.last_publish.elapsed() >= Duration::from_secs(1) {
    let temperature = 25.0 + noise;
    self.temp_pub.send(temperature, &mut ctx).ok();
}
```

**Key Points:**
- Uses `Instant` to track time between publishes
- Simulates realistic sensor data with noise
- Publishes to `"raw_temp"` topic

### FilterNode

```rust
// Exponential moving average filter
let filtered = self.alpha * raw_temp + (1.0 - self.alpha) * prev;
self.filtered_pub.send(filtered, &mut ctx).ok();
```

**Key Points:**
- Subscribes to `"raw_temp"`, publishes to `"filtered_temp"`
- Implements exponential moving average (EMA) filter
- `alpha = 0.3` balances responsiveness vs smoothness

**Filter Behavior:**
- **High alpha (0.8)**: Fast response, less smoothing
- **Low alpha (0.2)**: Slow response, more smoothing

### DisplayNode

```rust
if let Some(temp) = self.filtered_sub.recv(&mut ctx) {
    println!("[Reading #{}] Temperature: {:.1}°C", count, temp);
}
```

**Key Points:**
- Subscribes to `"filtered_temp"`
- Only receives when new data is available
- `recv()` returns `None` when no message (not an error!)

## Common Issues & Fixes

### Issue 1: No Output Displayed

**Symptom:**
```
Starting Temperature Pipeline...
All nodes initialized. Running...

========================================
  Temperature Monitor - Press Ctrl+C to stop
========================================

[Nothing appears]
```

**Cause:** Topics not connecting (typo in topic names)

**Fix:**
- Check topic names match exactly: `"raw_temp"` and `"filtered_temp"`
- Verify with monitor: `horus monitor` -> Topics tab
- Ensure all nodes are running in same scheduler

### Issue 2: Too Much/Too Little Smoothing

**Symptom:** Temperature changes too fast or too slow

**Fix:** Adjust the `alpha` value in `FilterNode`:

```rust
alpha: 0.3,  // Current: moderate smoothing

// Try these alternatives:
alpha: 0.7,  // More responsive, less smooth
alpha: 0.1,  // Very smooth, slower response
```

### Issue 3: Monitor Shows No Nodes

**Symptom:** Monitor is empty

**Cause:** Application not running or monitor started before app

**Fix:**
1. Start the application first: `horus run`
2. Then start monitor in separate terminal: `horus monitor`
3. Monitor auto-discovers running nodes

### Issue 4: Build Errors

**Symptom:**
```
error[E0433]: failed to resolve: use of undeclared type `Hub`
```

**Fix:**
- Ensure HORUS is installed: `horus --help`
- Check import: `use horus::prelude::*;`
- Run from project directory (where `Cargo.toml` is)

## Experiments to Try

### 1. Change Update Rate

Make the sensor publish faster:

```rust
// In SensorNode::tick()
if self.last_publish.elapsed() >= Duration::from_millis(500) {  // 2 Hz instead of 1 Hz
```

### 2. Add Temperature Alerts

Add to `DisplayNode`:

```rust
if temp > 30.0 {
    println!("  WARNING: High temperature detected!");
}
```

### 3. Log Data to File

Add to `DisplayNode::tick()`:

```rust
use std::fs::OpenOptions;
use std::io::Write;

let mut file = OpenOptions::new()
    .create(true)
    .append(true)
    .open("temperature_log.txt")
    .unwrap();

writeln!(file, "{:.1}", temp).ok();
```

### 4. Add Multiple Sensors

Create a second sensor node:

```rust
// In main()
scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));  // Sensor 1
scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));  // Sensor 2
```

Both will publish to the same topic, and FilterNode will process both!

## Key Concepts Demonstrated

**Pipeline Pattern**: Data flows through stages (Sensor -> Filter -> Display)

**Pub/Sub Decoupling**: Nodes don't know about each other, only topics

**Real-Time Processing**: Filtering happens as data arrives

**Shared Memory IPC**: Sub-microsecond communication between nodes

**Priority Scheduling**: Sensor runs before filter, filter before display

## Next Steps

Now that you've built a 3-node pipeline, try:

1. **[Testing](/development/testing)** - Learn how to unit test your nodes
2. **[Using Pre-Built Nodes](/package-management/using-prebuilt-nodes)** - Use library nodes instead of writing from scratch
3. **[node! Macro](/concepts/node-macro)** - Reduce boilerplate with macros
4. **[Message Types](/concepts/message-types)** - Use complex message types instead of primitives

## Full Code

The complete code above is production-ready. To save it:

1. Copy the entire code block
2. Replace `main.rs` in your project
3. Run with `horus run`

You can also find this example in the HORUS repository:
```bash
horus new --example temperature_pipeline
```

For additional examples, see [Basic Examples](/rust/examples/basic-examples).
