---
title: Hardware Discovery
description: Automatically detect and identify connected robotics hardware
---

# Hardware Discovery

HORUS provides a comprehensive **hardware discovery system** that automatically detects and identifies connected devices. This is essential for:

- **Auto-configuration** - Detect hardware at startup and configure nodes automatically
- **Development** - See what's connected without memorizing device paths
- **Deployment** - Verify hardware before running your robot
- **Debugging** - Identify missing or misconfigured devices

## Quick Start

```rust
use horus::prelude::*;

fn main() -> Result<()> {
    // Create discovery instance
    let discovery = HardwareDiscovery::new()?;

    // Get platform info
    println!("Platform: {:?}", discovery.platform());

    // Scan all hardware
    let report = discovery.scan_all();

    // Print summary
    println!("{}", report.summary());

    Ok(())
}
```

Output:
```
Platform: RaspberryPi4
Hardware Discovery Summary:
  USB devices: 12
  Serial ports: 3
  I2C buses: 2 (14 devices)
  SPI buses: 1
  CAN interfaces: 1
  GPIO chips: 1 (54 lines)
  Cameras: 1
  Network interfaces: 3
```

---

## Platform Detection

HORUS automatically detects the host platform:

```rust
use horus::prelude::*;

let detector = PlatformDetector::new();
let platform = detector.detect();

match platform {
    Platform::RaspberryPi4 => println!("Running on Pi 4"),
    Platform::RaspberryPi5 => println!("Running on Pi 5"),
    Platform::JetsonNano => println!("Running on Jetson Nano"),
    Platform::JetsonOrin => println!("Running on Jetson Orin"),
    Platform::BeagleBoneBlack => println!("Running on BeagleBone"),
    Platform::GenericLinux => println!("Generic Linux system"),
    Platform::Unknown => println!("Unknown platform"),
}

// Get platform capabilities
let caps = detector.capabilities();
println!("Has GPIO: {}", caps.has_gpio);
println!("Has I2C: {}", caps.has_i2c);
println!("Has SPI: {}", caps.has_spi);
println!("Has CAN: {}", caps.has_can);
println!("Has PWM: {}", caps.has_pwm);
println!("GPU: {:?}", caps.gpu);
```

### Supported Platforms

| Platform | Detection Method |
|----------|-----------------|
| Raspberry Pi 3/4/5 | `/proc/device-tree/model` |
| NVIDIA Jetson (Nano, Xavier, Orin) | `/proc/device-tree/model` |
| BeagleBone Black/AI | `/proc/device-tree/model` |
| Intel NUC | CPU info |
| Generic Linux | Fallback |

---

## Scanning Hardware

### Full Scan

Scan all hardware categories:

```rust
let discovery = HardwareDiscovery::new()?;
let report = discovery.scan_all();

// Access results
println!("USB devices: {}", report.usb_devices.len());
println!("Serial ports: {}", report.serial_ports.len());
println!("I2C devices: {}", report.i2c_devices.len());
println!("Cameras: {}", report.cameras.len());
```

### Selective Scan

Scan only specific categories for faster results:

```rust
use horus::prelude::*;

let discovery = HardwareDiscovery::new()?;

// Only scan for sensors
let options = DiscoveryOptions::default()
    .with_categories(CategoryFilter::only(&[
        DeviceCategory::Camera,
        DeviceCategory::Lidar,
        DeviceCategory::Imu,
        DeviceCategory::Gps,
    ]));

let report = discovery.scan_with_options(&options);
```

### Available Categories

```rust
pub enum DeviceCategory {
    Microcontroller,   // Arduino, Teensy, ESP32, STM32
    SerialAdapter,     // FTDI, CP210x, CH340
    MotorController,   // ODrive, VESC, RoboClaw
    ServoController,   // Dynamixel, Pololu Maestro
    Lidar,             // RPLIDAR, Velodyne, Livox
    DepthCamera,       // RealSense, ZED, Azure Kinect
    Camera,            // USB cameras, CSI cameras
    Imu,               // MPU6050, BNO055, ICM-20948
    Gps,               // u-blox, NMEA GPS modules
    CanAdapter,        // PEAK, Kvaser, Canable
    Joystick,          // Gamepads, RC controllers
    Bluetooth,         // Bluetooth adapters
    Audio,             // USB microphones, speakers
    Network,           // WiFi, Ethernet adapters
    Power,             // Battery monitors, power supplies
    Display,           // HDMI, LCD displays
    Storage,           // USB drives, SD cards
    Other,             // Unclassified devices
}
```

---

## Device Identification

HORUS includes a database of 100+ robotics devices with VID/PID mappings.

### USB Device Identification

```rust
let discovery = HardwareDiscovery::new()?;
let report = discovery.scan_all();

for device in &report.usb_devices {
    println!("USB: {} (VID:{:04X} PID:{:04X})",
        device.product.as_deref().unwrap_or("Unknown"),
        device.vendor_id,
        device.product_id
    );

    // Get device info from database
    if let Some(info) = discovery.database().lookup_usb(device.vendor_id, device.product_id) {
        println!("  Identified as: {} ({})", info.name, info.category.name());
        println!("  Driver: {:?}", info.driver);
    }
}
```

### Identified Device Categories

The database includes:

- **Motor Controllers**: ODrive, VESC, RoboClaw, Pololu
- **Servo Controllers**: Dynamixel U2D2, Pololu Maestro
- **LiDARs**: RPLIDAR A1/A2/S1, Velodyne, Livox, Hokuyo
- **Depth Cameras**: Intel RealSense D435/D455/L515, ZED, Azure Kinect, OAK-D
- **IMUs**: SparkFun, Adafruit, Phidgets, Xsens
- **GPS**: u-blox, SiRF, GlobalSat
- **CAN Adapters**: PEAK-System, Kvaser, Canable, USBtin
- **Serial Adapters**: FTDI, CP210x, CH340, PL2303
- **Microcontrollers**: Arduino, Teensy, ESP32, STM32, Raspberry Pi Pico
- **Joysticks**: Xbox, PlayStation, Logitech
- **Bluetooth**: Intel, Broadcom, Realtek, Qualcomm
- **Audio**: Blue Yeti, Seeed ReSpeaker, Focusrite

---

## Bus Scanners

### I2C Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut i2c = I2cDiscovery::new();
    let buses = i2c.enumerate_buses();

    for bus in buses {
        println!("I2C Bus {} ({}):", bus.bus_number, bus.path.display());

        for device in &bus.devices {
            println!("  0x{:02X}: {}",
                device.address,
                device.name.as_deref().unwrap_or("Unknown")
            );
        }
    }
}
```

Common I2C devices detected:
- **IMUs**: MPU6050 (0x68), BNO055 (0x28), ICM-20948 (0x69)
- **Displays**: SSD1306 OLED (0x3C), LCD (0x27)
- **ADCs**: ADS1115 (0x48), MCP3008
- **Motor Drivers**: PCA9685 (0x40)
- **Sensors**: BME280 (0x76), VL53L0X (0x29)

### SPI Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut spi = SpiDiscovery::new();
    let buses = spi.enumerate_buses();

    for bus in buses {
        println!("SPI Bus {}:", bus.bus_number);
        for cs in &bus.chip_selects {
            println!("  CS{}: {}", cs.chip_select, cs.device_path.display());
        }
    }
}
```

### CAN Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut can = CanDiscovery::new();
    let interfaces = can.enumerate_interfaces();

    for iface in interfaces {
        println!("CAN: {} ({:?})", iface.name, iface.interface_type);
        println!("  State: {:?}", iface.state);
        println!("  Bitrate: {} bps", iface.bitrate.unwrap_or(0));
    }
}
```

### GPIO Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut gpio = GpioDiscovery::new();
    let chips = gpio.enumerate_chips();

    for chip in chips {
        println!("GPIO Chip: {} ({})", chip.name, chip.label);
        println!("  Lines: {}", chip.num_lines);

        for line in &chip.lines {
            if line.consumer.is_some() {
                println!("  Line {}: {} (in use by {:?})",
                    line.offset, line.name, line.consumer);
            }
        }
    }
}
```

### PWM Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut pwm = PwmDiscovery::new();
    let chips = pwm.enumerate_chips();

    for chip in chips {
        println!("PWM Chip {} ({} channels):", chip.chip_number, chip.num_channels);

        for channel in &chip.channels {
            println!("  Channel {}: {}Hz, {:?} polarity",
                channel.channel_number,
                channel.frequency.unwrap_or(0),
                channel.polarity);
        }
    }
}
```

---

## Peripheral Scanners

### Camera Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut cameras = CameraDiscovery::new();
    let devices = cameras.enumerate_cameras();

    for camera in devices {
        println!("Camera: {} ({:?})", camera.name, camera.camera_type);
        println!("  Path: {}", camera.device_path.display());

        for format in &camera.formats {
            println!("  Format: {:?} {}x{} @ {}fps",
                format.pixel_format,
                format.width, format.height,
                format.fps);
        }
    }
}
```

### Bluetooth Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut bluetooth = BluetoothDiscovery::new();
    let adapters = bluetooth.enumerate_adapters();

    for adapter in adapters {
        println!("Bluetooth: {} ({:?})", adapter.name, adapter.adapter_type);
        println!("  Address: {}", adapter.address);
        println!("  State: {:?}", adapter.state);

        for device in &adapter.devices {
            println!("  Device: {} ({})", device.name, device.address);
        }
    }
}
```

### Network Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut network = NetworkDiscovery::new();
    let interfaces = network.enumerate_interfaces();

    for iface in interfaces {
        println!("Network: {} ({:?})", iface.name, iface.interface_type);
        println!("  State: {:?}", iface.state);

        if let Some(ip) = &iface.ip_address {
            println!("  IP: {}", ip);
        }

        if let Some(wifi) = &iface.wifi_info {
            println!("  WiFi SSID: {}", wifi.ssid);
            println!("  Signal: {} dBm", wifi.signal_strength);
        }
    }
}
```

### Audio Discovery

```rust
#[cfg(target_os = "linux")]
{
    let mut audio = AudioDiscovery::new();
    let cards = audio.enumerate_cards();

    for card in cards {
        println!("Audio: {} ({:?})", card.card_name, card.device_type);
        println!("  Driver: {:?}", card.driver);
        println!("  Playback: {}, Capture: {}",
            card.can_playback(), card.can_capture());

        for device in &card.devices {
            println!("  Device: {} ({:?})", device.device_name, device.direction);
        }
    }
}
```

---

## CLI Usage

Use `horus doctor` for hardware discovery from the command line:

```bash
# Full hardware scan
horus doctor --hardware

# Specific categories
horus doctor --hardware --categories usb,i2c,camera

# JSON output for scripting
horus doctor --hardware --json

# Verbose with device database lookup
horus doctor --hardware --verbose
```

Example output:
```
HORUS Hardware Discovery
========================

Platform: Raspberry Pi 4 Model B Rev 1.4
  CPU: 4 cores @ 1500 MHz
  Memory: 4 GB
  GPU: VideoCore VI

USB Devices (8):
  ✓ RPLIDAR A2 (Slamtec)         /dev/ttyUSB0
  ✓ Intel RealSense D435         /dev/video0
  ✓ Arduino Mega 2560            /dev/ttyACM0
  ✓ Xbox Wireless Controller     /dev/input/js0

I2C Devices (5):
  Bus 1:
    ✓ 0x28: BNO055 IMU
    ✓ 0x40: PCA9685 PWM Driver
    ✓ 0x76: BME280 Environmental Sensor

Serial Ports (3):
  /dev/ttyUSB0: RPLIDAR A2 (115200 baud)
  /dev/ttyACM0: Arduino Mega 2560
  /dev/ttyAMA0: Raspberry Pi UART

CAN Interfaces (1):
  can0: SocketCAN (1000000 bps, UP)
```

---

## Integration with Nodes

Auto-configure nodes based on discovered hardware:

```rust
use horus::prelude::*;

fn auto_configure_robot() -> Result<Vec<Box<dyn Node>>> {
    let discovery = HardwareDiscovery::new()?;
    let report = discovery.scan_all();

    let mut nodes: Vec<Box<dyn Node>> = Vec::new();

    // Auto-configure LiDAR if found
    for device in &report.usb_devices {
        if let Some(info) = discovery.database().lookup_usb(device.vendor_id, device.product_id) {
            match info.category {
                DeviceCategory::Lidar => {
                    if let Some(port) = &device.serial_port {
                        #[cfg(feature = "rplidar")]
                        nodes.push(Box::new(LidarNode::new(port)?));
                    }
                }
                DeviceCategory::Imu => {
                    // Configure IMU node
                }
                DeviceCategory::Camera => {
                    // Configure camera node
                }
                _ => {}
            }
        }
    }

    Ok(nodes)
}
```

---

## Best Practices

1. **Scan at startup** - Run discovery once at application start
2. **Cache results** - Don't re-scan frequently; hardware rarely changes
3. **Handle missing hardware** - Gracefully degrade when devices aren't found
4. **Use selective scanning** - Only scan categories you need for faster startup
5. **Verify before deploy** - Use `horus doctor` to verify hardware setup

```rust
// Good: Scan once, use many times
let discovery = HardwareDiscovery::new()?;
let report = discovery.scan_all();

// Check required hardware
let has_lidar = report.usb_devices.iter()
    .any(|d| d.product.as_deref().map_or(false, |p| p.contains("RPLIDAR")));

if !has_lidar {
    eprintln!("Warning: LiDAR not detected, using simulation");
}
```

---

## See Also

- [Hardware Drivers](/rust/library/drivers) - Low-level driver implementations
- [Built-in Nodes](/rust/library/built-in-nodes) - Pre-built hardware nodes
- [CLI Reference](/development/cli-reference) - Command-line tools
- [Testing](/development/testing) - Testing with simulated hardware
