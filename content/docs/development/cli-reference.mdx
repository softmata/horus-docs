---
title: CLI Reference
description: Complete guide to all HORUS commands
order: 40
---

# CLI Reference

The `horus` command gives you everything you need to build, run, and manage your applications. This page covers all 31 commands.

## Quick Reference

```bash
# Project Management
horus init                 # Initialize workspace in current directory
horus new <name>           # Create a new project
horus run [file]           # Build and run your app
horus build                # Build without running
horus test                 # Run tests
horus check                # Validate dependencies and environment
horus clean                # Clean build artifacts and shared memory

# Monitoring & Debugging
horus monitor [port]       # Monitor your system (web or TUI)
horus topic <command>      # Topic introspection (list, echo, info, hz, pub)
horus node <command>       # Node management (list, info, kill, restart)
horus log [node]           # View and filter logs
horus doctor               # System diagnostics and health check

# Simulation
horus sim2d                # Launch 2D simulator
horus sim3d                # Launch 3D simulator

# Coordinate Frames
horus hf <command>         # HORUS Frames (list, echo, tree, info, can, hz)

# Package Management
horus pkg <command>        # Manage packages (install, publish, etc.)
horus add <name>           # Add package, driver, or plugin (smart detection)
horus remove <name>        # Remove package, driver, or plugin
horus drivers <command>    # Driver management (list, info, search)
horus plugin <command>     # Plugin management (list, enable, disable)
horus cache <command>      # Cache management (info, clean, purge)

# Parameters & Messages
horus param <command>      # Parameter management (get, set, list, dump)
horus msg <command>        # Message type introspection (list, show, md5)

# Advanced
horus launch <file>        # Launch multiple nodes from YAML
horus deploy [target]      # Deploy to remote robot
horus from-ros <source>    # Convert ROS package to HORUS
horus bridge <command>     # ROS2 bridge for interoperability
horus hardware <command>   # Hardware discovery and platform detection
horus record <command>     # Record/replay for debugging and testing

# Environment & Auth
horus env <command>        # Save/restore environments
horus auth <command>       # Login to registry
```

---

## `horus init` - Initialize Workspace

**What it does**: Initializes a HORUS workspace in the current directory, creating the necessary configuration files.

**Why it's useful**: Quickly set up an existing directory as a HORUS project without creating new files from templates.

### Basic Usage

```bash
# Initialize in current directory (uses directory name)
horus init

# Initialize with custom name
horus init --name my_robot
```

### All Options

```bash
horus init [OPTIONS]

Options:
  -n, --name <NAME>    Workspace name (defaults to directory name)
```

### Examples

**Initialize existing code as HORUS project**:
```bash
cd ~/my-robot-code
horus init
# Creates horus.yaml with project configuration
```

**Initialize with specific name**:
```bash
horus init --name sensor_array
```

### What Gets Created

Running `horus init` creates:
- `horus.yaml` - Project manifest with name and version

This is useful when you have existing code and want to add HORUS support, or when setting up a workspace that will contain multiple HORUS projects.

---

## `horus new` - Create Projects

**What it does**: Creates a new HORUS project with all the boilerplate set up for you.

**Why it's useful**: Minimal configuration required. Select a language and begin development.

### Basic Usage

```bash
# Interactive mode (asks you questions)
horus new my_project

# Rust with node! macro (recommended for reduced boilerplate)
horus new my_project --macro

# Python project
horus new my_project --python
```

### All Options

```bash
horus new <NAME> [OPTIONS]

Options:
  -m, --macro              Rust with node! macro (less boilerplate)
  -r, --rust               Plain Rust project
  -p, --python             Python project
  -o, --output <PATH>      Where to create it (default: current directory)
```

### Examples

**Start with Rust + macros** (easiest):
```bash
horus new temperature_monitor --macro
cd temperature_monitor
horus run
```

**Python for prototyping**:
```bash
horus new sensor_test --python
cd sensor_test
python main.py
```

**Put it somewhere specific**:
```bash
horus new robot_controller --output ~/projects/robots
```

---

## `horus run` - Build and Run

**What it does**: Compiles your code and runs it. Handles all the build tools for you.

**Why it's useful**: One command works for Rust and Python. For Rust, it auto-generates `Cargo.toml` from `horus.yaml` and uses Cargo for compilation. For Python, it handles the appropriate tooling.

### Basic Usage

```bash
# Run current directory (finds main.rs or main.py)
horus run

# Run specific file
horus run src/controller.rs

# Run optimized (release mode)
horus run --release
```

### All Options

```bash
horus run [FILE] [OPTIONS] [-- ARGS]

Options:
  -r, --release            Optimize for speed (recommended for benchmarks)
  -c, --clean              Remove cached build artifacts and dependencies
                           (Use after updating HORUS or when compilation fails)
  -d, --drivers <LIST>     Override detected drivers (comma-separated)
                           Example: --drivers camera,lidar,imu
  -e, --enable <LIST>      Enable capabilities (comma-separated)
                           Example: --enable cuda,editor,python
  -- <ARGS>                Arguments for your program
```

### Using --enable for Capabilities

The `--enable` flag lets you quickly enable features without editing `horus.yaml`:

```bash
# Enable CUDA GPU acceleration
horus run --enable cuda

# Enable multiple capabilities
horus run --enable cuda,editor,python

# Combine with hardware features
horus run --enable gpio,i2c --release
```

**Available capabilities:**

| Capability | Description |
|------------|-------------|
| `cuda`, `gpu` | CUDA GPU acceleration |
| `editor` | Scene editor UI |
| `python`, `py` | Python bindings |
| `headless` | No rendering (for training) |
| `gpio`, `i2c`, `spi`, `can`, `serial` | Hardware interfaces |
| `opencv` | OpenCV backend |
| `realsense` | Intel RealSense support |
| `full` | All features |

**Or configure in horus.yaml:**

```yaml
enable:
  - cuda
  - editor
```

### Why --release Matters

Debug builds have significantly higher overhead than release builds due to runtime checks and lack of optimizations.

**Debug mode** (default): Fast compilation, slower execution
- Use case: Development iteration
- Typical tick time: 60-200μs
- Includes overflow checks, bounds checking, assertions

**Release mode** (`--release`): Slower compilation, optimized execution
- Use case: Performance testing, benchmarks, production deployment
- Typical tick time: 1-3μs
- Full compiler optimizations enabled

**Common Mistake:**
```bash
horus run  # Debug mode
# You see: [IPC: 1862ns | Tick: 87μs] - Looks slow!

horus run --release  # Release mode
# You see: [IPC: 947ns | Tick: 2μs] - Actually fast!
```

**The tick time difference is dramatic:**
- Debug: 60-200μs per tick (too slow for real-time control)
- Release: 1-3μs per tick (production-ready performance)

**Rule of thumb:** Always use `--release` when:
- Measuring performance
- Running benchmarks
- Testing real-time control loops
- Deploying to production
- Wondering "why is HORUS slow?"

### Why --clean Matters

The `--clean` flag removes the `.horus/target/` directory, which contains cached build artifacts and dependencies.

**When to use `--clean`:**

1. **After updating HORUS** - Most common use case
   ```bash
   # You updated horus CLI to a new version
   horus run --clean
   ```
   This fixes version mismatch errors like:
   ```
   error: the package `horus` depends on `horus_core 0.1.0`,
   but `horus_core 0.1.3` is installed
   ```

2. **Compilation fails mysteriously**
   ```bash
   horus run --clean
   # Sometimes cached state gets corrupted
   ```

3. **Dependencies changed**
   ```bash
   # You modified horus.yaml dependencies
   horus run --clean
   ```

**What it does:**
- Removes `.horus/target/` (build artifacts)
- Removes `.horus/Cargo.lock` (dependency lock file)
- Forces fresh dependency resolution
- Next build rebuilds everything from scratch

**Trade-off:**
- First build after `--clean` is slower (5-30 seconds)
- Subsequent builds are fast again (incremental compilation)

**Note:** The `--clean` flag only affects the current project's `.horus/` directory, not the global `~/.horus/` cache.

### Examples

**Daily development**:
```bash
horus run
# Fast iteration, slower execution
```

**Testing performance**:
```bash
horus run --release
# See real speed
```

**Build for CI without running**:
```bash
horus run --build-only --release
```

**Fresh build** (when things act weird or after updating HORUS):
```bash
horus run --clean --release
```

**After updating HORUS CLI** (fixes version mismatch errors):
```bash
# Clean removes cached dependencies from .horus/target/
horus run --clean
```

**Pass arguments to your program**:
```bash
horus run -- --config robot.yaml --verbose
```

### Important: Single-File Projects Only

`horus run` is designed for **single-file HORUS projects** (main.rs or main.py). It creates a temporary workspace in `.horus/` and automatically handles dependencies.

**What works with `horus run`:**
- Single main.rs with all nodes defined in one file
- Simple Python scripts (main.py)

**What doesn't work:**
- Multi-crate Cargo workspaces
- Projects with multiple Cargo.toml files
- Complex module structures with separate crate directories

**For multi-crate projects**, use `cargo` directly:
```bash
cd your_multi_crate_project
cargo build --release
cargo run --release
```

**Example of a proper single-file structure:**
```rust
// main.rs - everything in one file
use horus::prelude::*;

struct SensorNode { /* ... */ }
impl Node for SensorNode { /* ... */ }

struct ControlNode { /* ... */ }
impl Node for ControlNode { /* ... */ }

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));
    scheduler.add(Box::new(ControlNode::new()?), 1, Some(true));
    scheduler.run()
}
```

### Concurrent Multi-Process Execution

HORUS supports running multiple node files concurrently as separate processes using **glob patterns**. This is ideal for distributed robotics systems where nodes need to run independently.

**Basic Usage:**
```bash
horus run "nodes/*.py"          # Run all Python nodes concurrently
horus run "src/*.rs"            # Run all Rust nodes concurrently
```

**How it works:**
1. **Phase 1 (Build)**: Builds all files sequentially, respecting Cargo's file lock
2. **Phase 2 (Execute)**: Spawns all processes concurrently with their own schedulers
3. Each process communicates via HORUS shared memory IPC

**Features:**
- -**Color-coded output**: Each node is prefixed with `[node_name]` in a unique color
- -**Graceful shutdown**: Ctrl+C cleanly terminates all processes
- -**Multi-language**: Works with Rust and Python
- -**Automatic detection**: No flags needed, just use glob patterns

**Example output:**
```bash
$ horus run "nodes/*.py"
 Executing 3 files concurrently:
  1. nodes/sensor.py (python)
  2. nodes/controller.py (python)
  3. nodes/logger.py (python)

 Phase 1: Building all files...
 Phase 2: Starting all processes...
   Started [sensor]
   Started [controller]
   Started [logger]

 All processes running. Press Ctrl+C to stop.

[sensor] Sensor reading: 25.3°C
[controller] Motor speed: 45%
[logger] System operational
[sensor] Sensor reading: 26.1°C
[controller] Motor speed: 50%
[logger] System operational
```

**When to use concurrent execution:**
- Multi-node systems where each node is in a separate file
- Distributed control architectures (similar to ROS nodes)
- Testing multiple nodes simultaneously
- Microservices-style robotics architectures

**When to use single-process execution:**
- All nodes in one file (typical for simple projects)
- Projects requiring deterministic scheduling across all nodes
- Maximum performance with minimal overhead

**Important:** Each process runs its own scheduler. Nodes communicate through HORUS shared memory topics (`/dev/shm/horus/`), not direct function calls.

---

## `horus check` - Validate Environment

**What it does**: Validates your HORUS installation, dependencies, and environment configuration.

**Why it's useful**: Quickly diagnose issues with your setup before running into cryptic errors. Ensures all dependencies are properly installed and versions are compatible.

### Basic Usage

```bash
# Check current project
horus check

# Check specific package
horus check my-package
```

### What It Checks

The `horus check` command validates:
- **HORUS installation** - Core framework is properly installed
- **Dependencies** - All required packages are available
- **Package versions** - Version compatibility with `horus.yaml`
- **Environment** - Cargo, Python, and system tools are configured
- **Shared memory** - `/dev/shm` is accessible and writable

### Example Output

```bash
$ horus check
 HORUS framework installed (v0.1.0)
 Cargo toolchain found (1.70.0)
 Python bindings available (3.11)
 Shared memory accessible (/dev/shm)
 All dependencies satisfied

 Environment is ready!
```

**When validation fails**:
```bash
$ horus check
 HORUS framework installed (v0.1.0)
[FAIL] Missing dependency: horus-vision (required by horus.yaml)
[FAIL] Shared memory not writable (/dev/shm)

[WARNING] Fix these issues and run 'horus check' again
```

### Examples

**Before starting development**:
```bash
horus check
# Ensure environment is ready
```

**After installing packages**:
```bash
horus pkg install sensor-drivers
horus check
# Verify installation succeeded
```

**Troubleshooting build issues**:
```bash
horus check
# Identify missing dependencies
```

**CI/CD validation**:
```bash
#!/bin/bash
if ! horus check; then
  echo "Environment validation failed"
  exit 1
fi
horus run --release
```

---

## `horus sim2d` - Launch 2D Simulator

**What it does**: Launches the HORUS 2D simulator for testing robot behavior in a virtual environment.

**Why it's useful**: Test your algorithms without hardware. Validate behavior before deploying to real robots. Perfect for development and learning.

### Basic Usage

```bash
# Launch default simulation
horus sim2d

# Launch with world configuration
horus sim2d --world warehouse.yaml

# Headless mode (for testing)
horus sim2d --headless
```

### All Options

```bash
horus sim2d [OPTIONS]

Options:
  --headless                 Run without GUI (for CI/CD)
  --world <FILE>             World configuration file
  --world-image <FILE>       World image file (PNG, JPG, PGM) - occupancy grid
  --resolution <FLOAT>       Resolution in meters per pixel for world image
  --threshold <0-255>        Obstacle threshold (darker = obstacle)
  --robot <FILE>             Robot configuration file
  --topic <PREFIX>           HORUS topic prefix (default: /robot)
  --name <NAME>              Robot name for logging (default: robot)
```

### What You Get

The simulator provides:
- **2D physics** - Realistic robot movement and collisions
- **Sensor simulation** - Virtual LiDAR, odometry, IMU
- **Visual debugging** - See robot state and sensor readings
- **Occupancy grid support** - Load world images directly
- **HORUS integration** - Nodes communicate normally via shared memory

### Examples

**Test navigation algorithm**:
```bash
# Terminal 1: Launch simulator with world
horus sim2d --world maze.yaml

# Terminal 2: Run your navigation code
horus run navigation.rs --release

# Terminal 3: Monitor
horus monitor
```

**Headless testing (CI/CD)**:
```bash
horus sim2d --headless &
SIM_PID=$!
horus run test_behavior.rs --release
kill $SIM_PID
```

**Load occupancy grid image**:
```bash
# Load a PGM/PNG map as world
horus sim2d --world-image map.pgm --resolution 0.05 --threshold 128
```

### Integration with Your Code

Your HORUS nodes work unchanged in simulation:

```rust
// Same code works in sim and on real robot!
use horus::prelude::*;

struct RobotController {
    cmd_pub: Hub<CmdVel>,
    lidar_sub: Hub<LaserScan>,
}

impl RobotController {
    fn new() -> Result<Self> {
        Ok(Self {
            cmd_pub: Hub::new("cmd_vel")?,
            lidar_sub: Hub::new("scan")?,
        })
    }
}

impl Node for RobotController {
    fn name(&self) -> &'static str {
        "RobotController"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Read simulated LiDAR
        if let Some(scan) = self.lidar_sub.recv(&mut ctx) {
            // Send commands to simulated robot
            let cmd = calculate_motion(&scan);
            self.cmd_pub.send(cmd, &mut ctx).ok();
        }
    }
}
```

**Simulator vs Reality**: The same HORUS topics (`cmd_vel`, `scan`, `odom`, etc.) work in both. No code changes needed!

---

## `horus sim3d` - Launch 3D Simulator

**What it does**: Launches the HORUS 3D simulator with full physics, URDF robot support, and advanced sensor simulation.

**Why it's useful**: Realistic 3D testing environment for complex robots, manipulators, and scenarios requiring depth perception or 3D physics.

### Basic Usage

```bash
# Launch default 3D simulation
horus sim3d

# Launch with URDF robot
horus sim3d --robot turtlebot3.urdf

# Headless mode for RL training
horus sim3d --headless --seed 42
```

### All Options

```bash
horus sim3d [OPTIONS]

Options:
  --headless         Run without GUI (for RL training, CI/CD)
  --seed <U64>       Random seed for deterministic simulation
  --robot <FILE>     Robot URDF file to load
  --world <FILE>     World/scene configuration file
```

### Features

The 3D simulator provides:
- **Full 3D physics** - Rapier3D physics engine with realistic dynamics
- **URDF support** - Load standard robot description files
- **3D sensors** - LiDAR 3D, RGB-D cameras, IMU
- **Deterministic mode** - Use `--seed` for reproducible simulations
- **RL training ready** - Headless mode for high-speed training

### Examples

**Visual simulation with robot**:
```bash
horus sim3d --robot my_robot.urdf --world warehouse.yaml
```

**Deterministic RL training**:
```bash
# Same seed = same simulation
horus sim3d --headless --seed 12345
```

**Test with custom world**:
```bash
horus sim3d --world obstacle_course.yaml --robot quadruped.urdf
```

See [Simulation Guide](/development/simulation) for advanced features, custom scenarios, and RL integration.

---

## `horus monitor` - Monitor Everything

**What it does**: Opens a visual monitor showing all your running nodes, messages, and performance.

**Why it's useful**: Debug problems visually. See message flow in real-time. Monitor performance.

### Basic Usage

```bash
# Web monitor (opens in browser)
horus monitor

# Different port
horus monitor 8080

# Text-based (for SSH)
horus monitor --tui

# Reset monitor password before starting
horus monitor --reset-password
```

### What You See

The monitor shows:
- **All running nodes** - Names, status, tick rates
- **Message flow** - What's talking to what
- **Performance** - CPU, memory, latency per node
- **Topics** - All active communication channels
- **Graph view** - Visual network of your system

### Examples

**Start monitoring** (in a second terminal):
```bash
# Terminal 1: Run your app
horus run --release

# Terminal 2: Watch it
horus monitor
```

**Access from your phone**:
```bash
horus monitor
# Visit http://your-computer-ip:3000 from phone
```

**Monitor over SSH**:
```bash
ssh robot@192.168.1.100
horus monitor --tui
```

See [Monitor Guide](/development/monitor) for detailed features.

---

## `horus pkg` - Package Management

**What it does**: Install and manage reusable components.

**Why it's useful**: Don't reinvent the wheel. Use components others have built and tested.

### Commands

```bash
# Install a package
horus pkg install <package>

# Remove a package
horus pkg remove <package>

# List packages
horus pkg list

# Publish current package to registry
horus pkg publish

# Unpublish a package from registry
horus pkg unpublish <package> <version>
```

### Examples

**Install a package**:
```bash
horus pkg install pid-controller
```

**Install specific version**:
```bash
horus pkg install pid-controller --ver 1.2.0
```

**Install globally** (share across projects):
```bash
horus pkg install common-utils --global
```

**See what's installed**:
```bash
horus pkg list
```

**Search for packages**:
```bash
horus pkg list sensor
```

**Remove a package**:
```bash
horus pkg remove pid-controller
```

**Publish your package to registry**:
```bash
# First login
horus auth login

# Then publish from your project directory
horus pkg publish
```

**Unpublish from registry** (irreversible!):
```bash
horus pkg unpublish my-package 1.0.0
```

---

## `horus env` - Environment Management

**What it does**: Save and restore your exact setup (all package versions).

**Why it's useful**: Share your setup with teammates. Deploy the same version to production. Time-travel to old configurations.

### Commands

```bash
# Save current environment
horus env freeze

# Load saved environment
horus env restore <file>
```

### Examples

**Save your setup**:
```bash
horus env freeze
# Creates horus-freeze.yaml
```

**Load teammate's setup**:
```bash
horus env restore teammate-setup.yaml
```

**Deploy exact production environment**:
```bash
# On production machine
horus env restore production.yaml
```

---

## `horus auth` - Login to Registry

**What it does**: Authenticate so you can publish packages.

**Why it's useful**: Secure access to the package registry.

### Commands

```bash
# Login with GitHub
horus auth login

# Generate API key (for CI/CD)
horus auth generate-key

# Check who you are
horus auth whoami

# Logout
horus auth logout
```

### Examples

**First time setup**:
```bash
horus auth login
# Opens browser for GitHub login
```

**Check you're logged in**:
```bash
horus auth whoami
```

**Generate API key for CI/CD**:
```bash
horus auth generate-key --name github-actions --environment ci-cd
# Save the generated key in your CI secrets
```

**Logout**:
```bash
horus auth logout
```

---

## `horus build` - Build Without Running

**What it does**: Compiles your project without executing it.

**Why it's useful**: Validate compilation, prepare for deployment, or integrate with CI/CD pipelines.

### Basic Usage

```bash
# Build current project
horus build

# Build in release mode
horus build --release

# Clean build (remove cached artifacts first)
horus build --clean
```

### All Options

```bash
horus build [OPTIONS]

Options:
  -r, --release    Build in release mode (optimized)
  -c, --clean      Clean before building
  -h, --help       Print help
  -V, --version    Print version
```

### Examples

**CI/CD build validation**:
```bash
horus build --release
# Exit code 0 = success, non-zero = failure
```

**Clean release build for deployment**:
```bash
horus build --clean --release
```

---

## `horus test` - Run Tests

**What it does**: Runs your HORUS project's test suite.

**Why it's useful**: Validate functionality, run integration tests with simulation, and ensure code quality.

### Basic Usage

```bash
# Run all tests
horus test

# Run with parallel execution
horus test --parallel

# Run simulation tests
horus test --sim
```

### All Options

```bash
horus test [OPTIONS]

Options:
  -r, --release        Run tests in release mode
  -p, --parallel       Run tests in parallel
  -s, --sim            Run simulation-based tests
  -i, --integration    Run integration tests
  -h, --help           Print help
  -V, --version        Print version
```

### Examples

**Fast parallel test run**:
```bash
horus test --parallel --release
```

**Integration tests with simulator**:
```bash
horus test --integration --sim
```

---

## `horus clean` - Clean Build Artifacts

**What it does**: Removes build artifacts, cached dependencies, and shared memory files.

**Why it's useful**: Fix corrupted builds, reclaim disk space, or reset shared memory after crashes.

### Basic Usage

```bash
# Clean everything (build + shared memory + cache)
horus clean --all

# Only clean shared memory
horus clean --shm

# Preview what would be cleaned
horus clean --dry-run
```

### All Options

```bash
horus clean [OPTIONS]

Options:
      --shm      Only clean shared memory
  -a, --all      Clean everything (build cache + shared memory + horus cache)
  -n, --dry-run  Show what would be cleaned without removing anything
  -h, --help     Print help
  -V, --version  Print version
```

### Examples

**After a crash (clean stale shared memory)**:
```bash
horus clean --shm
```

**Full reset before deployment**:
```bash
horus clean --all
horus build --release
```

---

## `horus topic` - Topic Introspection

**What it does**: Inspect, monitor, and interact with HORUS topics (shared memory communication channels).

**Why it's useful**: Debug message flow, verify data publishing, and measure topic rates.

### Subcommands

```bash
horus topic list              # List all active topics
horus topic echo <topic>      # Print messages as they arrive
horus topic info <topic>      # Show topic details (type, publishers, subscribers)
horus topic hz <topic>        # Measure publishing rate
horus topic pub <topic> <msg> # Publish a message
```

### Examples

**List all topics**:
```bash
horus topic list
# Output:
# /cmd_vel (CmdVel) - 2 publishers, 1 subscriber
# /scan (LaserScan) - 1 publisher, 3 subscribers
# /odom (Odometry) - 1 publisher, 1 subscriber
```

**Monitor a topic in real-time**:
```bash
horus topic echo /scan
# Prints each LaserScan message as it arrives
```

**Check publishing rate**:
```bash
horus topic hz /cmd_vel
# Output: average rate: 50.0 Hz, min: 49.2, max: 50.8
```

**Publish test message**:
```bash
horus topic pub /cmd_vel '{"linear": [1.0, 0.0, 0.0], "angular": [0.0, 0.0, 0.5]}'
```

---

## `horus node` - Node Management

**What it does**: List, inspect, and control running HORUS nodes.

**Why it's useful**: Debug node states, restart misbehaving nodes, or pause nodes during testing.

### Subcommands

```bash
horus node list               # List all running nodes
horus node info <node>        # Show detailed node information
horus node kill <node>        # Terminate a node
horus node restart <node>     # Restart a node
horus node pause <node>       # Pause a node's tick execution
horus node resume <node>      # Resume a paused node
```

### Examples

**List all running nodes**:
```bash
horus node list
# Output:
# NAME              PID     RATE   CPU    MEMORY   STATUS
# SensorNode        12345   100Hz  1.2%   10MB     Running
# ControllerNode    12346   50Hz   2.5%   15MB     Running
# LoggerNode        12347   10Hz   0.1%   5MB      Paused
```

**Get detailed node info**:
```bash
horus node info SensorNode
# Shows: tick count, error count, subscribed topics, published topics
```

**Restart a stuck node**:
```bash
horus node restart ControllerNode
```

**Pause/resume for debugging**:
```bash
horus node pause SensorNode
# ... inspect state ...
horus node resume SensorNode
```

---

## `horus log` - View and Filter Logs

**What it does**: View, filter, and follow HORUS system logs.

**Why it's useful**: Debug issues, monitor specific nodes, and track errors in real-time.

### Basic Usage

```bash
# View all recent logs
horus log

# Filter by node
horus log SensorNode

# Follow logs in real-time
horus log --follow

# Show only errors
horus log --level error
```

### All Options

```bash
horus log [OPTIONS] [NODE]

Arguments:
  [NODE]  Filter by node name

Options:
  -l, --level <LEVEL>  Filter by log level (trace, debug, info, warn, error)
  -s, --since <SINCE>  Show logs from last duration (e.g., "5m", "1h", "30s")
  -f, --follow         Follow log output in real-time
  -n, --count <COUNT>  Number of recent log entries to show
      --clear          Clear logs instead of viewing
      --clear-all      Clear all logs (including file-based logs)
  -h, --help           Print help
```

### Examples

**Follow logs from a specific node**:
```bash
horus log SensorNode --follow
```

**View errors from last 10 minutes**:
```bash
horus log --level error --since 10m
```

**Show last 50 warnings and errors**:
```bash
horus log --level warn --count 50
```

---

## `horus doctor` - System Diagnostics

**What it does**: Runs comprehensive diagnostics on your HORUS installation and environment.

**Why it's useful**: Quickly identify configuration issues, missing dependencies, or environment problems.

### Basic Usage

```bash
# Run diagnostics
horus doctor

# Verbose output with details
horus doctor --verbose
```

### All Options

```bash
horus doctor [OPTIONS]

Options:
  -v, --verbose  Show detailed diagnostic information
  -h, --help     Print help
```

### Example Output

```bash
$ horus doctor
✓ HORUS CLI installed (v0.1.7)
✓ Rust toolchain available (1.75.0)
✓ Python 3.11 detected
✓ Shared memory accessible (/dev/shm/horus)
✓ No stale processes found
✓ Registry reachable (https://horus-registry.dev)
⚠ GPU: No CUDA device found (optional)

Overall: System healthy
```

---

## `horus param` - Parameter Management

**What it does**: Manage node parameters at runtime (get, set, list, dump, save, load).

**Why it's useful**: Tune robot behavior without recompiling, persist configurations, and debug parameter values.

### Subcommands

```bash
horus param list [node]           # List all parameters (or for specific node)
horus param get <node> <param>    # Get parameter value
horus param set <node> <param> <value>  # Set parameter value
horus param delete <node> <param> # Delete a parameter
horus param reset <node>          # Reset parameters to defaults
horus param load <file>           # Load parameters from file
horus param save <file>           # Save parameters to file
horus param dump [node]           # Dump all parameters as YAML
```

### Examples

**List all parameters**:
```bash
horus param list
# Output:
# /SensorNode/sample_rate: 100
# /SensorNode/filter_size: 5
# /ControllerNode/kp: 1.5
# /ControllerNode/ki: 0.1
```

**Tune a controller at runtime**:
```bash
horus param set ControllerNode kp 2.0
horus param set ControllerNode ki 0.2
```

**Save and restore configuration**:
```bash
# Save current params
horus param save robot_config.yaml

# Later, restore them
horus param load robot_config.yaml
```

---

## `horus hf` - HORUS Frames (Coordinate Transforms)

**What it does**: Inspect and monitor coordinate frame transforms (similar to ROS tf).

**Why it's useful**: Debug transform chains, visualize frame relationships, and verify sensor mounting.

### Subcommands

```bash
horus hf list                    # List all frames
horus hf echo <frame>            # Print transform updates
horus hf tree                    # Show frame tree hierarchy
horus hf info <frame>            # Detailed frame information
horus hf can <source> <target>   # Check if transform is possible
horus hf hz <frame>              # Measure transform update rate
```

### Examples

**View frame tree**:
```bash
horus hf tree
# Output:
# world
# └── base_link
#     ├── laser_frame
#     ├── camera_frame
#     └── imu_frame
```

**Monitor a transform**:
```bash
horus hf echo laser_frame
# Prints: translation [x, y, z] rotation [qx, qy, qz, qw]
```

**Check transform chain**:
```bash
horus hf can laser_frame world
# Output: Yes, chain: laser_frame -> base_link -> world
```

---

## `horus msg` - Message Type Introspection

**What it does**: Inspect HORUS message type definitions and schemas.

**Why it's useful**: Understand message structures, debug serialization issues, and verify type compatibility.

### Subcommands

```bash
horus msg list               # List all message types
horus msg show <type>        # Show message definition
horus msg md5 <type>         # Show MD5 hash (for compatibility checking)
```

### Examples

**List available message types**:
```bash
horus msg list
# Output:
# CmdVel (horus_library::messages::motion)
# LaserScan (horus_library::messages::sensor)
# Odometry (horus_library::messages::navigation)
# Image (horus_library::messages::perception)
```

**Show message definition**:
```bash
horus msg show CmdVel
# Output:
# struct CmdVel {
#   linear: [f64; 3],   // m/s [x, y, z]
#   angular: [f64; 3],  // rad/s [roll, pitch, yaw]
#   timestamp: u64,     // nanoseconds
# }
```

---

## `horus launch` - Launch Multiple Nodes

**What it does**: Launch multiple nodes from a YAML configuration file.

**Why it's useful**: Start complex multi-node systems with one command, define node dependencies and parameters.

### Basic Usage

```bash
# Launch from file
horus launch robot.yaml

# Preview without launching
horus launch robot.yaml --dry-run

# Launch with namespace
horus launch robot.yaml --namespace robot1
```

### All Options

```bash
horus launch [OPTIONS] <FILE>

Arguments:
  <FILE>  Path to launch file (YAML)

Options:
  -n, --dry-run                Show what would launch without actually launching
      --namespace <NAMESPACE>  Namespace prefix for all nodes
      --list                   List nodes in the launch file without launching
  -h, --help                   Print help
```

### Launch File Format

```yaml
# robot.yaml
nodes:
  - name: sensor_node
    file: src/sensor.rs
    rate: 100
    params:
      sample_rate: 100

  - name: controller
    file: src/controller.rs
    rate: 50
    depends_on: [sensor_node]
    params:
      kp: 1.5
      ki: 0.1

  - name: logger
    file: src/logger.py
    rate: 10
```

### Examples

**Launch robot system**:
```bash
horus launch robot.yaml
```

**Launch with namespace (for multi-robot)**:
```bash
horus launch robot.yaml --namespace robot1
horus launch robot.yaml --namespace robot2
```

---

## `horus deploy` - Deploy to Remote Robot

**What it does**: Cross-compile and deploy your project to a remote robot over SSH.

**Why it's useful**: Deploy from development machine to embedded robot, supports multiple architectures.

### Basic Usage

```bash
# Deploy to configured target
horus deploy robot@192.168.1.100

# Deploy and run immediately
horus deploy robot@192.168.1.100 --run

# Deploy to specific architecture
horus deploy robot@192.168.1.100 --arch aarch64
```

### All Options

```bash
horus deploy [OPTIONS] [TARGET]

Arguments:
  [TARGET]  Target host (user@host or configured target name)

Options:
  -d, --dir <REMOTE_DIR>     Remote directory (default: ~/horus_deploy)
  -a, --arch <ARCH>          Target architecture (aarch64, armv7, x86_64, native)
  -r, --run                  Run the project after deploying
      --debug                Build in debug mode instead of release
  -p, --port <PORT>          SSH port (default: 22)
  -i, --identity <IDENTITY>  SSH identity file
  -n, --dry-run              Show what would be done without doing it
      --list                 List configured deployment targets
  -h, --help                 Print help
```

### Examples

**Deploy to Raspberry Pi**:
```bash
horus deploy pi@raspberrypi.local --arch aarch64
```

**Deploy and run on NVIDIA Jetson**:
```bash
horus deploy ubuntu@jetson.local --arch aarch64 --run
```

**Configure named targets in horus.yaml**:
```yaml
deploy:
  targets:
    jetson:
      host: ubuntu@192.168.1.50
      arch: aarch64
    pi:
      host: pi@192.168.1.51
      arch: aarch64
```

Then deploy with:
```bash
horus deploy jetson --run
```

---

## `horus from-ros` - Convert ROS Package

**What it does**: Converts ROS1 or ROS2 packages to native HORUS projects with intelligent pattern detection.

**Why it's useful**: Migrate existing ROS code to HORUS with AI-like conversions that detect robotics patterns, extract parameters from launch files, and recommend HORUS built-in nodes.

### Basic Usage

```bash
# Convert ROS2 package to HORUS
horus from-ros /path/to/ros_package --ros2

# Convert ROS1 package
horus from-ros /path/to/catkin_pkg --ros1

# Specify output directory
horus from-ros /path/to/ros_package --ros2 --output my_horus_project

# Extract parameters from launch files and configs
horus from-ros /path/to/ros_package --ros2 \
  --launch-dir launch/ \
  --config-dir config/
```

### All Options

```bash
horus from-ros [OPTIONS] <SOURCE>

Arguments:
  <SOURCE>  Path to ROS package or workspace directory

Options:
      --ros1                 Treat source as ROS1 (catkin)
      --ros2                 Treat source as ROS2 (ament)
  -o, --output <OUTPUT>      Output directory (default: <source>_horus)
      --launch-dir <PATH>    Directory with launch files (for param extraction)
      --config-dir <PATH>    Directory with YAML configs (for param defaults)
      --analyze-only         Preview analysis without generating code
      --interactive          Ask questions for complex node conversions
      --skip-opencv          Don't include OpenCV dependencies
  -v, --verbose              Show detailed conversion progress
  -h, --help                 Print help
```

### Features

**Context-Aware Conversion**: Extracts parameter defaults from launch files (`.launch`, `.launch.py`) and YAML configs.

**Pattern Detection**: Identifies common robotics patterns (PID controllers, state machines, sensor processors) with confidence scores.

**Built-in Recommendations**: Suggests HORUS built-in nodes when a ROS node matches a known pattern.

### Examples

**Convert a ROS2 workspace**:
```bash
horus from-ros ~/ros2_ws/src --ros2 --output ~/horus_ws/
cd ~/horus_ws/my_robot_horus
cargo build
horus run
```

**Analyze before converting**:
```bash
horus from-ros ~/catkin_ws/src/my_robot --ros1 --analyze-only
```

**Full context extraction**:
```bash
horus from-ros ~/ros2_ws/src/nav_robot --ros2 \
  --launch-dir launch/ \
  --config-dir config/ \
  --verbose
```

**See full documentation**: [Migrate from ROS](/development/from-ros)

---

## `horus bridge` - ROS2 Bridge

**What it does**: Bridge between HORUS and ROS2 for interoperability.

**Why it's useful**: Integrate with existing ROS2 systems, use ROS2 tools with HORUS nodes, gradual migration.

### Subcommands

```bash
horus bridge ros2              # Start ROS2 bridge
horus bridge list              # List discoverable ROS2 topics
horus bridge info              # Show bridge information and capabilities
```

### Examples

**Start ROS2 bridge**:
```bash
# Terminal 1: Start bridge
horus bridge ros2

# Terminal 2: Run HORUS nodes
horus run

# ROS2 nodes can now see HORUS topics and vice versa
```

**List available ROS2 topics**:
```bash
horus bridge list
# Output:
# /ros2/cmd_vel (geometry_msgs/Twist)
# /ros2/scan (sensor_msgs/LaserScan)
```

---

## `horus hardware` - Hardware Discovery

**What it does**: Scan and detect connected hardware, suggest configurations.

**Why it's useful**: Auto-detect sensors, cameras, and I/O devices. Get configuration suggestions.

### Subcommands

```bash
horus hardware scan            # Scan for connected devices
horus hardware platform        # Show platform information
horus hardware suggest         # Suggest HORUS configuration
horus hardware info <device>   # Get device details
horus hardware export          # Export config to TOML
horus hardware watch           # Watch for hotplug events
```

### Examples

**Scan for hardware**:
```bash
horus hardware scan
# Output:
# ✓ USB Camera: /dev/video0 (Logitech C920)
# ✓ Serial: /dev/ttyUSB0 (FTDI)
# ✓ I2C: /dev/i2c-1 (available)
# ✓ GPIO: /dev/gpiochip0 (54 lines)
```

**Get configuration suggestions**:
```bash
horus hardware suggest
# Output:
# Suggested horus.yaml configuration:
# drivers:
#   - camera: /dev/video0
#   - serial: /dev/ttyUSB0
# enable:
#   - i2c
#   - gpio
```

**Watch for device changes**:
```bash
horus hardware watch
# Monitors USB connect/disconnect events
```

---

## `horus add` - Add Package/Driver/Plugin

**What it does**: Smart package installer that auto-detects whether you're installing a package, driver, or plugin.

**Why it's useful**: Single command for all installations, handles dependencies automatically.

### Basic Usage

```bash
# Add a package (auto-detected)
horus add pid-controller

# Add with specific version
horus add sensor-fusion --ver 1.2.0

# Force install as driver
horus add camera-driver --driver

# Install globally
horus add common-utils --global
```

### All Options

```bash
horus add [OPTIONS] <NAME>

Arguments:
  <NAME>  Package/driver/plugin name to add

Options:
  -v, --ver <VER>  Specific version (optional)
      --driver     Force install as driver
      --plugin     Force install as plugin
      --local      Force local installation
  -g, --global     Force global installation
      --no-system  Skip installing system dependencies
  -h, --help       Print help
```

### Examples

**Add common packages**:
```bash
horus add kalman-filter
horus add pid-controller --ver 2.0.0
```

**Add hardware drivers**:
```bash
horus add realsense-driver --driver
horus add rplidar-driver --driver
```

---

## `horus remove` - Remove Package/Driver/Plugin

**What it does**: Removes installed packages, drivers, or plugins.

**Why it's useful**: Clean up unused dependencies, switch to alternative implementations.

### Basic Usage

```bash
# Remove a package
horus remove pid-controller

# Remove and purge unused dependencies
horus remove sensor-fusion --purge

# Remove global package
horus remove common-utils --global
```

### All Options

```bash
horus remove [OPTIONS] <NAME>

Arguments:
  <NAME>  Package/driver/plugin name to remove

Options:
  -g, --global   Remove from global scope
      --purge    Also remove unused dependencies
  -h, --help     Print help
```

---

## `horus drivers` - Driver Management

**What it does**: List, search, and get information about hardware drivers.

**Why it's useful**: Find drivers for your hardware, check driver capabilities.

### Subcommands

```bash
horus drivers list             # List all available drivers
horus drivers info <driver>    # Show driver details
horus drivers search <query>   # Search for drivers
```

### Examples

**Find camera drivers**:
```bash
horus drivers search camera
# Output:
# realsense-driver (Intel RealSense D4xx, L5xx)
# oak-driver (Luxonis OAK-D)
# usb-camera (Generic V4L2 cameras)
```

**Get driver info**:
```bash
horus drivers info realsense-driver
# Shows: supported devices, dependencies, configuration options
```

---

## `horus plugin` - Plugin Management

**What it does**: Manage HORUS plugins (extensions that add CLI commands or features).

**Why it's useful**: Enable/disable plugins, verify plugin integrity.

### Subcommands

```bash
horus plugin list              # List installed plugins
horus plugin enable <plugin>   # Enable a disabled plugin
horus plugin disable <plugin>  # Disable a plugin
horus plugin verify            # Verify plugin integrity
```

### Examples

**List plugins**:
```bash
horus plugin list
# Output:
# ✓ horus-ros2-bridge (enabled)
# ○ horus-zenoh (disabled)
# ✓ horus-tensorrt (enabled)
```

**Disable a plugin temporarily**:
```bash
horus plugin disable horus-ros2-bridge
```

---

## `horus cache` - Cache Management

**What it does**: Manage the HORUS package cache (downloaded packages, compiled artifacts).

**Why it's useful**: Reclaim disk space, troubleshoot package issues.

### Subcommands

```bash
horus cache info               # Show cache statistics
horus cache list               # List cached packages
horus cache clean              # Remove unused packages
horus cache purge              # Remove ALL cached packages
```

### Examples

**Check cache usage**:
```bash
horus cache info
# Output:
# Location: ~/.horus/cache
# Total size: 1.2 GB
# Packages: 45
# Last cleaned: 7 days ago
```

**Clean unused packages**:
```bash
horus cache clean
# Removes packages not used by any project
```

---

## `horus record` - Record/Replay Management

**What it does**: Manage recorded sessions for debugging and testing.

**Why it's useful**: Replay exact scenarios, compare runs, debug timing-sensitive issues.

### Subcommands

```bash
horus record list              # List all recordings
horus record info <session>    # Show recording details
horus record replay <session>  # Replay a recording
horus record delete <session>  # Delete a recording
horus record diff <a> <b>      # Compare two recordings
horus record export <session>  # Export to different format
horus record inject <session>  # Inject recorded data into live scheduler
```

### Examples

**List recordings**:
```bash
horus record list
# Output:
# ID         DATE                 DURATION   NODES   SIZE
# rec_001    2024-01-15 10:30:00  5m 23s     4       45MB
# rec_002    2024-01-15 14:15:00  2m 10s     3       18MB
```

**Replay a session**:
```bash
horus record replay rec_001
```

**Compare two runs**:
```bash
horus record diff rec_001 rec_002
# Shows differences in timing, message counts, errors
```

**Inject recorded data into live system**:
```bash
# Use recorded sensor data with live controller
horus record inject rec_001 --nodes SensorNode
```

---

## Common Workflows

### First Time Using HORUS

```bash
# Create a project
horus new my_first_app --macro
cd my_first_app

# Run it
horus run --release

# Monitor it (new terminal)
horus monitor
```

### Daily Development

```bash
# Make changes to code
vim src/main.rs

# Test quickly
horus run

# Test for real
horus run --release
```

### Deploy to Production

```bash
# Clean build
horus run --clean --release

# Save the environment
horus env freeze --output production.yaml

# Run in production mode
horus run --release
```

### Share Your Work

```bash
# Login once
horus auth login

# Publish
horus pkg publish

# Others can now:
horus pkg install your-package-name
```

---

## Troubleshooting

### "command not found: horus"

Add cargo to your PATH:

```bash
export PATH="$HOME/.cargo/bin:$PATH"
echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc
```

### "Port already in use"

```bash
# Use different port
horus monitor 3001

# Or kill the old process
lsof -ti:3000 | xargs kill -9
```

### Build is slow

First build is always slow (5-10 min). After that it's fast (seconds).

Use `--release` only when you need speed, not during development.

### "Failed to create Hub"

Topic name conflict. Try a unique name or clean up stale shared memory.

**Note**: HORUS automatically cleans up shared memory after each run using session isolation. This error usually means a previous run crashed.

```bash
# Clean all HORUS shared memory (if needed after crashes)
rm -rf /dev/shm/horus/
```

---

## Environment Variables

Optional configuration:

```bash
# Custom registry (for companies)
export HORUS_REGISTRY_URL=https://your-company-registry.com

# Debug mode (see what's happening)
export RUST_LOG=debug
horus run

# CI/CD authentication
export HORUS_API_KEY=your-key-here
```

---

## Utility Scripts

Beyond the `horus` CLI, the repository includes helpful scripts:

```bash
./install.sh             # Install or update HORUS
./verify.sh              # Check installation health
```

See **[Troubleshooting & Maintenance](/troubleshooting)** for complete details.

---

## Next Steps

Now that you know the commands:

1. **[Quick Start](/getting-started/quick-start)** - Build your first app
2. **[node! Macro](/concepts/node-macro)** - Write less code
3. **[Monitor Guide](/development/monitor)** - Master monitoring
4. **[Examples](/rust/examples/basic-examples)** - See real applications

**Having issues?** Check the **[Troubleshooting Guide](/troubleshooting)** for solutions to common problems.
