---
title: Migrate from ROS
description: Convert ROS1/ROS2 packages to native HORUS with intelligent pattern detection
order: 51
---

# Migrate from ROS

The `horus from-ros` command converts ROS1 and ROS2 packages to native HORUS code. Unlike the [ROS2 Bridge](/development/ros2-bridge) which provides runtime interoperability, this command generates standalone HORUS code that runs without ROS dependencies.

## Why Migrate?

| Feature | ROS | HORUS |
|---------|-----|-------|
| **Latency** | ~100Î¼s (DDS) | ~1Î¼s (shared memory) |
| **Throughput** | 10K msg/s | 1M+ msg/s |
| **Memory** | Per-process allocation | Zero-copy shared memory |
| **Startup** | Seconds (ROS master) | Milliseconds (direct) |
| **Dependencies** | Heavy (ROS ecosystem) | Minimal (pure Rust) |
| **Cross-platform** | Linux-focused | Linux, macOS, Windows |

## Quick Start

### Convert a Single Package

```bash
# Convert a ROS2 package
horus from-ros path/to/my_robot_pkg --ros2 --output converted/

# Convert a ROS1 package
horus from-ros path/to/my_robot_pkg --ros1 --output converted/
```

### Convert an Entire Workspace

```bash
# Convert all packages in a ROS2 workspace
horus from-ros ~/catkin_ws/src --ros1 --output ~/horus_workspace/

# Convert all packages in a colcon workspace
horus from-ros ~/ros2_ws/src --ros2 --output ~/horus_workspace/
```

## Topic Naming Convention

ROS and HORUS use different topic naming conventions:

| System | Separator | Example |
|--------|-----------|---------|
| **ROS** | `/` (forward slash) | `/robot/sensor/scan`, `/cmd_vel` |
| **HORUS** | `.` (dot) | `robot.sensor.scan`, `cmd_vel` |

**The converter automatically translates topic names:**

```
ROS Topic              â†’  HORUS Topic
/scan                  â†’  scan
/robot/odom            â†’  robot.odom
/robot/sensor/lidar    â†’  robot.sensor.lidar
/cmd_vel               â†’  cmd_vel
```

The generated code uses HORUS-style topic names:

```rust
// ROS original: subscribes to /robot/scan, publishes to /robot/cmd_vel
// HORUS generated:
let scan = Link::consumer("robot.scan")?;
let cmd_vel = Hub::new("robot.cmd_vel")?;
```

The [ROS2 Bridge](/development/ros2-bridge) also handles this conversion automatically when bridging between ROS2 and HORUS at runtime.

## Intelligent Conversion Features

The converter uses AI-like pattern detection to generate idiomatic HORUS code.

### Context-Aware Conversion

The converter reads and analyzes additional context files:

```bash
# Automatic context extraction
horus from-ros my_robot_pkg \
  --launch-dir launch/ \           # Extract params from launch files
  --config-dir config/ \           # Read YAML configuration
  --ros2
```

**What gets extracted:**

| Source | Extracted Information |
|--------|----------------------|
| **Launch files** (`.launch`, `.launch.py`) | Default parameter values, topic remappings, node configurations |
| **YAML configs** | Parameter defaults, tuning values, hardware settings |
| **URDF/Xacro** | Robot geometry, joint limits, sensor placements |
| **CMakeLists.txt** | Dependencies, message definitions, target configurations |
| **package.xml** | Dependencies, version info, maintainer |

### Pattern Detection

The converter identifies common robotics patterns and generates appropriate implementations:

```
Analyzing: obstacle_avoidance_node.cpp

Detected Patterns:
  âœ“ LaserScan Processor (95% confidence)
    - Subscribes to /scan (LaserScan)
    - Publishes to /cmd_vel (Twist)
    - Safety distance check at ranges[180]

  âœ“ Emergency Stop (87% confidence)
    - Zero velocity on obstacle detection
    - Uses min_range threshold

  âš  Potential Issues:
    - Hard-coded index 180 (assumes 360Â° lidar)
    - No timeout handling for sensor loss
```

**Supported patterns:**

| Pattern | Detection Signals | Generated Code |
|---------|------------------|----------------|
| **Simple Relay** | 1 sub â†’ 1 pub, no processing | Direct message forwarding |
| **Transform Node** | geometry_msgs, tf lookups | Transform application |
| **Sensor Processor** | sensor_msgs input, processed output | Filter/processing pipeline |
| **State Machine** | Mode enums, state transitions | Enum-based state machine |
| **Safety Monitor** | Velocity + obstacle detection | E-stop logic |
| **PID Controller** | Error calc, gains, integral | HORUS PID node |
| **Aggregator** | Multiple subs â†’ single pub | Message merging |

### Built-in Node Recommendations

When a ROS node matches a HORUS built-in pattern, the converter suggests using the built-in:

```rust
// Generated code includes recommendations:

// ðŸ¤– HORUS Built-in Recommendation:
// This node matches the `CameraNode` pattern. Consider using:
//   use horus_library::sensors::CameraNode;
//   let camera = CameraNode::<V4L2Driver, YUV422>::new("/dev/video0")?;
//
// Built-in features: auto-exposure, frame rate control, format negotiation

pub struct ConvertedCameraNode {
    // ... converted implementation
}
```

**Matched patterns â†’ built-in nodes:**

| Pattern | HORUS Built-in | Features |
|---------|----------------|----------|
| Camera capture | `CameraNode<D,P>` | V4L2, format negotiation, processing |
| IMU sensor | `ImuNode<D>` | Calibration, filtering, fusion-ready |
| LIDAR processing | `LidarNode<D>` | Point cloud, scan matching |
| Motor control | `DcMotorNode<D>` | PWM, encoder, PID |
| Servo control | `ServoControllerNode<D>` | Position, velocity, limits |
| GPS receiver | `GpsNode<D>` | NMEA parsing, datum conversion |
| Differential drive | `DifferentialDriveNode` | Kinematics, odometry |
| PID control | `PidNode<T>` | Configurable gains, anti-windup |
| A* planning | `AStarNode` | Grid-based, diagonal movement |
| RRT planning | `RrtNode` | Sampling-based, constraints |
| Kalman filter | `KalmanFilterNode` | Linear, state estimation |
| EKF | `ExtendedKalmanFilterNode` | Nonlinear, sensor fusion |
| Pure pursuit | `PurePursuitNode` | Path following, lookahead |

## Command Reference

```bash
horus from-ros [OPTIONS] <SOURCE_PATH>
```

### Required Arguments

| Argument | Description |
|----------|-------------|
| `<SOURCE_PATH>` | Path to ROS package or workspace |

### Options

| Option | Description | Default |
|--------|-------------|---------|
| `--ros1` | Treat source as ROS1 (catkin) | Auto-detect |
| `--ros2` | Treat source as ROS2 (ament) | Auto-detect |
| `--output <PATH>` | Output directory | `./converted_horus/` |
| `--launch-dir <PATH>` | Directory with launch files | Auto-detect |
| `--config-dir <PATH>` | Directory with YAML configs | Auto-detect |
| `--analyze-only` | Show analysis without generating | false |
| `--interactive` | Ask questions for complex nodes | false |
| `--skip-opencv` | Don't include OpenCV dependencies | false |
| `--verbose` | Show detailed conversion progress | false |

### Analysis Mode

Preview what the converter will do without generating code:

```bash
horus from-ros my_robot_pkg --ros2 --analyze-only
```

Output:
```
Package: my_robot_pkg (ROS2 Humble)
  Nodes: 5
  Messages: 3 custom
  Services: 1
  Actions: 1

Conversion Plan:
  â”œâ”€â”€ my_robot_pkg/
  â”‚   â”œâ”€â”€ Cargo.toml (generated)
  â”‚   â”œâ”€â”€ src/
  â”‚   â”‚   â”œâ”€â”€ lib.rs
  â”‚   â”‚   â”œâ”€â”€ nodes/
  â”‚   â”‚   â”‚   â”œâ”€â”€ motor_controller.rs (pattern: PID Controller)
  â”‚   â”‚   â”‚   â”œâ”€â”€ sensor_fusion.rs (pattern: Aggregator)
  â”‚   â”‚   â”‚   â”œâ”€â”€ navigation.rs (pattern: State Machine)
  â”‚   â”‚   â”‚   â”œâ”€â”€ safety_monitor.rs (pattern: Safety Monitor)
  â”‚   â”‚   â”‚   â””â”€â”€ camera_processor.rs (pattern: Sensor Processor)
  â”‚   â”‚   â””â”€â”€ messages/
  â”‚   â”‚       â”œâ”€â”€ robot_state.rs
  â”‚   â”‚       â”œâ”€â”€ sensor_data.rs
  â”‚   â”‚       â””â”€â”€ command.rs

Recommendations:
  â€¢ motor_controller.rs â†’ Consider using PidNode<f64> built-in
  â€¢ camera_processor.rs â†’ Consider using CameraNode<D,P> built-in

Potential Issues:
  âš  navigation.rs: Complex state machine (15 states), review generated code
  âš  sensor_fusion.rs: Uses 6 message types, verify all are available
```

## Generated Code Structure

### Package Layout

```
my_robot_horus/
â”œâ”€â”€ Cargo.toml           # Dependencies, features
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs           # Public exports
â”‚   â”œâ”€â”€ nodes/           # Node implementations
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ *.rs
â”‚   â””â”€â”€ messages/        # Custom message types
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ *.rs
â”œâ”€â”€ config/              # Migrated YAML configs
â”‚   â””â”€â”€ defaults.yaml
â””â”€â”€ examples/            # Usage examples
    â””â”€â”€ run_robot.rs
```

### Generated Node Example

```rust
// src/nodes/obstacle_avoidance.rs

use horus::prelude::*; // Provides {Hub, Link, Node, NodeInfo, LaserScan, Twist, Vector3}

/// Obstacle avoidance node
///
/// Originally: obstacle_avoidance_node.cpp
/// Pattern: Safety Monitor (87% confidence)
///
/// Subscriptions:
///   - /scan (LaserScan) â†’ checks for obstacles
///
/// Publications:
///   - /cmd_vel (Twist) â†’ velocity commands
#[derive(Default)]
pub struct ObstacleAvoidanceNode {
    // Communication
    scan: Link<LaserScan>,
    cmd_vel: Hub<Twist>,

    // Parameters (from config/obstacle_avoidance.yaml)
    safety_distance: f32,      // default: 0.5m
    max_linear_speed: f32,     // default: 0.5 m/s
    max_angular_speed: f32,    // default: 1.0 rad/s

    // State
    last_scan_time: u64,
    emergency_stop: bool,
}

impl Node for ObstacleAvoidanceNode {
    fn name(&self) -> &'static str { "obstacle_avoidance" }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        let ctx = ctx.unwrap();

        // Process incoming laser scan
        if let Some(scan) = self.scan.try_recv() {
            self.last_scan_time = ctx.tick_count();

            // Check for obstacles in front (converted from ranges[180])
            let front_idx = scan.ranges.len() / 2;
            let front_range = scan.ranges.get(front_idx).copied().unwrap_or(f32::MAX);

            if front_range < self.safety_distance {
                // Emergency stop
                self.emergency_stop = true;
                self.cmd_vel.send(Twist::default(), ctx);
                ctx.log_warn(&format!("Obstacle at {:.2}m, stopping", front_range));
            } else {
                self.emergency_stop = false;
            }
        }

        // Timeout check - stop if no sensor data
        if ctx.tick_count() - self.last_scan_time > 100 {
            if !self.emergency_stop {
                ctx.log_warn("Sensor timeout, stopping");
                self.emergency_stop = true;
                self.cmd_vel.send(Twist::default(), ctx);
            }
        }
    }
}

impl ObstacleAvoidanceNode {
    pub fn new() -> Self {
        Self {
            safety_distance: 0.5,
            max_linear_speed: 0.5,
            max_angular_speed: 1.0,
            ..Default::default()
        }
    }

    pub fn with_config(safety_distance: f32, max_speed: f32) -> Self {
        Self {
            safety_distance,
            max_linear_speed: max_speed,
            max_angular_speed: max_speed * 2.0,
            ..Default::default()
        }
    }
}
```

### Generated Messages

Custom ROS messages are converted to HORUS message types:

```rust
// src/messages/robot_state.rs

use horus::prelude::*; // Provides {horus_message, Pod}
use serde::{Serialize, Deserialize};

/// Robot state message
///
/// Originally: msg/RobotState.msg
#[horus_message]
#[derive(Debug, Clone, Default, Pod, Serialize, Deserialize)]
#[repr(C)]
pub struct RobotState {
    pub x: f64,
    pub y: f64,
    pub theta: f64,
    pub linear_velocity: f64,
    pub angular_velocity: f64,
    pub battery_voltage: f32,
    pub emergency_stop: bool,
}
```

## Feature Flags

Generated Cargo.toml includes optional features for external dependencies:

```toml
[features]
default = []
opencv = ["dep:opencv"]      # Image processing
realsense = ["dep:realsense2"]  # Intel RealSense cameras
serial = ["dep:serialport"]  # Serial communication
network = ["horus-core/network"]  # Network transport
```

Use features when building:

```bash
# Build without optional dependencies
cargo build -p my_robot_horus

# Build with OpenCV support
cargo build -p my_robot_horus --features opencv

# Build with all features
cargo build -p my_robot_horus --all-features
```

## Handling OpenCV Code

ROS nodes often use OpenCV for image processing. The converter provides options:

### Option 1: Feature-Gated OpenCV

```bash
horus from-ros image_pipeline --ros2 --output converted/
```

Generates conditional code:

```rust
#[cfg(feature = "opencv")]
fn process_image(&mut self, img: &Image) -> Image {
    use opencv::prelude::*;
    // Actual OpenCV processing
}

#[cfg(not(feature = "opencv"))]
fn process_image(&mut self, img: &Image) -> Image {
    // Passthrough with warning
    log::warn!("OpenCV not available, using passthrough mode");
    img.clone()
}
```

### Option 2: Skip OpenCV

```bash
horus from-ros image_pipeline --ros2 --skip-opencv --output converted/
```

Generates stub implementations that can be filled in manually.

## Interactive Mode

For complex nodes, use interactive mode for better conversions:

```bash
horus from-ros complex_robot_pkg --ros2 --interactive
```

```
ðŸ¤– Analyzing: state_machine_node.cpp

   Detected patterns:
   - State machine with 15 states (medium confidence)
   - Service server: /change_mode
   - Multiple timer callbacks

   Questions:
   1. Found 'ranges[180]' - Is this front-facing on your lidar? [Y/n]: y
   2. Parameter 'safety_distance' units? [meters/cm/mm]: meters
   3. State enum names detected: IDLE, MOVING, STOPPED...
      Use these names or generate new ones? [keep/generate]: keep

   Generating with your preferences...
```

## Batch Conversion

Convert multiple packages with a configuration file:

```yaml
# convert_config.yaml
packages:
  - path: src/robot_base
    ros_version: ros2
    features: [serial]

  - path: src/navigation
    ros_version: ros2
    features: [network]

  - path: src/perception
    ros_version: ros2
    features: [opencv]
    skip_patterns: [yolo_node]  # Skip specific nodes

output_dir: ~/horus_workspace
analyze_first: true
```

```bash
horus from-ros --config convert_config.yaml
```

## Post-Conversion Steps

After converting:

1. **Build and verify:**
   ```bash
   cd converted/my_robot_horus
   cargo check
   cargo test
   ```

2. **Review recommendations:**
   Look for `// ðŸ¤– HORUS Built-in Recommendation` comments and consider using built-ins.

3. **Test communication:**
   ```bash
   horus run my_robot_horus --node sensor_node
   horus topic echo /sensor_data
   ```

4. **Profile performance:**
   ```bash
   horus run my_robot_horus --bench
   ```

## Troubleshooting

### Compilation Errors

**Missing message types:**
```bash
error[E0412]: cannot find type `CustomMsg`
```
Solution: Ensure all custom messages are converted. Check `src/messages/` or add missing types.

**OpenCV not found:**
```bash
error: failed to run custom build command for `opencv`
```
Solution: Either install OpenCV or use `--skip-opencv` flag.

### Runtime Issues

**Topic not connecting:**
```bash
[WARN] Subscriber /scan: no publishers
```
Solution: Verify topic names match. Check if remapping was in launch file.

**Parameter values wrong:**
Check generated `config/defaults.yaml` against original launch files.

## Examples

### Convert TurtleBot3 Package

```bash
# Clone TurtleBot3 sources
git clone https://github.com/ROBOTIS-GIT/turtlebot3.git

# Convert to HORUS
horus from-ros turtlebot3/turtlebot3_bringup \
  --ros2 \
  --launch-dir launch/ \
  --config-dir config/ \
  --output ~/turtlebot3_horus/

# Build and run
cd ~/turtlebot3_horus/turtlebot3_bringup_horus
cargo build --release
horus run . --all-nodes
```

### Convert Navigation Stack

```bash
horus from-ros navigation2/nav2_bt_navigator \
  --ros2 \
  --output ~/nav2_horus/ \
  --analyze-only  # Preview first

horus from-ros navigation2/nav2_bt_navigator \
  --ros2 \
  --output ~/nav2_horus/
```

## See Also

- [ROS2 Bridge](/development/ros2-bridge) - Runtime interoperability without conversion
- [CLI Reference](/development/cli-reference) - Full command reference
- [Built-in Nodes](/rust/library/built-in-nodes) - HORUS standard library nodes
- [Creating Custom Nodes](/concepts/core-concepts-nodes) - Node development guide
