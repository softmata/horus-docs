---
title: "Control Messages"
description: "Motor control, servo, PID, trajectory, and joint command messages"
weight: 52
---

# Control Messages

HORUS provides comprehensive message types for controlling motors, servos, and multi-joint robotic systems.

## MotorCommand

Direct motor control with multiple control modes.

```rust
use horus::prelude::*; // Provides control::MotorCommand;

// Velocity control
let vel_cmd = MotorCommand::velocity(0, 1.5);  // motor_id=0, 1.5 rad/s

// Position control with max velocity
let pos_cmd = MotorCommand::position(0, 3.14, 2.0);  // motor_id=0, 3.14 rad, max 2 rad/s

// Stop motor
let stop_cmd = MotorCommand::stop(0);

// Check validity
if vel_cmd.is_valid() {
    println!("Target: {:.2}", vel_cmd.target);
}
```

**Control Modes:**

| Constant | Value | Description |
|----------|-------|-------------|
| `MODE_VELOCITY` | 0 | Velocity control (rad/s) |
| `MODE_POSITION` | 1 | Position control (rad) |
| `MODE_TORQUE` | 2 | Torque control (Nm) |
| `MODE_VOLTAGE` | 3 | Direct voltage control |

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `motor_id` | `u8` | Motor identifier |
| `mode` | `u8` | Control mode |
| `target` | `f64` | Target value |
| `max_velocity` | `f64` | Velocity limit (position mode) |
| `max_acceleration` | `f64` | Acceleration limit |
| `feed_forward` | `f64` | Feed-forward term |
| `enable` | `bool` | Motor enabled |
| `timestamp` | `u64` | Nanoseconds since epoch |

## DifferentialDriveCommand

Commands for differential drive robots.

```rust
use horus::prelude::*; // Provides control::DifferentialDriveCommand;

// Direct wheel velocities
let cmd = DifferentialDriveCommand::new(1.0, 1.2);  // left=1.0, right=1.2 rad/s

// From linear and angular velocities
let wheel_base = 0.5;   // 50cm between wheels
let wheel_radius = 0.1; // 10cm wheels
let cmd = DifferentialDriveCommand::from_twist(
    0.5,  // 0.5 m/s forward
    0.2,  // 0.2 rad/s rotation
    wheel_base,
    wheel_radius
);

// Stop
let stop = DifferentialDriveCommand::stop();
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `left_velocity` | `f64` | Left wheel velocity (rad/s) |
| `right_velocity` | `f64` | Right wheel velocity (rad/s) |
| `max_acceleration` | `f64` | Acceleration limit (rad/s²) |
| `enable` | `bool` | Motors enabled |
| `timestamp` | `u64` | Nanoseconds since epoch |

## ServoCommand

Position-controlled servo commands.

```rust
use horus::prelude::*; // Provides control::ServoCommand;

// Position command (radians)
let cmd = ServoCommand::new(0, 1.57);  // servo_id=0, 90 degrees

// With specific speed (0-1)
let cmd = ServoCommand::with_speed(0, 1.57, 0.3);  // 30% speed

// From degrees
let cmd = ServoCommand::from_degrees(0, 90.0);

// Disable servo (release torque)
let disable = ServoCommand::disable(0);
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `servo_id` | `u8` | Servo identifier |
| `position` | `f32` | Target position (radians) |
| `speed` | `f32` | Movement speed (0-1) |
| `enable` | `bool` | Torque enabled |
| `timestamp` | `u64` | Nanoseconds since epoch |

## PwmCommand

PWM motor control for DC motors.

```rust
use horus::prelude::*; // Provides control::PwmCommand;

// Basic PWM command
let cmd = PwmCommand::new(0, 0.75);  // channel=0, 75% duty cycle

// Forward/reverse
let forward = PwmCommand::forward(0, 0.8);   // 80% forward
let reverse = PwmCommand::reverse(0, 0.5);   // 50% reverse

// Stop modes
let coast = PwmCommand::coast(0);  // Coast to stop
let brake = PwmCommand::brake(0);  // Active braking

// With custom frequency
let cmd = PwmCommand::new(0, 0.5)
    .with_frequency(20000)      // 20kHz PWM
    .with_current_limit(2.5);   // 2.5A limit

// Check properties
println!("Speed: {:.1}%", cmd.speed() * 100.0);
println!("Direction: {}", if cmd.is_forward() { "forward" } else { "reverse" });
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `channel_id` | `u8` | PWM channel (0-15) |
| `duty_cycle` | `f32` | Duty cycle (-1.0 to 1.0) |
| `frequency` | `u32` | PWM frequency (Hz) |
| `enable` | `bool` | Output enabled |
| `brake_mode` | `bool` | Brake when stopped |
| `current_limit` | `f32` | Current limit (A) |
| `timestamp` | `u64` | Nanoseconds since epoch |

## StepperCommand

Stepper motor control with various modes.

```rust
use horus::prelude::*; // Provides control::StepperCommand;

// Relative steps
let steps_cmd = StepperCommand::steps(0, 200);  // 200 steps forward

// Absolute position
let pos_cmd = StepperCommand::position(0, 3.14, 1000.0);  // 3.14 rad, max 1000 steps/s

// Continuous velocity
let vel_cmd = StepperCommand::velocity(0, 500.0);  // 500 steps/s

// Homing
let home_cmd = StepperCommand::home(0, 100.0);  // Home at 100 steps/s

// Disable (release holding torque)
let disable = StepperCommand::disable(0);

// With options
let cmd = StepperCommand::position(0, 6.28, 2000.0)
    .with_microsteps(16)        // 1/16 microstepping
    .with_acceleration(5000.0)  // 5000 steps/s²
    .with_current_limit(800);   // 800mA
```

**Control Modes:**

| Constant | Value | Description |
|----------|-------|-------------|
| `MODE_STEPS` | 0 | Relative steps |
| `MODE_POSITION` | 1 | Absolute position (rad) |
| `MODE_VELOCITY` | 2 | Continuous velocity |
| `MODE_HOMING` | 3 | Homing sequence |

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `motor_id` | `u8` | Motor identifier |
| `mode` | `u8` | Control mode |
| `target` | `f64` | Target value |
| `max_velocity` | `f64` | Velocity limit (steps/s) |
| `acceleration` | `f64` | Acceleration (steps/s²) |
| `enable` | `bool` | Motor enabled |
| `microsteps` | `u16` | Microstepping (1,2,4,8,16,32,64,128,256) |
| `current_limit` | `u16` | Current limit (mA) |
| `timestamp` | `u64` | Nanoseconds since epoch |

## PidConfig

PID controller configuration.

```rust
use horus::prelude::*; // Provides control::PidConfig;

// Full PID
let pid = PidConfig::new(1.0, 0.1, 0.05);  // Kp, Ki, Kd

// P-only controller
let p_only = PidConfig::proportional(2.0);

// PI controller
let pi = PidConfig::pi(1.5, 0.2);

// PD controller
let pd = PidConfig::pd(1.0, 0.1);

// With limits
let pid_limited = PidConfig::new(1.0, 0.1, 0.05)
    .with_limits(10.0, 100.0);  // integral_limit, output_limit

// Validation
if pid.is_valid() {
    println!("Kp={}, Ki={}, Kd={}", pid.kp, pid.ki, pid.kd);
}
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `controller_id` | `u8` | Controller identifier |
| `kp` | `f64` | Proportional gain |
| `ki` | `f64` | Integral gain |
| `kd` | `f64` | Derivative gain |
| `integral_limit` | `f64` | Integral windup limit |
| `output_limit` | `f64` | Output saturation limit |
| `anti_windup` | `bool` | Anti-windup enabled |
| `timestamp` | `u64` | Nanoseconds since epoch |

## TrajectoryPoint

Single point in a trajectory.

```rust
use horus::prelude::*; // Provides control::TrajectoryPoint;

// Simple 2D trajectory point
let point = TrajectoryPoint::new_2d(
    1.0, 2.0,   // x, y position
    0.5, 0.3,   // vx, vy velocity
    1.5         // time from start (seconds)
);

// Stationary point
let waypoint = TrajectoryPoint::stationary(1.0, 2.0, 0.0);
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `position` | `[f64; 3]` | Position [x, y, z] |
| `velocity` | `[f64; 3]` | Velocity [vx, vy, vz] |
| `acceleration` | `[f64; 3]` | Acceleration [ax, ay, az] |
| `orientation` | `[f64; 4]` | Quaternion [x, y, z, w] |
| `angular_velocity` | `[f64; 3]` | Angular velocity [wx, wy, wz] |
| `time_from_start` | `f64` | Time offset (seconds) |

## JointCommand

Multi-joint command for robot arms and manipulators.

```rust
use horus::prelude::*; // Provides control::JointCommand;

let mut cmd = JointCommand::new();

// Add position commands
cmd.add_position("shoulder", 0.5)?;
cmd.add_position("elbow", 1.0)?;
cmd.add_position("wrist", -0.3)?;

// Add velocity commands
cmd.add_velocity("gripper", 0.2)?;
```

**Control Modes:**

| Constant | Value | Description |
|----------|-------|-------------|
| `MODE_POSITION` | 0 | Position control (rad) |
| `MODE_VELOCITY` | 1 | Velocity control (rad/s) |
| `MODE_EFFORT` | 2 | Torque/effort control (Nm) |

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `joint_names` | `[[u8; 32]; 16]` | Joint name strings |
| `joint_count` | `u8` | Number of joints (max 16) |
| `positions` | `[f64; 16]` | Position commands (rad) |
| `velocities` | `[f64; 16]` | Velocity commands (rad/s) |
| `efforts` | `[f64; 16]` | Effort commands (Nm) |
| `modes` | `[u8; 16]` | Control mode per joint |
| `timestamp` | `u64` | Nanoseconds since epoch |

## Motor Control Node Example

```rust
use horus::prelude::*;
use horus::prelude::*; // Provides control::{PwmCommand, DifferentialDriveCommand};
use horus::prelude::*; // Provides CmdVel;

struct MotorDriverNode {
    cmd_sub: Hub<CmdVel>,
    left_pwm_pub: Hub<PwmCommand>,
    right_pwm_pub: Hub<PwmCommand>,
    wheel_base: f64,
    wheel_radius: f64,
    max_speed: f64,
}

impl Node for MotorDriverNode {
    fn name(&self) -> &'static str { "MotorDriver" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {
            // Convert CmdVel to differential drive
            let diff = DifferentialDriveCommand::from_twist(
                cmd.linear as f64,
                cmd.angular as f64,
                self.wheel_base,
                self.wheel_radius
            );

            // Convert to PWM (-1 to 1)
            let left_duty = (diff.left_velocity / self.max_speed).clamp(-1.0, 1.0) as f32;
            let right_duty = (diff.right_velocity / self.max_speed).clamp(-1.0, 1.0) as f32;

            // Send PWM commands
            self.left_pwm_pub.send(PwmCommand::new(0, left_duty), &mut ctx).ok();
            self.right_pwm_pub.send(PwmCommand::new(1, right_duty), &mut ctx).ok();
        }
    }
}
```

## See Also

- [Differential Drive Algorithm](/rust/library/algorithms/differential-drive) - Kinematics
- [PID Algorithm](/rust/library/algorithms/pid) - PID controller implementation
- [DC Motor Node](/rust/library/built-in-nodes/dc-motor) - Motor driver node
- [Servo Controller Node](/rust/library/built-in-nodes/servo-controller) - Servo driver
- [Stepper Motor Node](/rust/library/built-in-nodes/stepper-motor) - Stepper driver
