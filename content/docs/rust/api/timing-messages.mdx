---
title: "Timing Messages"
description: "Time synchronization, scheduling, and temporal coordination for distributed robotics"
weight: 53
---

# Timing Messages

HORUS provides time synchronization and scheduling messages for coordinating distributed robotic systems. Based on NTP/PTP protocols for accurate clock synchronization across multiple robots and computers.

## TimeSync

Time synchronization message for distributed systems.

Based on Network Time Protocol (NTP) and Precision Time Protocol (PTP) concepts for synchronizing clocks across multiple robots and computers.

```rust
use horus::prelude::*;

// Create time sync message for a master clock
let mut sync = TimeSync::new("master_clock");

// Set the message as received
sync.update_receive_time();

// Check synchronization quality
if sync.is_valid() {
    println!("Clock offset: {} ns", sync.clock_offset);
    println!("Network delay: {} ns", sync.network_delay);
    println!("Sync quality: {:?}", sync.sync_quality);
    println!("Confidence: {:.1}%", sync.confidence * 100.0);
}

// Get synchronized time (local time + offset)
let synchronized = sync.synchronized_time();
println!("Synchronized time: {} ns", synchronized);

// Get master clock identifier
println!("Master: {}", sync.master_id_str());
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `master_time` | `u64` | Master/reference time in nanoseconds since epoch |
| `local_send_time` | `u64` | Local time when message was sent (ns) |
| `local_receive_time` | `u64` | Local time when message was received (ns) |
| `network_delay` | `u64` | Estimated network delay in nanoseconds |
| `clock_offset` | `i64` | Clock offset from master in nanoseconds (signed) |
| `drift_rate` | `f64` | Clock drift rate (parts per million) |
| `accuracy_estimate` | `u64` | Synchronization accuracy estimate (ns) |
| `confidence` | `f32` | Synchronization confidence (0.0-1.0) |
| `master_id` | `[u8; 32]` | Master clock identifier |
| `sequence` | `u32` | Sync message sequence number |
| `sync_quality` | `SyncQuality` | Time synchronization quality indicator |
| `timestamp` | `u64` | Nanoseconds since epoch |

**Methods:**

| Method | Description |
|--------|-------------|
| `new(master_id)` | Create new time sync message |
| `update_receive_time()` | Update with current receive time and calculate parameters |
| `synchronized_time()` | Get synchronized time (local + offset) |
| `is_valid()` | Check if synchronization is valid |
| `master_id_str()` | Get master ID as string |

## SyncQuality

Time synchronization quality levels.

```rust
use horus::prelude::*;

let quality = SyncQuality::Good;

// Quality levels are comparable
if quality >= SyncQuality::Fair {
    println!("Acceptable synchronization for most operations");
}
```

**Values:**

| Value | Accuracy | Description |
|-------|----------|-------------|
| `None` | N/A | No synchronization available |
| `Poor` | &gt;1ms | Poor synchronization |
| `Fair` | 100μs - 1ms | Fair synchronization |
| `Good` | 10μs - 100μs | Good synchronization |
| `Excellent` | &lt;10μs | Excellent synchronization |
| `Precision` | &lt;1μs | Precision synchronization (PTP-level) |

## ScheduledEvent

Scheduled task/event message for temporal coordination.

```rust
use horus::prelude::*;

// Create a one-time event
let start_time = 2_000_000_000; // 2 seconds from epoch
let event = ScheduledEvent::new(1, EventType::TaskStart, start_time)
    .with_executor("robot_1");

// Create a repeating event (every 500ms)
let mut periodic = ScheduledEvent::repeating(
    2,
    EventType::DataCollection,
    start_time,
    500_000_000,  // 500ms interval
);
periodic.max_repeats = 10;  // Run 10 times

// Check if event is due
let current_time = 2_000_000_500;
if event.is_due(current_time) {
    println!("Event {} is ready to execute!", event.event_id);
}

// Check if event was missed
if event.is_missed(current_time) {
    println!("Event {} missed its execution window", event.event_id);
}

// Calculate time until execution
if let Some(time_left) = event.time_until_execution(1_500_000_000) {
    println!("Time until event: {} ns", time_left);
}

// Update event status after execution
let mut executing_event = event;
executing_event.update_status(EventStatus::Executing);
// ... perform task ...
executing_event.update_status(EventStatus::Completed);
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `event_id` | `u32` | Unique event identifier |
| `event_type` | `EventType` | Event type/category |
| `scheduled_time` | `u64` | Scheduled execution time (synchronized time) |
| `duration` | `u64` | Event duration in nanoseconds (0 = instantaneous) |
| `priority` | `u8` | Event priority (0 = highest) |
| `repeat_interval` | `u64` | Repeat interval (0 = no repeat) |
| `max_repeats` | `u32` | Maximum repeat count (0 = infinite) |
| `repeat_count` | `u32` | Current repeat count |
| `status` | `EventStatus` | Event status |
| `parameters` | `[u8; 32]` | Event parameters (flexible data) |
| `tolerance` | `u64` | Time tolerance (acceptable execution window, ns) |
| `executor_id` | `[u8; 32]` | Robot/system responsible for this event |
| `created_time` | `u64` | Event creation time |
| `last_execution` | `u64` | Last execution time |
| `timestamp` | `u64` | Nanoseconds since epoch |

**Methods:**

| Method | Description |
|--------|-------------|
| `new(event_id, event_type, scheduled_time)` | Create a new scheduled event |
| `repeating(event_id, event_type, start_time, interval)` | Create a repeating event |
| `is_due(current_time)` | Check if event is due for execution |
| `is_missed(current_time)` | Check if event has missed its execution window |
| `update_status(status)` | Update event status (auto-reschedules repeating events) |
| `time_until_execution(current_time)` | Calculate time until execution |
| `with_executor(executor_id)` | Set executor ID (builder pattern) |

## EventType

Event type enumeration for categorizing scheduled events.

**Values:**

| Value | Code | Description |
|-------|------|-------------|
| `TaskStart` | 0 | Start a task or operation |
| `TaskStop` | 1 | Stop a task or operation |
| `Command` | 2 | Send a command |
| `DataCollection` | 3 | Collect sensor data |
| `Maintenance` | 4 | Perform maintenance operation |
| `Synchronization` | 5 | Synchronization checkpoint |
| `StateChange` | 6 | System state change |
| `Communication` | 7 | Communication event |
| `Calibration` | 8 | Calibration procedure |
| `SafetyCheck` | 9 | Safety check |
| `FormationUpdate` | 10 | Multi-robot formation update |
| `Custom` | 255 | Custom user event |

## EventStatus

Event execution status.

**Values:**

| Value | Code | Description |
|-------|------|-------------|
| `Scheduled` | 0 | Event scheduled but not executed |
| `Executing` | 1 | Event is being executed |
| `Completed` | 2 | Event completed successfully |
| `Failed` | 3 | Event failed to execute |
| `Cancelled` | 4 | Event cancelled |
| `Missed` | 5 | Event missed its execution window |
| `Postponed` | 6 | Event postponed to later time |

## Timeline

Timeline/schedule of events for coordinated execution.

Supports up to 64 scheduled events, automatically sorted by scheduled time.

```rust
use horus::prelude::*;

// Create a new timeline
let start_time = 1_000_000_000;
let mut timeline = Timeline::new("mission_timeline", start_time);

// Add events (they'll be sorted by time automatically)
let event1 = ScheduledEvent::new(1, EventType::TaskStart, 1_100_000_000);
let event2 = ScheduledEvent::new(2, EventType::DataCollection, 1_050_000_000);
let event3 = ScheduledEvent::new(3, EventType::TaskStop, 1_200_000_000);

timeline.add_event(event1).unwrap();
timeline.add_event(event2).unwrap();
timeline.add_event(event3).unwrap();

// Start timeline execution
timeline.start();
assert_eq!(timeline.status, TimelineStatus::Running);

// Get events due for execution
let due_events = timeline.get_due_events(1_050_000_000);
for idx in due_events {
    println!("Event {} is due", timeline.events[idx].event_id);
}

// Update timeline with current time
timeline.update(1_100_000_000);

// Control timeline execution
timeline.pause();
timeline.resume();
timeline.stop();
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `events` | `[ScheduledEvent; 64]` | Array of scheduled events (max 64) |
| `event_count` | `u8` | Number of active events |
| `timeline_id` | `[u8; 32]` | Timeline identifier |
| `start_time` | `u64` | Timeline start time |
| `end_time` | `u64` | Timeline end time (0 = indefinite) |
| `current_time` | `u64` | Current timeline position |
| `status` | `TimelineStatus` | Timeline execution status |
| `coordinator_id` | `[u8; 32]` | Timeline owner/coordinator |
| `sync_reference` | `u64` | Synchronization reference time |
| `timestamp` | `u64` | Nanoseconds since epoch |

**Methods:**

| Method | Description |
|--------|-------------|
| `new(timeline_id, start_time)` | Create a new timeline |
| `add_event(event)` | Add event to timeline (auto-sorted by time) |
| `get_events()` | Get slice of active events |
| `get_due_events(current_time)` | Get indices of events due for execution |
| `update(current_synchronized_time)` | Update timeline execution, check missed events |
| `start()` | Start timeline execution |
| `pause()` | Pause timeline execution |
| `resume()` | Resume timeline execution |
| `stop()` | Stop timeline execution |

## TimelineStatus

Timeline execution status.

**Values:**

| Value | Code | Description |
|-------|------|-------------|
| `Created` | 0 | Timeline created but not started |
| `Running` | 1 | Timeline is running |
| `Paused` | 2 | Timeline paused |
| `Completed` | 3 | Timeline completed |
| `Aborted` | 4 | Timeline aborted due to error |
| `Stopped` | 5 | Timeline stopped by user |

## ClockStats

Clock synchronization statistics for monitoring sync health.

```rust
use horus::prelude::*;

// Create clock statistics tracker
let mut stats = ClockStats::new("master_clock");

// Update with sync measurements
stats.update_sync(-5000, SyncQuality::Good);  // -5μs offset
stats.update_sync(-3000, SyncQuality::Good);  // -3μs offset

// Check statistics
println!("Current offset: {} ns", stats.current_offset);
println!("Average offset: {} ns", stats.average_offset);
println!("Sync count: {}", stats.sync_count);
println!("Success rate: {:.1}%", stats.sync_success_rate() * 100.0);

// Check health status
if stats.is_sync_healthy() {
    println!("Synchronization is healthy");
}

// Get estimated accuracy
let accuracy = stats.estimated_accuracy();
println!("Estimated accuracy: {} ns", accuracy);
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `current_offset` | `i64` | Current clock offset from master (ns) |
| `average_offset` | `i64` | Average offset over measurement period |
| `offset_std_dev` | `u64` | Offset standard deviation |
| `drift_ppm` | `f64` | Clock drift rate (parts per million) |
| `sync_count` | `u32` | Number of sync messages received |
| `sync_lost` | `u32` | Number of sync messages lost/missed |
| `last_sync_time` | `u64` | Last sync message timestamp |
| `sync_interval` | `u64` | Sync interval in nanoseconds |
| `sync_quality` | `SyncQuality` | Current sync quality |
| `master_id` | `[u8; 32]` | Master clock identifier |
| `measurement_period` | `u64` | Statistics collection period |
| `timestamp` | `u64` | Nanoseconds since epoch |

**Methods:**

| Method | Description |
|--------|-------------|
| `new(master_id)` | Create new clock statistics tracker |
| `update_sync(offset, quality)` | Update statistics with new sync measurement |
| `sync_success_rate()` | Calculate sync success rate (0.0-1.0) |
| `is_sync_healthy()` | Check if synchronization is healthy |
| `estimated_accuracy()` | Get estimated time accuracy in nanoseconds |

## Multi-Robot Synchronization Example

```rust
use horus::prelude::*;

struct SynchronizedRobot {
    sync_sub: Hub<TimeSync>,
    event_sub: Hub<ScheduledEvent>,
    clock_stats_pub: Hub<ClockStats>,
    stats: ClockStats,
    timeline: Timeline,
}

impl Node for SynchronizedRobot {
    fn name(&self) -> &'static str { "SynchronizedRobot" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Process time sync messages
        if let Some(mut sync) = self.sync_sub.try_recv(&mut ctx) {
            sync.update_receive_time();

            if sync.is_valid() {
                // Update clock statistics
                self.stats.update_sync(sync.clock_offset, sync.sync_quality);

                // Update timeline with synchronized time
                let synced_time = sync.synchronized_time();
                self.timeline.update(synced_time);

                // Execute due events
                for idx in self.timeline.get_due_events(synced_time) {
                    self.execute_event(idx, &mut ctx);
                }
            }
        }

        // Process new scheduled events
        if let Some(event) = self.event_sub.try_recv(&mut ctx) {
            if let Err(e) = self.timeline.add_event(event) {
                log::warn!("Failed to add event: {}", e);
            }
        }

        // Publish clock stats periodically
        self.clock_stats_pub.send(self.stats, &mut ctx).ok();
    }
}

impl SynchronizedRobot {
    fn execute_event(&mut self, idx: usize, ctx: &mut Option<&mut NodeInfo>) {
        let event = &mut self.timeline.events[idx];
        event.update_status(EventStatus::Executing);

        match event.event_type {
            EventType::TaskStart => {
                log::info!("Starting task {}", event.event_id);
                // ... start task logic ...
            }
            EventType::DataCollection => {
                log::info!("Collecting data");
                // ... data collection logic ...
            }
            EventType::SafetyCheck => {
                log::info!("Performing safety check");
                // ... safety check logic ...
            }
            _ => {}
        }

        event.update_status(EventStatus::Completed);
    }
}
```

## Formation Coordination Example

```rust
use horus::prelude::*;

/// Coordinate multiple robots in a formation with synchronized timing
fn create_formation_timeline(robots: &[&str], start_time: u64) -> Timeline {
    let mut timeline = Timeline::new("formation_1", start_time);

    // All robots start at the same synchronized time
    for (i, robot) in robots.iter().enumerate() {
        let event = ScheduledEvent::new(
            i as u32,
            EventType::FormationUpdate,
            start_time,
        ).with_executor(robot);

        timeline.add_event(event).unwrap();
    }

    // Add periodic formation checks
    let check_event = ScheduledEvent::repeating(
        100,
        EventType::SafetyCheck,
        start_time + 1_000_000_000,  // 1 second after start
        500_000_000,                  // Every 500ms
    );
    timeline.add_event(check_event).unwrap();

    timeline
}
```

## See Also

- [Scheduler Configuration](/advanced/scheduler-configuration) - Real-time scheduling
- [Deterministic Execution](/advanced/deterministic-execution) - Reproducible timing
- [Network Communication](/concepts/network-communication) - Multi-robot networks
- [Sensor Messages](/rust/api/sensor-messages) - Timestamped sensor data
