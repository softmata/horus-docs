---
title: "Driver Error Handling Patterns"
description: "Comprehensive guide to handling driver errors in HORUS: error types, recovery strategies, and best practices"
weight: 24
---

# Driver Error Handling Patterns

Robust error handling is essential for reliable robotics systems. This guide covers HORUS error types, recovery strategies, and best practices for building fault-tolerant drivers.

---

## HORUS Error Types

HORUS uses a unified error type for all operations:

```rust
use horus::prelude::*;

// The main error type
pub enum HorusError {
    // I/O errors (file, network, serial)
    Io(std::io::Error),

    // Configuration errors
    Config(String),

    // Backend-specific errors
    Backend { backend: String, message: String },

    // Driver errors
    Driver(String),

    // Communication errors
    Communication(String),

    // Timeout errors
    Timeout(String),

    // Resource not found
    NotFound(String),

    // Permission denied
    PermissionDenied(String),

    // Initialization failures
    InitializationFailed(String),

    // ... and more
}

// Convenient Result alias
type HorusResult<T> = Result<T, HorusError>;
```

### Error Helpers

Create errors with helper methods:

```rust
use horus::prelude::*;

// Driver errors
let err = HorusError::driver("Sensor not responding");

// Backend errors (specify which backend failed)
let err = HorusError::backend("mpu6050", "I2C communication failed");

// Configuration errors
let err = HorusError::config("Invalid sample rate: must be > 0");

// Not found errors
let err = HorusError::not_found("Device /dev/i2c-1");

// Check error types
if err.is_timeout() { /* handle timeout */ }
if err.is_not_found() { /* handle missing resource */ }
if err.is_permission_denied() { /* handle permission issue */ }
```

---

## Error Handling in Driver Lifecycle

### Initialization Errors

```rust
pub struct MyDriver {
    status: DriverStatus,
    device: Option<DeviceHandle>,
}

impl MyDriver {
    pub fn init(&mut self) -> HorusResult<()> {
        // Validate preconditions
        if self.status != DriverStatus::Uninitialized {
            return Err(HorusError::driver(
                "Driver already initialized"
            ));
        }

        // Try to open the device
        let device = self.open_device()
            .map_err(|e| HorusError::InitializationFailed(
                format!("Failed to open device: {}", e)
            ))?;

        // Validate device is responsive
        device.ping()
            .map_err(|_| HorusError::backend(
                &self.backend_name,
                "Device not responding during init"
            ))?;

        // Configure device
        device.configure(&self.config)
            .map_err(|e| HorusError::Config(
                format!("Device rejected configuration: {}", e)
            ))?;

        self.device = Some(device);
        self.status = DriverStatus::Ready;
        Ok(())
    }
}
```

### Read/Write Errors

```rust
impl MyDriver {
    pub fn read(&mut self) -> HorusResult<SensorData> {
        // Check we're initialized
        let device = self.device.as_mut()
            .ok_or_else(|| HorusError::driver(
                "Driver not initialized - call init() first"
            ))?;

        // Update status
        self.status = DriverStatus::Running;

        // Attempt read with timeout
        let data = device.read_with_timeout(Duration::from_millis(100))
            .map_err(|e| match e.kind() {
                std::io::ErrorKind::TimedOut => {
                    HorusError::Timeout("Sensor read timed out after 100ms".into())
                }
                std::io::ErrorKind::PermissionDenied => {
                    HorusError::PermissionDenied(
                        "No permission to read device".into()
                    )
                }
                _ => HorusError::Io(e),
            })?;

        // Validate data
        self.validate_data(&data)?;

        Ok(data)
    }

    fn validate_data(&self, data: &SensorData) -> HorusResult<()> {
        // Check for sensor saturation
        if data.value > self.max_value {
            return Err(HorusError::driver(
                "Sensor reading saturated - value exceeds max"
            ));
        }

        // Check timestamp is recent
        if data.timestamp == 0 {
            return Err(HorusError::driver(
                "Invalid timestamp in sensor data"
            ));
        }

        Ok(())
    }
}
```

### Shutdown Errors

```rust
impl MyDriver {
    pub fn shutdown(&mut self) -> HorusResult<()> {
        // Allow shutdown from any state
        if let Some(device) = self.device.take() {
            // Best-effort device cleanup
            if let Err(e) = device.stop() {
                warn!("Error stopping device: {} - continuing shutdown", e);
            }

            // Close device handle
            device.close()
                .map_err(|e| HorusError::driver(
                    format!("Error closing device: {}", e)
                ))?;
        }

        self.status = DriverStatus::Shutdown;
        Ok(())
    }
}
```

---

## Error Recovery Strategies

### Strategy 1: Retry with Backoff

```rust
use std::time::Duration;
use std::thread;

/// Retry an operation with exponential backoff
pub fn retry_with_backoff<T, F>(
    mut operation: F,
    max_retries: usize,
    initial_delay: Duration,
) -> HorusResult<T>
where
    F: FnMut() -> HorusResult<T>,
{
    let mut delay = initial_delay;

    for attempt in 0..max_retries {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) => {
                if attempt < max_retries - 1 {
                    warn!(
                        "Attempt {} failed: {}. Retrying in {:?}...",
                        attempt + 1, e, delay
                    );
                    thread::sleep(delay);
                    delay *= 2; // Exponential backoff
                } else {
                    return Err(HorusError::driver(format!(
                        "Operation failed after {} attempts: {}",
                        max_retries, e
                    )));
                }
            }
        }
    }

    unreachable!()
}

// Usage
fn read_with_retry(&mut self) -> HorusResult<SensorData> {
    retry_with_backoff(
        || self.driver.read(),
        3,                          // max retries
        Duration::from_millis(10),  // initial delay
    )
}
```

### Strategy 2: Automatic Reconnection

```rust
pub struct ReconnectingDriver<D> {
    driver: D,
    config: SingleDriverConfig,
    max_reconnect_attempts: usize,
    reconnect_delay: Duration,
}

impl<D: Driver> ReconnectingDriver<D> {
    pub fn read(&mut self) -> HorusResult<D::Data> {
        match self.driver.read() {
            Ok(data) => Ok(data),
            Err(e) if self.is_connection_error(&e) => {
                warn!("Connection error: {}. Attempting reconnect...", e);
                self.reconnect()?;
                self.driver.read()
            }
            Err(e) => Err(e),
        }
    }

    fn reconnect(&mut self) -> HorusResult<()> {
        for attempt in 0..self.max_reconnect_attempts {
            info!("Reconnection attempt {}/{}", attempt + 1, self.max_reconnect_attempts);

            // Try to reinitialize
            if let Err(e) = self.driver.shutdown() {
                debug!("Shutdown during reconnect failed: {}", e);
            }

            thread::sleep(self.reconnect_delay);

            match self.driver.init() {
                Ok(()) => {
                    info!("Reconnection successful");
                    return Ok(());
                }
                Err(e) => {
                    warn!("Reconnection attempt failed: {}", e);
                }
            }
        }

        Err(HorusError::driver(format!(
            "Failed to reconnect after {} attempts",
            self.max_reconnect_attempts
        )))
    }

    fn is_connection_error(&self, e: &HorusError) -> bool {
        matches!(e,
            HorusError::Io(_) |
            HorusError::Timeout(_) |
            HorusError::Communication(_)
        )
    }
}
```

### Strategy 3: Graceful Degradation

```rust
/// Driver wrapper that falls back to simulation on hardware errors
pub struct FallbackDriver {
    hardware_driver: Option<Box<dyn ImuDriver>>,
    simulation_driver: SimulationImuDriver,
    using_simulation: bool,
}

impl FallbackDriver {
    pub fn new(hardware_config: &SingleDriverConfig) -> Self {
        let hardware = match create_hardware_driver(hardware_config) {
            Ok(d) => Some(d),
            Err(e) => {
                warn!("Hardware unavailable: {}. Will use simulation.", e);
                None
            }
        };

        Self {
            hardware_driver: hardware,
            simulation_driver: SimulationImuDriver::new(),
            using_simulation: hardware.is_none(),
        }
    }

    pub fn read(&mut self) -> HorusResult<Imu> {
        if self.using_simulation {
            return self.simulation_driver.read();
        }

        match self.hardware_driver.as_mut().unwrap().read() {
            Ok(data) => Ok(data),
            Err(e) => {
                error!("Hardware read failed: {}. Falling back to simulation.", e);
                self.using_simulation = true;
                self.simulation_driver.read()
            }
        }
    }

    pub fn is_using_simulation(&self) -> bool {
        self.using_simulation
    }
}
```

### Strategy 4: Health Monitoring

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

pub struct HealthMonitoredDriver<D> {
    driver: D,
    consecutive_errors: AtomicUsize,
    error_threshold: usize,
    health_callback: Option<Box<dyn Fn(DriverHealth) + Send>>,
}

#[derive(Debug, Clone, Copy)]
pub enum DriverHealth {
    Healthy,
    Degraded { error_count: usize },
    Unhealthy { error_count: usize },
}

impl<D: Driver> HealthMonitoredDriver<D> {
    pub fn read(&mut self) -> HorusResult<D::Data> {
        match self.driver.read() {
            Ok(data) => {
                // Reset error counter on success
                let prev = self.consecutive_errors.swap(0, Ordering::SeqCst);
                if prev > 0 {
                    self.notify_health(DriverHealth::Healthy);
                }
                Ok(data)
            }
            Err(e) => {
                let count = self.consecutive_errors.fetch_add(1, Ordering::SeqCst) + 1;

                let health = if count >= self.error_threshold {
                    DriverHealth::Unhealthy { error_count: count }
                } else {
                    DriverHealth::Degraded { error_count: count }
                };

                self.notify_health(health);
                Err(e)
            }
        }
    }

    fn notify_health(&self, health: DriverHealth) {
        if let Some(callback) = &self.health_callback {
            callback(health);
        }
    }

    pub fn health(&self) -> DriverHealth {
        let errors = self.consecutive_errors.load(Ordering::SeqCst);
        if errors == 0 {
            DriverHealth::Healthy
        } else if errors >= self.error_threshold {
            DriverHealth::Unhealthy { error_count: errors }
        } else {
            DriverHealth::Degraded { error_count: errors }
        }
    }
}
```

---

## Error Handling in Nodes

### Node-Level Error Handling

```rust
impl Node for ImuNode {
    fn process(&mut self, ctx: &mut NodeContext) -> HorusResult<()> {
        match self.driver.read() {
            Ok(data) => {
                self.publisher.publish(&data)?;
                Ok(())
            }
            Err(e) => {
                // Log but don't propagate - keep the node running
                error!("IMU read error: {}. Skipping this cycle.", e);
                self.error_count += 1;

                // Check if we should request restart
                if self.error_count > self.max_errors {
                    ctx.request_node_restart("Too many consecutive errors");
                }

                Ok(()) // Don't propagate to scheduler
            }
        }
    }
}
```

### Custom Error Handling Middleware

```rust
/// Wrapper that adds error handling behavior to any node
pub struct ErrorHandlingNode<N> {
    inner: N,
    error_policy: ErrorPolicy,
    stats: ErrorStats,
}

pub enum ErrorPolicy {
    /// Propagate all errors to scheduler
    Propagate,
    /// Log errors but continue processing
    LogAndContinue,
    /// Retry N times before propagating
    RetryThenPropagate { max_retries: usize },
    /// Fall back to default output on error
    FallbackValue { default: Box<dyn Any> },
}

impl<N: Node> Node for ErrorHandlingNode<N> {
    fn process(&mut self, ctx: &mut NodeContext) -> HorusResult<()> {
        let result = self.inner.process(ctx);

        match (&result, &self.error_policy) {
            (Err(e), ErrorPolicy::LogAndContinue) => {
                self.stats.record_error(e);
                warn!("Node error (ignored): {}", e);
                Ok(())
            }
            (Err(e), ErrorPolicy::RetryThenPropagate { max_retries }) => {
                for _ in 0..*max_retries {
                    if self.inner.process(ctx).is_ok() {
                        return Ok(());
                    }
                }
                self.stats.record_error(e);
                result
            }
            _ => result,
        }
    }
}
```

---

## Common Error Scenarios

### Device Not Found

```rust
fn handle_device_not_found() -> HorusResult<()> {
    let path = "/dev/i2c-1";

    if !std::path::Path::new(path).exists() {
        return Err(HorusError::not_found(format!(
            "Device {} not found. Ensure:\n\
             1. The device is connected\n\
             2. The correct bus is specified\n\
             3. I2C is enabled (raspi-config on Raspberry Pi)",
            path
        )));
    }

    Ok(())
}
```

### Permission Denied

```rust
fn handle_permission_denied(path: &str) -> HorusResult<()> {
    match std::fs::metadata(path) {
        Ok(_) => {
            // File exists but we can't access it
            Err(HorusError::PermissionDenied(format!(
                "Cannot access {}. Try:\n\
                 1. Run with sudo (for testing only)\n\
                 2. Add user to 'dialout' or 'i2c' group:\n\
                    sudo usermod -a -G dialout $USER\n\
                 3. Create udev rule for this device",
                path
            )))
        }
        Err(e) => Err(e.into()),
    }
}
```

### Sensor Disconnection

```rust
fn detect_disconnection(error: &std::io::Error) -> bool {
    matches!(error.kind(),
        std::io::ErrorKind::BrokenPipe |
        std::io::ErrorKind::ConnectionReset |
        std::io::ErrorKind::NotConnected |
        std::io::ErrorKind::UnexpectedEof
    )
}

fn handle_read_error(&mut self, error: std::io::Error) -> HorusResult<SensorData> {
    if detect_disconnection(&error) {
        warn!("Device appears disconnected. Attempting reconnection...");
        self.status = DriverStatus::Error;

        // Try to reconnect
        thread::sleep(Duration::from_millis(500));
        self.init()?;

        // Retry read
        return self.read();
    }

    Err(error.into())
}
```

---

## Best Practices

### 1. Provide Actionable Error Messages

```rust
// BAD: Vague error
Err(HorusError::driver("Failed"))

// GOOD: Actionable error
Err(HorusError::driver(
    "IMU initialization failed: No response on I2C bus 1 at address 0x68. \
     Verify: 1) Device is connected, 2) Address jumper is correct, \
     3) I2C is enabled (sudo raspi-config)"
))
```

### 2. Chain Errors with Context

```rust
fn read_calibration(&self) -> HorusResult<Calibration> {
    let path = &self.calibration_path;

    let contents = std::fs::read_to_string(path)
        .map_err(|e| HorusError::Config(format!(
            "Failed to read calibration file {}: {}",
            path, e
        )))?;

    serde_yaml::from_str(&contents)
        .map_err(|e| HorusError::Config(format!(
            "Invalid calibration format in {}: {}",
            path, e
        )))
}
```

### 3. Use Error Types Appropriately

```rust
// Use specific error types
impl MyDriver {
    fn init(&mut self) -> HorusResult<()> {
        // Not found
        if !self.device_path.exists() {
            return Err(HorusError::not_found(&self.device_path));
        }

        // Permission denied
        match std::fs::File::open(&self.device_path) {
            Err(e) if e.kind() == std::io::ErrorKind::PermissionDenied => {
                return Err(HorusError::PermissionDenied(
                    format!("Cannot access {}", self.device_path)
                ));
            }
            Err(e) => return Err(e.into()),
            Ok(_) => {}
        }

        // Configuration error
        if self.config.sample_rate <= 0.0 {
            return Err(HorusError::config(
                "sample_rate must be positive"
            ));
        }

        Ok(())
    }
}
```

### 4. Log at Appropriate Levels

```rust
fn process_with_logging(&mut self) -> HorusResult<()> {
    match self.driver.read() {
        Ok(data) => {
            trace!("Read sensor data: {:?}", data);  // Trace for detailed debugging
            Ok(())
        }
        Err(e) if e.is_timeout() => {
            debug!("Read timeout - will retry");     // Debug for expected issues
            Ok(())
        }
        Err(e) if self.error_count < 3 => {
            warn!("Read error ({}): {}", self.error_count, e);  // Warn for unusual
            self.error_count += 1;
            Ok(())
        }
        Err(e) => {
            error!("Persistent read error: {}", e);  // Error for serious issues
            Err(e)
        }
    }
}
```

---

## Testing Error Handling

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_handles_initialization_error() {
        let config = SingleDriverConfig {
            backend: "nonexistent".into(),
            ..Default::default()
        };

        let result = create_driver(&config);
        assert!(result.is_err());
        assert!(matches!(result, Err(HorusError::NotFound(_))));
    }

    #[test]
    fn test_retry_succeeds_eventually() {
        let mut attempts = 0;
        let result = retry_with_backoff(
            || {
                attempts += 1;
                if attempts < 3 {
                    Err(HorusError::Timeout("test".into()))
                } else {
                    Ok("success")
                }
            },
            5,
            Duration::from_millis(1),
        );

        assert_eq!(result.unwrap(), "success");
        assert_eq!(attempts, 3);
    }

    #[test]
    fn test_fallback_to_simulation() {
        let mut driver = FallbackDriver::new(&SingleDriverConfig {
            backend: "invalid_hardware".into(),
            ..Default::default()
        });

        // Should fall back to simulation
        assert!(driver.is_using_simulation());

        // Should still produce valid data
        let data = driver.read().unwrap();
        assert!(data.timestamp > 0);
    }
}
```

---

## See Also

- [Driver Testing Guide](/rust/library/drivers/testing) - Testing strategies
- [Driver Troubleshooting](/rust/library/drivers/troubleshooting) - Debug common issues
- [Simulation to Hardware Workflow](/rust/library/drivers/workflow) - Development lifecycle
- [Hardware Drivers](/rust/library/drivers) - Driver overview
