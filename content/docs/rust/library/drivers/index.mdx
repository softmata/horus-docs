---
title: Hardware Drivers
description: Low-level hardware drivers for custom node development
order: 19
---

# Hardware Drivers

The `horus_library::drivers` module provides **low-level hardware drivers** for direct hardware access. While most users should use [Built-in Nodes](/rust/library/built-in-nodes), drivers are essential for:

- Building custom hardware nodes
- Integrating unsupported hardware
- Fine-grained hardware control
- Testing with simulation backends

## Quick Start

```rust
use horus_library::drivers::{
    // IMU drivers
    ImuDriver, SimulationImuDriver,
    #[cfg(feature = "mpu6050-imu")]
    Mpu6050Driver,

    // Motor drivers
    MotorDriver, SimulationMotorDriver,

    // Bus drivers
    I2cDriver, SimulationI2cDriver,
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Development: Use simulation driver
    let imu = SimulationImuDriver::new();

    // Production: Use real hardware
    #[cfg(feature = "mpu6050-imu")]
    let imu = Mpu6050Driver::new("/dev/i2c-1", 0x68)?;

    // Read data
    let data = imu.read()?;
    println!("Accel: {:?}", data.linear_acceleration);

    Ok(())
}
```

---

## Driver Philosophy

HORUS drivers follow a simple pattern: **structs with methods, no trait hierarchy**.

```rust
// Simple struct - no ceremony
pub struct MyMotorDriver {
    port: String,
    status: DriverStatus,
}

impl MyMotorDriver {
    pub fn new(port: &str) -> Result<Self, Error> { ... }
    pub fn set_speed(&mut self, speed: f64) -> Result<(), Error> { ... }
    pub fn stop(&mut self) -> Result<(), Error> { ... }
}
```

Every driver type has:
- **Simulation driver** - Always available, no hardware needed
- **Hardware driver(s)** - Feature-gated, requires real hardware

---

## Driver Categories

### Sensors

| Driver | Simulation | Hardware | Feature Flag |
|--------|------------|----------|--------------|
| **IMU** | `SimulationImuDriver` | `Mpu6050Driver`, `Bno055Driver` | `mpu6050-imu`, `bno055-imu` |
| **Camera** | `SimulationCameraDriver` | `OpenCvCameraDriver`, `V4l2CameraDriver` | `opencv-backend`, `v4l2-backend` |
| **LiDAR** | `SimulationLidarDriver` | `RplidarDriver` | `rplidar` |
| **GPS** | `SimulationGpsDriver` | `NmeaGpsDriver` | `nmea-gps` |
| **Encoder** | `SimulationEncoderDriver` | `GpioEncoderDriver` | `gpio-hardware` |
| **Ultrasonic** | `SimulationUltrasonicDriver` | `GpioUltrasonicDriver` | `gpio-hardware` |
| **Depth Camera** | `SimulationDepthCameraDriver` | `RealSenseDriver` | `realsense` |
| **Battery** | `SimulationBatteryDriver` | `I2cBatteryDriver` | `i2c-hardware` |
| **Force/Torque** | `SimulationForceTorqueDriver` | `AtiNetFtDriver`, `RobotiqSerialDriver` | `netft`, `robotiq-serial` |

### Actuators

| Driver | Simulation | Hardware | Feature Flag |
|--------|------------|----------|--------------|
| **DC Motor** | `SimulationMotorDriver` | `GpioMotorDriver` | `gpio-hardware` |
| **Servo** | `SimulationServoDriver` | `Pca9685ServoDriver` | `i2c-hardware` |
| **BLDC Motor** | `SimulationBldcDriver` | `PwmBldcDriver` | `gpio-hardware` |
| **Stepper** | `SimulationStepperDriver` | `GpioStepperDriver` | `gpio-hardware` |
| **Dynamixel** | `SimulationDynamixelDriver` | `SerialDynamixelDriver` | `serial-hardware` |
| **RoboClaw** | `SimulationRoboclawDriver` | `SerialRoboclawDriver` | `serial-hardware` |

### Communication Buses

| Driver | Simulation | Hardware | Feature Flag |
|--------|------------|----------|--------------|
| **I2C** | `SimulationI2cDriver` | `LinuxI2cDriver` | `i2c-hardware` |
| **SPI** | `SimulationSpiDriver` | `LinuxSpiDriver` | `spi-hardware` |
| **CAN** | `SimulationCanDriver` | `SocketCanDriver` | `can-hardware` |
| **Serial** | `SimulationSerialDriver` | `SystemSerialDriver` | `serial-hardware` |
| **Modbus** | `SimulationModbusDriver` | `RtuModbusDriver` | `serial-hardware` |

### Input Devices

| Driver | Simulation | Hardware | Feature Flag |
|--------|------------|----------|--------------|
| **Joystick** | `SimulationJoystickDriver` | `GilrsJoystickDriver` | `gilrs` |
| **Keyboard** | `SimulationKeyboardDriver` | `CrosstermKeyboardDriver` | `crossterm` |
| **Digital I/O** | `SimulationDigitalIoDriver` | `GpioDigitalIoDriver` | `gpio-hardware` |

---

## Using Drivers

### IMU Driver Example

```rust
use horus_library::drivers::{ImuDriver, SimulationImuDriver};
use horus_core::driver::DriverStatus;

// Create simulation driver
let mut imu = SimulationImuDriver::new();

// Initialize
imu.init()?;
assert_eq!(imu.status(), DriverStatus::Ready);

// Read IMU data
let data = imu.read()?;
println!("Angular velocity: {:?}", data.angular_velocity);
println!("Linear acceleration: {:?}", data.linear_acceleration);

// With real hardware (MPU6050)
#[cfg(feature = "mpu6050-imu")]
{
    use horus_library::drivers::Mpu6050Driver;

    let mut imu = Mpu6050Driver::new("/dev/i2c-1", 0x68)?;
    imu.init()?;

    // Same API as simulation
    let data = imu.read()?;
}
```

### Motor Driver Example

```rust
use horus_library::drivers::{MotorDriver, SimulationMotorDriver};

let mut motor = SimulationMotorDriver::new();
motor.init()?;

// Set speed (-1.0 to 1.0)
motor.set_speed(0.5)?;

// Get current speed
let speed = motor.get_speed();

// Stop motor
motor.stop()?;

// With real hardware (GPIO)
#[cfg(feature = "gpio-hardware")]
{
    use horus_library::drivers::GpioMotorDriver;

    let mut motor = GpioMotorDriver::new(
        18,  // PWM pin
        23,  // Direction pin A
        24,  // Direction pin B
    )?;
    motor.init()?;
    motor.set_speed(0.75)?;
}
```

### Joystick Driver Example

```rust
use horus_library::drivers::{
    JoystickDriver, SimulationJoystickDriver, ButtonMapping,
};

// Simulation joystick
let mut joystick = SimulationJoystickDriver::new();
joystick.init()?;

// Read input
let input = joystick.read()?;
println!("Left stick: ({:.2}, {:.2})", input.left_x, input.left_y);
println!("Buttons: {:?}", input.buttons);

// With real hardware (gilrs)
#[cfg(feature = "gilrs")]
{
    use horus_library::drivers::GilrsJoystickDriver;

    let mut joystick = GilrsJoystickDriver::new()?;
    joystick.set_mapping(ButtonMapping::Xbox360);
    joystick.init()?;

    let input = joystick.read()?;
}
```

### Keyboard Driver Example

```rust
use horus_library::drivers::{
    KeyboardDriver, SimulationKeyboardDriver,
    keyboard::keycodes::{KEY_W, KEY_A, KEY_S, KEY_D, KEY_SPACE},
};

// Simulation keyboard
let mut keyboard = SimulationKeyboardDriver::new();
keyboard.init()?;

// Simulate key press
keyboard.simulate_key_press(KEY_W);

// Read input
let input = keyboard.read()?;
if input.is_key_pressed(KEY_W) {
    println!("W pressed - moving forward");
}

// With real terminal input (crossterm)
#[cfg(feature = "crossterm")]
{
    use horus_library::drivers::CrosstermKeyboardDriver;

    let mut keyboard = CrosstermKeyboardDriver::new()?;
    keyboard.init()?;

    // Non-blocking read
    if let Some(input) = keyboard.try_read()? {
        println!("Key pressed: {:?}", input.keycode);
    }
}
```

### Bus Driver Example (I2C)

```rust
use horus_library::drivers::{I2cDriver, SimulationI2cDriver};

// Simulation I2C bus
let mut i2c = SimulationI2cDriver::new();
i2c.init()?;

// Write to device
i2c.write(0x68, &[0x6B, 0x00])?;  // Wake up MPU6050

// Read from device
let mut buffer = [0u8; 6];
i2c.read(0x68, &mut buffer)?;

// With real hardware (Linux I2C)
#[cfg(feature = "i2c-hardware")]
{
    use horus_library::drivers::LinuxI2cDriver;

    let mut i2c = LinuxI2cDriver::new("/dev/i2c-1")?;
    i2c.init()?;

    // Same API
    i2c.write(0x68, &[0x6B, 0x00])?;
}
```

---

## Driver Configuration (YAML/TOML)

Drivers can be configured via YAML or TOML files for easy hardware swapping.

### drivers.yaml

```yaml
drivers:
  lidar:
    backend: rplidar
    port: /dev/ttyUSB0
    baud_rate: 115200

  camera:
    backend: v4l2
    device: /dev/video0
    width: 640
    height: 480
    fps: 30

  imu:
    backend: mpu6050
    i2c_bus: 1
    i2c_address: 0x68

  motors:
    backend: gpio
    enabled: true

  # Use simulation when hardware unavailable
  gps:
    backend: simulation
```

### drivers.toml

```toml
[drivers.lidar]
backend = "rplidar"
port = "/dev/ttyUSB0"
baud_rate = 115200

[drivers.imu]
backend = "mpu6050"
i2c_bus = 1
i2c_address = 104  # 0x68

[drivers.camera]
backend = "simulation"
width = 640
height = 480
```

### Loading Configuration

```rust
use horus_core::driver::{DriversConfig, SingleDriverConfig};

// Load from file
let config = DriversConfig::from_file("drivers.yaml")?;

// Or auto-find in standard locations
let config = DriversConfig::find_and_load()?;

// Get specific driver config
let lidar_config = config.get_driver("lidar")?;
println!("LiDAR backend: {}", lidar_config.backend);
println!("Port: {:?}", lidar_config.port);

// Get with default fallback
let gps_config = config.get_driver_or_default("gps");
if gps_config.is_simulation() {
    println!("GPS: Using simulation mode");
}

// List all enabled drivers
for (name, cfg) in config.enabled_drivers() {
    println!("{}: {} ({})", name, cfg.backend,
        if cfg.is_simulation() { "sim" } else { "hw" });
}
```

---

## Driver Factory

Create drivers dynamically from configuration:

```rust
use horus_library::drivers::{
    create_imu_driver,
    create_lidar_driver,
    create_camera_driver,
    create_motor_driver,
    create_drivers_from_config,
    CreatedDrivers,
    list_available_backends,
};
use horus_core::driver::SingleDriverConfig;

// Create single driver from config
let imu_config = SingleDriverConfig::i2c("mpu6050", 1, 0x68);
let imu = create_imu_driver(&imu_config)?;

// Create all drivers from config file
let drivers: CreatedDrivers = create_drivers_from_config("drivers.yaml")?;

// Access created drivers
if let Some(imu) = &drivers.imu {
    let data = imu.read()?;
}
if let Some(lidar) = &drivers.lidar {
    let scan = lidar.read()?;
}

// List available backends
let backends = list_available_backends();
println!("Available IMU backends: {:?}", backends.imu);
println!("Available camera backends: {:?}", backends.camera);
```

---

## Creating Custom Drivers

### Implement a Custom Sensor Driver

```rust
use horus_core::driver::DriverStatus;
use horus_library::Imu;

pub struct MyCustomImuDriver {
    device_path: String,
    status: DriverStatus,
    // Your hardware-specific fields
}

impl MyCustomImuDriver {
    pub fn new(device_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            device_path: device_path.to_string(),
            status: DriverStatus::Uninitialized,
        })
    }

    pub fn init(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Initialize your hardware
        // ...
        self.status = DriverStatus::Ready;
        Ok(())
    }

    pub fn read(&mut self) -> Result<Imu, Box<dyn std::error::Error>> {
        // Read from your hardware
        let mut imu = Imu::new();
        // Fill in data...
        Ok(imu)
    }

    pub fn status(&self) -> DriverStatus {
        self.status.clone()
    }

    pub fn shutdown(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Cleanup hardware
        self.status = DriverStatus::Shutdown;
        Ok(())
    }
}
```

### Use Custom Driver in a Node

```rust
use horus::prelude::*;

pub struct MyImuNode {
    driver: MyCustomImuDriver,
    publisher: Hub<Imu>,
}

impl MyImuNode {
    pub fn new(device_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let mut driver = MyCustomImuDriver::new(device_path)?;
        driver.init()?;

        Ok(Self {
            driver,
            publisher: Hub::new("imu")?,
        })
    }
}

impl Node for MyImuNode {
    fn name(&self) -> &'static str { "MyImuNode" }

    fn tick(&mut self, _ctx: Option<&mut NodeInfo>) {
        if let Ok(data) = self.driver.read() {
            self.publisher.send(&data);
        }
    }
}
```

---

## DriverStatus Lifecycle

```rust
use horus_core::driver::DriverStatus;

// Driver lifecycle states
DriverStatus::Uninitialized  // Created but not initialized
DriverStatus::Ready          // Initialized and ready to operate
DriverStatus::Running        // Actively streaming/operating
DriverStatus::Error(msg)     // Encountered an error
DriverStatus::Shutdown       // Gracefully shut down
```

---

## Feature Flags Reference

Enable hardware support in `Cargo.toml`:

```toml
[dependencies]
horus_library = { version = "0.1", features = [
    # IMU sensors
    "mpu6050-imu",
    "bno055-imu",

    # Camera backends
    "opencv-backend",
    "v4l2-backend",
    "realsense",

    # LiDAR
    "rplidar",

    # GPS
    "nmea-gps",

    # Communication buses
    "i2c-hardware",
    "spi-hardware",
    "can-hardware",
    "serial-hardware",

    # GPIO
    "gpio-hardware",

    # Input devices
    "gilrs",
    "crossterm",

    # Force/torque sensors
    "netft",
    "robotiq-serial",

    # Modbus
    "modbus-hardware",
]}
```

Or in `horus.yaml`:

```yaml
dependencies:
  - name: horus
    features:
      - mpu6050-imu
      - gpio-hardware
      - serial-hardware
```

---

## Keycodes Reference

Standard keyboard keycodes for `KeyboardDriver`:

```rust
use horus_library::drivers::keyboard::keycodes::*;

// Letters
KEY_A, KEY_B, KEY_C, KEY_D, KEY_W, KEY_S  // 65-90

// Arrows
KEY_ARROW_UP      // 38
KEY_ARROW_DOWN    // 40
KEY_ARROW_LEFT    // 37
KEY_ARROW_RIGHT   // 39

// Special keys
KEY_SPACE         // 32
KEY_ENTER         // 13
KEY_ESCAPE        // 27
KEY_TAB           // 9
KEY_BACKSPACE     // 8
```

---

## Button Mappings Reference

Gamepad button mappings for `JoystickDriver`:

```rust
use horus_library::drivers::joystick::ButtonMapping;

ButtonMapping::Xbox360      // Xbox 360 controller layout
ButtonMapping::PlayStation4 // PS4 DualShock layout
ButtonMapping::Generic      // Generic gamepad (default)
```

---

## Best Practices

1. **Always use simulation for development** - Test without hardware first
2. **Feature-gate hardware drivers** - Only compile what you need
3. **Handle driver errors gracefully** - Hardware can fail
4. **Use config files for deployment** - Easy hardware swapping
5. **Check driver status before reading** - Ensure initialization succeeded
6. **Shutdown drivers properly** - Release hardware resources

```rust
// Good practice: Check status
if imu.status() == DriverStatus::Ready {
    let data = imu.read()?;
}

// Good practice: Handle errors
match motor.set_speed(0.5) {
    Ok(_) => println!("Motor running"),
    Err(e) => {
        eprintln!("Motor error: {}", e);
        motor.stop().ok();  // Try to stop safely
    }
}

// Good practice: Cleanup on exit
impl Drop for MyRobot {
    fn drop(&mut self) {
        self.motor.stop().ok();
        self.motor.shutdown().ok();
    }
}
```

---

## See Also

- [Built-in Nodes](/rust/library/built-in-nodes) - Pre-configured nodes using these drivers
- [Node Macro](/concepts/node-macro) - Create custom nodes
- [Package Management](/package-management/package-management) - Publish custom drivers
