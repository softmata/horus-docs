---
title: StepperMotorNode
description: Stepper motor control with motion profiling and multi-motor support
---

# StepperMotorNode

High-performance stepper motor controller with support for up to 8 motors, microstepping, motion profiling, gear ratios, and homing. Ideal for CNC machines, 3D printers, robot arms, and precision positioning systems.

## Source Code

- [StepperMotorNode Implementation](https://github.com/softmata/horus/tree/main/horus_library/nodes/stepper_motor)
- [Stepper Control Messages](https://github.com/softmata/horus/blob/main/horus_library/messages/control.rs)

## Features

- Up to 8 stepper motors simultaneously
- Microstepping support (1, 2, 4, 8, 16, 32, etc.)
- Motion profiling (trapezoidal acceleration)
- Gear ratio support
- Position, velocity, and homing commands
- Per-motor configuration (steps/rev, max speed, acceleration)
- Current limiting
- Hardware GPIO control or simulation
- Position feedback

## Quick Start

```rust
use horus::prelude::*;

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Create stepper controller
    let mut stepper = StepperMotorNode::new()?;

    // Configure motor 0
    stepper.set_num_motors(1);
    stepper.set_steps_per_revolution(0, 200, 16);  // 200 steps, 1/16 microstepping
    stepper.set_max_velocity(0, 2000.0);           // 2000 steps/sec
    stepper.set_acceleration(0, 5000.0);           // 5000 steps/sec²
    stepper.set_gpio_pins(0, 17, 18, 27);          // step, dir, enable pins

    scheduler.add(Box::new(stepper), 1, Some(true));
    scheduler.run()?;
    Ok(())
}
```

## Hardware Setup

### System Requirements

```bash
# Install GPIO library
sudo apt install libraspberrypi-dev

# Enable GPIO interface
sudo raspi-config  # Interface Options -> Enable all
```

### Wiring Example (A4988 Driver)

```
Raspberry Pi    A4988 Driver    Stepper Motor
GPIO 17   -->   STEP
GPIO 18   -->   DIR
GPIO 27   -->   ENABLE
5V        -->   VDD
GND       -->   GND
12V       -->   VMOT            (Motor power)
                A1, A2    -->   Motor coil A
                B1, B2    -->   Motor coil B
```

### Enabling Features

There are three ways to enable the required `gpio-hardware` feature:

**Option 1: Automatic detection (recommended)**

When you use `horus run`, HORUS automatically detects that you're using `StepperMotorNode` and enables the feature:

```bash
horus run main.rs
# Output: Auto-detected hardware nodes (features: gpio-hardware)
```

**Option 2: Explicit in horus.yaml**

Add the feature to your `horus.yaml` dependencies:

```yaml
dependencies:
  - name: horus
    features:
      - gpio-hardware
```

**Option 3: Manual Cargo.toml (for cargo projects)**

If using `cargo` directly:

```toml
[dependencies]
horus_library = { version = "0.1", features = ["gpio-hardware"] }
```

## Configuration

### Motor Setup

```rust
let mut stepper = StepperMotorNode::new()?;

// Number of motors (1-8)
stepper.set_num_motors(4);

// Per-motor configuration
for motor_id in 0..4 {
    stepper.set_steps_per_revolution(motor_id, 200, 16); // 200 steps, 1/16 microstep
    stepper.set_max_velocity(motor_id, 2000.0);           // steps/sec
    stepper.set_acceleration(motor_id, 5000.0);           // steps/sec²
}
```

### Microstepping

```rust
// Full step (200 steps/rev for NEMA 17)
stepper.set_steps_per_revolution(0, 200, 1);

// Half step
stepper.set_steps_per_revolution(0, 200, 2);

// Quarter step
stepper.set_steps_per_revolution(0, 200, 4);

// 1/16 microstepping (3200 microsteps/rev)
stepper.set_steps_per_revolution(0, 200, 16);
```

### Gear Ratios

```rust
// Direct drive (no gearing)
stepper.set_gear_ratio(0, 1.0);

// 5:1 gear reduction
stepper.set_gear_ratio(0, 5.0);

// 1:3 gear increase (faster output)
stepper.set_gear_ratio(0, 1.0 / 3.0);
```

### Motion Parameters

```rust
// Maximum velocity (steps/sec)
stepper.set_max_velocity(0, 3000.0);

// Acceleration (steps/sec²)
stepper.set_acceleration(0, 10000.0);

// Current limit (mA) - driver dependent
stepper.set_current_limit(0, 1500); // 1.5A

// Invert direction
stepper.set_direction_inverted(0, true);
```

### GPIO Pins

```rust
// Set GPIO pins for motor 0
stepper.set_gpio_pins(
    0,   // Motor ID
    17,  // STEP pin
    18,  // DIR pin
    27   // ENABLE pin
);
```

### Timeouts and Feedback

```rust
// Command timeout (ms)
stepper.set_command_timeout(1000);

// Enable position feedback
stepper.set_feedback_enabled(true);
```

## Usage Patterns

### Position Control

```rust
use horus::prelude::*;

// Create position command
let mut cmd = StepperCommand {
    motor_id: 0,
    command_type: StepperCommand::CMD_MOVE_TO,
    target_position: 3200,  // Move to position (microsteps)
    velocity: 0.0,
    acceleration: 0.0,
};

// Send command
let hub = Hub::<StepperCommand>::new("stepper_cmd")?;
hub.send(cmd, &mut None).ok();
```

### Velocity Control

```rust
let mut cmd = StepperCommand {
    motor_id: 0,
    command_type: StepperCommand::CMD_MOVE_VELOCITY,
    velocity: 1000.0,  // 1000 steps/sec
    ..Default::default()
};
hub.send(cmd, &mut None).ok();
```

### Relative Movement

```rust
// Move 1000 steps forward
let mut cmd = StepperCommand {
    motor_id: 0,
    command_type: StepperCommand::CMD_MOVE_RELATIVE,
    target_position: 1000,
    ..Default::default()
};
hub.send(cmd, &mut None).ok();
```

### Homing

```rust
// Start homing sequence
let mut cmd = StepperCommand {
    motor_id: 0,
    command_type: StepperCommand::CMD_HOME,
    velocity: -500.0,  // Homing speed (negative = reverse)
    ..Default::default()
};
hub.send(cmd, &mut None).ok();
```

### Stop/Emergency

```rust
// Stop motor immediately
let mut cmd = StepperCommand {
    motor_id: 0,
    command_type: StepperCommand::CMD_STOP,
    ..Default::default()
};
hub.send(cmd, &mut None).ok();

// Emergency stop (all motors)
let mut cmd = StepperCommand {
    motor_id: 0xFF,  // Broadcast to all
    command_type: StepperCommand::CMD_EMERGENCY_STOP,
    ..Default::default()
};
hub.send(cmd, &mut None).ok();
```

## Motion Profiling

### Trapezoidal Profile

The node automatically generates trapezoidal velocity profiles:

```
Velocity
    ^
    |     /‾‾‾‾‾\
    |    /       \
    |   /         \
    |  /           \
    | /             \
    |/______________\___> Time
      Accel  Cruise  Decel
```

Parameters:
- **Acceleration phase**: Ramps up to target velocity
- **Cruise phase**: Constant velocity (if distance allows)
- **Deceleration phase**: Ramps down to target position

### Example

```rust
stepper.set_max_velocity(0, 2000.0);     // Max 2000 steps/sec
stepper.set_acceleration(0, 5000.0);      // Accel at 5000 steps/sec²

// This will:
// 1. Accelerate from 0 to 2000 steps/sec (0.4s)
// 2. Cruise at 2000 steps/sec
// 3. Decelerate to stop at target position
```

## Complete Example: CNC System

```rust
use horus::prelude::*;

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Configure 3-axis CNC
    let mut stepper = StepperMotorNode::new()?;
    stepper.set_num_motors(3);

    // X-axis (motor 0)
    stepper.set_steps_per_revolution(0, 200, 16);
    stepper.set_gear_ratio(0, 5.0);  // 5mm per rev (lead screw)
    stepper.set_max_velocity(0, 3000.0);
    stepper.set_acceleration(0, 10000.0);
    stepper.set_gpio_pins(0, 17, 18, 27);

    // Y-axis (motor 1)
    stepper.set_steps_per_revolution(1, 200, 16);
    stepper.set_gear_ratio(1, 5.0);
    stepper.set_max_velocity(1, 3000.0);
    stepper.set_acceleration(1, 10000.0);
    stepper.set_gpio_pins(1, 22, 23, 24);

    // Z-axis (motor 2)
    stepper.set_steps_per_revolution(2, 200, 16);
    stepper.set_gear_ratio(2, 2.0);  // Slower for vertical
    stepper.set_max_velocity(2, 1500.0);
    stepper.set_acceleration(2, 5000.0);
    stepper.set_gpio_pins(2, 5, 6, 13);

    scheduler.add(Box::new(stepper), 1, Some(true));

    // G-code interpreter node
    let gcode_node = node! {
        name: "gcode",
        tick: |ctx| {
            // Parse G-code and send stepper commands
            // G0 X10 Y20 Z5 -> Move to position
            // ...
            Ok(())
        }
    };
    scheduler.add(Box::new(gcode_node), 2, Some(true));

    scheduler.run()?;
    Ok(())
}
```

## Message Format

### StepperCommand

```rust
pub struct StepperCommand {
    pub motor_id: u8,          // Motor ID (0-7, 0xFF for all)
    pub command_type: u8,      // Command type
    pub target_position: i64,  // Target position (microsteps)
    pub velocity: f64,         // Target velocity (steps/sec)
    pub acceleration: f64,     // Override acceleration
}
```

### Command Types

```rust
pub const CMD_MOVE_TO: u8 = 0;          // Absolute position
pub const CMD_MOVE_RELATIVE: u8 = 1;    // Relative movement
pub const CMD_MOVE_VELOCITY: u8 = 2;    // Velocity mode
pub const CMD_STOP: u8 = 3;             // Stop motor
pub const CMD_EMERGENCY_STOP: u8 = 4;   // Emergency stop
pub const CMD_HOME: u8 = 5;             // Homing sequence
pub const CMD_SET_HOME: u8 = 6;         // Set current as home
pub const CMD_ENABLE: u8 = 7;           // Enable motor
pub const CMD_DISABLE: u8 = 8;          // Disable motor
```

## Best Practices

1. **Always enable feedback for critical applications:**
   ```rust
   stepper.set_feedback_enabled(true);
   // Monitor position via feedback messages
   ```

2. **Use appropriate microstepping:**
   - Full/half step: High torque, more vibration
   - 1/16 step: Smooth, quiet, less torque
   - Balance based on your needs

3. **Set realistic velocities:**
   ```rust
   // Too fast = missed steps
   // Rule of thumb: Start at 1000 steps/sec, tune upward
   stepper.set_max_velocity(0, 1500.0);
   ```

4. **Enable current limiting:**
   ```rust
   // Prevents overheating
   stepper.set_current_limit(0, 1500); // 1.5A
   ```

5. **Implement homing on startup:**
   ```rust
   // Find reference position
   let cmd = StepperCommand {
       command_type: StepperCommand::CMD_HOME,
       ..Default::default()
   };
   ```

## Troubleshooting

**Problem: "Hardware unavailable - using SIMULATION mode"**

**Solutions:**
1. Check GPIO permissions: `ls -l /sys/class/gpio`
2. Install GPIO library: `sudo apt install libraspberrypi-dev`
3. Enable GPIO: `sudo raspi-config`
4. Verify wiring with multimeter
5. Test with simple GPIO script first

**Problem: Motor vibrates but doesn't move**

**Solutions:**
1. Check wiring polarity
2. Reduce microstepping
3. Increase current limit
4. Slow down velocity

**Problem: Missed steps**

**Solutions:**
1. Reduce max velocity
2. Increase acceleration time
3. Check mechanical resistance
4. Verify power supply capacity

## Graceful Shutdown

StepperMotorNode automatically stops all motors when your application receives Ctrl+C (SIGINT/SIGTERM):

- Emergency stop called on all motors
- Enable pins set to disabled state (HIGH for active-low drivers)
- Motors hold position or coast depending on driver configuration

This ensures steppers stop safely when shutting down your robot.

## See Also

- [BldcMotorNode](./bldc-motor) - Brushless motor control
- [DynamixelNode](./dynamixel) - Smart servo control
- [EncoderNode](./encoder) - Closed-loop position feedback
- [DifferentialDriveNode](./differential-drive) - Mobile robot drive
